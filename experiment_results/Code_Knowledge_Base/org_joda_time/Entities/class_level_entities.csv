FEN:ID,:LABEL,Comment,Modifiers,Extends,Implements
org.joda.time.MutablePeriod,Class,"* Standard mutable time period implementation.\n * <p>\n * A time period is divided into a number of fields, such as hours and seconds.\n * Which fields are supported is defined by the PeriodType class.\n * The default is the standard period type, which supports years, months, weeks, days,\n * hours, minutes, seconds and millis.\n * <p>\n * When this time period is added to an instant, the effect is of adding each field in turn.\n * As a result, this takes into account daylight savings time.\n * Adding a time period of 1 day to the day before daylight savings starts will only add\n * 23 hours rather than 24 to ensure that the time remains the same.\n * If this is not the behaviour you want, then see {@link Duration}.\n * <p>\n * The definition of a period also affects the equals method. A period of 1\n * day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes.\n * This is because periods represent an abstracted definition of a time period\n * (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight\n * savings boundary). To compare the actual duration of two periods, convert\n * both to durations using toDuration, an operation that emphasises that the\n * result may differ according to the date you choose.\n * <p>\n * MutablePeriod is mutable and not thread-safe, unless concurrent threads\n * are not invoking mutator methods.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n * @see Period",public ,org.joda.time.base.BasePeriod,org.joda.time.ReadWritablePeriod;java.lang.Cloneable;java.io.Serializable
org.joda.time.ReadableDuration,Interface,"* Defines an exact duration of time in milliseconds.\n * <p>\n * The implementation of this interface may be mutable or immutable. This\n * interface only gives access to retrieve data, never to change it.\n * <p>\n * Methods that are passed a duration as a parameter will treat <code>null</code>\n * as a zero length duration.\n * <p>\n * The {@code compareTo} method is no longer defined in this class in version 2.0.\n * Instead, the definition is simply inherited from the {@code Comparable} interface.\n * This approach is necessary to preserve binary compatibility.\n * The definition of the comparison is ascending order by millisecond duration.\n * Implementors are recommended to extend {@code AbstractInstant} instead of this interface.\n *\n * @see ReadableInterval\n * @see ReadablePeriod\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0",public ,java.lang.Comparable,
org.joda.time.Minutes,Class,"* An immutable time period representing a number of minutes.\n * <p>\n * <code>Minutes</code> is an immutable period that can only store minutes.\n * It does not store years, months or hours for example. As such it is a\n * type-safe way of representing a number of minutes in an application.\n * <p>\n * The number of minutes is set in the constructor, and may be queried using\n * <code>getMinutes()</code>. Basic mathematical operations are provided -\n * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n * <code>dividedBy()</code>.\n * <p>\n * <code>Minutes</code> is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.4","public , final ",org.joda.time.base.BaseSingleFieldPeriod,
org.joda.time.ReadableInstant,Interface,"* Defines an instant in the datetime continuum.\n * This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.\n * <p>\n * The implementation of this interface may be mutable or immutable.\n * This interface only gives access to retrieve data, never to change it.\n * <p>\n * Methods in your application should be defined using <code>ReadableInstant</code>\n * as a parameter if the method only wants to read the instant without needing to know\n * the specific datetime fields.\n * <p>\n * The {@code compareTo} method is no longer defined in this class in version 2.0.\n * Instead, the definition is simply inherited from the {@code Comparable} interface.\n * This approach is necessary to preserve binary compatibility.\n * The definition of the comparison is ascending order by millisecond instant.\n * Implementors are recommended to extend {@code AbstractInstant} instead of this interface.\n *\n * @author Stephen Colebourne\n * @since 1.0",public ,java.lang.Comparable,
org.joda.time.MutableInterval,Class,"* MutableInterval is the standard implementation of a mutable time interval.\n * <p>\n * A time interval represents a period of time between two instants.\n * Intervals are inclusive of the start instant and exclusive of the end.\n * The end instant is always greater than or equal to the start instant.\n * <p>\n * Intervals have a fixed millisecond duration.\n * This is the difference between the start and end instants.\n * The duration is represented separately by {@link ReadableDuration}.\n * As a result, intervals are not comparable.\n * To compare the length of two intervals, you should compare their durations.\n * <p>\n * An interval can also be converted to a {@link ReadablePeriod}.\n * This represents the difference between the start and end points in terms of fields\n * such as years and days.\n * <p>\n * If performing significant calculations on an interval, it may be faster to\n * convert an Interval object to a MutableInterval one.\n * <p>\n * MutableInterval is mutable and not thread-safe, unless concurrent threads\n * are not invoking mutator methods.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0",public ,org.joda.time.base.BaseInterval,org.joda.time.ReadWritableInterval;java.lang.Cloneable;java.io.Serializable
org.joda.time.ReadableInterval,Interface,"* Readable interface for an interval of time between two instants.\n * <p>\n * A time interval represents a period of time between two instants.\n * Intervals are inclusive of the start instant and exclusive of the end.\n * The end instant is always greater than or equal to the start instant.\n * <p>\n * Intervals have a fixed millisecond duration.\n * This is the difference between the start and end instants.\n * The duration is represented separately by {@link ReadableDuration}.\n * As a result, intervals are not comparable.\n * To compare the length of two intervals, you should compare their durations.\n * <p>\n * An interval can also be converted to a {@link ReadablePeriod}.\n * This represents the difference between the start and end points in terms of fields\n * such as years and days.\n * <p>\n * Methods that are passed an interval as a parameter will treat <code>null</code>\n * as a zero length interval at the current instant in time.\n *\n * @author Sean Geoghegan\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0",public ,,
org.joda.time.DurationField,Abstract Class,"* Defines the calculation engine for duration fields.\n * The interface defines a set of methods that manipulate a millisecond duration\n * with regards to a single field, such as months or seconds.\n * <p>\n * This design is extensible so, if you wish, you can extract a different field from\n * the millisecond duration. A number of standard implementations are provided to assist.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , abstract ",,java.lang.Comparable
org.joda.time.ReadablePartial,Interface,"* Defines a partial time that does not support every datetime field, and is\n * thus a local time.\n * <p>\n * A {@code ReadablePartial} supports a subset of those fields on the chronology.\n * It cannot be compared to a {@code ReadableInstant}, as it does not fully\n * specify an instant in time. The time it does specify is a local time, and does\n * not include a time zone.\n * <p>\n * A {@code ReadablePartial} can be converted to a {@code ReadableInstant}\n * using the {@code toDateTime} method. This works by providing a full base\n * instant that can be used to 'fill in the gaps' and specify a time zone.\n * <p>\n * {@code ReadablePartial} is {@code Comparable} from v2.0.\n * The comparison is based on the fields, compared in order, from largest to smallest.\n * The first field that is non-equal is used to determine the result.\n *\n * @author Stephen Colebourne\n * @since 1.0",public ,java.lang.Comparable,
org.joda.time.ReadablePeriod,Interface,"* Defines a time period specified in terms of individual duration fields\n * such as years and days.\n * <p>\n * The implementation of this interface may be mutable or immutable. This\n * interface only gives access to retrieve data, never to change it.\n * <p>\n * Periods are split up into multiple fields, for example days and seconds.\n * Implementations are not required to evenly distribute the values across the fields.\n * The value for each field may be positive or negative.\n * <p>\n * When a time period is added to an instant, the effect is to add each field in turn.\n * For example, a time period could be defined as 3 months, 2 days and -1 hours.\n * In most circumstances this would be the same as 3 months, 1 day, and 23 hours.\n * However, when adding across a daylight savings boundary, a day may be 23 or 25 hours long.\n * Thus, the time period is always added field by field to the datetime.\n * <p>\n * Periods are independent of chronology, and can only be treated as durations\n * when paired with a time via an interval.\n *\n * @see ReadableDuration\n * @see ReadableInterval\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0",public ,,
org.joda.time.Partial,Class,"* Partial is an immutable partial datetime supporting any set of datetime fields.\n * <p>\n * A Partial instance can be used to hold any combination of fields.\n * The instance does not contain a time zone, so any datetime is local.\n * <p>\n * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n * This method compares each field on this partial with those of the instant\n * and determines if the partial matches the instant.\n * Given this definition, an empty Partial instance represents any datetime\n * and always matches.\n * <p>\n * Calculations on Partial are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * Partial is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.1","public , final ",org.joda.time.base.AbstractPartial,org.joda.time.ReadablePartial;java.io.Serializable
org.joda.time.Partial$Property,Class,* The property class for <code>Partial</code>.\n     * <p>\n     * This class binds a <code>Partial</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 1.1,"public , static ",org.joda.time.field.AbstractPartialFieldProperty,java.io.Serializable
org.joda.time.Duration,Class,"* An immutable duration specifying a length of time in milliseconds.\n * <p>\n * A duration is defined by a fixed number of milliseconds.\n * There is no concept of fields, such as days or seconds, as these fields can vary in length.\n * <p>\n * A duration may be converted to a {@link Period} to obtain field values.\n * This conversion will typically cause a loss of precision.\n * <p>\n * Duration is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0","public , final ",org.joda.time.base.BaseDuration,org.joda.time.ReadableDuration;java.io.Serializable
org.joda.time.DateMidnight,Class,"* DateMidnight defines a date where the time component is fixed at midnight.\n * The class uses a time zone, thus midnight is local unless a UTC time zone is used.\n * <p>\n * It is important to emphasise that this class represents the time of midnight on\n * any given day.\n * Note that midnight is defined as 00:00, which is at the very start of a day.\n * <p>\n * This class does not represent a day, but the millisecond instant at midnight.\n * If you need a class that represents the whole day, then an {@link Interval} or\n * a {@link LocalDate} may be more suitable.\n * <p>\n * This class uses a Chronology internally. The Chronology determines how the\n * millisecond instant value is converted into the date time fields.\n * The default Chronology is <code>ISOChronology</code> which is the agreed\n * international standard and compatible with the modern Gregorian calendar.\n *\n * <p>Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getDayOfMonth()</code>\n * <li><code>dayOfMonth().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value\n * <li>text value\n * <li>short text value\n * <li>maximum/minimum values\n * <li>add/subtract\n * <li>set\n * <li>rounding\n * </ul>\n *\n * <p>\n * DateMidnight is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.0\n * @deprecated The time of midnight does not exist in some time zones\n * where the daylight saving time forward shift skips the midnight hour.\n * Use {@link LocalDate} to represent a date without a time zone.\n * Or use {@link DateTime} to represent a full date and time, perhaps\n * using {@link DateTime#withTimeAtStartOfDay()} to get an instant at the\n * start of a day.","public , final ",org.joda.time.base.BaseDateTime,org.joda.time.ReadableDateTime;java.io.Serializable
org.joda.time.DateMidnight$Property,Class,"* DateMidnight.Property binds a DateMidnight to a DateTimeField allowing powerful\n     * datetime functionality to be easily accessed.\n     * <p>\n     * The simplest use of this class is as an alternative get method, here used to\n     * get the year '1972' (as an int) and the month 'December' (as a String).\n     * <pre>\n     * DateMidnight dt = new DateMidnight(1972, 12, 3);\n     * int year = dt.year().get();\n     * String monthStr = dt.monthOfYear().getAsText();\n     * </pre>\n     * <p>\n     * Methods are also provided that allow date modification. These return new instances\n     * of DateMidnight - they do not modify the original. The example below yields two\n     * independent immutable date objects 20 years apart.\n     * <pre>\n     * DateMidnight dt = new DateMidnight(1972, 12, 3);\n     * DateMidnight dt20 = dt.year().addToCopy(20);\n     * </pre>\n     * Serious modification of dates (ie. more than just changing one or two fields)\n     * should use the {@link org.joda.time.MutableDateTime MutableDateTime} class.\n     * <p>\n     * DateMidnight.Property itself is thread-safe and immutable.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.0","public , static , final ",org.joda.time.field.AbstractReadableInstantFieldProperty,
org.joda.time.DateTimeField,Abstract Class,"* Defines the calculation engine for date and time fields.\n * The interface defines a set of methods that manipulate a millisecond datetime\n * with regards to a single field, such as monthOfYear or secondOfMinute.\n * <p>\n * This design is extensible so, if you wish, you can extract a different field from\n * the milliseconds. A number of standard implementations are provided to assist.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , abstract ",,
org.joda.time.PeriodType,Class,"* Controls a period implementation by specifying which duration fields are to be used.\n * <p>\n * The following implementations are provided:\n * <ul>\n * <li>Standard - years, months, weeks, days, hours, minutes, seconds, millis\n * <li>YearMonthDayTime - years, months, days, hours, minutes, seconds, millis\n * <li>YearMonthDay - years, months, days\n * <li>YearWeekDayTime - years, weeks, days, hours, minutes, seconds, millis\n * <li>YearWeekDay - years, weeks, days\n * <li>YearDayTime - years, days, hours, minutes, seconds, millis\n * <li>YearDay - years, days, hours\n * <li>DayTime - days, hours, minutes, seconds, millis\n * <li>Time - hours, minutes, seconds, millis\n * <li>plus one for each single type\n * </ul>\n *\n * <p>\n * PeriodType is thread-safe and immutable, and all subclasses must be as well.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0",public ,,java.io.Serializable
org.joda.time.Instant,Class,"* Instant is the standard implementation of a fully immutable instant in time.\n * <p>\n * <code>Instant</code> is an implementation of {@link ReadableInstant}.\n * As with all instants, it represents an exact point on the time-line,\n * but limited to the precision of milliseconds. An <code>Instant</code>\n * should be used to represent a point in time irrespective of any other\n * factor, such as chronology or time zone.\n * <p>\n * Internally, the class holds one piece of data, the instant as milliseconds\n * from the Java epoch of 1970-01-01T00:00:00Z.\n * <p>\n * For example, an Instant can be used to compare two <code>DateTime</code>\n * objects irrespective of chronology or time zone.\n * <pre>\n * boolean sameInstant = dt1.toInstant().equals(dt2.toInstant());\n * </pre>\n * Note that the following code will also perform the same check:\n * <pre>\n * boolean sameInstant = dt1.isEqual(dt2);\n * </pre>\n * <p>\n * Instant is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.0","public , final ",org.joda.time.base.AbstractInstant,org.joda.time.ReadableInstant;java.io.Serializable
org.joda.time.chrono.GregorianChronology,Class,"* Implements a pure proleptic Gregorian calendar system, which defines every\n * fourth year as leap, unless the year is divisible by 100 and not by 400.\n * This improves upon the Julian calendar leap year rule.\n * <p>\n * Although the Gregorian calendar did not exist before 1582 CE, this\n * chronology assumes it did, thus it is proleptic. This implementation also\n * fixes the start of the year at January 1, and defines the year zero.\n * <p>\n * GregorianChronology is thread-safe and immutable.\n *\n * @see <a href=""https://en.wikipedia.org/wiki/Gregorian_calendar"">Wikipedia</a>\n * @see JulianChronology\n * @see GJChronology\n * \n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , final ",org.joda.time.chrono.BasicGJChronology,
org.joda.time.chrono.GJLocaleSymbols,Class,* Utility class used by a few of the GJDateTimeFields.\n *\n * @author Brian S O'Neill\n * @since 1.0,default,,
org.joda.time.chrono.BasicYearDateTimeField,Class,"* A year field suitable for many calendars.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.1, refactored from GJYearDateTimeField",default,org.joda.time.field.ImpreciseDateTimeField,
org.joda.time.chrono.BasicWeekyearDateTimeField,Class,"* Provides time calculations for the week of the weekyear component of time.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.1, refactored from GJWeekyearDateTimeField",final ,org.joda.time.field.ImpreciseDateTimeField,
org.joda.time.chrono.GJEraDateTimeField,Class,* Provides time calculations for the era component of time.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,final ,org.joda.time.field.BaseDateTimeField,
org.joda.time.chrono.BasicChronology,Abstract Class,"* Abstract implementation for calendar systems that use a typical\n * day/month/year/leapYear model.\n * Most of the utility methods required by subclasses are package-private,\n * reflecting the intention that they be defined in the same package.\n * <p>\n * BasicChronology is thread-safe and immutable, and all subclasses must\n * be as well.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @author Guy Allard\n * @since 1.2, renamed from BaseGJChronology",abstract ,org.joda.time.chrono.AssembledChronology,
org.joda.time.chrono.BasicChronology$HalfdayField,Class,No Comment,"private , static ",org.joda.time.field.PreciseDateTimeField,
org.joda.time.chrono.BasicChronology$YearInfo,Class,No Comment,"private , static ",,
org.joda.time.chrono.BasicDayOfYearDateTimeField,Class,"* Provides time calculations for the day of the year component of time.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.1, refactored from GJDayOfYearDateTimeField",final ,org.joda.time.field.PreciseDurationDateTimeField,
org.joda.time.chrono.IslamicChronology,Class,"* Implements the Islamic, or Hijri, calendar system using arithmetic rules.\n * <p>\n * This calendar is a lunar calendar with a shorter year than ISO.\n * Year 1 in the Islamic calendar began on July 16, 622 CE (Julian), thus\n * Islamic years do not begin at the same time as Julian years. This chronology\n * is not proleptic, as it does not allow dates before the first Islamic year.\n * <p>\n * There are two basic forms of the Islamic calendar, the tabular and the\n * observed. The observed form cannot easily be used by computers as it\n * relies on human observation of the new moon.\n * The tabular calendar, implemented here, is an arithmetical approximation\n * of the observed form that follows relatively simple rules.\n * <p>\n * The tabular form of the calendar defines 12 months of alternately\n * 30 and 29 days. The last month is extended to 30 days in a leap year.\n * Leap years occur according to a 30 year cycle. There are four recognised\n * patterns of leap years in the 30 year cycle:\n * <pre>\n * Years 2, 5, 7, 10, 13, 15, 18, 21, 24, 26 & 29 - 15-based, used by Microsoft\n * Years 2, 5, 7, 10, 13, 16, 18, 21, 24, 26 & 29 - 16-based, most commonly used\n * Years 2, 5, 8, 10, 13, 16, 19, 21, 24, 27 & 29 - Indian\n * Years 2, 5, 8, 11, 13, 16, 19, 21, 24, 27 & 30 - Habash al-Hasib\n * </pre>\n * You can select which pattern to use via the factory methods, or use the\n * default (16-based).\n * <p>\n * This implementation defines a day as midnight to midnight exactly as per\n * the ISO chronology. This correct start of day is at sunset on the previous\n * day, however this cannot readily be modelled and has been ignored.\n * <p>\n * IslamicChronology is thread-safe and immutable.\n *\n * @see <a href=""https://en.wikipedia.org/wiki/Islamic_calendar"">Wikipedia</a>\n *\n * @author Stephen Colebourne\n * @since 1.2","public , final ",org.joda.time.chrono.BasicChronology,
org.joda.time.chrono.IslamicChronology$LeapYearPatternType,Class,* Opaque object describing a leap year pattern for the Islamic Chronology.\n     *\n     * @since 1.2,"public , static ",,java.io.Serializable
org.joda.time.chrono.ISOYearOfEraDateTimeField,Class,"* This field is not publicly exposed by ISOChronology, but rather it is used to\n * build the yearOfCentury and centuryOfEra fields. It merely drops the sign of\n * the year.\n *\n * @author Brian S O'Neill\n * @see GJYearOfEraDateTimeField\n * @since 1.0",default,org.joda.time.field.DecoratedDateTimeField,
org.joda.time.chrono.LimitChronology,Class,* Wraps another Chronology to impose limits on the range of instants that\n * the fields within a Chronology may support. The limits are applied to both\n * DateTimeFields and DurationFields.\n * <p>\n * Methods in DateTimeField and DurationField throw an IllegalArgumentException\n * whenever given an input instant that is outside the limits or when an\n * attempt is made to move an instant outside the limits.\n * <p>\n * LimitChronology is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,"public , final ",org.joda.time.chrono.AssembledChronology,
org.joda.time.chrono.LimitChronology$LimitException,Class,* Extends IllegalArgumentException such that the exception message is not\n     * generated unless it is actually requested.,private ,java.lang.IllegalArgumentException,
org.joda.time.chrono.LimitChronology$LimitDurationField,Class,No Comment,private ,org.joda.time.field.DecoratedDurationField,
org.joda.time.chrono.LimitChronology$LimitDateTimeField,Class,No Comment,private ,org.joda.time.field.DecoratedDateTimeField,
org.joda.time.chrono.GJCacheKey,Class,* For internal usage in GJChronology only.,default,,
org.joda.time.chrono.EthiopicChronology,Class,"* Implements the Ethiopic calendar system, which defines every fourth year as\n * leap, much like the Julian calendar. The year is broken down into 12 months,\n * each 30 days in length. An extra period at the end of the year is either 5\n * or 6 days in length. In this implementation, it is considered a 13th month.\n * <p>\n * Year 1 in the Ethiopic calendar began on August 29, 8 CE (Julian), thus\n * Ethiopic years do not begin at the same time as Julian years. This chronology\n * is not proleptic, as it does not allow dates before the first Ethiopic year.\n * <p>\n * This implementation defines a day as midnight to midnight exactly as per\n * the ISO chronology. Some references indicate that a coptic day starts at\n * sunset on the previous ISO day, but this has not been confirmed and is not\n * implemented.\n * <p>\n * EthiopicChronology is thread-safe and immutable.\n *\n * @see <a href=""https://en.wikipedia.org/wiki/Ethiopian_calendar"">Wikipedia</a>\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.2","public , final ",org.joda.time.chrono.BasicFixedMonthChronology,
org.joda.time.chrono.LenientChronology,Class,"* Wraps another Chronology, ensuring all the fields are lenient.\n * <p>\n * LenientChronology is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see LenientDateTimeField\n * @see StrictChronology","public , final ",org.joda.time.chrono.AssembledChronology,
org.joda.time.chrono.BasicMonthOfYearDateTimeField,Class,"* Provides time calculations for the month of the year component of time.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.2, refactored from GJMonthOfYearDateTimeField",default,org.joda.time.field.ImpreciseDateTimeField,
org.joda.time.chrono.GJYearOfEraDateTimeField,Class,* Provides time calculations for the year of era component of time.\n * \n * @author Brian S O'Neill\n * @since 1.0,final ,org.joda.time.field.DecoratedDateTimeField,
org.joda.time.chrono.ZonedChronology,Class,* Wraps another Chronology to add support for time zones.\n * <p>\n * ZonedChronology is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,"public , final ",org.joda.time.chrono.AssembledChronology,
org.joda.time.chrono.ZonedChronology$ZonedDurationField,Class,"* Because time durations are typically smaller than time zone offsets, the\n     * arithmetic methods subtract the original offset. This produces a more\n     * expected behavior when crossing time zone offset transitions. For dates,\n     * the new offset is subtracted off. This behavior, if applied to time\n     * fields, can nullify or reverse an add when crossing a transition.",static ,org.joda.time.field.BaseDurationField,
org.joda.time.chrono.ZonedChronology$ZonedDateTimeField,Class,"* A DateTimeField that decorates another to add timezone behaviour.\n     * <p>\n     * This class converts passed in instants to local wall time, and vice\n     * versa on output.","static , final ",org.joda.time.field.BaseDateTimeField,
org.joda.time.chrono.JulianChronology,Class,"* Implements a pure proleptic Julian calendar system, which defines every\n * fourth year as leap. This implementation follows the leap year rule\n * strictly, even for dates before 8 CE, where leap years were actually\n * irregular. In the Julian calendar, year zero does not exist: 1 BCE is\n * followed by 1 CE.\n * <p>\n * Although the Julian calendar did not exist before 45 BCE, this chronology\n * assumes it did, thus it is proleptic. This implementation also fixes the\n * start of the year at January 1.\n * <p>\n * JulianChronology is thread-safe and immutable.\n *\n * @see <a href=""https://en.wikipedia.org/wiki/Julian_calendar"">Wikipedia</a>\n * @see GregorianChronology\n * @see GJChronology\n *\n * @author Guy Allard\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0","public , final ",org.joda.time.chrono.BasicGJChronology,
org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField,Class,"* Provides time calculations for the week of a week based year component of time.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.1, refactored from GJWeekOfWeekyearDateTimeField",final ,org.joda.time.field.PreciseDurationDateTimeField,
org.joda.time.chrono.BaseChronology,Abstract Class,"* BaseChronology provides a skeleton implementation for chronology\n * classes. Many utility methods are defined, but all fields are unsupported.\n * <p>\n * BaseChronology is thread-safe and immutable, and all subclasses must be\n * as well.\n *\n * @author Brian S O'Neill\n * @since 1.0","public , abstract ",org.joda.time.Chronology,java.io.Serializable
org.joda.time.chrono.AssembledChronology,Abstract Class,* Abstract Chronology that enables chronologies to be assembled from\n * a container of fields.\n * <p>\n * AssembledChronology is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0,"public , abstract ",org.joda.time.chrono.BaseChronology,
org.joda.time.chrono.AssembledChronology$Fields,Class,* A container of fields used for assembling a chronology.,"public , static , final ",,
org.joda.time.chrono.GJMonthOfYearDateTimeField,Class,* Provides time calculations for the month of the year component of time.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,final ,org.joda.time.chrono.BasicMonthOfYearDateTimeField,
org.joda.time.chrono.CopticChronology,Class,"* Implements the Coptic calendar system, which defines every fourth year as\n * leap, much like the Julian calendar. The year is broken down into 12 months,\n * each 30 days in length. An extra period at the end of the year is either 5\n * or 6 days in length. In this implementation, it is considered a 13th month.\n * <p>\n * Year 1 in the Coptic calendar began on August 29, 284 CE (Julian), thus\n * Coptic years do not begin at the same time as Julian years. This chronology\n * is not proleptic, as it does not allow dates before the first Coptic year.\n * <p>\n * This implementation defines a day as midnight to midnight exactly as per\n * the ISO chronology. Some references indicate that a coptic day starts at\n * sunset on the previous ISO day, but this has not been confirmed and is not\n * implemented.\n * <p>\n * CopticChronology is thread-safe and immutable.\n *\n * @see <a href=""https://en.wikipedia.org/wiki/Coptic_calendar"">Wikipedia</a>\n * @see JulianChronology\n *\n * @author Brian S O'Neill\n * @since 1.0","public , final ",org.joda.time.chrono.BasicFixedMonthChronology,
org.joda.time.chrono.BasicFixedMonthChronology,Abstract Class,"* Abstract implementation of a calendar system based around fixed length months.\n * <p>\n * As the month length is fixed various calculations can be optimised.\n * This implementation assumes any additional days after twelve\n * months fall into a thirteenth month.\n * <p>\n * BasicFixedMonthChronology is thread-safe and immutable, and all\n * subclasses must be as well.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.2, refactored from CopticChronology",abstract ,org.joda.time.chrono.BasicChronology,
org.joda.time.chrono.ISOChronology,Class,"* Implements a chronology that follows the rules of the ISO8601 standard,\n * which is compatible with Gregorian for all modern dates.\n * When ISO does not define a field, but it can be determined (such as AM/PM)\n * it is included.\n * <p>\n * With the exception of century related fields, ISOChronology is exactly the\n * same as {@link GregorianChronology}. In this chronology, centuries and year\n * of century are zero based. For all years, the century is determined by\n * dropping the last two digits of the year, ignoring sign. The year of century\n * is the value of the last two year digits.\n * <p>\n * ISOChronology is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , final ",org.joda.time.chrono.AssembledChronology,
org.joda.time.chrono.ISOChronology$Stub,Class,No Comment,"private , static , final ",,java.io.Serializable
org.joda.time.chrono.BasicGJChronology,Abstract Class,"* Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae.\n * Most of the utility methods required by subclasses are package-private,\n * reflecting the intention that they be defined in the same package.\n * <p>\n * BasicGJChronology is thread-safe and immutable, and all subclasses must\n * be as well.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @author Guy Allard\n * @since 1.2, refactored from CommonGJChronology",abstract ,org.joda.time.chrono.BasicChronology,
org.joda.time.chrono.GJChronology,Class,"* Implements the Gregorian/Julian calendar system which is the calendar system\n * used in most of the world. Wherever possible, it is recommended to use the\n * {@link ISOChronology} instead.\n * <p>\n * The Gregorian calendar replaced the Julian calendar, and the point in time\n * when this chronology switches can be controlled using the second parameter\n * of the getInstance method. By default this cutover is set to the date the\n * Gregorian calendar was first instituted, October 15, 1582.\n * <p>\n * Before this date, this chronology uses the proleptic Julian calendar\n * (proleptic means extending indefinitely). The Julian calendar has leap years\n * every four years, whereas the Gregorian has special rules for 100 and 400\n * years. A meaningful result will thus be obtained for all input values.\n * However before 8 CE, Julian leap years were irregular, and before 45 BCE\n * there was no Julian calendar.\n * <p>\n * This chronology differs from\n * {@link java.util.GregorianCalendar GregorianCalendar} in that years\n * in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1.\n * The yearOfEra field produces results compatible with GregorianCalendar.\n * <p>\n * The Julian calendar does not have a year zero, and so year -1 is followed by\n * year 1. If the Gregorian cutover date is specified at or before year -1\n * (Julian), year zero is defined. In other words, the proleptic Gregorian\n * chronology used by this class has a year zero.\n * <p>\n * To create a pure proleptic Julian chronology, use {@link JulianChronology},\n * and to create a pure proleptic Gregorian chronology, use\n * {@link GregorianChronology}.\n * <p>\n * GJChronology is thread-safe and immutable.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0","public , final ",org.joda.time.chrono.AssembledChronology,
org.joda.time.chrono.GJChronology$CutoverField,Class,"* This basic cutover field adjusts calls to 'get' and 'set' methods, and\n     * assumes that calls to add and addWrapField are unaffected by the cutover.",private ,org.joda.time.field.BaseDateTimeField,
org.joda.time.chrono.GJChronology$ImpreciseCutoverField,Class,"* Cutover field for variable length fields. These fields internally call\n     * set whenever add is called. As a result, the same correction applied to\n     * set must be applied to add and addWrapField. Knowing when to use this\n     * field requires specific knowledge of how the GJ fields are implemented.","private , final ",org.joda.time.chrono.GJChronology.CutoverField,
org.joda.time.chrono.GJChronology$LinkedDurationField,Class,* Links the duration back to a ImpreciseCutoverField.,"private , static ",org.joda.time.field.DecoratedDurationField,
org.joda.time.chrono.StrictChronology,Class,"* Wraps another Chronology, ensuring all the fields are strict.\n * <p>\n * StrictChronology is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see StrictDateTimeField\n * @see LenientChronology","public , final ",org.joda.time.chrono.AssembledChronology,
org.joda.time.chrono.BuddhistChronology,Class,"* A chronology that matches the BuddhistCalendar class supplied by Sun.\n * <p>\n * The chronology is identical to the Gregorian/Julian, except that the\n * year is offset by +543 and the era is named 'BE' for Buddhist Era.\n * <p>\n * This class was intended by Sun to model the calendar used in Thailand.\n * However, the actual rules for Thailand are much more involved than\n * this class covers. (This class is accurate after 1941-01-01 ISO).\n * <p>\n * This chronology is being retained for those who want a same effect\n * replacement for the Sun class. It is hoped that community support will\n * enable a more accurate chronology for Thailand, to be developed.\n * <p>\n * BuddhistChronology is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , final ",org.joda.time.chrono.AssembledChronology,
org.joda.time.chrono.BasicSingleEraDateTimeField,Class,"* Provides time calculations for the coptic era component of time.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.2, refactored from CopticEraDateTimeField",final ,org.joda.time.field.BaseDateTimeField,
org.joda.time.chrono.GJDayOfWeekDateTimeField,Class,* GJDayOfWeekDateTimeField provides time calculations for the\n * day of the week component of time.\n *\n * @since 1.0\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill,final ,org.joda.time.field.PreciseDurationDateTimeField,
org.joda.time.chrono.BasicDayOfMonthDateTimeField,Class,"* Provides time calculations for the day of the month component of time.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.1, refactored from GJDayOfMonthDateTimeField",final ,org.joda.time.field.PreciseDurationDateTimeField,
org.joda.time.Interval,Class,"* Interval is the standard implementation of an immutable time interval.\n * <p>\n * A time interval represents a period of time between two instants.\n * Intervals are inclusive of the start instant and exclusive of the end.\n * The end instant is always greater than or equal to the start instant.\n * <p>\n * Intervals have a fixed millisecond duration.\n * This is the difference between the start and end instants.\n * The duration is represented separately by {@link ReadableDuration}.\n * As a result, intervals are not comparable.\n * To compare the length of two intervals, you should compare their durations.\n * <p>\n * An interval can also be converted to a {@link ReadablePeriod}.\n * This represents the difference between the start and end points in terms of fields\n * such as years and days.\n * <p>\n * Interval is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Sean Geoghegan\n * @author Stephen Colebourne\n * @author Julen Parra\n * @since 1.0","public , final ",org.joda.time.base.BaseInterval,org.joda.time.ReadableInterval;java.io.Serializable
org.joda.time.ReadWritablePeriod,Interface,* Defines a duration of time that can be queried and modified using datetime fields.\n * <p>\n * The implementation of this interface will be mutable.\n * It may provide more advanced methods than those in the interface.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,public ,org.joda.time.ReadablePeriod,
org.joda.time.DateTimeComparator,Class,* DateTimeComparator provides comparators to compare one date with another.\n * <p>\n * Dates may be specified using any object recognised by the\n * {@link org.joda.time.convert.ConverterManager ConverterManager} class.\n * <p>\n * The default objects recognised by the comparator are:\n * <ul>\n * <li>ReadableInstant\n * <li>String\n * <li>Calendar\n * <li>Date\n * <li>Long (milliseconds)\n * <li>null (now)\n * </ul>\n *\n * <p>\n * DateTimeComparator is thread-safe and immutable.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,public ,,java.util.Comparator;java.io.Serializable
org.joda.time.LocalDateTime,Class,"* LocalDateTime is an unmodifiable datetime class representing a\n * datetime without a time zone.\n * <p>\n * LocalDateTime implements the {@link ReadablePartial} interface.\n * To do this, certain methods focus on key fields Year, MonthOfYear,\n * DayOfYear and MillisOfDay.\n * However, <b>all</b> fields may in fact be queried.\n * <p>\n * Internally, LocalDateTime uses a single millisecond-based value to\n * represent the local datetime. This value is only used internally and\n * is not exposed to applications.\n * <p>\n * Calculations on LocalDateTime are performed using a {@link Chronology}.\n * This chronology will be set internally to be in the UTC time zone\n * for all calculations.\n *\n * <p>Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getHourOfDay()</code>\n * <li><code>hourOfDay().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value\n * <li>text value\n * <li>short text value\n * <li>maximum/minimum values\n * <li>add/subtract\n * <li>set\n * <li>rounding\n * </ul>\n *\n * <p>\n * LocalDateTime is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.3","public , final ",org.joda.time.base.BaseLocal,org.joda.time.ReadablePartial;java.io.Serializable
org.joda.time.LocalDateTime$Property,Class,"* LocalDateTime.Property binds a LocalDateTime to a DateTimeField allowing\n     * powerful datetime functionality to be easily accessed.\n     * <p>\n     * The simplest use of this class is as an alternative get method, here used to\n     * get the year '1972' (as an int) and the month 'December' (as a String).\n     * <pre>\n     * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0);\n     * int year = dt.year().get();\n     * String monthStr = dt.month().getAsText();\n     * </pre>\n     * <p>\n     * Methods are also provided that allow date modification. These return\n     * new instances of LocalDateTime - they do not modify the original.\n     * The example below yields two independent immutable date objects\n     * 20 years apart.\n     * <pre>\n     * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0);\n     * LocalDateTime dt1920 = dt.year().setCopy(1920);\n     * </pre>\n     * <p>\n     * LocalDateTime.Property itself is thread-safe and immutable, as well as the\n     * LocalDateTime being operated on.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.3","public , static , final ",org.joda.time.field.AbstractReadableInstantFieldProperty,
org.joda.time.DateTimeFieldType,Abstract Class,"* Identifies a field, such as year or minuteOfHour, in a chronology-neutral way.\n * <p>\n * A field type defines the type of the field, such as hourOfDay.\n * If does not directly enable any calculations, however it does provide a\n * {@link #getField(Chronology)} method that returns the actual calculation engine\n * for a particular chronology.\n * It also provides access to the related {@link DurationFieldType}s.\n * <p>\n * Instances of <code>DateTimeFieldType</code> are singletons.\n * They can be compared using <code>==</code>.\n * <p>\n * If required, you can create your own field, for example a quarterOfYear.\n * You must create a subclass of <code>DateTimeFieldType</code> that defines the field type.\n * This class returns the actual calculation engine from {@link #getField(Chronology)}.\n * The subclass should implement equals and hashCode.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , abstract ",,java.io.Serializable
org.joda.time.DateTimeFieldType$StandardDateTimeFieldType,Class,No Comment,"private , static ",org.joda.time.DateTimeFieldType,
org.joda.time.ReadWritableInterval,Interface,* Writable interface for an interval.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,public ,org.joda.time.ReadableInterval,
org.joda.time.Months,Class,"* An immutable time period representing a number of months.\n * <p>\n * <code>Months</code> is an immutable period that can only store months.\n * It does not store years, days or hours for example. As such it is a\n * type-safe way of representing a number of months in an application.\n * <p>\n * The number of months is set in the constructor, and may be queried using\n * <code>getMonths()</code>. Basic mathematical operations are provided -\n * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n * <code>dividedBy()</code>.\n * <p>\n * <code>Months</code> is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.4","public , final ",org.joda.time.base.BaseSingleFieldPeriod,
org.joda.time.LocalTime,Class,"* LocalTime is an immutable time class representing a time\n * without a time zone.\n * <p>\n * LocalTime implements the {@link ReadablePartial} interface.\n * To do this, the interface methods focus on the key fields -\n * HourOfDay, MinuteOfHour, SecondOfMinute and MillisOfSecond.\n * However, <b>all</b> time fields may in fact be queried.\n * <p>\n * Calculations on LocalTime are performed using a {@link Chronology}.\n * This chronology will be set internally to be in the UTC time zone\n * for all calculations.\n *\n * <p>Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getHourOfDay()</code>\n * <li><code>hourOfDay().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value\n * <li>text value\n * <li>short text value\n * <li>maximum/minimum values\n * <li>add/subtract\n * <li>set\n * <li>rounding\n * </ul>\n *\n * <p>\n * LocalTime is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.3","public , final ",org.joda.time.base.BaseLocal,org.joda.time.ReadablePartial;java.io.Serializable
org.joda.time.LocalTime$Property,Class,"* LocalTime.Property binds a LocalTime to a DateTimeField allowing\n     * powerful datetime functionality to be easily accessed.\n     * <p>\n     * The simplest use of this class is as an alternative get method, here used to\n     * get the minute '30'.\n     * <pre>\n     * LocalTime dt = new LocalTime(12, 30);\n     * int year = dt.minuteOfHour().get();\n     * </pre>\n     * <p>\n     * Methods are also provided that allow time modification. These return\n     * new instances of LocalTime - they do not modify the original. The example\n     * below yields two independent immutable date objects 2 hours apart.\n     * <pre>\n     * LocalTime dt1230 = new LocalTime(12, 30);\n     * LocalTime dt1430 = dt1230.hourOfDay().setCopy(14);\n     * </pre>\n     * <p>\n     * LocalTime.Property itself is thread-safe and immutable, as well as the\n     * LocalTime being operated on.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.3","public , static , final ",org.joda.time.field.AbstractReadableInstantFieldProperty,
org.joda.time.Weeks,Class,"* An immutable time period representing a number of weeks.\n * <p>\n * <code>Weeks</code> is an immutable period that can only store weeks.\n * It does not store years, months or hours for example. As such it is a\n * type-safe way of representing a number of weeks in an application.\n * <p>\n * The number of weeks is set in the constructor, and may be queried using\n * <code>getWeeks()</code>. Basic mathematical operations are provided -\n * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n * <code>dividedBy()</code>.\n * <p>\n * <code>Weeks</code> is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.4","public , final ",org.joda.time.base.BaseSingleFieldPeriod,
org.joda.time.Hours,Class,"* An immutable time period representing a number of hours.\n * <p>\n * <code>Hours</code> is an immutable period that can only store hours.\n * It does not store years, months or minutes for example. As such it is a\n * type-safe way of representing a number of hours in an application.\n * <p>\n * The number of hours is set in the constructor, and may be queried using\n * <code>getHours()</code>. Basic mathematical operations are provided -\n * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n * <code>dividedBy()</code>.\n * <p>\n * <code>Hours</code> is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.4","public , final ",org.joda.time.base.BaseSingleFieldPeriod,
org.joda.time.field.OffsetDateTimeField,Class,* Generic offset adjusting datetime field.\n * <p>\n * OffsetDateTimeField is thread-safe and immutable.\n * \n * @author Brian S O'Neill\n * @since 1.0,public ,org.joda.time.field.DecoratedDateTimeField,
org.joda.time.field.SkipDateTimeField,Class,"* Wraps another field such that a certain value is skipped.\n * <p>\n * This is most useful for years where you want to skip zero, so the\n * sequence runs ...,2,1,-1,-2,...\n * <p>\n * SkipDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0","public , final ",org.joda.time.field.DelegatedDateTimeField,
org.joda.time.field.SkipUndoDateTimeField,Class,* Wraps another field such that a certain value is added back into\n * the sequence of numbers.\n * <p>\n * This reverses the effect of SkipDateTimeField. This isn't very\n * elegant.\n * <p>\n * SkipUndoDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,"public , final ",org.joda.time.field.DelegatedDateTimeField,
org.joda.time.field.ScaledDurationField,Class,* Scales a DurationField such that it's unit millis becomes larger in\n * magnitude.\n * <p>\n * ScaledDurationField is thread-safe and immutable.\n *\n * @see PreciseDurationField\n *\n * @author Brian S O'Neill\n * @since 1.0,public ,org.joda.time.field.DecoratedDurationField,
org.joda.time.field.PreciseDateTimeField,Class,"* Precise datetime field, composed of two precise duration fields.\n * <p>\n * This DateTimeField is useful for defining DateTimeFields that are composed\n * of precise durations, like time of day fields. If either duration field is\n * imprecise, then an {@link ImpreciseDateTimeField} may be used instead.\n * <p>\n * PreciseDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n * @see ImpreciseDateTimeField",public ,org.joda.time.field.PreciseDurationDateTimeField,
org.joda.time.field.AbstractReadableInstantFieldProperty,Abstract Class,"* AbstractReadableInstantFieldProperty is a base class for binding a\n * ReadableInstant to a DateTimeField.\n * <p>\n * It allows the date and time manipulation code to be field based yet\n * still easy to use.\n * <p>\n * AbstractReadableInstantFieldProperty itself is thread-safe and immutable,\n * but the ReadableInstant being operated on may be mutable and not\n * thread-safe.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @author Mike Schrag\n * @since 1.0","public , abstract ",,java.io.Serializable
org.joda.time.field.MillisDurationField,Class,* Duration field class representing a field with a fixed unit length of one\n * millisecond.\n * <p>\n * MillisDurationField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0,"public , final ",org.joda.time.DurationField,java.io.Serializable
org.joda.time.field.PreciseDurationDateTimeField,Abstract Class,"* Precise datetime field, which has a precise unit duration field.\n * <p>\n * PreciseDurationDateTimeField is thread-safe and immutable, and its\n * subclasses must be as well.\n *\n * @author Brian S O'Neill\n * @since 1.0","public , abstract ",org.joda.time.field.BaseDateTimeField,
org.joda.time.field.StrictDateTimeField,Class,"* Converts a lenient DateTimeField into a strict one. By being strict, the set\n * throws an IllegalArgumentException if the value is out of bounds.\n * <p>\n * StrictDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @see org.joda.time.chrono.StrictChronology\n * @see LenientDateTimeField\n * @since 1.0",public ,org.joda.time.field.DelegatedDateTimeField,
org.joda.time.field.PreciseDurationField,Class,* Duration field class representing a field with a fixed unit length.\n * <p>\n * PreciseDurationField is thread-safe and immutable.\n * \n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,public ,org.joda.time.field.BaseDurationField,
org.joda.time.field.ZeroIsMaxDateTimeField,Class,"* Wraps another field such that zero values are replaced with one more than\n * it's maximum. This is particularly useful for implementing an clockhourOfDay\n * field, where the midnight value of 0 is replaced with 24.\n * <p>\n * ZeroIsMaxDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0","public , final ",org.joda.time.field.DecoratedDateTimeField,
org.joda.time.field.DecoratedDurationField,Class,"* <code>DecoratedDurationField</code> extends {@link BaseDurationField},\n * implementing only the minimum required set of methods. These implemented\n * methods delegate to a wrapped field.\n * <p>\n * This design allows new DurationField types to be defined that piggyback on\n * top of another, inheriting all the safe method implementations from\n * BaseDurationField. Should any method require pure delegation to the\n * wrapped field, simply override and use the provided getWrappedField method.\n * <p>\n * DecoratedDurationField is thread-safe and immutable, and its subclasses must\n * be as well.\n *\n * @author Brian S O'Neill\n * @see DelegatedDurationField\n * @since 1.0",public ,org.joda.time.field.BaseDurationField,
org.joda.time.field.DividedDateTimeField,Class,"* Divides a DateTimeField such that the retrieved values are reduced by a\n * fixed divisor. The field's unit duration is scaled accordingly, but the\n * range duration is unchanged.\n * <p>\n * DividedDateTimeField is thread-safe and immutable.\n *\n * @see RemainderDateTimeField\n * \n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0",public ,org.joda.time.field.DecoratedDateTimeField,
org.joda.time.field.RemainderDateTimeField,Class,"* Counterpart remainder datetime field to {@link DividedDateTimeField}. The\n * field's unit duration is unchanged, but the range duration is scaled\n * accordingly.\n * <p>\n * RemainderDateTimeField is thread-safe and immutable.\n *\n * @see DividedDateTimeField\n *\n * @author Brian S O'Neill\n * @since 1.0",public ,org.joda.time.field.DecoratedDateTimeField,
org.joda.time.field.DecoratedDateTimeField,Abstract Class,"* <code>DecoratedDateTimeField</code> extends {@link BaseDateTimeField},\n * implementing only the minimum required set of methods. These implemented\n * methods delegate to a wrapped field.\n * <p>\n * This design allows new DateTimeField types to be defined that piggyback on\n * top of another, inheriting all the safe method implementations from\n * BaseDateTimeField. Should any method require pure delegation to the\n * wrapped field, simply override and use the provided getWrappedField method.\n * <p>\n * DecoratedDateTimeField is thread-safe and immutable, and its subclasses must\n * be as well.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see DelegatedDateTimeField","public , abstract ",org.joda.time.field.BaseDateTimeField,
org.joda.time.field.LenientDateTimeField,Class,"* Converts a strict DateTimeField into a lenient one. By being lenient, the\n * set method accepts out of bounds values, performing an addition instead.\n * <p>\n * LenientDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @see org.joda.time.chrono.LenientChronology\n * @see StrictDateTimeField\n * @since 1.0",public ,org.joda.time.field.DelegatedDateTimeField,
org.joda.time.field.DelegatedDurationField,Class,"* <code>DelegatedDurationField</code> delegates each method call to the\n * duration field it wraps.\n * <p>\n * DelegatedDurationField is thread-safe and immutable, and its subclasses must\n * be as well.\n *\n * @author Brian S O'Neill\n * @see DecoratedDurationField\n * @since 1.0",public ,org.joda.time.DurationField,java.io.Serializable
org.joda.time.field.AbstractPartialFieldProperty,Abstract Class,* AbstractPartialFieldProperty is a base class for binding a\n * ReadablePartial to a DateTimeField.\n * <p>\n * It allows the date and time manipulation code to be field based yet\n * still easy to use.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,"public , abstract ",,
org.joda.time.field.BaseDurationField,Abstract Class,"* BaseDurationField provides the common behaviour for DurationField\n * implementations.\n * <p>\n * This class should generally not be used directly by API users. The\n * DurationField class should be used when different kinds of DurationField\n * objects are to be referenced.\n * <p>\n * BaseDurationField is thread-safe and immutable, and its subclasses must\n * be as well.\n *\n * @author Brian S O'Neill\n * @see DecoratedDurationField\n * @since 1.0","public , abstract ",org.joda.time.DurationField,java.io.Serializable
org.joda.time.field.UnsupportedDurationField,Class,* A placeholder implementation to use when a duration field is not supported.\n * <p>\n * UnsupportedDurationField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0,"public , final ",org.joda.time.DurationField,java.io.Serializable
org.joda.time.field.UnsupportedDateTimeField,Class,* A placeholder implementation to use when a datetime field is not supported.\n * <p>\n * UnsupportedDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0,"public , final ",org.joda.time.DateTimeField,java.io.Serializable
org.joda.time.field.BaseDateTimeField,Abstract Class,"* BaseDateTimeField provides the common behaviour for DateTimeField\n * implementations. \n * <p>\n * This class should generally not be used directly by API users. The\n * DateTimeField class should be used when different kinds of DateTimeField\n * objects are to be referenced.\n * <p>\n * BaseDateTimeField is thread-safe and immutable, and its subclasses must\n * be as well.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see DecoratedDateTimeField","public , abstract ",org.joda.time.DateTimeField,
org.joda.time.field.ImpreciseDateTimeField,Abstract Class,"* Abstract datetime field class that defines its own DurationField, which\n * delegates back into this ImpreciseDateTimeField.\n * <p>\n * This DateTimeField is useful for defining DateTimeFields that are composed\n * of imprecise durations. If both duration fields are precise, then a\n * {@link PreciseDateTimeField} should be used instead.\n * <p>\n * When defining imprecise DateTimeFields where a matching DurationField is\n * already available, just extend BaseDateTimeField directly so as not to\n * create redundant DurationField instances.\n * <p>\n * ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must\n * be as well.\n *\n * @author Brian S O'Neill\n * @see PreciseDateTimeField\n * @since 1.0","public , abstract ",org.joda.time.field.BaseDateTimeField,
org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField,Class,No Comment,"private , final ",org.joda.time.field.BaseDurationField,
org.joda.time.field.FieldUtils,Class,* General utilities that don't fit elsewhere.\n * <p>\n * FieldUtils is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.0,public ,,
org.joda.time.field.DelegatedDateTimeField,Class,"* <code>DelegatedDateTimeField</code> delegates each method call to the\n * date time field it wraps.\n * <p>\n * DelegatedDateTimeField is thread-safe and immutable, and its subclasses must\n * be as well.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see DecoratedDateTimeField",public ,org.joda.time.DateTimeField,java.io.Serializable
org.joda.time.YearMonth,Class,"* YearMonth is an immutable partial supporting the year and monthOfYear fields.\n * <p>\n * NOTE: This class only supports the two fields listed above.\n * It is impossible to query any other fields, such as dayOfWeek or centuryOfEra.\n * <p>\n * Calculations on YearMonth are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * One use case for this class is to store a credit card expiry date, as that only\n * references the year and month.\n * This class can be used as the gYearMonth type in XML Schema.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getMonthOfYear()</code>\n * <li><code>monthOfYear().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * YearMonth is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 2.0","public , final ",org.joda.time.base.BasePartial,org.joda.time.ReadablePartial;java.io.Serializable
org.joda.time.YearMonth$Property,Class,* The property class for <code>YearMonth</code>.\n     * <p>\n     * This class binds a <code>YearMonth</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 2.0,"public , static ",org.joda.time.field.AbstractPartialFieldProperty,java.io.Serializable
org.joda.time.DateTimeUtils,Class,* DateTimeUtils provide public utility methods for the date-time library.\n * <p>\n * DateTimeUtils uses shared static variables which are declared as volatile\n * for thread-safety. These can be changed during the lifetime of the application\n * however doing so is generally a bad idea.\n *\n * @author Stephen Colebourne\n * @since 1.0,public ,,
org.joda.time.DateTimeUtils$MillisProvider,Interface,"* A millisecond provider, allowing control of the system clock.\n     * \n     * @author Stephen Colebourne\n     * @since 2.0 (previously private)","public , static ",,
org.joda.time.DateTimeUtils$SystemMillisProvider,Class,* System millis provider.,static ,,org.joda.time.DateTimeUtils.MillisProvider
org.joda.time.DateTimeUtils$FixedMillisProvider,Class,* Fixed millisecond provider.,static ,,org.joda.time.DateTimeUtils.MillisProvider
org.joda.time.DateTimeUtils$OffsetMillisProvider,Class,* Offset from system millis provider.,static ,,org.joda.time.DateTimeUtils.MillisProvider
org.joda.time.UTCDateTimeZone,Class,* A DateTimeZone implementation for UTC.\n * <p>\n * This exists instead of using FixedDateTimeZone to avoid deadlocks.\n * https://github.com/JodaOrg/joda-time/issues/171,final ,org.joda.time.DateTimeZone,
org.joda.time.MonthDay,Class,"* MonthDay is an immutable partial supporting the monthOfYear and dayOfMonth fields.\n * <p>\n * NOTE: This class only supports the two fields listed above.\n * It is impossible to query any other fields, such as dayOfWeek or centuryOfEra.\n * <p>\n * Calculations on MonthDay are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * One use case for this class is to store a birthday without the year (to avoid\n * storing the age of the person).\n * This class can be used as the gMonthDay type in XML Schema.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getMonthOfYear()</code>\n * <li><code>monthOfYear().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * MonthDay is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Chris Pheby\n * @since 2.0","public , final ",org.joda.time.base.BasePartial,org.joda.time.ReadablePartial;java.io.Serializable
org.joda.time.MonthDay$Property,Class,* The property class for <code>MonthDay</code>.\n     * <p>\n     * This class binds a <code>YearMonth</code> to a <code>DateTimeField</code>.\n     * \n     * @author Chris Pheby\n     * @since 2.0,"public , static ",org.joda.time.field.AbstractPartialFieldProperty,java.io.Serializable
org.joda.time.TimeOfDay,Class,"* TimeOfDay is an immutable partial supporting the hour, minute, second\n * and millisecond fields.\n * <p>\n * NOTE: This class only supports the four fields listed above. Thus, you\n * cannot query the millisOfDay or secondOfDay fields for example.\n * The new <code>LocalTime</code> class removes this restriction.\n * <p>\n * Calculations on TimeOfDay are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getHourOfDay()</code>\n * <li><code>hourOfDay().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>hourOfDay().get()</code>\n * <li>text value - <code>hourOfDay().getAsText()</code>\n * <li>short text value - <code>hourOfDay().getAsShortText()</code>\n * <li>maximum/minimum values - <code>hourOfDay().getMaximumValue()</code>\n * <li>add/subtract - <code>hourOfDay().addToCopy()</code>\n * <li>set - <code>hourOfDay().setCopy()</code>\n * </ul>\n * <p>\n * TimeOfDay is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0\n * @deprecated Use LocalTime which has a much better internal implementation and\n *  has been available since 1.3","public , final ",org.joda.time.base.BasePartial,org.joda.time.ReadablePartial;java.io.Serializable
org.joda.time.TimeOfDay$Property,Class,* The property class for <code>TimeOfDay</code>.\n     * <p>\n     * This class binds a <code>TimeOfDay</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 1.0\n     * @deprecated Use LocalTime which has a much better internal implementation,"public , static ",org.joda.time.field.AbstractPartialFieldProperty,java.io.Serializable
org.joda.time.Chronology,Abstract Class,"* Chronology provides access to the individual date time fields for a\n * chronological calendar system.\n * <p>\n * Various chronologies are supported by subclasses including ISO\n * and GregorianJulian. To construct a Chronology you should use the\n * factory methods on the chronology subclass in the chrono package.\n * <p>\n * For example, to obtain the current time in the coptic calendar system:\n * <pre>\n * DateTime dt = new DateTime(CopticChronology.getInstance());\n * </pre>\n * <p>\n * The provided chronology implementations are:\n * <ul>\n * <li>ISO - The <i>de facto<i> world calendar system, based on the ISO-8601 standard\n * <li>GJ - Historically accurate calendar with Julian followed by Gregorian\n * <li>Gregorian - The Gregorian calendar system used for all time (proleptic)\n * <li>Julian - The Julian calendar system used for all time (proleptic)\n * <li>Buddhist - The Buddhist calendar system which is an offset in years from GJ\n * <li>Coptic - The Coptic calendar system which defines 30 day months\n * <li>Ethiopic - The Ethiopic calendar system which defines 30 day months\n * <li>Islamic - The Islamic, or Hijri, lunar calendar system\n * </ul>\n * Hopefully future releases will contain more chronologies.\n * <p>\n * This class defines a number of fields with names from the ISO8601 standard.\n * It does not 'strongly' define these fields however, thus implementations\n * are free to interpret the field names as they wish.\n * For example, a week could be defined as 10 days and a month as 40 days in a\n * special WeirdChronology implementation. Clearly the GJ and ISO\n * implementations provided use the field names as you would expect.\n *\n * @see org.joda.time.chrono.ISOChronology\n * @see org.joda.time.chrono.GJChronology\n * @see org.joda.time.chrono.GregorianChronology\n * @see org.joda.time.chrono.JulianChronology\n * @see org.joda.time.chrono.CopticChronology\n * @see org.joda.time.chrono.BuddhistChronology\n * @see org.joda.time.chrono.EthiopicChronology\n * @see org.joda.time.chrono.IslamicChronology\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , abstract ",,
org.joda.time.YearMonthDay,Class,"* YearMonthDay is an immutable partial supporting the year, monthOfYear\n * and dayOfMonth fields.\n * <p>\n * NOTE: This class only supports the three fields listed above. Thus, you\n * cannot query the dayOfWeek or centuryOfEra fields for example.\n * The new <code>LocalDate</code> class removes this restriction.\n * <p>\n * Calculations on YearMonthDay are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getMonthOfYear()</code>\n * <li><code>monthOfYear().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value - <code>monthOfYear().get()</code>\n * <li>text value - <code>monthOfYear().getAsText()</code>\n * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n * <li>set - <code>monthOfYear().setCopy()</code>\n * </ul>\n * <p>\n * YearMonthDay is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.0\n * @deprecated Use LocalDate which has a much better internal implementation and\n *  has been available since 1.3","public , final ",org.joda.time.base.BasePartial,org.joda.time.ReadablePartial;java.io.Serializable
org.joda.time.YearMonthDay$Property,Class,* The property class for <code>YearMonthDay</code>.\n     * <p>\n     * This class binds a <code>YearMonthDay</code> to a <code>DateTimeField</code>.\n     * \n     * @author Stephen Colebourne\n     * @since 1.0\n     * @deprecated Use LocalDate which has a much better internal implementation,"public , static ",org.joda.time.field.AbstractPartialFieldProperty,java.io.Serializable
org.joda.time.JodaTimePermission,Class,"* JodaTimePermission is used for securing global method calls in the Joda-Time\n * library. Since this class extends BasicPermission, asterisks may be used to\n * denote wildcard permissions. The following permissions are supported:\n *\n * <pre>\n * DateTimeZone\n *   .setDefault                 Allows a default DateTimeZone to be set\n *   .setProvider                Allows the DateTimeZone instance provider to be set\n *   .setNameProvider            Allows the DateTimeZone name provider to be set\n *\n * ConverterManager\n *   .alterInstantConverters     Allows an instant converter to be added or removed\n *   .alterPartialConverters     Allows a partial converter to be added or removed\n *   .alterDurationConverters    Allows a duration converter to be added or removed\n *   .alterPeriodConverters      Allows a period converter to be added or removed\n *   .alterIntervalConverters    Allows an interval converter to be added or removed\n *\n * CurrentTime.setProvider       Allows the current time provider to be set\n * </pre>\n * <p>\n * JodaTimePermission is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0",public ,java.security.BasicPermission,
org.joda.time.DateTimeZone,Abstract Class,"* DateTimeZone represents a time zone.\n * <p>\n * A time zone is a system of rules to convert time from one geographic \n * location to another. For example, Paris, France is one hour ahead of\n * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n * <p>\n * All time zone rules are expressed, for historical reasons, relative to\n * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n * Time (GMT).  This is similar, but not precisely identical, to Universal \n * Coordinated Time, or UTC. This library only uses the term UTC.\n * <p>\n * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n * <p>\n * The offset differs in the summer because of daylight saving time, or DST.\n * The following definitions are helpful:\n * <ul>\n * <li>UTC - The reference time.\n * <li>Offset - The amount of time a zone differs from UTC. This can vary during the year.\n * <li>Daylight Saving - The process of having two offsets each year, one in winter and one in summer.\n * <li>Raw offset - The base offset of the zone.\n * <li>Additional offset - The additional offset on top of the raw offset.\n *   This is typically zero in winter and one hour in summer in zones that apply DST.\n * <li>Actual offset - The actual offset that applies, which is the combination of the raw offset and additional offset.\n * </ul>\n * <p>\n * For example, in 2018 Greece applied daylight saving.\n * Throughout the whole year, the raw offset was +02:00.\n * In winter, the additional offset was zero, while in summer the additional offset was one hour.\n * Thus, the actual offset was +02:00 in winter and +03:00 in summer.\n * <p>\n * Note: Some governments, most notably Ireland, define daylight saving by describing\n * a ""standard"" time in summer and a <i>negative</i> DST offset in winter.\n * Joda-Time, like the JDK, follows a model for time-zone data where there is a\n * raw offset all year round and a <i>positive</i> additional offset.\n * As such, callers cannot assume that the raw offset is that defined by law for the zone.\n * <p>\n * Note: Some governments define a daylight saving time that applies for two separate periods.\n * For example, the year might be winter time, then summer time, then a special time equal\n * to winter time, then back to summer time before finally dropping back to winter time.\n * As such, callers cannot assume that the raw and DST offsets directly correlate to summer and winter.\n * <p>\n * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n * supports long format time zone ids. Thus PST and ECT are not accepted.\n * However, the factory that accepts a TimeZone will attempt to convert from\n * the old short id to a suitable long id.\n * <p>\n * There are four approaches to loading time-zone data, which are tried in this order:\n * <ol>\n * <li>load the specific {@link Provider} specified by the system property\n *   {@code org.joda.time.DateTimeZone.Provider}.\n * <li>load {@link ZoneInfoProvider} using the data in the filing system folder\n *   pointed to by system property {@code org.joda.time.DateTimeZone.Folder}.\n * <li>load {@link ZoneInfoProvider} using the data in the classpath location\n *   {@code org/joda/time/tz/data}.\n * <li>load {@link UTCProvider}\n * </ol>\n * <p>\n * Unless you override the standard behaviour, the default if the third approach.\n * <p>\n * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n * well.\n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0","public , abstract ",,java.io.Serializable
org.joda.time.DateTimeZone$Stub,Class,* Used to serialize DateTimeZones by id.,"private , static , final ",,java.io.Serializable
org.joda.time.DateTimeZone$LazyInit,Class,* Lazy initialization to avoid a synchronization lock.,"static , final ",,
org.joda.time.Days,Class,"* An immutable time period representing a number of days.\n * <p>\n * <code>Days</code> is an immutable period that can only store days.\n * It does not store years, months or hours for example. As such it is a\n * type-safe way of representing a number of days in an application.\n * <p>\n * The number of days is set in the constructor, and may be queried using\n * <code>getDays()</code>. Basic mathematical operations are provided -\n * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n * <code>dividedBy()</code>.\n * <p>\n * <code>Days</code> is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.4","public , final ",org.joda.time.base.BaseSingleFieldPeriod,
org.joda.time.format.DateTimeParserBucket,Class,"* DateTimeParserBucket is an advanced class, intended mainly for parser\n * implementations. It can also be used during normal parsing operations to\n * capture more information about the parse.\n * <p>\n * This class allows fields to be saved in any order, but be physically set in\n * a consistent order. This is useful for parsing against formats that allow\n * field values to contradict each other.\n * <p>\n * Field values are applied in an order where the ""larger"" fields are set\n * first, making their value less likely to stick.  A field is larger than\n * another when it's range duration is longer. If both ranges are the same,\n * then the larger field has the longer duration. If it cannot be determined\n * which field is larger, then the fields are set in the order they were saved.\n * <p>\n * For example, these fields were saved in this order: dayOfWeek, monthOfYear,\n * dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in\n * this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.\n * <p>\n * DateTimeParserBucket is mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Fredrik Borgh\n * @since 1.0",public ,,
org.joda.time.format.DateTimeParserBucket$SavedState,Class,No Comment,,,
org.joda.time.format.DateTimeParserBucket$SavedField,Class,No Comment,static ,,java.lang.Comparable
org.joda.time.format.PeriodFormatterBuilder,Class,"* Factory that creates complex instances of PeriodFormatter via method calls.\n * <p>\n * Period formatting is performed by the {@link PeriodFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.\n * <p>\n * PeriodFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints years and months, like ""15 years and 8 months"",\n * can be constructed as follows:\n * <p>\n * <pre>\n * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()\n *     .printZeroAlways()\n *     .appendYears()\n *     .appendSuffix("" year"", "" years"")\n *     .appendSeparator("" and "")\n *     .printZeroRarelyLast()\n *     .appendMonths()\n *     .appendSuffix("" month"", "" months"")\n *     .toFormatter();\n * </pre>\n * <p>\n * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see PeriodFormat",public ,,
org.joda.time.format.PeriodFormatterBuilder$PeriodFieldAffix,Interface,* Defines a formatted field's prefix or suffix text.\n     * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.,static ,,
org.joda.time.format.PeriodFormatterBuilder$SimpleAffix,Class,* Implements an affix where the text does not vary by the amount.,static ,org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix,
org.joda.time.format.PeriodFormatterBuilder$PluralAffix,Class,* Implements an affix where the text varies by the amount of the field.\n     * Only singular (1) and plural (not 1) are supported.,static ,org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix,
org.joda.time.format.PeriodFormatterBuilder$RegExAffix,Class,* Implements an affix where the text varies by the amount of the field.\n     * Different amounts are supported based on the provided parameters.,static ,org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix,
org.joda.time.format.PeriodFormatterBuilder$CompositeAffix,Class,* Builds a composite affix by merging two other affix implementations.,static ,org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix,
org.joda.time.format.PeriodFormatterBuilder$FieldFormatter,Class,"* Formats the numeric value of a field, potentially with prefix/suffix.",static ,,org.joda.time.format.PeriodPrinter;org.joda.time.format.PeriodParser
org.joda.time.format.PeriodFormatterBuilder$Literal,Class,* Handles a simple literal piece of text.,static ,,org.joda.time.format.PeriodPrinter;org.joda.time.format.PeriodParser
org.joda.time.format.PeriodFormatterBuilder$Separator,Class,"* Handles a separator, that splits the fields into multiple parts.\n     * For example, the 'T' in the ISO8601 standard.",static ,,org.joda.time.format.PeriodPrinter;org.joda.time.format.PeriodParser
org.joda.time.format.PeriodFormatterBuilder$Composite,Class,* Composite implementation that merges other fields to create a full pattern.,static ,,org.joda.time.format.PeriodPrinter;org.joda.time.format.PeriodParser
org.joda.time.format.PeriodFormatterBuilder$IgnorableAffix,Abstract Class,* An affix that can be ignored.,"static , abstract ",,org.joda.time.format.PeriodFormatterBuilder.PeriodFieldAffix
org.joda.time.format.FormatUtils,Class,* Utility methods used by formatters.\n * <p>\n * FormatUtils is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0,public ,,
org.joda.time.format.DateTimeFormatterBuilder,Class,"* Factory that creates complex instances of DateTimeFormatter via method calls.\n * <p>\n * Datetime formatting is performed by the {@link DateTimeFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link DateTimeFormat} and {@link ISODateTimeFormat}.\n * <p>\n * DateTimeFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints month and year, like ""January 1970"",\n * can be constructed as follows:\n * <p>\n * <pre>\n * DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()\n *     .appendMonthOfYearText()\n *     .appendLiteral(' ')\n *     .appendYear(4, 4)\n *     .toFormatter();\n * </pre>\n * <p>\n * DateTimeFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Fredrik Borgh\n * @since 1.0\n * @see DateTimeFormat\n * @see ISODateTimeFormat",public ,,
org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$StringLiteral,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber,Class,-----------------------------------------------------------------------,static ,org.joda.time.format.DateTimeFormatterBuilder.NumberFormatter,
org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber,Class,-----------------------------------------------------------------------,static ,org.joda.time.format.DateTimeFormatterBuilder.NumberFormatter,
org.joda.time.format.DateTimeFormatterBuilder$FixedNumber,Class,-----------------------------------------------------------------------,static ,org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber,
org.joda.time.format.DateTimeFormatterBuilder$TwoDigitYear,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$TextField,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$Fraction,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$TimeZoneName,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId,Enum,-----------------------------------------------------------------------,static ,enum has no extends,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$Composite,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$MatchingParser,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter,Abstract Class,-----------------------------------------------------------------------,"static , abstract ",,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.InternalParser,Interface,* Internal interface for parsing textual representations of datetimes.\n * <p>\n * This has been separated from {@link DateTimeParser} to change to using\n * {@code CharSequence}.\n *\n * @author Stephen Colebourne\n * @since 2.4,default,,
org.joda.time.format.DateTimePrinter,Interface,"* Internal interface for creating textual representations of datetimes.\n * <p>\n * Application users will rarely use this class directly. Instead, you\n * will use one of the factory classes to create a {@link DateTimeFormatter}.\n * <p>\n * The factory classes are:<br />\n * - {@link DateTimeFormatterBuilder}<br />\n * - {@link DateTimeFormat}<br />\n * - {@link ISODateTimeFormat}<br />\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @see DateTimeFormatterBuilder\n * @see DateTimeFormat\n * @see ISODateTimeFormat\n * @since 1.0",public ,,
org.joda.time.format.ISOPeriodFormat,Class,"* Factory that creates instances of PeriodFormatter for the ISO8601 standard.\n * <p>\n * Period formatting is performed by the {@link PeriodFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link PeriodFormat} and {@link PeriodFormatterBuilder}.\n * <p>\n * ISOPeriodFormat is thread-safe and immutable, and the formatters it\n * returns are as well.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see PeriodFormat\n * @see PeriodFormatterBuilder",public ,,
org.joda.time.format.InternalPrinter,Interface,* Internal interface for creating textual representations of datetimes.\n * <p>\n * This has been separated from {@link DateTimePrinter} to avoid code duplication.\n *\n * @author Stephen Colebourne\n * @since 2.4,default,,
org.joda.time.format.PeriodFormat,Class,"* Factory that creates instances of PeriodFormatter.\n * <p>\n * Period formatting is performed by the {@link PeriodFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link ISOPeriodFormat} and {@link PeriodFormatterBuilder}.\n * <p>\n * PeriodFormat is thread-safe and immutable, and the formatters it returns\n * are as well.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see ISOPeriodFormat\n * @see PeriodFormatterBuilder",public ,,
org.joda.time.format.PeriodFormat$DynamicWordBased,Class,* Printer/parser that reacts to the locale and changes the word-based\n     * pattern if necessary.,static ,,org.joda.time.format.PeriodPrinter;org.joda.time.format.PeriodParser
org.joda.time.format.DateTimeFormatter,Class,"* Controls the printing and parsing of a datetime to and from a string.\n * <p>\n * This class is the main API for printing and parsing used by most applications.\n * Instances of this class are created via one of three factory classes:\n * <ul>\n * <li>{@link DateTimeFormat} - formats by pattern and style</li>\n * <li>{@link ISODateTimeFormat} - ISO8601 formats</li>\n * <li>{@link DateTimeFormatterBuilder} - complex formats created via method calls</li>\n * </ul>\n * <p>\n * An instance of this class holds a reference internally to one printer and\n * one parser. It is possible that one of these may be null, in which case the\n * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}\n * and {@link #isParser()} methods.\n * <p>\n * The underlying printer/parser can be altered to behave exactly as required\n * by using one of the decorator modifiers:\n * <ul>\n * <li>{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale</li>\n * <li>{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone</li>\n * <li>{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology</li>\n * <li>{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset</li>\n * <li>{@link #withPivotYear(int)} - returns a new formatter with the specified pivot year</li>\n * <li>{@link #withDefaultYear(int)} - returns a new formatter with the specified default year</li>\n * </ul>\n * Each of these returns a new formatter (instances of this class are immutable).\n * <p>\n * The main methods of the class are the <code>printXxx</code> and\n * <code>parseXxx</code> methods. These are used as follows:\n * <pre>\n * // print using the defaults (default locale, chronology/zone of the datetime)\n * String dateStr = formatter.print(dt);\n * // print using the French locale\n * String dateStr = formatter.withLocale(Locale.FRENCH).print(dt);\n * // print using the UTC zone\n * String dateStr = formatter.withZone(DateTimeZone.UTC).print(dt);\n * \n * // parse using the Paris zone\n * DateTime date = formatter.withZone(DateTimeZone.forID(""Europe/Paris"")).parseDateTime(str);\n * </pre>\n * <p>\n * Parsing builds up the resultant instant by 'setting' the value of each parsed field\n * from largest to smallest onto an initial instant, typically 1970-01-01T00:00Z.\n * This design means that day-of-month is set before day-of-week.\n * As such, if both the day-of-month and day-of-week are parsed, and the day-of-week\n * is incorrect, then the day-of-week overrides the day-of-month.\n * \n * This has a side effect if the input is not consistent.\n * \n * \n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Fredrik Borgh\n * @since 1.0",public ,,
org.joda.time.format.DateTimeParserInternalParser,Class,* Adapter between old and new parser interface.\n *\n * @author Stephen Colebourne\n * @since 2.4,default,,org.joda.time.format.InternalParser
org.joda.time.format.PeriodParser,Interface,"* Internal interface for parsing textual representations of time periods.\n * <p>\n * Application users will rarely use this class directly. Instead, you\n * will use one of the factory classes to create a {@link PeriodFormatter}.\n * <p>\n * The factory classes are:<br />\n * - {@link PeriodFormatterBuilder}<br />\n * - {@link PeriodFormat}<br />\n * - {@link ISOPeriodFormat}<br />\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n * @see PeriodFormatter\n * @see PeriodFormatterBuilder\n * @see PeriodFormat",public ,,
org.joda.time.format.InternalPrinterDateTimePrinter,Class,* Adapter between old and new printer interface.\n *\n * @author Stephen Colebourne\n * @since 2.4,default,,org.joda.time.format.DateTimePrinter;org.joda.time.format.InternalPrinter
org.joda.time.format.DateTimeParser,Interface,"* Internal interface for parsing textual representations of datetimes.\n * <p>\n * Application users will rarely use this class directly. Instead, you\n * will use one of the factory classes to create a {@link DateTimeFormatter}.\n * <p>\n * The factory classes are:<br />\n * - {@link DateTimeFormatterBuilder}<br />\n * - {@link DateTimeFormat}<br />\n * - {@link ISODateTimeFormat}<br />\n *\n * @author Brian S O'Neill\n * @see DateTimeFormatter\n * @see DateTimeFormatterBuilder\n * @see DateTimeFormat\n * @since 1.0",public ,,
org.joda.time.format.ISODateTimeFormat,Class,"* Factory that creates instances of DateTimeFormatter based on the ISO8601 standard.\n * <p>\n * Date-time formatting is performed by the {@link DateTimeFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link DateTimeFormat} and {@link DateTimeFormatterBuilder}.\n * <p>\n * ISO8601 is the international standard for data interchange. It defines a\n * framework, rather than an absolute standard. As a result this provider has a\n * number of methods that represent common uses of the framework. The most common\n * formats are {@link #date() date}, {@link #time() time}, and {@link #dateTime() dateTime}.\n * <p>\n * For example, to format a date time in ISO format:\n * <pre>\n * DateTime dt = new DateTime();\n * DateTimeFormatter fmt = ISODateTimeFormat.dateTime();\n * String str = fmt.print(dt);\n * </pre>\n * <p>\n * Note that these formatters mostly follow the ISO8601 standard for printing.\n * For parsing, the formatters are more lenient and allow formats that are not\n * in strict compliance with the standard.\n * <p>\n * It is important to understand that these formatters are not linked to\n * the <code>ISOChronology</code>. These formatters may be used with any\n * chronology, however there may be certain side effects with more unusual\n * chronologies. For example, the ISO formatters rely on dayOfWeek being\n * single digit, dayOfMonth being two digit and dayOfYear being three digit.\n * A chronology with a ten day week would thus cause issues. However, in\n * general, it is safe to use these formatters with other chronologies.\n * <p>\n * ISODateTimeFormat is thread-safe and immutable, and the formatters it\n * returns are as well.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see DateTimeFormat\n * @see DateTimeFormatterBuilder",public ,,
org.joda.time.format.ISODateTimeFormat$Constants,Class,-----------------------------------------------------------------------,"static , final ",,
org.joda.time.format.PeriodPrinter,Interface,"* Internal interface for printing textual representations of time periods.\n * <p>\n * Application users will rarely use this class directly. Instead, you\n * will use one of the factory classes to create a {@link PeriodFormatter}.\n * <p>\n * The factory classes are:<br />\n * - {@link PeriodFormatterBuilder}<br />\n * - {@link PeriodFormat}<br />\n * - {@link ISOPeriodFormat}<br />\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n * @see PeriodFormatter\n * @see PeriodFormatterBuilder\n * @see PeriodFormat",public ,,
org.joda.time.format.InternalParserDateTimeParser,Class,* Adapter between old and new printer interface.\n *\n * @author Stephen Colebourne\n * @since 2.4,default,,org.joda.time.format.DateTimeParser;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormat,Class,"* Factory that creates instances of DateTimeFormatter from patterns and styles.\n * <p>\n * Datetime formatting is performed by the {@link DateTimeFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link ISODateTimeFormat} and {@link DateTimeFormatterBuilder}.\n * <p>\n * This class provides two types of factory:\n * <ul>\n * <li>{@link #forPattern(String) Pattern} provides a DateTimeFormatter based on\n * a pattern string that is mostly compatible with the JDK date patterns.\n * <li>{@link #forStyle(String) Style} provides a DateTimeFormatter based on a\n * two character style, representing short, medium, long and full.\n * </ul>\n * <p>\n * For example, to use a pattern:\n * <pre>\n * DateTime dt = new DateTime();\n * DateTimeFormatter fmt = DateTimeFormat.forPattern(""MMMM, yyyy"");\n * String str = fmt.print(dt);\n * </pre>\n *\n * The pattern syntax is mostly compatible with java.text.SimpleDateFormat -\n * time zone names cannot be parsed and a few more symbols are supported.\n * All ASCII letters are reserved as pattern letters, which are defined as follows:\n * <blockquote>\n * <pre>\n * Symbol  Meaning                      Presentation  Examples\n * ------  -------                      ------------  -------\n * G       era                          text          AD\n * C       century of era (&gt;=0)         number        20\n * Y       year of era (&gt;=0)            year          1996\n *\n * x       weekyear                     year          1996\n * w       week of weekyear             number        27\n * e       day of week                  number        2\n * E       day of week                  text          Tuesday; Tue\n *\n * y       year                         year          1996\n * D       day of year                  number        189\n * M       month of year                month         July; Jul; 07\n * d       day of month                 number        10\n *\n * a       halfday of day               text          PM\n * K       hour of halfday (0~11)       number        0\n * h       clockhour of halfday (1~12)  number        12\n *\n * H       hour of day (0~23)           number        0\n * k       clockhour of day (1~24)      number        24\n * m       minute of hour               number        30\n * s       second of minute             number        55\n * S       fraction of second           millis        978\n *\n * z       time zone                    text          Pacific Standard Time; PST\n * Z       time zone offset/id          zone          -0800; -08:00; America/Los_Angeles\n *\n * '       escape for text              delimiter\n * ''      single quote                 literal       '\n * </pre>\n * </blockquote>\n * The count of pattern letters determine the format.\n * <p>\n * <strong>Text</strong>: If the number of pattern letters is 4 or more,\n * the full form is used; otherwise a short or abbreviated form is used if\n * available.\n * <p>\n * <strong>Number</strong>: The minimum number of digits.\n * Shorter numbers are zero-padded to this amount.\n * When parsing, any number of digits are accepted.\n * <p>\n * <strong>Year</strong>: Numeric presentation for year and weekyear fields\n * are handled specially. For example, if the count of 'y' is 2, the year\n * will be displayed as the zero-based year of the century, which is two\n * digits.\n * <p>\n * <strong>Month</strong>: 3 or over, use text, otherwise use number.\n * <p>\n * <strong>Millis</strong>: The exact number of fractional digits.\n * If more millisecond digits are available then specified the number will be truncated,\n * if there are fewer than specified then the number will be zero-padded to the right.\n * When parsing, only the exact number of digits are accepted.\n * <p>\n * <strong>Zone</strong>: 'Z' outputs offset without a colon, 'ZZ' outputs\n * the offset with a colon, 'ZZZ' or more outputs the zone id.\n * <p>\n * <strong>Zone names</strong>: Time zone names ('z') cannot be parsed.\n * <p>\n * Any characters in the pattern that are not in the ranges of ['a'..'z']\n * and ['A'..'Z'] will be treated as quoted text. For instance, characters\n * like ':', '.', ' ', '#' and '?' will appear in the resulting time text\n * even they are not embraced within single quotes.\n * <p>\n * DateTimeFormat is thread-safe and immutable, and the formatters it returns\n * are as well.\n *\n * @author Brian S O'Neill\n * @author Maxim Zhao\n * @since 1.0\n * @see ISODateTimeFormat\n * @see DateTimeFormatterBuilder",public ,,
org.joda.time.format.DateTimeFormat$StyleFormatter,Class,-----------------------------------------------------------------------,static ,,org.joda.time.format.InternalPrinter;org.joda.time.format.InternalParser
org.joda.time.format.DateTimeFormat$StyleFormatterCacheKey,Class,No Comment,static ,,
org.joda.time.format.PeriodFormatter,Class,"* Controls the printing and parsing of a time period to and from a string.\n * <p>\n * This class is the main API for printing and parsing used by most applications.\n * Instances of this class are created via one of three factory classes:\n * <ul>\n * <li>{@link PeriodFormat} - formats by pattern and style</li>\n * <li>{@link ISOPeriodFormat} - ISO8601 formats</li>\n * <li>{@link PeriodFormatterBuilder} - complex formats created via method calls</li>\n * </ul>\n * <p>\n * An instance of this class holds a reference internally to one printer and\n * one parser. It is possible that one of these may be null, in which case the\n * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}\n * and {@link #isParser()} methods.\n * <p>\n * The underlying printer/parser can be altered to behave exactly as required\n * by using a decorator modifier:\n * <ul>\n * <li>{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale</li>\n * </ul>\n * This returns a new formatter (instances of this class are immutable).\n * <p>\n * The main methods of the class are the <code>printXxx</code> and\n * <code>parseXxx</code> methods. These are used as follows:\n * <pre>\n * // print using the default locale\n * String periodStr = formatter.print(period);\n * // print using the French locale\n * String periodStr = formatter.withLocale(Locale.FRENCH).print(period);\n * \n * // parse using the French locale\n * Period date = formatter.withLocale(Locale.FRENCH).parsePeriod(str);\n * </pre>\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0",public ,,
org.joda.time.format.DateTimePrinterInternalPrinter,Class,* Adapter between old and new printer interface.\n *\n * @author Stephen Colebourne\n * @since 2.4,default,,org.joda.time.format.InternalPrinter
org.joda.time.ReadWritableDateTime,Interface,* Defines an instant in time that can be queried and modified using datetime fields.\n * <p>\n * The implementation of this interface will be mutable.\n * It may provide more advanced methods than those in the interface.\n * <p>\n * Methods in your application should be defined using <code>ReadWritableDateTime</code>\n * as a parameter if the method wants to manipulate and change a date in simple ways.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,public ,org.joda.time.ReadableDateTime;org.joda.time.ReadWritableInstant,
org.joda.time.ReadWritableInstant,Interface,* Defines an instant in the datetime continuum that can be queried and modified.\n * This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.\n * <p>\n * The implementation of this interface will be mutable.\n * It may provide more advanced methods than those in the interface.\n *\n * @author Stephen Colebourne\n * @since 1.0,public ,org.joda.time.ReadableInstant,
org.joda.time.DateTimeConstants,Class,"* DateTimeConstants is a non-instantiable class of constants used in\n * the date time system. These are the ISO8601 constants, but should be\n * used by all chronologies.\n * <p>\n * DateTimeConstants is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0",public ,,
org.joda.time.IllegalFieldValueException,Class,* Exception thrown when attempting to set a field outside its supported range.\n *\n * @author Brian S O'Neill\n * @since 1.1,public ,java.lang.IllegalArgumentException,
org.joda.time.DurationFieldType,Abstract Class,"* Identifies a duration field, such as years or minutes, in a chronology-neutral way.\n * <p>\n * A duration field type defines the type of the field, such as hours.\n * If does not directly enable any calculations, however it does provide a\n * {@link #getField(Chronology)} method that returns the actual calculation engine\n * for a particular chronology.\n * <p>\n * Instances of <code>DurationFieldType</code> are singletons.\n * They can be compared using <code>==</code>.\n * <p>\n * If required, you can create your own field, for example a quarters.\n * You must create a subclass of <code>DurationFieldType</code> that defines the field type.\n * This class returns the actual calculation engine from {@link #getField(Chronology)}.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , abstract ",,java.io.Serializable
org.joda.time.DurationFieldType$StandardDurationFieldType,Class,No Comment,"private , static ",org.joda.time.DurationFieldType,
org.joda.time.DateTime,Class,"* DateTime is the standard implementation of an unmodifiable datetime class.\n * <p>\n * <code>DateTime</code> is the most widely used implementation of\n * {@link ReadableInstant}. As with all instants, it represents an exact\n * point on the time-line, but limited to the precision of milliseconds.\n * A <code>DateTime</code> calculates its fields with respect to a\n * {@link DateTimeZone time zone}.\n * <p>\n * Internally, the class holds two pieces of data. Firstly, it holds the\n * datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.\n * Secondly, it holds a {@link Chronology} which determines how the\n * millisecond instant value is converted into the date time fields.\n * The default Chronology is {@link ISOChronology} which is the agreed\n * international standard and compatible with the modern Gregorian calendar.\n * <p>\n * Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getHourOfDay()</code>\n * <li><code>hourOfDay().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value\n * <li>text value\n * <li>short text value\n * <li>maximum/minimum values\n * <li>add/subtract\n * <li>set\n * <li>rounding\n * </ul>\n * <p>\n * DateTime is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @author Kandarp Shah\n * @author Brian S O'Neill\n * @since 1.0\n * @see MutableDateTime","public , final ",org.joda.time.base.BaseDateTime,org.joda.time.ReadableDateTime;java.io.Serializable
org.joda.time.DateTime$Property,Class,"* DateTime.Property binds a DateTime to a DateTimeField allowing powerful\n     * datetime functionality to be easily accessed.\n     * <p>\n     * The simplest use of this class is as an alternative get method, here used to\n     * get the year '1972' (as an int) and the month 'December' (as a String).\n     * <pre>\n     * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n     * int year = dt.year().get();\n     * String monthStr = dt.month().getAsText();\n     * </pre>\n     * <p>\n     * Methods are also provided that allow date modification. These return new instances\n     * of DateTime - they do not modify the original. The example below yields two\n     * independent immutable date objects 20 years apart.\n     * <pre>\n     * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n     * DateTime dt20 = dt.year().addToCopy(20);\n     * </pre>\n     * Serious modification of dates (ie. more than just changing one or two fields)\n     * should use the {@link org.joda.time.MutableDateTime MutableDateTime} class.\n     * <p>\n     * DateTime.Propery itself is thread-safe and immutable, as well as the\n     * DateTime being operated on.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.0","public , static , final ",org.joda.time.field.AbstractReadableInstantFieldProperty,
org.joda.time.Years,Class,"* An immutable time period representing a number of years.\n * <p>\n * <code>Years</code> is an immutable period that can only store years.\n * It does not store months, days or hours for example. As such it is a\n * type-safe way of representing a number of years in an application.\n * <p>\n * The number of years is set in the constructor, and may be queried using\n * <code>getYears()</code>. Basic mathematical operations are provided -\n * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n * <code>dividedBy()</code>.\n * <p>\n * <code>Years</code> is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.4","public , final ",org.joda.time.base.BaseSingleFieldPeriod,
org.joda.time.tz.ZoneInfoCompiler,Class,"* Compiles standard format time zone data files into binary files for each time zone\n * in the database. {@link DateTimeZoneBuilder} is used to construct and encode\n * compiled data files. {@link ZoneInfoProvider} loads the encoded files and\n * converts them back into {@link DateTimeZone} objects.\n * <p>\n * Although this tool is similar to zic, the binary formats are not\n * compatible. The latest time zone database files may be obtained\n * <a href=""https://github.com/JodaOrg/global-tz/releases"">here</a>.\n * <p>\n * ZoneInfoCompiler is mutable and not thread-safe, although the main method\n * may be safely invoked by multiple threads.\n *\n * @author Brian S O'Neill\n * @since 1.0",public ,,
org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear,Class,ScopedForTesting,static ,,
org.joda.time.tz.ZoneInfoCompiler$Rule,Class,ScopedForTesting,static ,,
org.joda.time.tz.ZoneInfoCompiler$RuleSet,Class,No Comment,"private , static ",,
org.joda.time.tz.ZoneInfoCompiler$Zone,Class,No Comment,"private , static ",,
org.joda.time.tz.Provider,Interface,* Service provider factory for time zones.\n *\n * @author Brian S O'Neill\n * @since 1.0,public ,,
org.joda.time.tz.CachedDateTimeZone,Class,"* Improves the performance of requesting time zone offsets and name keys by\n * caching the results. Time zones that have simple rules or are fixed should\n * not be cached, as it is unlikely to improve performance.\n * <p>\n * CachedDateTimeZone is thread-safe and immutable.\n * \n * @author Brian S O'Neill\n * @since 1.0",public ,org.joda.time.DateTimeZone,
org.joda.time.tz.CachedDateTimeZone$Info,Class,No Comment,"private , final , static ",,
org.joda.time.tz.ZoneInfoProvider,Class,* ZoneInfoProvider loads compiled data files as generated by\n * {@link ZoneInfoCompiler}.\n * <p>\n * ZoneInfoProvider is thread-safe and publicly immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0,public ,,org.joda.time.tz.Provider
org.joda.time.tz.DefaultNameProvider,Class,* The default name provider acquires localized names from\n * {@link DateFormatSymbols java.text.DateFormatSymbols}.\n * <p>\n * DefaultNameProvider is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0,public ,,org.joda.time.tz.NameProvider
org.joda.time.tz.DateTimeZoneBuilder,Class,"* DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since\n * creating a new DateTimeZone this way is a relatively expensive operation,\n * built zones can be written to a file. Reading back the encoded data is a\n * quick operation.\n * <p>\n * DateTimeZoneBuilder itself is mutable and not thread-safe, but the\n * DateTimeZone objects that it builds are thread-safe and immutable.\n * <p>\n * It is intended that {@link ZoneInfoCompiler} be used to read time zone data\n * files, indirectly calling DateTimeZoneBuilder. The following complex\n * example defines the America/Los_Angeles time zone, with all historical\n * transitions:\n * \n * <pre>\n * DateTimeZone America_Los_Angeles = new DateTimeZoneBuilder()\n *     .addCutover(-2147483648, 'w', 1, 1, 0, false, 0)\n *     .setStandardOffset(-28378000)\n *     .setFixedSavings(""LMT"", 0)\n *     .addCutover(1883, 'w', 11, 18, 0, false, 43200000)\n *     .setStandardOffset(-28800000)\n *     .addRecurringSavings(""PDT"", 3600000, 1918, 1919, 'w',  3, -1, 7, false, 7200000)\n *     .addRecurringSavings(""PST"",       0, 1918, 1919, 'w', 10, -1, 7, false, 7200000)\n *     .addRecurringSavings(""PWT"", 3600000, 1942, 1942, 'w',  2,  9, 0, false, 7200000)\n *     .addRecurringSavings(""PPT"", 3600000, 1945, 1945, 'u',  8, 14, 0, false, 82800000)\n *     .addRecurringSavings(""PST"",       0, 1945, 1945, 'w',  9, 30, 0, false, 7200000)\n *     .addRecurringSavings(""PDT"", 3600000, 1948, 1948, 'w',  3, 14, 0, false, 7200000)\n *     .addRecurringSavings(""PST"",       0, 1949, 1949, 'w',  1,  1, 0, false, 7200000)\n *     .addRecurringSavings(""PDT"", 3600000, 1950, 1966, 'w',  4, -1, 7, false, 7200000)\n *     .addRecurringSavings(""PST"",       0, 1950, 1961, 'w',  9, -1, 7, false, 7200000)\n *     .addRecurringSavings(""PST"",       0, 1962, 1966, 'w', 10, -1, 7, false, 7200000)\n *     .addRecurringSavings(""PST"",       0, 1967, 2147483647, 'w', 10, -1, 7, false, 7200000)\n *     .addRecurringSavings(""PDT"", 3600000, 1967, 1973, 'w', 4, -1,  7, false, 7200000)\n *     .addRecurringSavings(""PDT"", 3600000, 1974, 1974, 'w', 1,  6,  0, false, 7200000)\n *     .addRecurringSavings(""PDT"", 3600000, 1975, 1975, 'w', 2, 23,  0, false, 7200000)\n *     .addRecurringSavings(""PDT"", 3600000, 1976, 1986, 'w', 4, -1,  7, false, 7200000)\n *     .addRecurringSavings(""PDT"", 3600000, 1987, 2147483647, 'w', 4, 1, 7, true, 7200000)\n *     .toDateTimeZone(""America/Los_Angeles"", true);\n * </pre>\n *\n * @author Brian S O'Neill\n * @see ZoneInfoCompiler\n * @see ZoneInfoProvider\n * @since 1.0",public ,,
org.joda.time.tz.DateTimeZoneBuilder$OfYear,Class,* Supports setting fields of year and moving between transitions.,"private , static , final ",,
org.joda.time.tz.DateTimeZoneBuilder$Recurrence,Class,* Extends OfYear with a nameKey and savings.,"private , static , final ",,
org.joda.time.tz.DateTimeZoneBuilder$Rule,Class,* Extends Recurrence with inclusive year limits.,"private , static , final ",,
org.joda.time.tz.DateTimeZoneBuilder$Transition,Class,No Comment,"private , static , final ",,
org.joda.time.tz.DateTimeZoneBuilder$RuleSet,Class,No Comment,"private , static , final ",,
org.joda.time.tz.DateTimeZoneBuilder$DSTZone,Class,No Comment,"private , static , final ",org.joda.time.DateTimeZone,
org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone,Class,No Comment,"private , static , final ",org.joda.time.DateTimeZone,
org.joda.time.tz.NameProvider,Interface,* Service provider factory for localized time zone names.\n *\n * @author Brian S O'Neill\n * @since 1.0,public ,,
org.joda.time.tz.ZoneInfoLogger,Class,* Logger for the compiler.,public ,,
org.joda.time.tz.UTCProvider,Class,* Simple time zone provider that supports only UTC.\n * <p>\n * UTCProvider is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0,"public , final ",,org.joda.time.tz.Provider
org.joda.time.tz.FixedDateTimeZone,Class,* Basic DateTimeZone implementation that has a fixed name key and offsets.\n * <p>\n * FixedDateTimeZone is thread-safe and immutable.\n * \n * @author Brian S O'Neill\n * @since 1.0,"public , final ",org.joda.time.DateTimeZone,
org.joda.time.LocalDate,Class,"* LocalDate is an immutable datetime class representing a date\n * without a time zone.\n * <p>\n * LocalDate implements the {@link ReadablePartial} interface.\n * To do this, the interface methods focus on the key fields -\n * Year, MonthOfYear and DayOfMonth.\n * However, <b>all</b> date fields may in fact be queried.\n * <p>\n * LocalDate differs from DateMidnight in that this class does not\n * have a time zone and does not represent a single instant in time.\n * <p>\n * Calculations on LocalDate are performed using a {@link Chronology}.\n * This chronology will be set internally to be in the UTC time zone\n * for all calculations.\n *\n * <p>Each individual field can be queried in two ways:\n * <ul>\n * <li><code>getMonthOfYear()</code>\n * <li><code>monthOfYear().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>numeric value\n * <li>text value\n * <li>short text value\n * <li>maximum/minimum values\n * <li>add/subtract\n * <li>set\n * <li>rounding\n * </ul>\n *\n * <p>\n * LocalDate is thread-safe and immutable, provided that the Chronology is as well.\n * All standard Chronology classes supplied are thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.3","public , final ",org.joda.time.base.BaseLocal,org.joda.time.ReadablePartial;java.io.Serializable
org.joda.time.LocalDate$Property,Class,"* LocalDate.Property binds a LocalDate to a DateTimeField allowing\n     * powerful datetime functionality to be easily accessed.\n     * <p>\n     * The simplest use of this class is as an alternative get method, here used to\n     * get the year '1972' (as an int) and the month 'December' (as a String).\n     * <pre>\n     * LocalDate dt = new LocalDate(1972, 12, 3, 0, 0);\n     * int year = dt.year().get();\n     * String monthStr = dt.month().getAsText();\n     * </pre>\n     * <p>\n     * Methods are also provided that allow date modification. These return\n     * new instances of LocalDate - they do not modify the original. The example\n     * below yields two independent immutable date objects 20 years apart.\n     * <pre>\n     * LocalDate dt = new LocalDate(1972, 12, 3);\n     * LocalDate dt1920 = dt.year().setCopy(1920);\n     * </pre>\n     * <p>\n     * LocalDate.Property itself is thread-safe and immutable, as well as the\n     * LocalDate being operated on.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.3","public , static , final ",org.joda.time.field.AbstractReadableInstantFieldProperty,
org.joda.time.IllegalInstantException,Class,"* Exception thrown when attempting to create an instant or date-time that cannot exist.\n * <p>\n * Classes like {@code DateTime} only store valid date-times.\n * One of the cases where validity is important is handling daylight savings time (DST).\n * In many places DST is used, where the local clock moves forward by an hour in spring and back by an hour in autumn/fall.\n * This means that in spring, there is a ""gap"" where a local time does not exist.\n * <p>\n * This exception refers to this gap, and it means that your application tried to create\n * a date-time inside the gap - a time that did not exist.\n * Since Joda-Time objects must be valid, this is not allowed.\n * <p>\n * Possible solutions may be as follows:<br />\n * Use <code>LocalDateTime</code>, as all local date-times are valid.<br />\n * When converting a <code>LocalDate</code> to a <code>DateTime</code>, then use <code>toDateTimeAsStartOfDay()</code>\n * as this handles and manages any gaps.<br />\n * When parsing, use <code>parseLocalDateTime()</code> if the string being parsed has no time-zone.\n *\n * @author Stephen Colebourne\n * @since 2.2",public ,java.lang.IllegalArgumentException,
org.joda.time.Period,Class,"* An immutable time period specifying a set of duration field values.\n * <p>\n * A time period is divided into a number of fields, such as hours and seconds.\n * Which fields are supported is defined by the PeriodType class.\n * The default is the standard period type, which supports years, months, weeks, days,\n * hours, minutes, seconds and millis.\n * <p>\n * When this time period is added to an instant, the effect is of adding each field in turn.\n * As a result, this takes into account daylight savings time.\n * Adding a time period of 1 day to the day before daylight savings starts will only add\n * 23 hours rather than 24 to ensure that the time remains the same.\n * If this is not the behaviour you want, then see {@link Duration}.\n * <p>\n * The definition of a period also affects the equals method. A period of 1\n * day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes.\n * This is because periods represent an abstracted definition of a time period\n * (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight\n * savings boundary). To compare the actual duration of two periods, convert\n * both to durations using toDuration, an operation that emphasises that the\n * result may differ according to the date you choose.\n * <p>\n * Period is thread-safe and immutable, provided that the PeriodType is as well.\n * All standard PeriodType classes supplied are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n * @see MutablePeriod","public , final ",org.joda.time.base.BasePeriod,org.joda.time.ReadablePeriod;java.io.Serializable
org.joda.time.base.AbstractInstant,Abstract Class,"* AbstractInstant provides the common behaviour for instant classes.\n * <p>\n * This class has no concept of a chronology, all methods work on the\n * millisecond instant.\n * <p>\n * This class should generally not be used directly by API users. The \n * {@link ReadableInstant} interface should be used when different \n * kinds of date/time objects are to be referenced.\n * <p>\n * Whenever you want to implement <code>ReadableInstant</code> you should\n * extend this class.\n * <p>\n * AbstractInstant itself is thread-safe and immutable, but subclasses may be\n * mutable and not thread-safe.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , abstract ",,org.joda.time.ReadableInstant
org.joda.time.base.AbstractPartial,Abstract Class,"* AbstractPartial provides a standard base implementation of most methods\n * in the ReadablePartial interface.\n * <p>\n * Calculations on are performed using a {@link Chronology}.\n * This chronology is set to be in the UTC time zone for all calculations.\n * <p>\n * The methods on this class use {@link ReadablePartial#size()},\n * {@link AbstractPartial#getField(int, Chronology)} and\n * {@link ReadablePartial#getValue(int)} to calculate their results.\n * Subclasses may have a better implementation.\n * <p>\n * AbstractPartial allows subclasses may be mutable and not thread-safe.\n *\n * @author Stephen Colebourne\n * @since 1.0","public , abstract ",,org.joda.time.ReadablePartial;java.lang.Comparable
org.joda.time.base.BasePartial,Abstract Class,* BasePartial is an abstract implementation of ReadablePartial that stores\n * data in array and <code>Chronology</code> fields.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link org.joda.time.ReadablePartial} interface should be used when different \n * kinds of partial objects are to be referenced.\n * <p>\n * BasePartial subclasses may be mutable and not thread-safe.\n *\n * @author Stephen Colebourne\n * @since 1.0,"public , abstract ",org.joda.time.base.AbstractPartial,org.joda.time.ReadablePartial;java.io.Serializable
org.joda.time.base.AbstractInterval,Abstract Class,* AbstractInterval provides the common behaviour for time intervals.\n * <p>\n * This class should generally not be used directly by API users. The \n * {@link ReadableInterval} interface should be used when different \n * kinds of intervals are to be referenced.\n * <p>\n * AbstractInterval subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,"public , abstract ",,org.joda.time.ReadableInterval
org.joda.time.base.BaseDateTime,Abstract Class,* BaseDateTime is an abstract implementation of ReadableDateTime that stores\n * data in <code>long</code> and <code>Chronology</code> fields.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadableDateTime} interface should be used when different \n * kinds of date/time objects are to be referenced.\n * <p>\n * BaseDateTime subclasses may be mutable and not thread-safe.\n *\n * @author Stephen Colebourne\n * @author Kandarp Shah\n * @author Brian S O'Neill\n * @since 1.0,"public , abstract ",org.joda.time.base.AbstractDateTime,org.joda.time.ReadableDateTime;java.io.Serializable
org.joda.time.base.BasePeriod,Abstract Class,* BasePeriod is an abstract implementation of ReadablePeriod that stores\n * data in a <code>PeriodType</code> and an <code>int[]</code>.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadablePeriod} interface should be used when different \n * kinds of period objects are to be referenced.\n * <p>\n * BasePeriod subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,"public , abstract ",org.joda.time.base.AbstractPeriod,org.joda.time.ReadablePeriod;java.io.Serializable
org.joda.time.base.AbstractDuration,Abstract Class,* AbstractDuration provides the common behaviour for duration classes.\n * <p>\n * This class should generally not be used directly by API users. The \n * {@link ReadableDuration} interface should be used when different \n * kinds of durations are to be referenced.\n * <p>\n * AbstractDuration subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,"public , abstract ",,org.joda.time.ReadableDuration
org.joda.time.base.BaseInterval,Abstract Class,* BaseInterval is an abstract implementation of ReadableInterval that stores\n * data in two <code>long</code> millisecond fields.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadableInterval} interface should be used when different \n * kinds of interval objects are to be referenced.\n * <p>\n * BaseInterval subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Sean Geoghegan\n * @author Stephen Colebourne\n * @since 1.0,"public , abstract ",org.joda.time.base.AbstractInterval,org.joda.time.ReadableInterval;java.io.Serializable
org.joda.time.base.AbstractDateTime,Abstract Class,* AbstractDateTime provides the common behaviour for datetime classes.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadableDateTime} interface should be used when different \n * kinds of date/time objects are to be referenced.\n * <p>\n * Whenever you want to implement <code>ReadableDateTime</code> you should\n * extend this class.\n * <p>\n * AbstractDateTime subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,"public , abstract ",org.joda.time.base.AbstractInstant,org.joda.time.ReadableDateTime
org.joda.time.base.AbstractPeriod,Abstract Class,* AbstractPeriod provides the common behaviour for period classes.\n * <p>\n * This class should generally not be used directly by API users. The \n * {@link ReadablePeriod} interface should be used when different \n * kinds of periods are to be referenced.\n * <p>\n * AbstractPeriod subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,"public , abstract ",,org.joda.time.ReadablePeriod
org.joda.time.base.BaseDuration,Abstract Class,* BaseDuration is an abstract implementation of ReadableDuration that stores\n * data in a <code>long</code> duration milliseconds field.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadableDuration} interface should be used when different \n * kinds of duration objects are to be referenced.\n * <p>\n * BaseDuration subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,"public , abstract ",org.joda.time.base.AbstractDuration,org.joda.time.ReadableDuration;java.io.Serializable
org.joda.time.base.BaseSingleFieldPeriod,Abstract Class,"* BaseSingleFieldPeriod is an abstract implementation of ReadablePeriod that\n * manages a single duration field, such as days or minutes.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadablePeriod} interface should be used when different \n * kinds of period objects are to be referenced.\n * <p>\n * BaseSingleFieldPeriod subclasses may be mutable and not thread-safe.\n *\n * @author Stephen Colebourne\n * @since 1.4","public , abstract ",,org.joda.time.ReadablePeriod;java.lang.Comparable;java.io.Serializable
org.joda.time.base.BaseLocal,Abstract Class,* BaseLocal is an abstract implementation of ReadablePartial that\n * use a local milliseconds internal representation.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link org.joda.time.ReadablePartial} interface should be used when different \n * kinds of partial objects are to be referenced.\n * <p>\n * BasePartial subclasses may be mutable and not thread-safe.\n *\n * @author Stephen Colebourne\n * @since 1.5,"public , abstract ",org.joda.time.base.AbstractPartial,
org.joda.time.ReadableDateTime,Interface,"* Defines an instant in time that can be queried using datetime fields.\n * <p>\n * The implementation of this interface may be mutable or immutable.\n * This interface only gives access to retrieve data, never to change it.\n * <p>\n * Methods in your application should be defined using <code>ReadableDateTime</code>\n * as a parameter if the method only wants to read the datetime, and not perform\n * any advanced manipulations.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0",public ,org.joda.time.ReadableInstant,
org.joda.time.convert.ReadablePartialConverter,Class,* ReadablePartialConverter extracts partial fields and chronology from a ReadablePartial.\n *\n * @author Stephen Colebourne\n * @since 1.0,default,org.joda.time.convert.AbstractConverter,org.joda.time.convert.PartialConverter
org.joda.time.convert.AbstractConverter,Abstract Class,* AbstractConverter simplifies the process of implementing a converter.\n *\n * @author Stephen Colebourne\n * @since 1.0,"public , abstract ",,org.joda.time.convert.Converter
org.joda.time.convert.DurationConverter,Interface,* DurationConverter defines how an object is converted to a millisecond duration.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,public ,org.joda.time.convert.Converter,
org.joda.time.convert.IntervalConverter,Interface,* IntervalConverter defines how an object is converted to an interval.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0,public ,org.joda.time.convert.Converter,
org.joda.time.convert.LongConverter,Class,"* LongConverter converts a Long to an instant, partial or duration.\n * The Long value represents milliseconds in the ISO chronology.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0",default,org.joda.time.convert.AbstractConverter,org.joda.time.convert.InstantConverter;org.joda.time.convert.PartialConverter;org.joda.time.convert.DurationConverter
org.joda.time.convert.StringConverter,Class,"* StringConverter converts from a String to an instant, partial,\n * duration, period or interval..\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0",default,org.joda.time.convert.AbstractConverter,org.joda.time.convert.InstantConverter;org.joda.time.convert.PartialConverter;org.joda.time.convert.DurationConverter;org.joda.time.convert.PeriodConverter;org.joda.time.convert.IntervalConverter
org.joda.time.convert.NullConverter,Class,"* NullConverter converts null to an instant, partial, duration, period\n * or interval. Null means now for instant/partial, zero for duration/period\n * and from now to now for interval.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0",default,org.joda.time.convert.AbstractConverter,org.joda.time.convert.InstantConverter;org.joda.time.convert.PartialConverter;org.joda.time.convert.DurationConverter;org.joda.time.convert.PeriodConverter;org.joda.time.convert.IntervalConverter
org.joda.time.convert.ReadableIntervalConverter,Class,* Converts intervals into durations of any requested period type.\n *\n * @author Brian S O'Neill\n * @since 1.0,default,org.joda.time.convert.AbstractConverter,org.joda.time.convert.IntervalConverter;org.joda.time.convert.DurationConverter;org.joda.time.convert.PeriodConverter
org.joda.time.convert.ReadableDurationConverter,Class,* ReadableDurationConverter extracts milliseconds and chronology from a ReadableDuration.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,default,org.joda.time.convert.AbstractConverter,org.joda.time.convert.DurationConverter;org.joda.time.convert.PeriodConverter
org.joda.time.convert.InstantConverter,Interface,"* InstantConverter defines how an object is converted to milliseconds/chronology.\n * <p>\n * The two methods in this interface must be called in order, as the\n * <code>getInstantMillis</code> method relies on the result of the\n * <code>getChronology</code> method being passed in.\n *\n * @author Stephen Colebourne\n * @since 1.0",public ,org.joda.time.convert.Converter,
org.joda.time.convert.DateConverter,Class,* DateConverter converts a java util Date to an instant or partial.\n * The Date is converted to milliseconds in the ISO chronology.\n *\n * @author Stephen Colebourne\n * @since 1.0,final ,org.joda.time.convert.AbstractConverter,org.joda.time.convert.InstantConverter;org.joda.time.convert.PartialConverter
org.joda.time.convert.Converter,Interface,* Basic converter interface for specifying what object type can be converted.\n *\n * @author Brian S O'Neill\n * @since 1.0,public ,,
org.joda.time.convert.ConverterManager,Class,"* ConverterManager controls the date and time converters.\n * <p>\n * This class enables additional conversion classes to be added via\n * {@link #addInstantConverter(InstantConverter)}, which may replace an\n * existing converter. Similar methods exist for duration, time period and\n * interval converters.\n * <p>\n * This class is threadsafe, so adding/removing converters can be done at any\n * time. Updating the set of converters is relatively expensive, and so should\n * not be performed often.\n * <p>\n * The default instant converters are:\n * <ul>\n * <li>ReadableInstant\n * <li>String\n * <li>Calendar\n * <li>Date (includes sql package subclasses)\n * <li>Long (milliseconds)\n * <li>null (now)\n * </ul>\n * \n * The default partial converters are:\n * <ul>\n * <li>ReadablePartial\n * <li>ReadableInstant\n * <li>String\n * <li>Calendar\n * <li>Date (includes sql package subclasses)\n * <li>Long (milliseconds)\n * <li>null (now)\n * </ul>\n * \n * The default duration converters are:\n * <ul>\n * <li>ReadableDuration\n * <li>ReadableInterval\n * <li>String\n * <li>Long (milliseconds)\n * <li>null (zero ms)\n * </ul>\n *\n * The default time period converters are:\n * <ul>\n * <li>ReadablePeriod\n * <li>ReadableInterval\n * <li>String\n * <li>null (zero)\n * </ul>\n * \n * The default interval converters are:\n * <ul>\n * <li>ReadableInterval\n * <li>String\n * <li>null (zero-length from now to now)\n * </ul>\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0","public , final ",,
org.joda.time.convert.ConverterManager$LazyConverterManagerHolder,Class,"* Holds the singleton instance, lazily loaded to avoid class loading.","private , static , final ",,
org.joda.time.convert.PartialConverter,Interface,"* PartialConverter defines how an object is converted to a ReadablePartial.\n * <p>\n * The two methods in this interface must be called in order, as the\n * <code>getPartialValues</code> method relies on the result of the\n * <code>getChronology</code> method being passed in.\n *\n * @author Stephen Colebourne\n * @since 1.0",public ,org.joda.time.convert.Converter,
org.joda.time.convert.ConverterSet,Class,"* A set of converters, which allows exact converters to be quickly\n * selected. This class is threadsafe because it is (essentially) immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0",default,,
org.joda.time.convert.ConverterSet$Entry,Class,No Comment,static ,,
org.joda.time.convert.ReadableInstantConverter,Class,* ReadableInstantConverter extracts milliseconds and chronology from a ReadableInstant.\n *\n * @author Stephen Colebourne\n * @since 1.0,default,org.joda.time.convert.AbstractConverter,org.joda.time.convert.InstantConverter;org.joda.time.convert.PartialConverter
org.joda.time.convert.ReadablePeriodConverter,Class,* ReadablePeriodConverter extracts milliseconds and chronology from a ReadablePeriod.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,default,org.joda.time.convert.AbstractConverter,org.joda.time.convert.PeriodConverter
org.joda.time.convert.CalendarConverter,Class,* CalendarConverter converts a java util Calendar to an instant or partial.\n * The Calendar is converted to milliseconds and the chronology that best\n * matches the calendar.\n *\n * @author Stephen Colebourne\n * @since 1.0,final ,org.joda.time.convert.AbstractConverter,org.joda.time.convert.InstantConverter;org.joda.time.convert.PartialConverter
org.joda.time.convert.PeriodConverter,Interface,* PeriodConverter defines how an object is converted to a time period.\n *\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.0,public ,org.joda.time.convert.Converter,
org.joda.time.MutableDateTime,Class,"* MutableDateTime is the standard implementation of a modifiable datetime class.\n * It holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.\n * <p>\n * This class uses a Chronology internally. The Chronology determines how the\n * millisecond instant value is converted into the date time fields.\n * The default Chronology is <code>ISOChronology</code> which is the agreed\n * international standard and compatible with the modern Gregorian calendar.\n * <p>\n * Each individual field can be accessed in two ways:\n * <ul>\n * <li><code>getHourOfDay()</code>\n * <li><code>hourOfDay().get()</code>\n * </ul>\n * The second technique also provides access to other useful methods on the\n * field:\n * <ul>\n * <li>get numeric value\n * <li>set numeric value\n * <li>add to numeric value\n * <li>add to numeric value wrapping with the field\n * <li>get text value\n * <li>get short text value\n * <li>set text value\n * <li>field maximum value\n * <li>field minimum value\n * </ul>\n *\n * <p>\n * MutableDateTime is mutable and not thread-safe, unless concurrent threads\n * are not invoking mutator methods.\n *\n * @author Guy Allard\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Mike Schrag\n * @since 1.0\n * @see DateTime",public ,org.joda.time.base.BaseDateTime,org.joda.time.ReadWritableDateTime;java.lang.Cloneable;java.io.Serializable
org.joda.time.MutableDateTime$Property,Class,"* MutableDateTime.Property binds a MutableDateTime to a\n     * DateTimeField allowing powerful datetime functionality to be easily\n     * accessed.\n     * <p>\n     * The example below shows how to use the property to change the value of a\n     * MutableDateTime object.\n     * <pre>\n     * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 13, 32, 19, 123);\n     * dt.year().add(20);\n     * dt.second().roundFloor().minute().set(10);\n     * </pre>\n     * <p>\n     * MutableDateTime.Propery itself is thread-safe and immutable, but the\n     * MutableDateTime being operated on is not.\n     *\n     * @author Stephen Colebourne\n     * @author Brian S O'Neill\n     * @since 1.0","public , static , final ",org.joda.time.field.AbstractReadableInstantFieldProperty,
org.joda.time.Seconds,Class,"* An immutable time period representing a number of seconds.\n * <p>\n * <code>Seconds</code> is an immutable period that can only store seconds.\n * It does not store years, months or hours for example. As such it is a\n * type-safe way of representing a number of seconds in an application.\n * <p>\n * The number of seconds is set in the constructor, and may be queried using\n * <code>getSeconds()</code>. Basic mathematical operations are provided -\n * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n * <code>dividedBy()</code>.\n * <p>\n * <code>Seconds</code> is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.4","public , final ",org.joda.time.base.BaseSingleFieldPeriod,
