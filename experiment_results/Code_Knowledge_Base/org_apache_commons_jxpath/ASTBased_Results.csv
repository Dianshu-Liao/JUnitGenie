"FEN","Type","Comment","Source Code","Return Type","Modifier","class_extends","implements"
"org.apache.commons.jxpath.JXPathContext","Abstract Class","* JXPathContext  provides APIs for the traversal of graphs of JavaBeans using
 * the XPath syntax. Using JXPathContext, you can read and write properties of
 * JavaBeans, arrays, collections and maps. JXPathContext uses JavaBeans
 * introspection to enumerate and access JavaBeans properties.
 * <p>
 * JXPathContext  allows alternative implementations. This is why instead of
 * allocating JXPathContext directly, you should call a static
 * {@code newContext} method.  This method will utilize the
 * {@link JXPathContextFactory} API to locate a suitable implementation of
 * JXPath. Bundled with JXPath comes a default implementation called Reference
 * Implementation.
 * </p>
 *
 * <h2>JXPath Interprets XPath Syntax on Java Object Graphs</h2>
 *
 * JXPath uses an intuitive interpretation of the xpath syntax in the context
 * of Java object graphs. Here are some examples:
 *
 * <h3>Example 1: JavaBean Property Access</h3>
 *
 * JXPath can be used to access properties of a JavaBean.
 *
 * <pre>
 * public class Employee {
 *    public String getFirstName(){
 *       ...
 *    }
 * }
 *
 * Employee emp = new Employee();
 * ...
 *
 * JXPathContext context = JXPathContext.newContext(emp);
 * String fName = (String)context.getValue(""firstName"");
 * </pre>
 *
 * In  this example, we are using JXPath to access a property of the
 * {@code emp} bean. In this simple case the invocation of JXPath is
 * equivalent to invocation of getFirstName() on the bean.
 *
 * <h3>Example 2: Nested Bean Property Access</h3>
 * JXPath can traverse object graphs:
 *
 * <pre>
 * public class Employee {
 *    public Address getHomeAddress(){
 *       ...
 *    }
 * }
 * public class Address {
 *    public String getStreetNumber(){
 *       ...
 *    }
 * }
 *
 * Employee emp = new Employee();
 * ...
 *
 * JXPathContext context = JXPathContext.newContext(emp);
 * String sNumber = (String)context.getValue(""homeAddress/streetNumber"");
 * </pre>
 *
 * In this case XPath is used to access a property of a nested bean.
 * <p>
 * A property identified by the xpath does not have to be a ""leaf"" property.
 * For instance, we can extract the whole Address object in above example:
 * </p>
 * <pre>
 *    Address addr = (Address)context.getValue(""homeAddress"");
 * </pre>
 *
 * <h3>Example 3: Collection Subscripts</h3>
 * JXPath can extract elements from arrays and collections.
 *
 * <pre>
 * public class Integers {
 *    public int[] getNumbers(){
 *       ...
 *    }
 * }
 *
 * Integers ints = new Integers();
 * ...
 *
 * JXPathContext context = JXPathContext.newContext(ints);
 * Integer thirdInt = (Integer)context.getValue(""numbers[3]"");
 * </pre>
 * A  collection can be an arbitrary array or an instance of java.util.
 * Collection.
 * <p>
 * Note: in XPath the first element of a collection has index 1, not 0.<br>
 *
 * <h3>Example 4: Map Element Access</h3>
 *
 * JXPath supports maps. To get a value use its key.
 *
 * <pre>
 * public class Employee {
 *    public Map getAddresses(){
 *       return addressMap;
 *    }
 *
 *    public void addAddress(String key, Address address){
 *       addressMap.put(key, address);
 *    }
 *    ...
 * }
 *
 * Employee emp = new Employee();
 * emp.addAddress(""home"", new Address(...));
 * emp.addAddress(""office"", new Address(...));
 * ...
 *
 * JXPathContext context = JXPathContext.newContext(emp);
 * String homeZipCode = (String)context.getValue(""addresses/home/zipCode"");
 * </pre>
 *
 * Often you will need to use the alternative syntax for accessing Map
 * elements:
 *
 * <pre>
 * String homeZipCode =
 *     (String) context.getValue(""addresses[@name='home']/zipCode"");
 * </pre>
 *
 * In this case, the key can be an expression, e.g. a variable.<br>
 *
 * Note: At this point JXPath only supports Maps that use strings for keys.<br>
 * Note: JXPath supports the extended notion of Map: any object with
 *       dynamic properties can be handled by JXPath provided that its
 *       class is registered with the {@link JXPathIntrospector}.
 *
 * <h3>Example 5: Retrieving Multiple Results</h3>
 *
 * JXPath can retrieve multiple objects from a graph. Note that the method
 * called in this case is not {@code getValue}, but {@code iterate}.
 *
 * <pre>{@code
 * public class Author {
 *    public Book[] getBooks(){
 *       ...
 *    }
 * }
 *
 * Author auth = new Author();
 * ...
 *
 * JXPathContext context = JXPathContext.newContext(auth);
 * Iterator threeBooks = context.iterate(""books[position() < 4]"");
 * }</pre>
 *
 * This returns a list of at most three books from the array of all books
 * written by the author.
 *
 * <h3>Example 6: Setting Properties</h3>
 * JXPath can be used to modify property values.
 *
 * <pre>
 * public class Employee {
 *    public Address getAddress() {
 *       ...
 *    }
 *
 *    public void setAddress(Address address) {
 *       ...
 *    }
 * }
 *
 * Employee emp = new Employee();
 * Address addr = new Address();
 * ...
 *
 * JXPathContext context = JXPathContext.newContext(emp);
 * context.setValue(""address"", addr);
 * context.setValue(""address/zipCode"", ""90190"");
 *
 * </pre>
 *
 * <h3>Example 7: Creating objects</h3>
 * JXPath  can be used to create new objects. First, create a subclass of {@link
 * AbstractFactory AbstractFactory} and install it on the JXPathContext. Then
 * call {@link JXPathContext#createPath createPathAndSetValue()} instead of
 * ""setValue"". JXPathContext will invoke your AbstractFactory when it discovers
 * that an intermediate node of the path is <strong>null</strong>.  It will not override
 * existing nodes.
 *
 * <pre>
 * public class AddressFactory extends AbstractFactory {
 *    public boolean createObject(JXPathContext context,
 *               Pointer pointer, Object parent, String name, int index){
 *     if ((parent instanceof Employee) &amp;&amp; name.equals(""address""){
 *       ((Employee)parent).setAddress(new Address());
 *       return true;
 *     }
 *     return false;
 *   }
 * }
 *
 * JXPathContext context = JXPathContext.newContext(emp);
 * context.setFactory(new AddressFactory());
 * context.createPathAndSetValue(""address/zipCode"", ""90190"");
 * </pre>
 *
 * <h3>Example 8: Using Variables</h3>
 * JXPath supports the notion of variables. The XPath syntax for accessing
 * variables is <em>""$varName""</em>.
 *
 * <pre>
 * public class Author {
 *    public Book[] getBooks(){
 *       ...
 *    }
 * }
 *
 * Author auth = new Author();
 * ...
 *
 * JXPathContext context = JXPathContext.newContext(auth);
 * context.getVariables().declareVariable(""index"", Integer.valueOf(2));
 *
 * Book secondBook = (Book)context.getValue(""books[$index]"");
 * </pre>
 *
 * You can also set variables using JXPath:
 *
 * <pre>
 * context.setValue(""$index"", Integer.valueOf(3));
 * </pre>
 *
 * Note: you can only <em>change</em> the value of an existing variable this
 * way, you cannot <em>define</em> a new variable.
 *
 * <p>
 * When a variable contains a JavaBean or a collection, you can
 * traverse the bean or collection as well:
 * <pre>
 * ...
 * context.getVariables().declareVariable(""book"", myBook);
 * String title = (String)context.getValue(""$book/title);
 *
 * Book array[] = new Book[]{...};
 *
 * context.getVariables().declareVariable(""books"", array);
 *
 * String title = (String)context.getValue(""$books[2]/title);
 * </pre>
 *
 * <h3>Example 9: Using Nested Contexts</h3>
 * If  you need to use the same set of variable while interpreting XPaths with
 * different beans, it makes sense to put the variables in a separate context
 * and specify that context as a parent context every time you allocate a new
 * JXPathContext for a JavaBean.
 *
 * <pre>
 * JXPathContext varContext = JXPathContext.newContext(null);
 * varContext.getVariables().declareVariable(""title"", ""Java"");
 *
 * JXPathContext context = JXPathContext.newContext(varContext, auth);
 *
 * Iterator javaBooks = context.iterate(""books[title = $title]"");
 * </pre>
 *
 * <h3>Using Custom Variable Pools</h3>
 * By default, JXPathContext creates a HashMap of variables. However,
 * you can substitute a custom implementation of the Variables
 * interface to make JXPath work with an alternative source of variables.
 * For example, you can define implementations of Variables that
 * cover a servlet context, HTTP request or any similar structure.
 *
 * <h3>Example 10: Using Standard Extension Functions</h3>
 * Using the standard extension functions, you can call methods on objects,
 * static methods on classes and create objects using any constructor.
 * The class names should be fully qualified.
 * <p>
 * Here's how you can create new objects:
 * <pre>
 * Book book =
 *    (Book) context.getValue(
 *         ""org.apache.commons.jxpath.example.Book.new ('John Updike')"");
 * </pre>
 *
 * Here's how you can call static methods:
 * <pre>
 *   Book book =
 *    (Book) context.getValue(
 *       ""org. apache.commons.jxpath.example.Book.getBestBook('John Updike')"");
 * </pre>
 *
 * Here's how you can call regular methods:
 * <pre>
 * String firstName = (String)context.getValue(""getAuthorsFirstName($book)"");
 * </pre>
 * As you can see, the target of the method is specified as the first parameter
 * of the function.
 *
 * <h3>Example 11: Using Custom Extension Functions</h3>
 * Collections of custom extension functions can be implemented
 * as {@link Functions Functions} objects or as Java classes, whose methods
 * become extenstion functions.
 * <p>
 * Let's say the following class implements various formatting operations:
 * <pre>
 * public class Formats {
 *    public static String date(Date d, String pattern){
 *        return new SimpleDateFormat(pattern).format(d);
 *    }
 *    ...
 * }
 * </pre>
 *
 * We can register this class with a JXPathContext:
 *
 * <pre>
 * context.setFunctions(new ClassFunctions(Formats.class, ""format""));
 * ...
 *
 * context.getVariables().declareVariable(""today"", new Date());
 * String today = (String)context.getValue(""format:date($today, 'MM/dd/yyyy')"");
 *
 * </pre>
 * You can also register whole packages of Java classes using PackageFunctions.
 * <p>
 * Also, see {@link FunctionLibrary FunctionLibrary}, which is a class
 * that allows you to register multiple sets of extension functions with
 * the same JXPathContext.
 *
 * <h2>Configuring JXPath</h2>
 *
 * JXPath uses JavaBeans introspection to discover properties of JavaBeans.
 * You can provide alternative property lists by supplying
 * custom JXPathBeanInfo classes (see {@link JXPathBeanInfo JXPathBeanInfo}).
 *
 * <h2>Notes</h2>
 * <ul>
 * <li> JXPath does not support DOM attributes for non-DOM objects. Even though
 * XPaths like ""para[@type='warning']"" are legitimate, they will always produce
 * empty results. The only attribute supported for JavaBeans is ""name"".  The
 * XPath ""foo/bar"" is equivalent to ""foo[@name='bar']"".
 *
 * <li id='matches_no_property_in_the_graph'>The term <b>matches no property in
 * the graph</b> is used throughout the documentation. It describes a property or
 * path that can be determined as not belonging to the graph. Determining
 * whether a property or path belongs to the graph depends on the type of object
 * being used as {@code cotextBean} (see {@link #newContext(Object)}).
 * It is only possible strongly typed models where a specific Java model is used
 * as context. It is not possible with dynamic models such Maps or DOM
 * implementations.
 * <p>When a XPath does not match a property in the graph, the methods of this
 * class that retrieve a pointer will generally behave in the following way,
 * depending on the last value configured with {@link #setLenient(boolean)}:</p>
 *
 *  <ol style='list-style:upper-alpha'>
 *      <li>If {@code lenient} is {@code false} (default) - methods
 *          will throw {@link JXPathNotFoundException}.
 *      <li>If {@code lenient} is {@code true} - methods will throw
 *          no exception and return a value appropriate for that method to
 *          express the absence: might be a Java {@code null} or a
 *          {@link Pointer} whose {@link Pointer#getValue()} returns
 *          {@code null}, depends on the method.
 *  </ol>
 * </li>
 * </ul>
 *
 * See  <a href=""http://www.w3schools.com/xpath"">XPath Tutorial by
 * W3Schools</a><br>. Also see <a href=""http://www.w3.org/TR/xpath"">XML Path
 * Language (XPath) Version 1.0</a><br><br>
 *
 * You will also find more information and examples in
 * <a href=""https://commons.apache.org/jxpath/users-guide.html"">
 * JXPath User's Guide</a>","Abstract Class do not obtain Source Code","No return type","public , abstract ","",""
"org.apache.commons.jxpath.JXPathContext.contextFactory","Field","No Comment","private static volatile JXPathContextFactory contextFactory;","No return type","private , static , volatile ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.compilationContext","Field","No Comment","private static volatile JXPathContext compilationContext;","No return type","private , static , volatile ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.GENERIC_FUNCTIONS","Field","No Comment","private static final PackageFunctions GENERIC_FUNCTIONS = new PackageFunctions("""", null);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.parentContext","Field","Parent context","protected JXPathContext parentContext;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.contextBean","Field","Context bean","protected Object contextBean;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.vars","Field","Variables","protected Variables vars;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.functions","Field","Functions","protected Functions functions;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.factory","Field","AbstractFactory","protected AbstractFactory factory;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.idManager","Field","IdentityManager","protected IdentityManager idManager;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.keyManager","Field","KeyManager","protected KeyManager keyManager;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.decimalFormats","Field","Decimal format map","protected HashMap<String, DecimalFormatSymbols> decimalFormats;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.locale","Field","No Comment","private Locale locale;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.lenientSet","Field","No Comment","private boolean lenientSet = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.lenient","Field","No Comment","private boolean lenient = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.newContext(Object)","Method","* Creates a new JXPathContext with the specified object as the root node.
     * @param contextBean Object
     * @return JXPathContext","public static JXPathContext newContext(final Object contextBean) {
    return getContextFactory().newContext(null, contextBean);
}","JXPathContext","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.newContext(Object).contextBean","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.newContext(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.newContext(JXPathContext,Object)","Method","* Creates a new JXPathContext with the specified bean as the root node and
     * the specified parent context. Variables defined in a parent context can
     * be referenced in XPaths passed to the child context.
     * @param parentContext parent context
     * @param contextBean Object
     * @return JXPathContext","public static JXPathContext newContext(final JXPathContext parentContext, final Object contextBean) {
    return getContextFactory().newContext(parentContext, contextBean);
}","JXPathContext","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.newContext(JXPathContext,Object).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.newContext(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.newContext(JXPathContext,Object).contextBean","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContext.newContext(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getContextFactory()","Method","* Acquires a context factory and caches it.
     * @return JXPathContextFactory","private static JXPathContextFactory getContextFactory() {
    if (contextFactory == null) {
        contextFactory = JXPathContextFactory.newInstance();
    }
    return contextFactory;
}","JXPathContextFactory","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getParentContext()","Method","* Returns the parent context of this context or null.
     * @return JXPathContext","public JXPathContext getParentContext() {
    return parentContext;
}","JXPathContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getContextBean()","Method","* Returns the JavaBean associated with this context.
     * @return Object","public Object getContextBean() {
    return contextBean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getContextPointer()","Abstract Method","* Returns a Pointer for the context bean.
     * @return Pointer","public abstract Pointer getContextPointer();","Pointer","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getRelativeContext(Pointer)","Abstract Method","* Returns a JXPathContext that is relative to the current JXPathContext.
     * The supplied pointer becomes the context pointer of the new context.
     * The relative context inherits variables, extension functions, locale etc
     * from the parent context.
     * @param pointer Pointer
     * @return JXPathContext","public abstract JXPathContext getRelativeContext(Pointer pointer);","JXPathContext","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getRelativeContext(Pointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getRelativeContext(Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setVariables(Variables)","Method","* Installs a custom implementation of the Variables interface.
     * @param vars Variables","public void setVariables(final Variables vars) {
    this.vars = vars;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setVariables(Variables).vars","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setVariables(Variables)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getVariables()","Method","* Returns the variable pool associated with the context. If no such
     * pool was specified with the {@link #setVariables} method,
     * returns the default implementation of Variables,
     * {@link BasicVariables BasicVariables}.
     * @return Variables","public Variables getVariables() {
    if (vars == null) {
        vars = new BasicVariables();
    }
    return vars;
}","Variables","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setFunctions(Functions)","Method","* Install a library of extension functions.
     * @param functions Functions
     * @see FunctionLibrary","public void setFunctions(final Functions functions) {
    this.functions = functions;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setFunctions(Functions).functions","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setFunctions(Functions)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getFunctions()","Method","* Returns the set of functions installed on the context.
     * @return Functions","public Functions getFunctions() {
    if (functions != null) {
        return functions;
    }
    if (parentContext == null) {
        return GENERIC_FUNCTIONS;
    }
    return null;
}","Functions","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setFactory(AbstractFactory)","Method","* Install an abstract factory that should be used by the
     * {@code createPath()} and {@code createPathAndSetValue()}
     * methods.
     * @param factory AbstractFactory","public void setFactory(final AbstractFactory factory) {
    this.factory = factory;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setFactory(AbstractFactory).factory","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setFactory(AbstractFactory)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getFactory()","Method","* Returns the AbstractFactory installed on this context.
     * If none has been installed and this context has a parent context,
     * returns the parent's factory.  Otherwise returns null.
     * @return AbstractFactory","public AbstractFactory getFactory() {
    if (factory == null && parentContext != null) {
        return parentContext.getFactory();
    }
    return factory;
}","AbstractFactory","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setLocale(Locale)","Method","* Sets the locale for this context.  The value of the ""lang""
     * attribute as well as the lang() function will be
     * affected by the locale.  By default, JXPath uses
     * {@code Locale.getDefault()}
     * @param locale Locale","public synchronized void setLocale(final Locale locale) {
    this.locale = locale;
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setLocale(Locale).locale","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setLocale(Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getLocale()","Method","* Returns the locale set with setLocale. If none was set and
     * the context has a parent, returns the parent's locale.
     * Otherwise, returns Locale.getDefault().
     * @return Locale","public synchronized Locale getLocale() {
    if (locale == null) {
        if (parentContext != null) {
            return parentContext.getLocale();
        }
        locale = Locale.getDefault();
    }
    return locale;
}","Locale","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setDecimalFormatSymbols(String,DecimalFormatSymbols)","Method","* Sets {@link DecimalFormatSymbols} for a given name. The DecimalFormatSymbols
     * can be referenced as the third, optional argument in the invocation of
     * {@code format-number (number,format,decimal-format-name)} function.
     * By default, JXPath uses the symbols for the current locale.
     *
     * @param name the format name or null for default format.
     * @param symbols DecimalFormatSymbols","public synchronized void setDecimalFormatSymbols(final String name, final DecimalFormatSymbols symbols) {
    if (decimalFormats == null) {
        decimalFormats = new HashMap<>();
    }
    decimalFormats.put(name, symbols);
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setDecimalFormatSymbols(String,DecimalFormatSymbols).name","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setDecimalFormatSymbols(String,DecimalFormatSymbols)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setDecimalFormatSymbols(String,DecimalFormatSymbols).symbols","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContext.setDecimalFormatSymbols(String,DecimalFormatSymbols)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getDecimalFormatSymbols(String)","Method","* Gets the named DecimalFormatSymbols.
     * @param name key
     * @return DecimalFormatSymbols
     * @see #setDecimalFormatSymbols(String, DecimalFormatSymbols)","public synchronized DecimalFormatSymbols getDecimalFormatSymbols(final String name) {
    if (decimalFormats == null) {
        return parentContext == null ? null : parentContext.getDecimalFormatSymbols(name);
    }
    return decimalFormats.get(name);
}","DecimalFormatSymbols","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getDecimalFormatSymbols(String).name","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getDecimalFormatSymbols(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setLenient(boolean)","Method","* If the context is in the lenient mode, then getValue() returns null
     * for inexistent paths.  Otherwise, a path that does not map to
     * an existing property will throw an exception.  Note that if the
     * property exists, but its value is null, the exception is <em>not</em>
     * thrown.
     * <p>
     * By default, lenient = false
     * @param lenient flag","public synchronized void setLenient(final boolean lenient) {
    this.lenient = lenient;
    lenientSet = true;
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setLenient(boolean).lenient","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setLenient(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.isLenient()","Method","* Learn whether this JXPathContext is lenient.
     * @return boolean
     * @see #setLenient(boolean)","public synchronized boolean isLenient() {
    if (!lenientSet && parentContext != null) {
        return parentContext.isLenient();
    }
    return lenient;
}","boolean","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.compile(String)","Method","* Compiles the supplied XPath and returns an internal representation
     * of the path that can then be evaluated.  Use CompiledExpressions
     * when you need to evaluate the same expression multiple times
     * and there is a convenient place to cache CompiledExpression
     * between invocations.
     * @param xpath to compile
     * @return CompiledExpression","public static CompiledExpression compile(final String xpath) {
    if (compilationContext == null) {
        compilationContext = newContext(null);
    }
    return compilationContext.compilePath(xpath);
}","CompiledExpression","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.compile(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.compile(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.compilePath(String)","Abstract Method","* Overridden by each concrete implementation of JXPathContext
     * to perform compilation. Is called by {@code compile()}.
     * @param xpath to compile
     * @return CompiledExpression","protected abstract CompiledExpression compilePath(String xpath);","CompiledExpression","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.compilePath(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.compilePath(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.selectSingleNode(String)","Method","* Finds the first object that matches the specified XPath. It is equivalent
     * to {@code getPointer(xpath).getNode()}. Note that this method
     * produces the same result as {@code getValue()} on object models
     * like JavaBeans, but a different result for DOM/JDOM etc., because it
     * returns the Node itself, rather than its textual contents.
     *
     * @param xpath the xpath to be evaluated
     * @return the found object","public Object selectSingleNode(final String xpath) {
    final Pointer pointer = getPointer(xpath);
    return pointer == null ? null : pointer.getNode();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.selectSingleNode(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.selectSingleNode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.selectNodes(String)","Method","* Finds all nodes that match the specified XPath.
     *
     * @param xpath the xpath to be evaluated
     * @return a list of found objects","public List selectNodes(final String xpath) {
    final ArrayList list = new ArrayList();
    final Iterator<Pointer> iterator = iteratePointers(xpath);
    while (iterator.hasNext()) {
        final Pointer pointer = iterator.next();
        list.add(pointer.getNode());
    }
    return list;
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.selectNodes(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.selectNodes(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getValue(String)","Abstract Method","* Evaluates the xpath and returns the resulting object. Primitive
     * types are wrapped into objects.
     * @param xpath to evaluate
     * @return Object found","public abstract Object getValue(String xpath);","Object","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getValue(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getValue(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getValue(String,Class)","Abstract Method","* Evaluates the xpath, converts the result to the specified class and
     * returns the resulting object.
     * @param xpath to evaluate
     * @param requiredType required type
     * @return Object found","public abstract Object getValue(String xpath, Class requiredType);","Object","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getValue(String,Class).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getValue(String,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getValue(String,Class).requiredType","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContext.getValue(String,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setValue(String,Object)","Abstract Method","* Modifies the value of the property described by the supplied xpath.
     * Will throw an exception if one of the following conditions occurs:
     * <ul>
     * <li>The xpath does not in fact describe an existing property
     * <li>The property is not writable (no public, non-static set method)
     * </ul>
     * @param xpath indicating position
     * @param value to set","public abstract void setValue(String xpath, Object value);","void","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setValue(String,Object).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setValue(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setValue(String,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContext.setValue(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.createPath(String)","Abstract Method","* Creates missing elements of the path by invoking an {@link AbstractFactory},
     * which should first be installed on the context by calling {@link #setFactory}.
     * <p>
     * Will throw an exception if the AbstractFactory fails to create
     * an instance for a path element.
     * @param xpath indicating destination to create
     * @return pointer to new location","public abstract Pointer createPath(String xpath);","Pointer","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.createPath(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.createPath(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.createPathAndSetValue(String,Object)","Abstract Method","* The same as setValue, except it creates intermediate elements of
     * the path by invoking an {@link AbstractFactory}, which should first be
     * installed on the context by calling {@link #setFactory}.
     * <p>
     * Will throw an exception if one of the following conditions occurs:
     * <ul>
     * <li>Elements of the xpath aleady exist, but the path does not in
     *  fact describe an existing property
     * <li>The AbstractFactory fails to create an instance for an intermediate
     * element.
     * <li>The property is not writable (no public, non-static set method)
     * </ul>
     * @param xpath indicating position to create
     * @param value to set
     * @return pointer to new location","public abstract Pointer createPathAndSetValue(String xpath, Object value);","Pointer","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.createPathAndSetValue(String,Object).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.createPathAndSetValue(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.createPathAndSetValue(String,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContext.createPathAndSetValue(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.removePath(String)","Abstract Method","* Removes the element of the object graph described by the xpath.
     * @param xpath indicating position to remove","public abstract void removePath(String xpath);","void","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.removePath(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.removePath(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.removeAll(String)","Abstract Method","* Removes all elements of the object graph described by the xpath.
     * @param xpath indicating positions to remove","public abstract void removeAll(String xpath);","void","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.removeAll(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.removeAll(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.iterate(String)","Abstract Method","* Traverses the xpath and returns an Iterator of all results found
     * for the path. If the xpath matches no properties
     * in the graph, the Iterator will be empty, but not null.
     *
     * @param <E> the type of elements returned by the iterator.
     * @param xpath to iterate
     * @return Iterator","public abstract <E> Iterator<E> iterate(String xpath);","Iterator","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.iterate(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.iterate(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getPointer(String)","Abstract Method","* Traverses the xpath and returns a Pointer. A Pointer provides easy access
     * to a property.
     * <p>
     * If the xpath <a href='#matches_no_property_in_the_graph'>matches no
     * properties in the graph</a> the behavior depends on the value that has
     * been configured with {@link #setLenient(boolean)}:</p>
     * <ul>
     * <li> {@code false} (default) the method will throw a
     * {@link JXPathNotFoundException}.
     * <li> {@code true} the method returns a pointer whose
     * {@link Pointer#getValue()} method will always return null.
     * </ul>
     *
     * @param xpath desired
     * @return Pointer A {@link Pointer}, never {@code null}.
     * @throws JXPathNotFoundException see method description.","public abstract Pointer getPointer(String xpath);","Pointer","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getPointer(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getPointer(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.iteratePointers(String)","Abstract Method","* Traverses the xpath and returns an Iterator of Pointers.
     * A Pointer provides easy access to a property.
     * If the xpath matches no properties
     * in the graph, the Iterator be empty, but not null.
     * @param xpath to iterate
     * @return Iterator","public abstract Iterator<Pointer> iteratePointers(String xpath);","Iterator","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.iteratePointers(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.iteratePointers(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setIdentityManager(IdentityManager)","Method","* Install an identity manager that will be used by the context
     * to look up a node by its ID.
     * @param idManager IdentityManager to set","public void setIdentityManager(final IdentityManager idManager) {
    this.idManager = idManager;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setIdentityManager(IdentityManager).idManager","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setIdentityManager(IdentityManager)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getIdentityManager()","Method","* Returns this context's identity manager. If none has been installed,
     * returns the identity manager of the parent context.
     * @return IdentityManager","public IdentityManager getIdentityManager() {
    if (idManager == null && parentContext != null) {
        return parentContext.getIdentityManager();
    }
    return idManager;
}","IdentityManager","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getPointerByID(String)","Method","* Locates a Node by its ID.
     *
     * @param id is the ID of the sought node.
     * @return Pointer","public Pointer getPointerByID(final String id) {
    final IdentityManager manager = getIdentityManager();
    if (manager != null) {
        return manager.getPointerByID(this, id);
    }
    throw new JXPathException(""Cannot find an element by ID - "" + ""no IdentityManager has been specified"");
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getPointerByID(String).id","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getPointerByID(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setKeyManager(KeyManager)","Method","* Install a key manager that will be used by the context
     * to look up a node by a key value.
     * @param keyManager KeyManager","public void setKeyManager(final KeyManager keyManager) {
    this.keyManager = keyManager;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setKeyManager(KeyManager).keyManager","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setKeyManager(KeyManager)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getKeyManager()","Method","* Returns this context's key manager. If none has been installed,
     * returns the key manager of the parent context.
     * @return KeyManager","public KeyManager getKeyManager() {
    if (keyManager == null && parentContext != null) {
        return parentContext.getKeyManager();
    }
    return keyManager;
}","KeyManager","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getPointerByKey(String,String)","Method","* Locates a Node by a key value.
     * @param key string
     * @param value string
     * @return Pointer found","public Pointer getPointerByKey(final String key, final String value) {
    final KeyManager manager = getKeyManager();
    if (manager != null) {
        return manager.getPointerByKey(this, key, value);
    }
    throw new JXPathException(""Cannot find an element by key - "" + ""no KeyManager has been specified"");
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getPointerByKey(String,String).key","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getPointerByKey(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getPointerByKey(String,String).value","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContext.getPointerByKey(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getNodeSetByKey(String,Object)","Method","* Locates a NodeSet by key/value.
     * @param key string
     * @param value object
     * @return NodeSet found","public NodeSet getNodeSetByKey(final String key, final Object value) {
    final KeyManager manager = getKeyManager();
    if (manager != null) {
        return KeyManagerUtils.getExtendedKeyManager(manager).getNodeSetByKey(this, key, value);
    }
    throw new JXPathException(""Cannot find an element by key - "" + ""no KeyManager has been specified"");
}","NodeSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getNodeSetByKey(String,Object).key","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getNodeSetByKey(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getNodeSetByKey(String,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContext.getNodeSetByKey(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.registerNamespace(String,String)","Method","* Registers a namespace prefix.
     *
     * @param prefix A namespace prefix
     * @param namespaceURI A URI for that prefix","public void registerNamespace(final String prefix, final String namespaceURI) {
    throw new UnsupportedOperationException(""Namespace registration is not implemented by "" + getClass());
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.registerNamespace(String,String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.registerNamespace(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.registerNamespace(String,String).namespaceURI","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContext.registerNamespace(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getNamespaceURI(String)","Method","* Given a prefix, returns a registered namespace URI. If the requested
     * prefix was not defined explicitly using the registerNamespace method,
     * JXPathContext will then check the context node to see if the prefix is
     * defined there. See
     * {@link #setNamespaceContextPointer(Pointer) setNamespaceContextPointer}.
     *
     * @param prefix The namespace prefix to look up
     * @return namespace URI or null if the prefix is undefined.","public String getNamespaceURI(final String prefix) {
    throw new UnsupportedOperationException(""Namespace registration is not implemented by "" + getClass());
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getNamespaceURI(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getNamespaceURI(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getPrefix(String)","Method","* Gets the prefix associated with the specifed namespace URI.
     * @param namespaceURI the ns URI to check.
     * @return String prefix
     * @since JXPath 1.3","public String getPrefix(final String namespaceURI) {
    throw new UnsupportedOperationException(""Namespace registration is not implemented by "" + getClass());
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getPrefix(String).namespaceURI","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.getPrefix(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setNamespaceContextPointer(Pointer)","Method","* Namespace prefixes can be defined implicitly by specifying a pointer to a
     * context where the namespaces are defined. By default,
     * NamespaceContextPointer is the same as the Context Pointer, see
     * {@link #getContextPointer() getContextPointer()}
     *
     * @param namespaceContextPointer The pointer to the context where prefixes used in
     *        XPath expressions should be resolved.","public void setNamespaceContextPointer(final Pointer namespaceContextPointer) {
    throw new UnsupportedOperationException(""Namespace registration is not implemented by "" + getClass());
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setNamespaceContextPointer(Pointer).namespaceContextPointer","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setNamespaceContextPointer(Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.getNamespaceContextPointer()","Method","* Returns the namespace context pointer set with
     * {@link #setNamespaceContextPointer(Pointer) setNamespaceContextPointer()}
     * or, if none has been specified, the context pointer otherwise.
     *
     * @return The namespace context pointer.","public Pointer getNamespaceContextPointer() {
    throw new UnsupportedOperationException(""Namespace registration is not implemented by "" + getClass());
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setExceptionHandler(ExceptionHandler)","Method","* Sets the ExceptionHandler used by this context, if any.
     * @param exceptionHandler to set
     * @since 1.4","public void setExceptionHandler(final ExceptionHandler exceptionHandler) {
    throw new UnsupportedOperationException(""ExceptionHandler registration is not implemented by "" + getClass());
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.setExceptionHandler(ExceptionHandler).exceptionHandler","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.setExceptionHandler(ExceptionHandler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.<init>(JXPathContext,Object)","Constructor","* This constructor should remain protected - it is to be overridden by
     * subclasses, but never explicitly invoked by clients.
     * @param parentContext parent context
     * @param contextBean Object","protected JXPathContext(final JXPathContext parentContext, final Object contextBean) {
    this.parentContext = parentContext;
    this.contextBean = contextBean;
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.<init>(JXPathContext,Object).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContext.<init>(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContext.<init>(JXPathContext,Object).contextBean","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContext.<init>(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathTypeConversionException","Class","No Comment","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.JXPathException",""
"org.apache.commons.jxpath.JXPathTypeConversionException.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -4403564377958943239L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathTypeConversionException.<init>(String)","Constructor","* Create a new JXPathTypeConversionException.
     * @param message exception text","public JXPathTypeConversionException(final String message) {
    super(message);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathTypeConversionException.<init>(String).message","Parameter_1","Belong to org.apache.commons.jxpath.JXPathTypeConversionException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathTypeConversionException.<init>(String,Exception)","Constructor","* Create a new JXPathTypeConversionException.
     * @param message exception text
     * @param ex underlying cause","public JXPathTypeConversionException(final String message, final Exception ex) {
    super(message, ex);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathTypeConversionException.<init>(String,Exception).message","Parameter_1","Belong to org.apache.commons.jxpath.JXPathTypeConversionException.<init>(String,Exception)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathTypeConversionException.<init>(String,Exception).ex","Parameter_2","Belong to org.apache.commons.jxpath.JXPathTypeConversionException.<init>(String,Exception)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler","Class","* Implementation of the {@link org.apache.commons.jxpath.DynamicPropertyHandler}
 * interface that provides access to attributes and parameters
 * of a {@link ServletRequest}.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.servlet.HttpSessionHandler",""
"org.apache.commons.jxpath.servlet.ServletRequestHandler.collectPropertyNames(HashSet,Object)","Method","No Comment","@Override
protected void collectPropertyNames(final HashSet set, final Object bean) {
    super.collectPropertyNames(set, bean);
    final ServletRequestAndContext handle = (ServletRequestAndContext) bean;
    final ServletRequest servletRequest = handle.getServletRequest();
    Enumeration e = servletRequest.getAttributeNames();
    while (e.hasMoreElements()) {
        set.add(e.nextElement());
    }
    e = servletRequest.getParameterNames();
    while (e.hasMoreElements()) {
        set.add(e.nextElement());
    }
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler.collectPropertyNames(HashSet,Object).set","Parameter_1","Belong to org.apache.commons.jxpath.servlet.ServletRequestHandler.collectPropertyNames(HashSet,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler.collectPropertyNames(HashSet,Object).bean","Parameter_2","Belong to org.apache.commons.jxpath.servlet.ServletRequestHandler.collectPropertyNames(HashSet,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler.getProperty(Object,String)","Method","No Comment","@Override
public Object getProperty(final Object bean, final String property) {
    final ServletRequestAndContext handle = (ServletRequestAndContext) bean;
    final ServletRequest servletRequest = handle.getServletRequest();
    final String[] strings = servletRequest.getParameterValues(property);
    if (strings != null) {
        if (strings.length == 0) {
            return null;
        }
        if (strings.length == 1) {
            return strings[0];
        }
        return strings;
    }
    final Object object = servletRequest.getAttribute(property);
    if (object != null) {
        return object;
    }
    return super.getProperty(bean, property);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler.getProperty(Object,String).bean","Parameter_1","Belong to org.apache.commons.jxpath.servlet.ServletRequestHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler.getProperty(Object,String).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.ServletRequestHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler.setProperty(Object,String,Object)","Method","No Comment","@Override
public void setProperty(final Object request, final String property, final Object value) {
    ((ServletRequestAndContext) request).getServletRequest().setAttribute(property, value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler.setProperty(Object,String,Object).request","Parameter_1","Belong to org.apache.commons.jxpath.servlet.ServletRequestHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler.setProperty(Object,String,Object).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.ServletRequestHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestHandler.setProperty(Object,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.servlet.ServletRequestHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler","Class","* Implementation of the {@link DynamicPropertyHandler} interface that provides
 * access to attributes of a {@link PageScopeContext}.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.DynamicPropertyHandler"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.DEFAULT_LIST_SIZE","Field","No Comment","private static final int DEFAULT_LIST_SIZE = 16;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.getPropertyNames(Object)","Method","No Comment","@Override
public String[] getPropertyNames(final Object pageScope) {
    final Enumeration e = ((PageScopeContext) pageScope).getAttributeNames();
    final ArrayList list = new ArrayList(DEFAULT_LIST_SIZE);
    while (e.hasMoreElements()) {
        list.add(e.nextElement());
    }
    return (String[]) list.toArray(new String[list.size()]);
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.getPropertyNames(Object).pageScope","Parameter_1","Belong to org.apache.commons.jxpath.servlet.PageScopeContextHandler.getPropertyNames(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.getProperty(Object,String)","Method","No Comment","@Override
public Object getProperty(final Object pageScope, final String property) {
    return ((PageScopeContext) pageScope).getAttribute(property);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.getProperty(Object,String).pageScope","Parameter_1","Belong to org.apache.commons.jxpath.servlet.PageScopeContextHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.getProperty(Object,String).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.PageScopeContextHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.setProperty(Object,String,Object)","Method","No Comment","@Override
public void setProperty(final Object pageScope, final String property, final Object value) {
    ((PageScopeContext) pageScope).setAttribute(property, value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.setProperty(Object,String,Object).pageScope","Parameter_1","Belong to org.apache.commons.jxpath.servlet.PageScopeContextHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.setProperty(Object,String,Object).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.PageScopeContextHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContextHandler.setProperty(Object,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.servlet.PageScopeContextHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler","Class","* Implementation of the {@link DynamicPropertyHandler} interface that provides
 * access to attributes of a {@link ServletContext}.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.DynamicPropertyHandler"
"org.apache.commons.jxpath.servlet.ServletContextHandler.DEFAULT_PROPERTY_COUNT","Field","No Comment","private static final int DEFAULT_PROPERTY_COUNT = 16;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.getPropertyNames(Object)","Method","No Comment","@Override
public String[] getPropertyNames(final Object context) {
    final HashSet list = new HashSet(DEFAULT_PROPERTY_COUNT);
    collectPropertyNames(list, context);
    return (String[]) list.toArray(new String[list.size()]);
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.getPropertyNames(Object).context","Parameter_1","Belong to org.apache.commons.jxpath.servlet.ServletContextHandler.getPropertyNames(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.collectPropertyNames(HashSet,Object)","Method","* Collect the property names from bean, storing in set.
     * @param set destination
     * @param bean to read","protected void collectPropertyNames(final HashSet set, Object bean) {
    if (bean instanceof HttpSessionAndServletContext) {
        bean = ((HttpSessionAndServletContext) bean).getServletContext();
    }
    final Enumeration e = ((ServletContext) bean).getAttributeNames();
    while (e.hasMoreElements()) {
        set.add(e.nextElement());
    }
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.collectPropertyNames(HashSet,Object).set","Parameter_1","Belong to org.apache.commons.jxpath.servlet.ServletContextHandler.collectPropertyNames(HashSet,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.collectPropertyNames(HashSet,Object).bean","Parameter_2","Belong to org.apache.commons.jxpath.servlet.ServletContextHandler.collectPropertyNames(HashSet,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.getProperty(Object,String)","Method","No Comment","@Override
public Object getProperty(final Object context, final String property) {
    return ((ServletContext) context).getAttribute(property);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.getProperty(Object,String).context","Parameter_1","Belong to org.apache.commons.jxpath.servlet.ServletContextHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.getProperty(Object,String).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.ServletContextHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.setProperty(Object,String,Object)","Method","No Comment","@Override
public void setProperty(final Object context, final String property, final Object value) {
    ((ServletContext) context).setAttribute(property, value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.setProperty(Object,String,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.servlet.ServletContextHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.setProperty(Object,String,Object).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.ServletContextHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletContextHandler.setProperty(Object,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.servlet.ServletContextHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContext","Class","* A lightweight wrapper for {@link PageContext} that restricts access
 * to attributes of the ""page"" scope.  This object is needed so that
 * XPath ""foo"" would lookup the attribute ""foo"" in all scopes, while
 * ""$page/foo"" would only look in the ""page"" scope.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.servlet.PageScopeContext.pageContext","Field","No Comment","private final PageContext pageContext;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContext.getAttributeNames()","Method","* Returns attributes of the pageContext declared in the ""page"" scope.
     * @return Enumeration of attribute names","public Enumeration getAttributeNames() {
    return pageContext.getAttributeNamesInScope(PageContext.PAGE_SCOPE);
}","Enumeration","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContext.getAttribute(String)","Method","* Gets the value of the specified attribute.
     * @param attribute name
     * @return Object","public Object getAttribute(final String attribute) {
    return pageContext.getAttribute(attribute, PageContext.PAGE_SCOPE);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContext.getAttribute(String).attribute","Parameter_1","Belong to org.apache.commons.jxpath.servlet.PageScopeContext.getAttribute(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContext.setAttribute(String,Object)","Method","* Sets the specified attribute.
     * @param attribute to set
     * @param value to set","public void setAttribute(final String attribute, final Object value) {
    pageContext.setAttribute(attribute, value, PageContext.PAGE_SCOPE);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContext.setAttribute(String,Object).attribute","Parameter_1","Belong to org.apache.commons.jxpath.servlet.PageScopeContext.setAttribute(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContext.setAttribute(String,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.servlet.PageScopeContext.setAttribute(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContext.<init>(PageContext)","Constructor","* Create a new PageScopeContext.
     * @param pageContext base","public PageScopeContext(final PageContext pageContext) {
    this.pageContext = pageContext;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageScopeContext.<init>(PageContext).pageContext","Parameter_1","Belong to org.apache.commons.jxpath.servlet.PageScopeContext.<init>(PageContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler","Class","* Implementation of the {@link org.apache.commons.jxpath.DynamicPropertyHandler}
 * interface that provides access to attributes of a @{link HttpSession}.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.servlet.ServletContextHandler",""
"org.apache.commons.jxpath.servlet.HttpSessionHandler.collectPropertyNames(HashSet,Object)","Method","No Comment","@Override
protected void collectPropertyNames(final HashSet set, final Object bean) {
    final HttpSessionAndServletContext handle = (HttpSessionAndServletContext) bean;
    super.collectPropertyNames(set, handle.getServletContext());
    final HttpSession session = handle.getSession();
    if (session != null) {
        final Enumeration e = session.getAttributeNames();
        while (e.hasMoreElements()) {
            set.add(e.nextElement());
        }
    }
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler.collectPropertyNames(HashSet,Object).set","Parameter_1","Belong to org.apache.commons.jxpath.servlet.HttpSessionHandler.collectPropertyNames(HashSet,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler.collectPropertyNames(HashSet,Object).bean","Parameter_2","Belong to org.apache.commons.jxpath.servlet.HttpSessionHandler.collectPropertyNames(HashSet,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler.getProperty(Object,String)","Method","No Comment","@Override
public Object getProperty(final Object bean, final String property) {
    final HttpSessionAndServletContext handle = (HttpSessionAndServletContext) bean;
    final HttpSession session = handle.getSession();
    if (session != null) {
        final Object object = session.getAttribute(property);
        if (object != null) {
            return object;
        }
    }
    return super.getProperty(handle.getServletContext(), property);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler.getProperty(Object,String).bean","Parameter_1","Belong to org.apache.commons.jxpath.servlet.HttpSessionHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler.getProperty(Object,String).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.HttpSessionHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler.setProperty(Object,String,Object)","Method","No Comment","@Override
public void setProperty(final Object bean, final String property, final Object value) {
    final HttpSessionAndServletContext handle = (HttpSessionAndServletContext) bean;
    final HttpSession session = handle.getSession();
    if (session != null) {
        session.setAttribute(property, value);
    } else {
        throw new JXPathException(""Cannot set session attribute: "" + ""there is no session"");
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler.setProperty(Object,String,Object).bean","Parameter_1","Belong to org.apache.commons.jxpath.servlet.HttpSessionHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler.setProperty(Object,String,Object).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.HttpSessionHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionHandler.setProperty(Object,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.servlet.HttpSessionHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables","Class","* Implementation of the Variables interface that provides access
 * to a single object using a reserved name (keyword).","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.Variables"
"org.apache.commons.jxpath.servlet.KeywordVariables.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 894145608741325442L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.keyword","Field","No Comment","private final String keyword;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.object","Field","No Comment","private final Object object;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.isDeclaredVariable(String)","Method","No Comment","@Override
public boolean isDeclaredVariable(final String variable) {
    return variable.equals(keyword);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.isDeclaredVariable(String).variable","Parameter_1","Belong to org.apache.commons.jxpath.servlet.KeywordVariables.isDeclaredVariable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.getVariable(String)","Method","No Comment","@Override
public Object getVariable(final String variable) {
    return isDeclaredVariable(variable) ? object : null;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.getVariable(String).variable","Parameter_1","Belong to org.apache.commons.jxpath.servlet.KeywordVariables.getVariable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.declareVariable(String,Object)","Method","No Comment","@Override
public void declareVariable(final String variable, final Object value) {
    throw new UnsupportedOperationException(""Cannot declare new keyword variables."");
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.declareVariable(String,Object).variable","Parameter_1","Belong to org.apache.commons.jxpath.servlet.KeywordVariables.declareVariable(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.declareVariable(String,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.servlet.KeywordVariables.declareVariable(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.undeclareVariable(String)","Method","No Comment","@Override
public void undeclareVariable(final String variable) {
    throw new UnsupportedOperationException(""Cannot undeclare keyword variables."");
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.undeclareVariable(String).variable","Parameter_1","Belong to org.apache.commons.jxpath.servlet.KeywordVariables.undeclareVariable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.<init>(String,Object)","Constructor","* Create a new KeywordVariables.
     * @param keyword String
     * @param object value","public KeywordVariables(final String keyword, final Object object) {
    if (keyword == null) {
        throw new IllegalArgumentException(""keyword cannot be null"");
    }
    this.keyword = keyword;
    this.object = object;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.<init>(String,Object).keyword","Parameter_1","Belong to org.apache.commons.jxpath.servlet.KeywordVariables.<init>(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.KeywordVariables.<init>(String,Object).object","Parameter_2","Belong to org.apache.commons.jxpath.servlet.KeywordVariables.<init>(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageContextHandler","Class","* Implementation of the {@link DynamicPropertyHandler} interface that provides
 * access to attributes of a {@link PageContext} in all scopes.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.DynamicPropertyHandler"
"org.apache.commons.jxpath.servlet.PageContextHandler.getPropertyNames(Object)","Method","No Comment","@Override
public String[] getPropertyNames(final Object pageContext) {
    final HashSet list = new HashSet();
    Enumeration e = ((PageContext) pageContext).getAttributeNamesInScope(PageContext.PAGE_SCOPE);
    while (e.hasMoreElements()) {
        list.add(e.nextElement());
    }
    e = ((PageContext) pageContext).getAttributeNamesInScope(PageContext.REQUEST_SCOPE);
    while (e.hasMoreElements()) {
        list.add(e.nextElement());
    }
    e = ((PageContext) pageContext).getAttributeNamesInScope(PageContext.SESSION_SCOPE);
    while (e.hasMoreElements()) {
        list.add(e.nextElement());
    }
    e = ((PageContext) pageContext).getAttributeNamesInScope(PageContext.APPLICATION_SCOPE);
    while (e.hasMoreElements()) {
        list.add(e.nextElement());
    }
    return (String[]) list.toArray(new String[list.size()]);
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageContextHandler.getPropertyNames(Object).pageContext","Parameter_1","Belong to org.apache.commons.jxpath.servlet.PageContextHandler.getPropertyNames(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageContextHandler.getProperty(Object,String)","Method","* Returns {@code pageContext.findAttribute(property)}.
     * @param pageContext to search
     * @param property name
     * @return Object value","@Override
public Object getProperty(final Object pageContext, final String property) {
    return ((PageContext) pageContext).findAttribute(property);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageContextHandler.getProperty(Object,String).pageContext","Parameter_1","Belong to org.apache.commons.jxpath.servlet.PageContextHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageContextHandler.getProperty(Object,String).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.PageContextHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageContextHandler.setProperty(Object,String,Object)","Method","No Comment","@Override
public void setProperty(final Object pageContext, final String property, final Object value) {
    ((PageContext) pageContext).setAttribute(property, value, PageContext.PAGE_SCOPE);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageContextHandler.setProperty(Object,String,Object).pageContext","Parameter_1","Belong to org.apache.commons.jxpath.servlet.PageContextHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageContextHandler.setProperty(Object,String,Object).property","Parameter_2","Belong to org.apache.commons.jxpath.servlet.PageContextHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.PageContextHandler.setProperty(Object,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.servlet.PageContextHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionAndServletContext","Class","* Just a structure to hold a ServletRequest and ServletContext together.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.servlet.HttpSessionAndServletContext.session","Field","No Comment","private final HttpSession session;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionAndServletContext.context","Field","No Comment","private final ServletContext context;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionAndServletContext.getSession()","Method","* Gets the session.
     * @return HttpSession","public HttpSession getSession() {
    return session;
}","HttpSession","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionAndServletContext.getServletContext()","Method","* Gets the ServletContext.
     * @return ServletContext","public ServletContext getServletContext() {
    return context;
}","ServletContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionAndServletContext.<init>(HttpSession,ServletContext)","Constructor","* Create a new HttpSessionAndServletContext.
     * @param session HttpSession
     * @param context ServletContext","public HttpSessionAndServletContext(final HttpSession session, final ServletContext context) {
    this.session = session;
    this.context = context;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionAndServletContext.<init>(HttpSession,ServletContext).session","Parameter_1","Belong to org.apache.commons.jxpath.servlet.HttpSessionAndServletContext.<init>(HttpSession,ServletContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.HttpSessionAndServletContext.<init>(HttpSession,ServletContext).context","Parameter_2","Belong to org.apache.commons.jxpath.servlet.HttpSessionAndServletContext.<init>(HttpSession,ServletContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts","Class","* Static methods that allocate and cache JXPathContexts bound to
 * {@link PageContext}, {@link ServletRequest}, {@link HttpSession}
 * and {@link ServletContext}.
 * <p>
 * The {@link JXPathContext} returned by {@link #getPageContext getPageContext()}
 * provides access to all scopes via the PageContext.findAttribute()
 * method.  Thus, an expression like ""foo"" will first look for the attribute
 * named ""foo"" in the ""page"" context, then the ""request"" context, then
 * the ""session"" one and finally in the ""application"" context.
 * <p>
 * If you need to limit the attibute lookup to just one scope, you can use the
 * pre-definded variables ""page"", ""request"", ""session"" and ""application"".
 * For example, the expression ""$session/foo"" extracts the value of the
 * session attribute named ""foo"".
 * <p>
 * Following are some implementation details. There is a separate JXPathContext
 * for each of the four scopes. These contexts are chained according to the
 * nesting of the scopes.  So, the parent of the ""page"" JXPathContext is a
 * ""request"" JXPathContext, whose parent is a ""session"" JXPathContext (that is
 * if there is a session), whose parent is an ""application"" context.
 * <p>
 * The  XPath context node for each context is the corresponding object:
 * PageContext, ServletRequest, HttpSession or ServletContext.  This feature can
 * be used by servlets.  A servlet can use one of the methods declared by this
 * class and work with a specific JXPathContext for any scope.
 * <p>
 * Since JXPath chains lookups for variables and extension functions, variables
 * and extension function declared in the outer scopes are also available in
 * the inner scopes.
 * <p>
 * Each  of the four context declares exactly one variable, the value of which
 * is the corresponding object: PageContext, etc.
 * <p>
 * The  ""session"" variable will be undefined if there is no session for this
 * servlet. JXPath does not automatically create sessions.","Class do not obtain Source Code","No return type","public , final ","",""
"org.apache.commons.jxpath.servlet.JXPathServletContexts.factory","Field","No Comment","private static JXPathContextFactory factory;","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getPageContext(PageContext)","Method","* Returns a JXPathContext bound to the ""page"" scope. Caches that context
     * within the PageContext itself.
     * @param pageContext as described
     * @return JXPathContext","public static JXPathContext getPageContext(final PageContext pageContext) {
    JXPathContext context = (JXPathContext) pageContext.getAttribute(Constants.JXPATH_CONTEXT);
    if (context == null) {
        final JXPathContext parentContext = getRequestContext(pageContext.getRequest(), pageContext.getServletContext());
        context = factory.newContext(parentContext, pageContext);
        context.setVariables(new KeywordVariables(Constants.PAGE_SCOPE, new PageScopeContext(pageContext)));
        pageContext.setAttribute(Constants.JXPATH_CONTEXT, context);
    }
    return context;
}","JXPathContext","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getPageContext(PageContext).pageContext","Parameter_1","Belong to org.apache.commons.jxpath.servlet.JXPathServletContexts.getPageContext(PageContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getRequestContext(ServletRequest,ServletContext)","Method","* Returns a JXPathContext bound to the ""request"" scope. Caches that context
     * within the request itself.
     * @param request as described
     * @param servletContext operative
     * @return JXPathContext","public static JXPathContext getRequestContext(final ServletRequest request, final ServletContext servletContext) {
    JXPathContext context = (JXPathContext) request.getAttribute(Constants.JXPATH_CONTEXT);
    // If we are in an included JSP or Servlet, the request parameter
    // will represent the included URL, but the JXPathContext we have
    // just acquired will represent the outer request.
    if (context != null) {
        final ServletRequestAndContext handle = (ServletRequestAndContext) context.getContextBean();
        if (handle.getServletRequest() == request) {
            return context;
        }
    }
    JXPathContext parentContext = null;
    if (request instanceof HttpServletRequest) {
        final HttpSession session = ((HttpServletRequest) request).getSession(false);
        if (session != null) {
            parentContext = getSessionContext(session, servletContext);
        } else {
            parentContext = getApplicationContext(servletContext);
        }
    }
    final ServletRequestAndContext handle = new ServletRequestAndContext(request, servletContext);
    context = factory.newContext(parentContext, handle);
    context.setVariables(new KeywordVariables(Constants.REQUEST_SCOPE, handle));
    request.setAttribute(Constants.JXPATH_CONTEXT, context);
    return context;
}","JXPathContext","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getRequestContext(ServletRequest,ServletContext).request","Parameter_1","Belong to org.apache.commons.jxpath.servlet.JXPathServletContexts.getRequestContext(ServletRequest,ServletContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getRequestContext(ServletRequest,ServletContext).servletContext","Parameter_2","Belong to org.apache.commons.jxpath.servlet.JXPathServletContexts.getRequestContext(ServletRequest,ServletContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getSessionContext(HttpSession,ServletContext)","Method","* Returns a JXPathContext bound to the ""session"" scope. Caches that context
     * within the session itself.
     * @param session as described
     * @param servletContext operative
     * @return JXPathContext","public static JXPathContext getSessionContext(final HttpSession session, final ServletContext servletContext) {
    JXPathContext context = (JXPathContext) session.getAttribute(Constants.JXPATH_CONTEXT);
    if (context == null) {
        final JXPathContext parentContext = getApplicationContext(servletContext);
        final HttpSessionAndServletContext handle = new HttpSessionAndServletContext(session, servletContext);
        context = factory.newContext(parentContext, handle);
        context.setVariables(new KeywordVariables(Constants.SESSION_SCOPE, handle));
        session.setAttribute(Constants.JXPATH_CONTEXT, context);
    }
    return context;
}","JXPathContext","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getSessionContext(HttpSession,ServletContext).session","Parameter_1","Belong to org.apache.commons.jxpath.servlet.JXPathServletContexts.getSessionContext(HttpSession,ServletContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getSessionContext(HttpSession,ServletContext).servletContext","Parameter_2","Belong to org.apache.commons.jxpath.servlet.JXPathServletContexts.getSessionContext(HttpSession,ServletContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getApplicationContext(ServletContext)","Method","* Returns  a JXPathContext bound to the ""application"" scope. Caches that
     * context within the servlet context itself.
     * @param servletContext operative
     * @return JXPathContext","public static JXPathContext getApplicationContext(final ServletContext servletContext) {
    JXPathContext context = (JXPathContext) servletContext.getAttribute(Constants.JXPATH_CONTEXT);
    if (context == null) {
        context = factory.newContext(null, servletContext);
        context.setVariables(new KeywordVariables(Constants.APPLICATION_SCOPE, servletContext));
        servletContext.setAttribute(Constants.JXPATH_CONTEXT, context);
    }
    return context;
}","JXPathContext","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.JXPathServletContexts.getApplicationContext(ServletContext).servletContext","Parameter_1","Belong to org.apache.commons.jxpath.servlet.JXPathServletContexts.getApplicationContext(ServletContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestAndContext","Class","* Just a structure to hold a {@link ServletRequest} and {@link ServletContext}
 * together.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.servlet.HttpSessionAndServletContext",""
"org.apache.commons.jxpath.servlet.ServletRequestAndContext.request","Field","No Comment","private final ServletRequest request;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestAndContext.getSession()","Method","No Comment","@Override
public HttpSession getSession() {
    return request instanceof HttpServletRequest ? ((HttpServletRequest) request).getSession(false) : null;
}","HttpSession","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestAndContext.getServletRequest()","Method","* Gets the request.
     *
     * @return ServletRequest","public ServletRequest getServletRequest() {
    return request;
}","ServletRequest","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestAndContext.<init>(ServletRequest,ServletContext)","Constructor","* Create a new ServletRequestAndContext.
     *
     * @param request ServletRequest
     * @param context ServletContext","public ServletRequestAndContext(final ServletRequest request, final ServletContext context) {
    super(null, context);
    this.request = request;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestAndContext.<init>(ServletRequest,ServletContext).request","Parameter_1","Belong to org.apache.commons.jxpath.servlet.ServletRequestAndContext.<init>(ServletRequest,ServletContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.ServletRequestAndContext.<init>(ServletRequest,ServletContext).context","Parameter_2","Belong to org.apache.commons.jxpath.servlet.ServletRequestAndContext.<init>(ServletRequest,ServletContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.Constants","Class","* String constants for this package.","Class do not obtain Source Code","No return type","public , final ","",""
"org.apache.commons.jxpath.servlet.Constants.APPLICATION_SCOPE","Field","* Variable name for {@link javax.servlet.ServletContext}.","public static final String APPLICATION_SCOPE = ""application"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.Constants.SESSION_SCOPE","Field","* Variable name for {@link javax.servlet.http.HttpSession}.","public static final String SESSION_SCOPE = ""session"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.Constants.REQUEST_SCOPE","Field","* Variable name for {@link javax.servlet.ServletRequest}.","public static final String REQUEST_SCOPE = ""request"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.Constants.PAGE_SCOPE","Field","* Variable name for {@link javax.servlet.jsp.PageContext}.","public static final String PAGE_SCOPE = ""page"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.servlet.Constants.JXPATH_CONTEXT","Field","* Attribute  name used in page context, requst, session, and servlet
     * context to store the corresponding {@link org.apache.commons.jxpath.JXPathContext}.","public static final String JXPATH_CONTEXT = ""org.apache.commons.jxpath.JXPATH_CONTEXT"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Pointer","Interface","* Pointers represent locations of objects and their properties
 * in Java object graphs. JXPathContext has methods
 * ({@link JXPathContext#getPointer(java.lang.String) getPointer()}
 * and  ({@link JXPathContext#iteratePointers(java.lang.String)
 * iteratePointers()}, which, given an XPath, produce Pointers for the objects
 * or properties described the path. For example, {@code ctx.getPointer
 * (""foo/bar"")} will produce a Pointer that can get and set the property
 * ""bar"" of the object which is the value of the property ""foo"" of the root
 * object. The value of {@code ctx.getPointer(""aMap/aKey[3]"")} will be a
 * pointer to the 3'rd element of the array, which is the value for the key
 * ""aKey"" of the map, which is the value of the property ""aMap"" of the root
 * object.","Interface do not obtain Source Code","No return type","public ","java.lang.Cloneable;java.lang.Comparable;java.io.Serializable",""
"org.apache.commons.jxpath.Pointer.getValue()","Abstract Method","* Returns the value of the object, property or collection element
     * this pointer represents. May convert the value to one of the
     * canonical InfoSet types: String, Number, Boolean, Set.
     *
     * For example, in the case of an XML element, getValue() will
     * return the text contained by the element rather than
     * the element itself.
     * @return Object value","Object getValue();","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Pointer.getNode()","Abstract Method","* Returns the raw value of the object, property or collection element
     * this pointer represents.  Never converts the object to a
     * canonical type: returns it as is.
     *
     * For example, for an XML element, getNode() will
     * return the element itself rather than the text it contains.
     * @return Object node","Object getNode();","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Pointer.setValue(Object)","Abstract Method","* Modifies the value of the object, property or collection element
     * this pointer represents.
     * @param value value to set","void setValue(Object value);","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Pointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.Pointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Pointer.getRootNode()","Abstract Method","* Returns the node this pointer is based on.
     * @return Object","Object getRootNode();","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Pointer.asPath()","Abstract Method","* Returns a string that is a proper ""canonical"" XPath that corresponds to
     * this pointer.  Consider this example:
     * <p>{@code Pointer  ptr = ctx.getPointer(""//employees[firstName = 'John']"")
     * }
     * <p>The  value of {@code ptr.asPath()} will look something like
     * {@code ""/departments[2]/employees[3]""}, so, basically, it represents
     * the concrete location(s) of the result of a search performed by JXPath.
     * If an object in the pointer's path is a Dynamic Property object (like a
     * Map), the asPath method generates an XPath that looks like this: {@code ""
     * /departments[@name = 'HR']/employees[3]""}.
     * @return String path","String asPath();","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Pointer.clone()","Abstract Method","* Pointers are cloneable.
     * @return cloned Object","Object clone();","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Functions","Interface","* A group of Function objects sharing a common namespace or a set of
 * common namespaces. Use the classes
 * {@link ClassFunctions ClassFunctions} and
 * {@link PackageFunctions PackageFunctions}
 * to register extension functions implemented as Java methods.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.Functions.getUsedNamespaces()","Abstract Method","* Returns all namespaces in which this function collection defines
     * functions.
     * @return Set","Set getUsedNamespaces();","Set","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Functions.getFunction(String,String,Object[])","Abstract Method","* Returns a Function, if any, for the specified namespace,
     * name and parameter types.
     * @param namespace ns
     * @param name function name
     * @param parameters Object[]
     * @return Function","Function getFunction(String namespace, String name, Object[] parameters);","Function","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Functions.getFunction(String,String,Object[]).namespace","Parameter_1","Belong to org.apache.commons.jxpath.Functions.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Functions.getFunction(String,String,Object[]).name","Parameter_2","Belong to org.apache.commons.jxpath.Functions.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Functions.getFunction(String,String,Object[]).parameters","Parameter_3","Belong to org.apache.commons.jxpath.Functions.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExpressionContext","Interface","* If an extenstion function has an argument of type ExpressionContext,
 * it can gain access to the current node of an XPath expression context.
 * <p>
 * Example:
 * <blockquote><pre>
 * public class MyExtenstionFunctions {
 *    public static String objectType(ExpressionContext context){
 *       Object value = context.getContextNodePointer().getValue();
 *       if (value == null){
 *           return ""null"";
 *       }
 *       return value.getClass().getName();
 *    }
 * }
 * </pre></blockquote>
 *
 * You can then register this extension function using a {@link ClassFunctions
 * ClassFunctions} object and call it like this:
 * <blockquote><pre>
 *   ""/descendent-or-self::node()[ns:objectType() = 'java.util.Date']""
 * </pre></blockquote>
 * This expression will find all nodes of the graph that are dates.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ExpressionContext.getJXPathContext()","Abstract Method","* Gets the JXPathContext in which this function is being evaluated.
     *
     * @return A list representing the current context nodes.","JXPathContext getJXPathContext();","JXPathContext","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExpressionContext.getContextNodePointer()","Abstract Method","* Gets the current context node.
     *
     * @return The current context node pointer.","Pointer getContextNodePointer();","Pointer","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExpressionContext.getContextNodeList()","Abstract Method","* Gets the current context node list.  Each element of the list is
     * a Pointer.
     *
     * @return A list representing the current context nodes.","List getContextNodeList();","List","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExpressionContext.getPosition()","Abstract Method","* Returns the current context position.
     * @return int","int getPosition();","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExceptionHandler","Interface","* Exception handler interface.  Actually handles Throwables.
 * @since 1.4","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ExceptionHandler.handle(Throwable,Pointer)","Abstract Method","* Handle an encountered Throwable.
     * @param t to handle
     * @param ptr specific context","void handle(Throwable t, Pointer ptr);","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExceptionHandler.handle(Throwable,Pointer).t","Parameter_1","Belong to org.apache.commons.jxpath.ExceptionHandler.handle(Throwable,Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExceptionHandler.handle(Throwable,Pointer).ptr","Parameter_2","Belong to org.apache.commons.jxpath.ExceptionHandler.handle(Throwable,Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.IdentityManager","Interface","* A delegate of {@link JXPathContext} that implements the XPath {@code ""id()""}
 * function. This delegate is only used when there is no default implementation
 * of the {@code id()} function. For example, it is <em>not</em> used
 * when the root of the context is a DOM Node.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.IdentityManager.getPointerByID(JXPathContext,String)","Abstract Method","* Finds a node by its ID.
     * @param context JXPathContext
     * @param id String
     * @return Pointer","Pointer getPointerByID(JXPathContext context, String id);","Pointer","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.IdentityManager.getPointerByID(JXPathContext,String).context","Parameter_1","Belong to org.apache.commons.jxpath.IdentityManager.getPointerByID(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.IdentityManager.getPointerByID(JXPathContext,String).id","Parameter_2","Belong to org.apache.commons.jxpath.IdentityManager.getPointerByID(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo","Class","* An implementation of JXPathBeanInfo based on JavaBeans' BeanInfo. Properties
 * advertised by JXPathBasicBeanInfo are the same as those advertised by
 * BeanInfo for the corresponding class.
 *
 * @see java.beans.BeanInfo
 * @see java.beans.Introspector","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.JXPathBeanInfo"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -3863803443111484155L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.PROPERTY_DESCRIPTOR_COMPARATOR","Field","No Comment","private static final Comparator PROPERTY_DESCRIPTOR_COMPARATOR = (left, right) -> ((PropertyDescriptor) left).getName().compareTo(((PropertyDescriptor) right).getName());","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.atomic","Field","No Comment","private boolean atomic = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.clazz","Field","No Comment","private final Class clazz;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.dynamicPropertyHandlerClass","Field","No Comment","private Class dynamicPropertyHandlerClass;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.propertyDescriptors","Field","No Comment","private transient PropertyDescriptor[] propertyDescriptors;","No return type","private , transient ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.propertyDescriptorMap","Field","No Comment","private transient HashMap propertyDescriptorMap;","No return type","private , transient ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.isAtomic()","Method","* Returns true if objects of this class are treated as atomic
     * objects which have no properties of their own.
     * @return boolean","@Override
public boolean isAtomic() {
    return atomic;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.isDynamic()","Method","* Return true if the corresponding objects have dynamic properties.
     * @return boolean","@Override
public boolean isDynamic() {
    return dynamicPropertyHandlerClass != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.getPropertyDescriptors()","Method","No Comment","@Override
public synchronized PropertyDescriptor[] getPropertyDescriptors() {
    if (propertyDescriptors == null) {
        if (clazz == Object.class) {
            propertyDescriptors = new PropertyDescriptor[0];
        } else {
            try {
                BeanInfo bi;
                if (clazz.isInterface()) {
                    bi = Introspector.getBeanInfo(clazz);
                } else {
                    bi = Introspector.getBeanInfo(clazz, Object.class);
                }
                final PropertyDescriptor[] pds = bi.getPropertyDescriptors();
                final PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length];
                System.arraycopy(pds, 0, descriptors, 0, pds.length);
                Arrays.sort(descriptors, PROPERTY_DESCRIPTOR_COMPARATOR);
                propertyDescriptors = descriptors;
            } catch (final IntrospectionException ex) {
                ex.printStackTrace();
                return new PropertyDescriptor[0];
            }
        }
    }
    if (propertyDescriptors.length == 0) {
        return propertyDescriptors;
    }
    final PropertyDescriptor[] result = new PropertyDescriptor[propertyDescriptors.length];
    System.arraycopy(propertyDescriptors, 0, result, 0, propertyDescriptors.length);
    return result;
}","PropertyDescriptor[]","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.getPropertyDescriptor(String)","Method","No Comment","@Override
public synchronized PropertyDescriptor getPropertyDescriptor(final String propertyName) {
    if (propertyDescriptorMap == null) {
        propertyDescriptorMap = new HashMap();
        final PropertyDescriptor[] pds = getPropertyDescriptors();
        for (final PropertyDescriptor pd : pds) {
            propertyDescriptorMap.put(pd.getName(), pd);
        }
    }
    return (PropertyDescriptor) propertyDescriptorMap.get(propertyName);
}","PropertyDescriptor","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.getPropertyDescriptor(String).propertyName","Parameter_1","Belong to org.apache.commons.jxpath.JXPathBasicBeanInfo.getPropertyDescriptor(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.getDynamicPropertyHandlerClass()","Method","* For a dynamic class, returns the corresponding DynamicPropertyHandler
     * class.
     * @return Class","@Override
public Class getDynamicPropertyHandlerClass() {
    return dynamicPropertyHandlerClass;
}","Class","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.toString()","Method","No Comment","@Override
public String toString() {
    final StringBuilder buffer = new StringBuilder();
    buffer.append(""BeanInfo [class = "");
    buffer.append(clazz.getName());
    if (isDynamic()) {
        buffer.append("", dynamic"");
    }
    if (isAtomic()) {
        buffer.append("", atomic"");
    }
    buffer.append("", properties = "");
    final PropertyDescriptor[] jpds = getPropertyDescriptors();
    for (final PropertyDescriptor jpd : jpds) {
        buffer.append(""\n    "");
        buffer.append(jpd.getPropertyType());
        buffer.append("": "");
        buffer.append(jpd.getName());
    }
    buffer.append(""]"");
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class)","Constructor","* Create a new JXPathBasicBeanInfo.
     * @param clazz bean class","public JXPathBasicBeanInfo(final Class clazz) {
    this.clazz = clazz;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class).clazz","Parameter_1","Belong to org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,boolean)","Constructor","* Create a new JXPathBasicBeanInfo.
     * @param clazz bean class
     * @param atomic whether objects of this class are treated as atomic
     *               objects which have no properties of their own.","public JXPathBasicBeanInfo(final Class clazz, final boolean atomic) {
    this.clazz = clazz;
    this.atomic = atomic;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,boolean).clazz","Parameter_1","Belong to org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,boolean).atomic","Parameter_2","Belong to org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,Class)","Constructor","* Create a new JXPathBasicBeanInfo.
     * @param clazz bean class
     * @param dynamicPropertyHandlerClass dynamic property handler class","public JXPathBasicBeanInfo(final Class clazz, final Class dynamicPropertyHandlerClass) {
    this.clazz = clazz;
    this.atomic = false;
    this.dynamicPropertyHandlerClass = dynamicPropertyHandlerClass;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,Class).clazz","Parameter_1","Belong to org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,Class).dynamicPropertyHandlerClass","Parameter_2","Belong to org.apache.commons.jxpath.JXPathBasicBeanInfo.<init>(Class,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Variables","Interface","* Variables provide access to a global set of values accessible via XPath.
 * XPath can reference variables using the {@code ""$varname""} syntax.
 * To use a custom implementation of this interface, pass it to
 * {@link JXPathContext#setVariables JXPathContext.setVariables()}","Interface do not obtain Source Code","No return type","public ","java.io.Serializable",""
"org.apache.commons.jxpath.Variables.isDeclaredVariable(String)","Abstract Method","* Returns true if the specified variable is declared.
     * @param varName variable name
     * @return boolean","boolean isDeclaredVariable(String varName);","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Variables.isDeclaredVariable(String).varName","Parameter_1","Belong to org.apache.commons.jxpath.Variables.isDeclaredVariable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Variables.getVariable(String)","Abstract Method","* Returns the value of the specified variable.
     * @param varName variable name
     * @return Object value
     * @throws IllegalArgumentException if there is no such variable.","Object getVariable(String varName);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Variables.getVariable(String).varName","Parameter_1","Belong to org.apache.commons.jxpath.Variables.getVariable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Variables.declareVariable(String,Object)","Abstract Method","* Defines a new variable with the specified value or modifies
     * the value of an existing variable.
     * May throw UnsupportedOperationException.
     * @param varName variable name
     * @param value to declare","void declareVariable(String varName, Object value);","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Variables.declareVariable(String,Object).varName","Parameter_1","Belong to org.apache.commons.jxpath.Variables.declareVariable(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Variables.declareVariable(String,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.Variables.declareVariable(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Variables.undeclareVariable(String)","Abstract Method","* Removes an existing variable. May throw UnsupportedOperationException.
     *
     * @param varName is a variable name without the ""$"" sign","void undeclareVariable(String varName);","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Variables.undeclareVariable(String).varName","Parameter_1","Belong to org.apache.commons.jxpath.Variables.undeclareVariable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter","Class","* The default implementation of TypeConverter.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.util.TypeConverter"
"org.apache.commons.jxpath.util.BasicTypeConverter.canConvert(Object,Class)","Method","* Returns true if it can convert the supplied
     * object to the specified class.
     * @param object to check
     * @param toType prospective destination class
     * @return boolean","@Override
public boolean canConvert(final Object object, final Class toType) {
    if (object == null) {
        return true;
    }
    final Class useType = TypeUtils.wrapPrimitive(toType);
    final Class fromType = object.getClass();
    if (useType.isAssignableFrom(fromType)) {
        return true;
    }
    if (useType == String.class) {
        return true;
    }
    if (object instanceof Boolean && (Number.class.isAssignableFrom(useType) || ""java.util.concurrent.atomic.AtomicBoolean"".equals(useType.getName()))) {
        return true;
    }
    if (object instanceof Number && (Number.class.isAssignableFrom(useType) || useType == Boolean.class)) {
        return true;
    }
    if (object instanceof String && (useType == Boolean.class || useType == Character.class || useType == Byte.class || useType == Short.class || useType == Integer.class || useType == Long.class || useType == Float.class || useType == Double.class)) {
        return true;
    }
    if (fromType.isArray()) {
        // Collection -> array
        if (useType.isArray()) {
            final Class cType = useType.getComponentType();
            final int length = Array.getLength(object);
            for (int i = 0; i < length; i++) {
                final Object value = Array.get(object, i);
                if (!canConvert(value, cType)) {
                    return false;
                }
            }
            return true;
        }
        if (Collection.class.isAssignableFrom(useType)) {
            return canCreateCollection(useType);
        }
        if (Array.getLength(object) > 0) {
            final Object value = Array.get(object, 0);
            return canConvert(value, useType);
        }
        return canConvert("""", useType);
    }
    if (object instanceof Collection) {
        // Collection -> array
        if (useType.isArray()) {
            final Class cType = useType.getComponentType();
            final Iterator it = ((Collection) object).iterator();
            while (it.hasNext()) {
                final Object value = it.next();
                if (!canConvert(value, cType)) {
                    return false;
                }
            }
            return true;
        }
        if (Collection.class.isAssignableFrom(useType)) {
            return canCreateCollection(useType);
        }
        if (((Collection) object).size() > 0) {
            Object value;
            if (object instanceof List) {
                value = ((List) object).get(0);
            } else {
                final Iterator it = ((Collection) object).iterator();
                value = it.next();
            }
            return canConvert(value, useType);
        }
        return canConvert("""", useType);
    }
    if (object instanceof NodeSet) {
        return canConvert(((NodeSet) object).getValues(), useType);
    }
    if (object instanceof Pointer) {
        return canConvert(((Pointer) object).getValue(), useType);
    }
    return ConvertUtils.lookup(useType) != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.canConvert(Object,Class).object","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.canConvert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.canConvert(Object,Class).toType","Parameter_2","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.canConvert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.convert(Object,Class)","Method","* Converts the supplied object to the specified
     * type. Throws a runtime exception if the conversion is
     * not possible.
     * @param object to convert
     * @param toType destination class
     * @return converted object","@Override
public Object convert(final Object object, final Class toType) {
    if (object == null) {
        return toType.isPrimitive() ? convertNullToPrimitive(toType) : null;
    }
    if (toType == Object.class) {
        if (object instanceof NodeSet) {
            return convert(((NodeSet) object).getValues(), toType);
        }
        if (object instanceof Pointer) {
            return convert(((Pointer) object).getValue(), toType);
        }
        return object;
    }
    final Class useType = TypeUtils.wrapPrimitive(toType);
    final Class fromType = object.getClass();
    if (useType.isAssignableFrom(fromType)) {
        return object;
    }
    if (fromType.isArray()) {
        final int length = Array.getLength(object);
        if (useType.isArray()) {
            final Class cType = useType.getComponentType();
            final Object array = Array.newInstance(cType, length);
            for (int i = 0; i < length; i++) {
                final Object value = Array.get(object, i);
                Array.set(array, i, convert(value, cType));
            }
            return array;
        }
        if (Collection.class.isAssignableFrom(useType)) {
            final Collection collection = allocateCollection(useType);
            for (int i = 0; i < length; i++) {
                collection.add(Array.get(object, i));
            }
            return unmodifiableCollection(collection);
        }
        if (length > 0) {
            final Object value = Array.get(object, 0);
            return convert(value, useType);
        }
        return convert("""", useType);
    }
    if (object instanceof Collection) {
        final int length = ((Collection) object).size();
        if (useType.isArray()) {
            final Class cType = useType.getComponentType();
            final Object array = Array.newInstance(cType, length);
            final Iterator it = ((Collection) object).iterator();
            for (int i = 0; i < length; i++) {
                final Object value = it.next();
                Array.set(array, i, convert(value, cType));
            }
            return array;
        }
        if (Collection.class.isAssignableFrom(useType)) {
            final Collection collection = allocateCollection(useType);
            collection.addAll((Collection) object);
            return unmodifiableCollection(collection);
        }
        if (length > 0) {
            Object value;
            if (object instanceof List) {
                value = ((List) object).get(0);
            } else {
                final Iterator it = ((Collection) object).iterator();
                value = it.next();
            }
            return convert(value, useType);
        }
        return convert("""", useType);
    }
    if (object instanceof NodeSet) {
        return convert(((NodeSet) object).getValues(), useType);
    }
    if (object instanceof Pointer) {
        return convert(((Pointer) object).getValue(), useType);
    }
    if (useType == String.class) {
        return object.toString();
    }
    if (object instanceof Boolean) {
        if (Number.class.isAssignableFrom(useType)) {
            return allocateNumber(useType, ((Boolean) object).booleanValue() ? 1 : 0);
        }
        if (""java.util.concurrent.atomic.AtomicBoolean"".equals(useType.getName())) {
            try {
                return useType.getConstructor(new Class[] { boolean.class }).newInstance(object);
            } catch (final Exception e) {
                throw new JXPathTypeConversionException(useType.getName(), e);
            }
        }
    }
    if (object instanceof Number) {
        final double value = ((Number) object).doubleValue();
        if (useType == Boolean.class) {
            return value == 0.0 ? Boolean.FALSE : Boolean.TRUE;
        }
        if (Number.class.isAssignableFrom(useType)) {
            return allocateNumber(useType, value);
        }
    }
    if (object instanceof String) {
        final Object value = convertStringToPrimitive(object, useType);
        if (value != null) {
            return value;
        }
    }
    final Converter converter = ConvertUtils.lookup(useType);
    if (converter != null) {
        return converter.convert(useType, object);
    }
    throw new JXPathTypeConversionException(""Cannot convert "" + object.getClass() + "" to "" + useType);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.convert(Object,Class).object","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.convert(Object,Class).toType","Parameter_2","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.convertNullToPrimitive(Class)","Method","* Convert null to a primitive type.
     * @param toType destination class
     * @return a wrapper","protected Object convertNullToPrimitive(final Class toType) {
    if (toType == boolean.class) {
        return Boolean.FALSE;
    }
    if (toType == char.class) {
        return Character.valueOf('\0');
    }
    if (toType == byte.class) {
        return Byte.valueOf((byte) 0);
    }
    if (toType == short.class) {
        return Short.valueOf((short) 0);
    }
    if (toType == int.class) {
        return Integer.valueOf(0);
    }
    if (toType == long.class) {
        return Long.valueOf(0L);
    }
    if (toType == float.class) {
        return Float.valueOf(0.0f);
    }
    if (toType == double.class) {
        return Double.valueOf(0.0);
    }
    return null;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.convertNullToPrimitive(Class).toType","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.convertNullToPrimitive(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.convertStringToPrimitive(Object,Class)","Method","* Convert a string to a primitive type.
     * @param object String
     * @param toType destination class
     * @return wrapper","protected Object convertStringToPrimitive(final Object object, Class toType) {
    toType = TypeUtils.wrapPrimitive(toType);
    if (toType == Boolean.class) {
        return Boolean.valueOf((String) object);
    }
    if (toType == Character.class) {
        return Character.valueOf(((String) object).charAt(0));
    }
    if (toType == Byte.class) {
        return Byte.valueOf((String) object);
    }
    if (toType == Short.class) {
        return Short.valueOf((String) object);
    }
    if (toType == Integer.class) {
        return Integer.valueOf((String) object);
    }
    if (toType == Long.class) {
        return Long.valueOf((String) object);
    }
    if (toType == Float.class) {
        return Float.valueOf((String) object);
    }
    if (toType == Double.class) {
        return Double.valueOf((String) object);
    }
    return null;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.convertStringToPrimitive(Object,Class).object","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.convertStringToPrimitive(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.convertStringToPrimitive(Object,Class).toType","Parameter_2","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.convertStringToPrimitive(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.allocateNumber(Class,double)","Method","* Allocate a number of a given type and value.
     * @param type destination class
     * @param value double
     * @return Number","protected Number allocateNumber(Class type, final double value) {
    type = TypeUtils.wrapPrimitive(type);
    if (type == Byte.class) {
        return Byte.valueOf((byte) value);
    }
    if (type == Short.class) {
        return Short.valueOf((short) value);
    }
    if (type == Integer.class) {
        return Integer.valueOf((int) value);
    }
    if (type == Long.class) {
        return Long.valueOf((long) value);
    }
    if (type == Float.class) {
        return Float.valueOf((float) value);
    }
    if (type == Double.class) {
        return Double.valueOf(value);
    }
    if (type == BigInteger.class) {
        return BigInteger.valueOf((long) value);
    }
    if (type == BigDecimal.class) {
        // TODO ? https://pmd.sourceforge.io/pmd-6.50.0/pmd_rules_java_errorprone.html#avoiddecimalliteralsinbigdecimalconstructor
        // NOPMD
        return new BigDecimal(value);
    }
    final String className = type.getName();
    Class initialValueType = null;
    if (""java.util.concurrent.atomic.AtomicInteger"".equals(className)) {
        initialValueType = int.class;
    }
    if (""java.util.concurrent.atomic.AtomicLong"".equals(className)) {
        initialValueType = long.class;
    }
    if (initialValueType != null) {
        try {
            return (Number) type.getConstructor(new Class[] { initialValueType }).newInstance(allocateNumber(initialValueType, value));
        } catch (final Exception e) {
            throw new JXPathTypeConversionException(className, e);
        }
    }
    return null;
}","Number","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.allocateNumber(Class,double).type","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.allocateNumber(Class,double)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.allocateNumber(Class,double).value","Parameter_2","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.allocateNumber(Class,double)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.canCreateCollection(Class)","Method","* Learn whether this BasicTypeConverter can create a collection of the specified type.
     * @param type prospective destination class
     * @return boolean","protected boolean canCreateCollection(final Class type) {
    if (!type.isInterface() && (type.getModifiers() & Modifier.ABSTRACT) == 0) {
        try {
            type.getConstructor();
            return true;
        } catch (final Exception e) {
            return false;
        }
    }
    return type == List.class || type == Collection.class || type == Set.class;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.canCreateCollection(Class).type","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.canCreateCollection(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.allocateCollection(Class)","Method","* Create a collection of a given type.
     * @param type destination class
     * @return Collection","protected Collection allocateCollection(final Class type) {
    if (!type.isInterface() && (type.getModifiers() & Modifier.ABSTRACT) == 0) {
        try {
            return (Collection) type.getConstructor().newInstance();
        } catch (final Exception ex) {
            throw new JXPathInvalidAccessException(""Cannot create collection of type: "" + type, ex);
        }
    }
    if (type == List.class || type == Collection.class) {
        return new ArrayList();
    }
    if (type == Set.class) {
        return new HashSet();
    }
    throw new JXPathInvalidAccessException(""Cannot create collection of type: "" + type);
}","Collection","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.allocateCollection(Class).type","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.allocateCollection(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.unmodifiableCollection(Collection)","Method","* Gets an unmodifiable version of a collection.
     * @param collection to wrap
     * @return Collection","protected Collection unmodifiableCollection(final Collection collection) {
    if (collection instanceof List) {
        return Collections.unmodifiableList((List) collection);
    }
    if (collection instanceof SortedSet) {
        return Collections.unmodifiableSortedSet((SortedSet) collection);
    }
    if (collection instanceof Set) {
        return Collections.unmodifiableSet((Set) collection);
    }
    return Collections.unmodifiableCollection(collection);
}","Collection","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.unmodifiableCollection(Collection).collection","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.unmodifiableCollection(Collection)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet","Class","* NodeSet implementation","Class do not obtain Source Code","No return type","static , final ","","org.apache.commons.jxpath.NodeSet"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet.values","Field","No Comment","private final List values;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet.pointers","Field","No Comment","private List pointers;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet.getValues()","Method","No Comment","@Override
public List getValues() {
    return Collections.unmodifiableList(values);
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet.getNodes()","Method","No Comment","@Override
public List getNodes() {
    return Collections.unmodifiableList(values);
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet.getPointers()","Method","No Comment","@Override
public List getPointers() {
    if (pointers == null) {
        pointers = new ArrayList();
        for (int i = 0; i < values.size(); i++) {
            pointers.add(new ValuePointer(values.get(i)));
        }
        pointers = Collections.unmodifiableList(pointers);
    }
    return pointers;
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet.<init>(List)","Constructor","* Create a new ValueNodeSet.
         * @param values to return","public ValueNodeSet(final List values) {
    this.values = values;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet.<init>(List).values","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet.<init>(List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer","Class","* Value pointer","Class do not obtain Source Code","No return type","static , final ","","org.apache.commons.jxpath.Pointer"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -4817239482392206188L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.bean","Field","No Comment","private final Object bean;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.getValue()","Method","No Comment","@Override
public Object getValue() {
    return bean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.getNode()","Method","No Comment","@Override
public Object getNode() {
    return bean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.getRootNode()","Method","No Comment","@Override
public Object getRootNode() {
    return bean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.setValue(Object)","Method","No Comment","@Override
public void setValue(final Object value) {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.clone()","Method","No Comment","@Override
public Object clone() {
    return this;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.compareTo(Object)","Method","No Comment","@Override
public int compareTo(final Object object) {
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.compareTo(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.compareTo(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    if (bean == null) {
        return ""null()"";
    }
    if (bean instanceof Number) {
        String string = bean.toString();
        if (string.endsWith("".0"")) {
            string = string.substring(0, string.length() - 2);
        }
        return string;
    }
    if (bean instanceof Boolean) {
        return ((Boolean) bean).booleanValue() ? ""true()"" : ""false()"";
    }
    if (bean instanceof String) {
        return ""'"" + bean + ""'"";
    }
    return ""{object of type "" + bean.getClass().getName() + ""}"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.<init>(Object)","Constructor","* Create a new ValuePointer.
         * @param object value","public ValuePointer(final Object object) {
    this.bean = object;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.<init>(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer.<init>(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValueNodeSet","Class","* NodeSet implementation","Class do not obtain Source Code","No return type","static , final ","","org.apache.commons.jxpath.NodeSet"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValueNodeSet.values","Field","No Comment","private final List values;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValueNodeSet.pointers","Field","No Comment","private List pointers;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValueNodeSet.getValues()","Method","No Comment","@Override
public List getValues() {
    return Collections.unmodifiableList(values);
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValueNodeSet.getNodes()","Method","No Comment","@Override
public List getNodes() {
    return Collections.unmodifiableList(values);
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValueNodeSet.getPointers()","Method","No Comment","@Override
public List getPointers() {
    if (pointers == null) {
        pointers = new ArrayList();
        for (int i = 0; i < values.size(); i++) {
            pointers.add(new ValuePointer(values.get(i)));
        }
        pointers = Collections.unmodifiableList(pointers);
    }
    return pointers;
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValueNodeSet.<init>(List)","Constructor","* Create a new ValueNodeSet.
         * @param values to return","public ValueNodeSet(final List values) {
    this.values = values;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValueNodeSet.<init>(List).values","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.ValueNodeSet.<init>(List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer","Class","* Value pointer","Class do not obtain Source Code","No return type","static , final ","","org.apache.commons.jxpath.Pointer"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -4817239482392206188L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.bean","Field","No Comment","private final Object bean;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.getValue()","Method","No Comment","@Override
public Object getValue() {
    return bean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.getNode()","Method","No Comment","@Override
public Object getNode() {
    return bean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.getRootNode()","Method","No Comment","@Override
public Object getRootNode() {
    return bean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.setValue(Object)","Method","No Comment","@Override
public void setValue(final Object value) {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.clone()","Method","No Comment","@Override
public Object clone() {
    return this;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.compareTo(Object)","Method","No Comment","@Override
public int compareTo(final Object object) {
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.compareTo(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.compareTo(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    if (bean == null) {
        return ""null()"";
    }
    if (bean instanceof Number) {
        String string = bean.toString();
        if (string.endsWith("".0"")) {
            string = string.substring(0, string.length() - 2);
        }
        return string;
    }
    if (bean instanceof Boolean) {
        return ((Boolean) bean).booleanValue() ? ""true()"" : ""false()"";
    }
    if (bean instanceof String) {
        return ""'"" + bean + ""'"";
    }
    return ""{object of type "" + bean.getClass().getName() + ""}"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.<init>(Object)","Constructor","* Create a new ValuePointer.
         * @param object value","public ValuePointer(final Object object) {
    this.bean = object;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.<init>(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.util.BasicTypeConverter.ValuePointer.<init>(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils","Class","* Global type conversion utilities.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.util.TypeUtils.typeConverter","Field","No Comment","private static TypeConverter typeConverter = new BasicTypeConverter();","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.PRIMITIVE_TYPE_MAP","Field","No Comment","private static final HashMap PRIMITIVE_TYPE_MAP = new HashMap() {

    private static final long serialVersionUID = 1L;

    {
        put(int.class, Integer.class);
        put(byte.class, Byte.class);
        put(short.class, Short.class);
        put(char.class, Character.class);
        put(long.class, Long.class);
        put(float.class, Float.class);
        put(double.class, Double.class);
        put(boolean.class, Boolean.class);
    }
};","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.setTypeConverter(TypeConverter)","Method","* Install an alternative type converter.
     * @param converter new TypeConverter","public static synchronized void setTypeConverter(final TypeConverter converter) {
    typeConverter = converter;
}","void","public , static , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.setTypeConverter(TypeConverter).converter","Parameter_1","Belong to org.apache.commons.jxpath.util.TypeUtils.setTypeConverter(TypeConverter)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.getTypeConverter()","Method","* Returns the current type converter.
     * @return TypeConverter","public static TypeConverter getTypeConverter() {
    return typeConverter;
}","TypeConverter","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.canConvert(Object,Class)","Method","* Returns true if the global converter can convert the supplied
     * object to the specified type.
     * @param object object to test
     * @param toType target class
     * @return boolean","public static boolean canConvert(final Object object, final Class toType) {
    return typeConverter.canConvert(object, toType);
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.canConvert(Object,Class).object","Parameter_1","Belong to org.apache.commons.jxpath.util.TypeUtils.canConvert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.canConvert(Object,Class).toType","Parameter_2","Belong to org.apache.commons.jxpath.util.TypeUtils.canConvert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.convert(Object,Class)","Method","* Converts the supplied object to the specified type. May
     * throw a RuntimeException.
     * @param object object to convert
     * @param toType target class
     * @return resulting Object","public static Object convert(final Object object, final Class toType) {
    return typeConverter.convert(object, toType);
}","Object","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.convert(Object,Class).object","Parameter_1","Belong to org.apache.commons.jxpath.util.TypeUtils.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.convert(Object,Class).toType","Parameter_2","Belong to org.apache.commons.jxpath.util.TypeUtils.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.wrapPrimitive(Class)","Method","* Return the appropriate wrapper type for the specified class.
     * @param p Class for which to retrieve a wrapper class.
     * @return the wrapper if {@code p} is primitive, else {@code p}.
     * @since JXPath 1.3","public static Class wrapPrimitive(final Class p) {
    return p.isPrimitive() ? (Class) PRIMITIVE_TYPE_MAP.get(p) : p;
}","Class","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeUtils.wrapPrimitive(Class).p","Parameter_1","Belong to org.apache.commons.jxpath.util.TypeUtils.wrapPrimitive(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeConverter","Interface","* A type converter can be installed on {@link TypeUtils} to introduce
 * additional type conversions for JXPath. Most of
 * the time {@link BasicTypeConverter} should be used as the superclass.
 *
 * @see TypeUtils#setTypeConverter","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.util.TypeConverter.canConvert(Object,Class)","Abstract Method","* Returns true if it can convert the supplied
     * object to the specified class.
     * @param object object to test
     * @param toType target class
     * @return boolean","boolean canConvert(Object object, Class toType);","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeConverter.canConvert(Object,Class).object","Parameter_1","Belong to org.apache.commons.jxpath.util.TypeConverter.canConvert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeConverter.canConvert(Object,Class).toType","Parameter_2","Belong to org.apache.commons.jxpath.util.TypeConverter.canConvert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeConverter.convert(Object,Class)","Abstract Method","* Converts the supplied object to the specified
     * type. Throws a runtime exception if the conversion is
     * not possible.
     * @param object object to convert
     * @param toType target class
     * @return resulting Object","Object convert(Object object, Class toType);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeConverter.convert(Object,Class).object","Parameter_1","Belong to org.apache.commons.jxpath.util.TypeConverter.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.TypeConverter.convert(Object,Class).toType","Parameter_2","Belong to org.apache.commons.jxpath.util.TypeConverter.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ReverseComparator","Class","* Reverse comparator.","Class do not obtain Source Code","No return type","public , final ","","java.util.Comparator;java.io.Serializable"
"org.apache.commons.jxpath.util.ReverseComparator.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -2795475743948616649L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ReverseComparator.INSTANCE","Field","* Singleton reverse comparator instance.","public static final Comparator INSTANCE = new ReverseComparator();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ReverseComparator.compare(Object,Object)","Method","No Comment","@Override
public int compare(final Object o1, final Object o2) {
    return ((Comparable) o2).compareTo(o1);
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ReverseComparator.compare(Object,Object).o1","Parameter_1","Belong to org.apache.commons.jxpath.util.ReverseComparator.compare(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ReverseComparator.compare(Object,Object).o2","Parameter_2","Belong to org.apache.commons.jxpath.util.ReverseComparator.compare(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ReverseComparator.<init>()","Constructor","* Create a new ReverseComparator.","private ReverseComparator() {
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter","Class","* TypeConverter implementation to circumvent automagic {@link NodeSet}
 * decoding. Suggested by JIRA issue JXPATH-10.
 *
 * @since JXPath 1.3","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.util.BasicTypeConverter",""
"org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.canConvert(Object,Class)","Method","No Comment","@Override
public boolean canConvert(final Object object, final Class toType) {
    return object instanceof NodeSet ? toType.isInstance(object) : super.canConvert(object, toType);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.canConvert(Object,Class).object","Parameter_1","Belong to org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.canConvert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.canConvert(Object,Class).toType","Parameter_2","Belong to org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.canConvert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.convert(Object,Class)","Method","No Comment","@Override
public Object convert(final Object object, final Class toType) {
    return object instanceof NodeSet && toType.isInstance(object) ? object : super.convert(object, toType);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.convert(Object,Class).object","Parameter_1","Belong to org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.convert(Object,Class).toType","Parameter_2","Belong to org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil","Class","* Port of class loading methods from {@code org.apache.commons.lang3.ClassUtils} from
 * the Apache Commons Lang Component. Some adjustments made to remove dependency on
 * {@code org.apache.commons.lang3.StringUtils}. Also modified to fall back on the
 * current class loader when an attempt to load a class with the context class loader
 * results in a {@code java.lang.ClassNotFoundException}.
 *
 * See org.apache.commons.lang3.ClassUtils","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.util.ClassLoaderUtil.abbreviationMap","Field","* Maps a primitive class name to its corresponding abbreviation used in array class names.","private static Map abbreviationMap = new HashMap();","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.addAbbreviation(String,String)","Method","* Add primitive type abbreviation to maps of abbreviations.
     *
     * @param primitive Canonical name of primitive type
     * @param abbreviation Corresponding abbreviation of primitive type","private static void addAbbreviation(final String primitive, final String abbreviation) {
    abbreviationMap.put(primitive, abbreviation);
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.addAbbreviation(String,String).primitive","Parameter_1","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.addAbbreviation(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.addAbbreviation(String,String).abbreviation","Parameter_2","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.addAbbreviation(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String,boolean)","Method","* Returns the class represented by {@code className} using the
     * {@code classLoader}.  This implementation supports names like
     * ""{@code java.lang.String[]}"" as well as ""{@code [Ljava.lang.String;}"".
     *
     * @param classLoader  the class loader to use to load the class
     * @param className  the class name
     * @param initialize  whether the class must be initialized
     * @return the class represented by {@code className} using the {@code classLoader}
     * @throws ClassNotFoundException if the class is not found","public static Class getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {
    Class clazz;
    if (abbreviationMap.containsKey(className)) {
        final String clsName = ""["" + abbreviationMap.get(className);
        clazz = Class.forName(clsName, initialize, classLoader).getComponentType();
    } else {
        clazz = Class.forName(toCanonicalName(className), initialize, classLoader);
    }
    return clazz;
}","Class","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String,boolean).classLoader","Parameter_1","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String,boolean).className","Parameter_2","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String,boolean).initialize","Parameter_3","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String)","Method","* Returns the (initialized) class represented by {@code className}
     * using the {@code classLoader}.  This implementation supports names
     * like ""{@code java.lang.String[]}"" as well as
     * ""{@code [Ljava.lang.String;}"".
     *
     * @param classLoader  the class loader to use to load the class
     * @param className  the class name
     * @return the class represented by {@code className} using the {@code classLoader}
     * @throws ClassNotFoundException if the class is not found","public static Class getClass(final ClassLoader classLoader, final String className) throws ClassNotFoundException {
    return getClass(classLoader, className, true);
}","Class","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String).classLoader","Parameter_1","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String).className","Parameter_2","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(ClassLoader,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(String)","Method","* Returns the (initialized) class represented by {@code className}
     * using the current thread's context class loader. This implementation
     * supports names like ""{@code java.lang.String[]}"" as well as
     * ""{@code [Ljava.lang.String;}"".
     *
     * @param className  the class name
     * @return the class represented by {@code className} using the current thread's context class loader
     * @throws ClassNotFoundException if the class is not found","public static Class getClass(final String className) throws ClassNotFoundException {
    return getClass(className, true);
}","Class","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(String).className","Parameter_1","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(String,boolean)","Method","* Returns the class represented by {@code className} using the
     * current thread's context class loader. This implementation supports
     * names like ""{@code java.lang.String[]}"" as well as
     * ""{@code [Ljava.lang.String;}"".
     *
     * @param className  the class name
     * @param initialize  whether the class must be initialized
     * @return the class represented by {@code className} using the current thread's context class loader
     * @throws ClassNotFoundException if the class is not found","public static Class getClass(final String className, final boolean initialize) throws ClassNotFoundException {
    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();
    final ClassLoader currentCL = ClassLoaderUtil.class.getClassLoader();
    if (contextCL != null) {
        try {
            return getClass(contextCL, className, initialize);
        } catch (final ClassNotFoundException ignore) {
            // NOPMD
            // ignore this exception and try the current class loader
        }
    }
    return getClass(currentCL, className, initialize);
}","Class","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(String,boolean).className","Parameter_1","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(String,boolean).initialize","Parameter_2","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.getClass(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.toCanonicalName(String)","Method","* Converts a class name to a JLS style class name.
     *
     * @param className  the class name
     * @return the converted name","private static String toCanonicalName(String className) {
    Objects.requireNonNull(className, ""className"");
    if (className.endsWith(""[]"")) {
        final StringBuilder classNameBuffer = new StringBuilder();
        while (className.endsWith(""[]"")) {
            className = className.substring(0, className.length() - 2);
            classNameBuffer.append(""["");
        }
        final String abbreviation = (String) abbreviationMap.get(className);
        if (abbreviation != null) {
            classNameBuffer.append(abbreviation);
        } else {
            classNameBuffer.append(""L"").append(className).append("";"");
        }
        className = classNameBuffer.toString();
    }
    return className;
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ClassLoaderUtil.toCanonicalName(String).className","Parameter_1","Belong to org.apache.commons.jxpath.util.ClassLoaderUtil.toCanonicalName(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils","Class","* Collection and property access utilities.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.util.ValueUtils.dynamicPropertyHandlerMap","Field","No Comment","private static Map dynamicPropertyHandlerMap = new HashMap();","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.UNKNOWN_LENGTH_MAX_COUNT","Field","No Comment","private static final int UNKNOWN_LENGTH_MAX_COUNT = 16000;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.isCollection(Object)","Method","* Returns true if the object is an array or a Collection.
     * @param value to test
     * @return boolean","public static boolean isCollection(Object value) {
    value = getValue(value);
    if (value == null) {
        return false;
    }
    if (value.getClass().isArray()) {
        return true;
    }
    return value instanceof Collection;
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.isCollection(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.isCollection(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getCollectionHint(Class)","Method","* Returns 1 if the type is a collection,
     * -1 if it is definitely not
     * and 0 if it may be a collection in some cases.
     * @param clazz to test
     * @return int","public static int getCollectionHint(final Class clazz) {
    if (clazz.isArray()) {
        return 1;
    }
    if (Collection.class.isAssignableFrom(clazz)) {
        return 1;
    }
    if (clazz.isPrimitive()) {
        return -1;
    }
    if (clazz.isInterface()) {
        return 0;
    }
    if (Modifier.isFinal(clazz.getModifiers())) {
        return -1;
    }
    return 0;
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getCollectionHint(Class).clazz","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getCollectionHint(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getIndexedPropertyLength(Object,IndexedPropertyDescriptor)","Method","* If there is a regular non-indexed read method for this property,
     * uses this method to obtain the collection and then returns its
     * length.
     * Otherwise, attempts to guess the length of the collection by
     * calling the indexed get method repeatedly.  The method is supposed
     * to throw an exception if the index is out of bounds.
     * @param object collection
     * @param pd IndexedPropertyDescriptor
     * @return int","public static int getIndexedPropertyLength(final Object object, final IndexedPropertyDescriptor pd) {
    if (pd.getReadMethod() != null) {
        return getLength(getValue(object, pd));
    }
    final Method readMethod = pd.getIndexedReadMethod();
    if (readMethod == null) {
        throw new JXPathException(""No indexed read method for property "" + pd.getName());
    }
    for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) {
        try {
            readMethod.invoke(object, Integer.valueOf(i));
        } catch (final Throwable t) {
            return i;
        }
    }
    throw new JXPathException(""Cannot determine the length of the indexed property "" + pd.getName());
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getIndexedPropertyLength(Object,IndexedPropertyDescriptor).object","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getIndexedPropertyLength(Object,IndexedPropertyDescriptor)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getIndexedPropertyLength(Object,IndexedPropertyDescriptor).pd","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.getIndexedPropertyLength(Object,IndexedPropertyDescriptor)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getLength(Object)","Method","* Returns the length of the supplied collection. If the supplied object
     * is not a collection, returns 1. If collection is null, returns 0.
     * @param collection to check
     * @return int","public static int getLength(Object collection) {
    if (collection == null) {
        return 0;
    }
    collection = getValue(collection);
    if (collection.getClass().isArray()) {
        return Array.getLength(collection);
    }
    if (collection instanceof Collection) {
        return ((Collection) collection).size();
    }
    return 1;
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getLength(Object).collection","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getLength(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.iterate(Object)","Method","* Returns an iterator for the supplied collection. If the argument
     * is null, returns an empty iterator. If the argument is not
     * a collection, returns an iterator that produces just that one object.
     * @param collection to iterate
     * @return Iterator","public static Iterator iterate(final Object collection) {
    if (collection == null) {
        return Collections.EMPTY_LIST.iterator();
    }
    if (collection.getClass().isArray()) {
        final int length = Array.getLength(collection);
        if (length == 0) {
            return Collections.EMPTY_LIST.iterator();
        }
        final ArrayList list = new ArrayList();
        for (int i = 0; i < length; i++) {
            list.add(Array.get(collection, i));
        }
        return list.iterator();
    }
    if (collection instanceof Collection) {
        return ((Collection) collection).iterator();
    }
    return Collections.singletonList(collection).iterator();
}","Iterator","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.iterate(Object).collection","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.iterate(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.expandCollection(Object,int)","Method","* Grows the collection if necessary to the specified size. Returns
     * the new, expanded collection.
     * @param collection to expand
     * @param size desired size
     * @return collection or array","public static Object expandCollection(final Object collection, final int size) {
    if (collection == null) {
        return null;
    }
    if (size < getLength(collection)) {
        throw new JXPathException(""adjustment of "" + collection + "" to size "" + size + "" is not an expansion"");
    }
    if (collection.getClass().isArray()) {
        final Object bigger = Array.newInstance(collection.getClass().getComponentType(), size);
        System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection));
        return bigger;
    }
    if (collection instanceof Collection) {
        while (((Collection) collection).size() < size) {
            ((Collection) collection).add(null);
        }
        return collection;
    }
    throw new JXPathException(""Cannot turn "" + collection.getClass().getName() + "" into a collection of size "" + size);
}","Object","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.expandCollection(Object,int).collection","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.expandCollection(Object,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.expandCollection(Object,int).size","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.expandCollection(Object,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.remove(Object,int)","Method","* Remove the index'th element from the supplied collection.
     * @param collection to edit
     * @param index int
     * @return the resulting collection","public static Object remove(Object collection, final int index) {
    collection = getValue(collection);
    if (collection == null) {
        return null;
    }
    if (index >= getLength(collection)) {
        throw new JXPathException(""No such element at index "" + index);
    }
    if (collection.getClass().isArray()) {
        final int length = Array.getLength(collection);
        final Object smaller = Array.newInstance(collection.getClass().getComponentType(), length - 1);
        if (index > 0) {
            System.arraycopy(collection, 0, smaller, 0, index);
        }
        if (index < length - 1) {
            System.arraycopy(collection, index + 1, smaller, index, length - index - 1);
        }
        return smaller;
    }
    if (collection instanceof List) {
        final int size = ((List) collection).size();
        if (index < size) {
            ((List) collection).remove(index);
        }
        return collection;
    }
    if (collection instanceof Collection) {
        final Iterator it = ((Collection) collection).iterator();
        for (int i = 0; i < index; i++) {
            if (!it.hasNext()) {
                break;
            }
            it.next();
        }
        if (it.hasNext()) {
            it.next();
            it.remove();
        }
        return collection;
    }
    throw new JXPathException(""Cannot remove "" + collection.getClass().getName() + ""["" + index + ""]"");
}","Object","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.remove(Object,int).collection","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.remove(Object,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.remove(Object,int).index","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.remove(Object,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,int)","Method","* Returns the index'th element of the supplied collection.
     * @param collection to read
     * @param index int
     * @return collection[index]","public static Object getValue(Object collection, final int index) {
    collection = getValue(collection);
    Object value = collection;
    if (collection != null) {
        if (collection.getClass().isArray()) {
            if (index < 0 || index >= Array.getLength(collection)) {
                return null;
            }
            value = Array.get(collection, index);
        } else if (collection instanceof List) {
            if (index < 0 || index >= ((List) collection).size()) {
                return null;
            }
            value = ((List) collection).get(index);
        } else if (collection instanceof Collection) {
            if (index < 0 || index >= ((Collection) collection).size()) {
                return null;
            }
            int i = 0;
            final Iterator it = ((Collection) collection).iterator();
            for (; i < index; i++) {
                it.next();
            }
            if (it.hasNext()) {
                value = it.next();
            } else {
                value = null;
            }
        }
    }
    return value;
}","Object","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,int).collection","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getValue(Object,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,int).index","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.getValue(Object,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,int,Object)","Method","* Modifies the index'th element of the supplied collection.
     * Converts the value to the required type if necessary.
     * @param collection to edit
     * @param index to replace
     * @param value new value","public static void setValue(Object collection, final int index, final Object value) {
    collection = getValue(collection);
    if (collection != null) {
        if (collection.getClass().isArray()) {
            Array.set(collection, index, convert(value, collection.getClass().getComponentType()));
        } else if (collection instanceof List) {
            ((List) collection).set(index, value);
        } else if (collection instanceof Collection) {
            throw new UnsupportedOperationException(""Cannot set value of an element of a "" + collection.getClass().getName());
        }
    }
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,int,Object).collection","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,int,Object).index","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,int,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor)","Method","* Returns the value of the bean's property represented by
     * the supplied property descriptor.
     * @param bean to read
     * @param propertyDescriptor indicating what to read
     * @return Object value","public static Object getValue(final Object bean, final PropertyDescriptor propertyDescriptor) {
    Object value;
    try {
        final Method method = getAccessibleMethod(propertyDescriptor.getReadMethod());
        if (method == null) {
            throw new JXPathException(""No read method"");
        }
        value = method.invoke(bean);
    } catch (final Exception ex) {
        throw new JXPathException(""Cannot access property: "" + (bean == null ? ""null"" : bean.getClass().getName()) + ""."" + propertyDescriptor.getName(), ex);
    }
    return value;
}","Object","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor).bean","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor).propertyDescriptor","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,Object)","Method","* Modifies the value of the bean's property represented by
     * the supplied property descriptor.
     * @param bean to read
     * @param propertyDescriptor indicating what to read
     * @param value to set","public static void setValue(final Object bean, final PropertyDescriptor propertyDescriptor, Object value) {
    try {
        final Method method = getAccessibleMethod(propertyDescriptor.getWriteMethod());
        if (method == null) {
            throw new JXPathException(""No write method"");
        }
        value = convert(value, propertyDescriptor.getPropertyType());
        method.invoke(bean, value);
    } catch (final Exception ex) {
        throw new JXPathException(""Cannot modify property: "" + (bean == null ? ""null"" : bean.getClass().getName()) + ""."" + propertyDescriptor.getName(), ex);
    }
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,Object).bean","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,Object).propertyDescriptor","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.convert(Object,Class)","Method","* Convert value to type.
     * @param value Object
     * @param type destination
     * @return conversion result","private static Object convert(final Object value, final Class type) {
    try {
        return TypeUtils.convert(value, type);
    } catch (final Exception ex) {
        throw new JXPathException(""Cannot convert value of class "" + (value == null ? ""null"" : value.getClass().getName()) + "" to type "" + type, ex);
    }
}","Object","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.convert(Object,Class).value","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.convert(Object,Class).type","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.convert(Object,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor,int)","Method","* Returns the index'th element of the bean's property represented by
     * the supplied property descriptor.
     * @param bean to read
     * @param propertyDescriptor indicating what to read
     * @param index int
     * @return Object","public static Object getValue(final Object bean, final PropertyDescriptor propertyDescriptor, final int index) {
    if (propertyDescriptor instanceof IndexedPropertyDescriptor) {
        try {
            final IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor;
            final Method method = ipd.getIndexedReadMethod();
            if (method != null) {
                return method.invoke(bean, Integer.valueOf(index));
            }
        } catch (final InvocationTargetException ex) {
            final Throwable t = ex.getTargetException();
            if (t instanceof IndexOutOfBoundsException) {
                return null;
            }
            throw new JXPathException(""Cannot access property: "" + propertyDescriptor.getName(), t);
        } catch (final Throwable ex) {
            throw new JXPathException(""Cannot access property: "" + propertyDescriptor.getName(), ex);
        }
    }
    // We will fall through if there is no indexed read
    return getValue(getValue(bean, propertyDescriptor), index);
}","Object","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor,int).bean","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor,int).propertyDescriptor","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor,int).index","Parameter_3","Belong to org.apache.commons.jxpath.util.ValueUtils.getValue(Object,PropertyDescriptor,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,int,Object)","Method","* Modifies the index'th element of the bean's property represented by
     * the supplied property descriptor. Converts the value to the required
     * type if necessary.
     * @param bean to edit
     * @param propertyDescriptor indicating what to set
     * @param index int
     * @param value to set","public static void setValue(final Object bean, final PropertyDescriptor propertyDescriptor, final int index, final Object value) {
    if (propertyDescriptor instanceof IndexedPropertyDescriptor) {
        try {
            final IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor;
            final Method method = ipd.getIndexedWriteMethod();
            if (method != null) {
                method.invoke(bean, Integer.valueOf(index), convert(value, ipd.getIndexedPropertyType()));
                return;
            }
        } catch (final Exception ex) {
            throw new IllegalArgumentException(""Cannot access property: "" + propertyDescriptor.getName() + "", "" + ex.getMessage());
        }
    }
    // We will fall through if there is no indexed read
    final Object collection = getValue(bean, propertyDescriptor);
    if (isCollection(collection)) {
        setValue(collection, index, value);
    } else if (index == 0) {
        setValue(bean, propertyDescriptor, value);
    } else {
        throw new IllegalArgumentException(""Not a collection: "" + propertyDescriptor.getName());
    }
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,int,Object).bean","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,int,Object).propertyDescriptor","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,int,Object).index","Parameter_3","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,int,Object).value","Parameter_4","Belong to org.apache.commons.jxpath.util.ValueUtils.setValue(Object,PropertyDescriptor,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object)","Method","* If the parameter is a container, opens the container and
     * return the contents.  The method is recursive.
     * @param object to read
     * @return Object","public static Object getValue(Object object) {
    while (object instanceof Container) {
        object = ((Container) object).getValue();
    }
    return object;
}","Object","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getValue(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getDynamicPropertyHandler(Class)","Method","* Returns a shared instance of the dynamic property handler class
     * returned by {@code getDynamicPropertyHandlerClass()}.
     * @param clazz to handle
     * @return DynamicPropertyHandler","public static DynamicPropertyHandler getDynamicPropertyHandler(final Class clazz) {
    return (DynamicPropertyHandler) dynamicPropertyHandlerMap.computeIfAbsent(clazz, k -> {
        try {
            return (DynamicPropertyHandler) clazz.getConstructor().newInstance();
        } catch (final Exception ex) {
            throw new JXPathException(""Cannot allocate dynamic property handler of class "" + clazz.getName(), ex);
        }
    });
}","DynamicPropertyHandler","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getDynamicPropertyHandler(Class).clazz","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getDynamicPropertyHandler(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethod(Method)","Method","* Gets an accessible method (that is, one that can be invoked via
     * reflection) that implements the specified Method.  If no such method
     * can be found, return {@code null}.
     *
     * @param method The method that we wish to call
     * @return Method","public static Method getAccessibleMethod(final Method method) {
    // Make sure we have a method to check
    if (method == null) {
        return null;
    }
    // If the requested method is not public we cannot call it
    if (!Modifier.isPublic(method.getModifiers())) {
        return null;
    }
    // If the declaring class is public, we are done
    Class clazz = method.getDeclaringClass();
    if (Modifier.isPublic(clazz.getModifiers())) {
        return method;
    }
    final String name = method.getName();
    final Class[] parameterTypes = method.getParameterTypes();
    while (clazz != null) {
        // Check the implemented interfaces and subinterfaces
        final Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes);
        if (aMethod != null) {
            return aMethod;
        }
        clazz = clazz.getSuperclass();
        if (clazz != null && Modifier.isPublic(clazz.getModifiers())) {
            try {
                return clazz.getDeclaredMethod(name, parameterTypes);
            } catch (final NoSuchMethodException ignore) {
                // NOPMD
                //ignore
            }
        }
    }
    return null;
}","Method","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethod(Method).method","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethod(Method)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethodFromInterfaceNest(Class,String,Class[])","Method","* Gets an accessible method (that is, one that can be invoked via
     * reflection) that implements the specified method, by scanning through
     * all implemented interfaces and subinterfaces.  If no such Method
     * can be found, return {@code null}.
     *
     * @param clazz Parent class for the interfaces to be checked
     * @param methodName Method name of the method we wish to call
     * @param parameterTypes The parameter type signatures
     * @return Method","private static Method getAccessibleMethodFromInterfaceNest(final Class clazz, final String methodName, final Class[] parameterTypes) {
    Method method = null;
    // Check the implemented interfaces of the parent class
    final Class[] interfaces = clazz.getInterfaces();
    for (final Class element : interfaces) {
        // Is this interface public?
        if (!Modifier.isPublic(element.getModifiers())) {
            continue;
        }
        // Does the method exist on this interface?
        try {
            method = element.getDeclaredMethod(methodName, parameterTypes);
        } catch (final NoSuchMethodException ignore) {
            // NOPMD
            // ignore
        }
        if (method != null) {
            break;
        }
        // Recursively check our parent interfaces
        method = getAccessibleMethodFromInterfaceNest(element, methodName, parameterTypes);
        if (method != null) {
            break;
        }
    }
    // Return whatever we have found
    return method;
}","Method","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethodFromInterfaceNest(Class,String,Class[]).clazz","Parameter_1","Belong to org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethodFromInterfaceNest(Class,String,Class[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethodFromInterfaceNest(Class,String,Class[]).methodName","Parameter_2","Belong to org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethodFromInterfaceNest(Class,String,Class[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethodFromInterfaceNest(Class,String,Class[]).parameterTypes","Parameter_3","Belong to org.apache.commons.jxpath.util.ValueUtils.getAccessibleMethodFromInterfaceNest(Class,String,Class[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils","Class","* Method lookup utilities, which find static and non-static methods as well
 * as constructors based on a name and list of parameters.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.util.MethodLookupUtils.NO_MATCH","Field","No Comment","private static final int NO_MATCH = 0;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.APPROXIMATE_MATCH","Field","No Comment","private static final int APPROXIMATE_MATCH = 1;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.EXACT_MATCH","Field","No Comment","private static final int EXACT_MATCH = 2;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupConstructor(Class,Object[])","Method","* Look up a constructor.
     * @param targetClass the class constructed
     * @param parameters arguments
     * @return Constructor found if any.","public static Constructor lookupConstructor(final Class targetClass, final Object[] parameters) {
    boolean tryExact = true;
    final int count = parameters == null ? 0 : parameters.length;
    final Class[] types = new Class[count];
    for (int i = 0; i < count; i++) {
        final Object param = parameters[i];
        if (param != null) {
            types[i] = param.getClass();
        } else {
            types[i] = null;
            tryExact = false;
        }
    }
    Constructor constructor = null;
    if (tryExact) {
        // First - without type conversion
        try {
            constructor = targetClass.getConstructor(types);
            if (constructor != null) {
                return constructor;
            }
        } catch (final NoSuchMethodException ignore) {
            // NOPMD
            // Ignore
        }
    }
    int currentMatch = 0;
    boolean ambiguous = false;
    // Then - with type conversion
    final Constructor[] constructors = targetClass.getConstructors();
    for (final Constructor constructor2 : constructors) {
        final int match = matchParameterTypes(constructor2.getParameterTypes(), parameters);
        if (match != NO_MATCH) {
            if (match > currentMatch) {
                constructor = constructor2;
                currentMatch = match;
                ambiguous = false;
            } else if (match == currentMatch) {
                ambiguous = true;
            }
        }
    }
    if (ambiguous) {
        throw new JXPathException(""Ambiguous constructor "" + Arrays.asList(parameters));
    }
    return constructor;
}","Constructor","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupConstructor(Class,Object[]).targetClass","Parameter_1","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.lookupConstructor(Class,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupConstructor(Class,Object[]).parameters","Parameter_2","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.lookupConstructor(Class,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupStaticMethod(Class,String,Object[])","Method","* Look up a static method.
     * @param targetClass the owning class
     * @param name method name
     * @param parameters method parameters
     * @return Method found if any","public static Method lookupStaticMethod(final Class targetClass, final String name, final Object[] parameters) {
    boolean tryExact = true;
    final int count = parameters == null ? 0 : parameters.length;
    final Class[] types = new Class[count];
    for (int i = 0; i < count; i++) {
        final Object param = parameters[i];
        if (param != null) {
            types[i] = param.getClass();
        } else {
            types[i] = null;
            tryExact = false;
        }
    }
    Method method = null;
    if (tryExact) {
        // First - without type conversion
        try {
            method = targetClass.getMethod(name, types);
            if (method != null && Modifier.isStatic(method.getModifiers())) {
                return method;
            }
        } catch (final NoSuchMethodException ignore) {
            // NOPMD
            // Ignore
        }
    }
    int currentMatch = 0;
    boolean ambiguous = false;
    // Then - with type conversion
    final Method[] methods = targetClass.getMethods();
    for (final Method method2 : methods) {
        if (Modifier.isStatic(method2.getModifiers()) && method2.getName().equals(name)) {
            final int match = matchParameterTypes(method2.getParameterTypes(), parameters);
            if (match != NO_MATCH) {
                if (match > currentMatch) {
                    method = method2;
                    currentMatch = match;
                    ambiguous = false;
                } else if (match == currentMatch) {
                    ambiguous = true;
                }
            }
        }
    }
    if (ambiguous) {
        throw new JXPathException(""Ambiguous method call: "" + name);
    }
    return method;
}","Method","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupStaticMethod(Class,String,Object[]).targetClass","Parameter_1","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.lookupStaticMethod(Class,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupStaticMethod(Class,String,Object[]).name","Parameter_2","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.lookupStaticMethod(Class,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupStaticMethod(Class,String,Object[]).parameters","Parameter_3","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.lookupStaticMethod(Class,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupMethod(Class,String,Object[])","Method","* Look up a method.
     * @param targetClass owning class
     * @param name method name
     * @param parameters method parameters
     * @return Method found if any","public static Method lookupMethod(Class targetClass, final String name, final Object[] parameters) {
    if (parameters == null || parameters.length < 1 || parameters[0] == null) {
        return null;
    }
    if (matchType(targetClass, parameters[0]) == NO_MATCH) {
        return null;
    }
    targetClass = TypeUtils.convert(parameters[0], targetClass).getClass();
    boolean tryExact = true;
    final int count = parameters.length - 1;
    final Class[] types = new Class[count];
    final Object[] arguments = new Object[count];
    for (int i = 0; i < count; i++) {
        final Object param = parameters[i + 1];
        arguments[i] = param;
        if (param != null) {
            types[i] = param.getClass();
        } else {
            types[i] = null;
            tryExact = false;
        }
    }
    Method method = null;
    if (tryExact) {
        // First - without type conversion
        try {
            method = targetClass.getMethod(name, types);
            if (method != null && !Modifier.isStatic(method.getModifiers())) {
                return method;
            }
        } catch (final NoSuchMethodException ignore) {
            // NOPMD
            // Ignore
        }
    }
    int currentMatch = 0;
    boolean ambiguous = false;
    // Then - with type conversion
    final Method[] methods = targetClass.getMethods();
    for (final Method method2 : methods) {
        if (!Modifier.isStatic(method2.getModifiers()) && method2.getName().equals(name)) {
            final int match = matchParameterTypes(method2.getParameterTypes(), arguments);
            if (match != NO_MATCH) {
                if (match > currentMatch) {
                    method = method2;
                    currentMatch = match;
                    ambiguous = false;
                } else if (match == currentMatch) {
                    ambiguous = true;
                }
            }
        }
    }
    if (ambiguous) {
        throw new JXPathException(""Ambiguous method call: "" + name);
    }
    return method;
}","Method","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupMethod(Class,String,Object[]).targetClass","Parameter_1","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.lookupMethod(Class,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupMethod(Class,String,Object[]).name","Parameter_2","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.lookupMethod(Class,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.lookupMethod(Class,String,Object[]).parameters","Parameter_3","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.lookupMethod(Class,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.matchParameterTypes(Class[],Object[])","Method","* Return a match code of objects to types.
     * @param types Class[] of expected types
     * @param parameters Object[] to attempt to match
     * @return int code","private static int matchParameterTypes(final Class[] types, final Object[] parameters) {
    int pi = 0;
    if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) {
        pi++;
    }
    final int length = parameters == null ? 0 : parameters.length;
    if (types.length != length + pi) {
        return NO_MATCH;
    }
    int totalMatch = EXACT_MATCH;
    for (int i = 0; i < length; i++) {
        final int match = matchType(types[i + pi], parameters[i]);
        if (match == NO_MATCH) {
            return NO_MATCH;
        }
        if (match < totalMatch) {
            totalMatch = match;
        }
    }
    return totalMatch;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.matchParameterTypes(Class[],Object[]).types","Parameter_1","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.matchParameterTypes(Class[],Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.matchParameterTypes(Class[],Object[]).parameters","Parameter_2","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.matchParameterTypes(Class[],Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.matchType(Class,Object)","Method","* Return a match code between an object and type.
     * @param expected class to test
     * @param object object to test
     * @return int code","private static int matchType(final Class expected, final Object object) {
    if (object == null) {
        return APPROXIMATE_MATCH;
    }
    final Class actual = object.getClass();
    if (expected.equals(actual)) {
        return EXACT_MATCH;
    }
    if (expected.isAssignableFrom(actual)) {
        return EXACT_MATCH;
    }
    if (TypeUtils.canConvert(object, expected)) {
        return APPROXIMATE_MATCH;
    }
    return NO_MATCH;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.matchType(Class,Object).expected","Parameter_1","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.matchType(Class,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.MethodLookupUtils.matchType(Class,Object).object","Parameter_2","Belong to org.apache.commons.jxpath.util.MethodLookupUtils.matchType(Class,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils","Class","* Utility class.
 * @since JXPath 1.3","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.util.KeyManagerUtils.getExtendedKeyManager(KeyManager)","Method","* Gets an ExtendedKeyManager from the specified KeyManager.
     * @param keyManager to adapt, if necessary
     * @return {@code keyManager} if it implements ExtendedKeyManager
     *         or a basic single-result ExtendedKeyManager that delegates to
     *         {@code keyManager}.","public static ExtendedKeyManager getExtendedKeyManager(final KeyManager keyManager) {
    return keyManager instanceof ExtendedKeyManager ? (ExtendedKeyManager) keyManager : new SingleNodeExtendedKeyManager(keyManager);
}","ExtendedKeyManager","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.getExtendedKeyManager(KeyManager).keyManager","Parameter_1","Belong to org.apache.commons.jxpath.util.KeyManagerUtils.getExtendedKeyManager(KeyManager)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager","Class","* Adapt KeyManager to implement ExtendedKeyManager.","Class do not obtain Source Code","No return type","private , static , final ","","org.apache.commons.jxpath.ExtendedKeyManager"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.delegate","Field","No Comment","private final KeyManager delegate;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Method","No Comment","@Override
public NodeSet getNodeSetByKey(final JXPathContext context, final String key, final Object value) {
    final Pointer pointer = delegate.getPointerByKey(context, key, InfoSetUtil.stringValue(value));
    final BasicNodeSet result = new BasicNodeSet();
    result.add(pointer);
    return result;
}","NodeSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object).key","Parameter_2","Belong to org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String)","Method","No Comment","@Override
public Pointer getPointerByKey(final JXPathContext context, final String keyName, final String keyValue) {
    return delegate.getPointerByKey(context, keyName, keyValue);
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String).context","Parameter_1","Belong to org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String).keyName","Parameter_2","Belong to org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String).keyValue","Parameter_3","Belong to org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.<init>(KeyManager)","Constructor","* Create a new SingleNodeExtendedKeyManager.
         * @param delegate KeyManager to wrap","public SingleNodeExtendedKeyManager(final KeyManager delegate) {
    this.delegate = delegate;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.<init>(KeyManager).delegate","Parameter_1","Belong to org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager.<init>(KeyManager)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager","Class","* Adapt KeyManager to implement ExtendedKeyManager.","Class do not obtain Source Code","No return type","private , static , final ","","org.apache.commons.jxpath.ExtendedKeyManager"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.delegate","Field","No Comment","private final KeyManager delegate;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Method","No Comment","@Override
public NodeSet getNodeSetByKey(final JXPathContext context, final String key, final Object value) {
    final Pointer pointer = delegate.getPointerByKey(context, key, InfoSetUtil.stringValue(value));
    final BasicNodeSet result = new BasicNodeSet();
    result.add(pointer);
    return result;
}","NodeSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object).key","Parameter_2","Belong to org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String)","Method","No Comment","@Override
public Pointer getPointerByKey(final JXPathContext context, final String keyName, final String keyValue) {
    return delegate.getPointerByKey(context, keyName, keyValue);
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String).context","Parameter_1","Belong to org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String).keyName","Parameter_2","Belong to org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String).keyValue","Parameter_3","Belong to org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.<init>(KeyManager)","Constructor","* Create a new SingleNodeExtendedKeyManager.
         * @param delegate KeyManager to wrap","public SingleNodeExtendedKeyManager(final KeyManager delegate) {
    this.delegate = delegate;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.<init>(KeyManager).delegate","Parameter_1","Belong to org.apache.commons.jxpath.util.KeyManagerUtils.SingleNodeExtendedKeyManager.<init>(KeyManager)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathInvalidSyntaxException","Class","No Comment","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.JXPathException",""
"org.apache.commons.jxpath.JXPathInvalidSyntaxException.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 504555366032561816L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathInvalidSyntaxException.<init>(String)","Constructor","* Create a new JXPathInvalidSyntaxException.
     * @param message relevant message","public JXPathInvalidSyntaxException(final String message) {
    super(message);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathInvalidSyntaxException.<init>(String).message","Parameter_1","Belong to org.apache.commons.jxpath.JXPathInvalidSyntaxException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.AbstractFactory","Abstract Class","* The  {@link JXPathContext#createPath JXPathContext.createPath()} method of
 * JXPathContext can create missing objects as it traverses an XPath; it
 * utilizes an AbstractFactory for that purpose. Install a factory on
 * JXPathContext by calling {@link JXPathContext#setFactory JXPathContext.
 * setFactory()}.
 * <p>
 * All  methods of this class return false.  Override any of them to return true
 * to indicate that the factory has successfully created the described object.","Abstract Class do not obtain Source Code","No return type","public , abstract ","",""
"org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int)","Method","* The  parameters may describe a collection element or an individual
     * object. It is up to the factory to infer which one it is. If it is a
     * collection, the factory should check if the collection exists.  If not,
     * it should create the collection. Then it should create the index'th
     * element of the collection and return true.
     * <p>
     *
     * @param context can be used to evaluate other XPaths, get to variables
     * etc.
     * @param pointer describes the location of the node to be created
     * @param parent is the object that will serve as a parent of the new
     * object
     * @param name is the name of the child of the parent that needs to be
     * created. In the case of DOM may be qualified.
     * @param index is used if the pointer represents a collection element. You
     * may need to expand or even create the collection to accommodate the new
     * element.
     *
     * @return true if the object was successfully created","public boolean createObject(final JXPathContext context, final Pointer pointer, final Object parent, final String name, final int index) {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int).context","Parameter_1","Belong to org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int).pointer","Parameter_2","Belong to org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int).parent","Parameter_3","Belong to org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int).name","Parameter_4","Belong to org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int).index","Parameter_5","Belong to org.apache.commons.jxpath.AbstractFactory.createObject(JXPathContext,Pointer,Object,String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.AbstractFactory.declareVariable(JXPathContext,String)","Method","* Declare the specified variable
     *
     * @param context hosts variable pools. See
     * {@link JXPathContext#getVariables() JXPathContext.getVariables()}
     * @param name is the name of the variable without the ""$"" sign
     * @return true if the variable was successfully defined","public boolean declareVariable(final JXPathContext context, final String name) {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.AbstractFactory.declareVariable(JXPathContext,String).context","Parameter_1","Belong to org.apache.commons.jxpath.AbstractFactory.declareVariable(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.AbstractFactory.declareVariable(JXPathContext,String).name","Parameter_2","Belong to org.apache.commons.jxpath.AbstractFactory.declareVariable(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathInvalidAccessException","Class","* Similary to {@link java.lang.reflect.InvocationTargetException} in that
 * it is thrown when JXPath cannot access properties, collection etc on the
 * target object model.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.JXPathException",""
"org.apache.commons.jxpath.JXPathInvalidAccessException.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -8875537628056117241L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathInvalidAccessException.<init>(String)","Constructor","* Create a new JXPathInvalidAccessException.
     * @param message exception message","public JXPathInvalidAccessException(final String message) {
    super(message);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathInvalidAccessException.<init>(String).message","Parameter_1","Belong to org.apache.commons.jxpath.JXPathInvalidAccessException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathInvalidAccessException.<init>(String,Throwable)","Constructor","* Create a new JXPathInvalidAccessException.
     * @param message exception message
     * @param ex precipitating exception","public JXPathInvalidAccessException(final String message, final Throwable ex) {
    super(message, ex);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathInvalidAccessException.<init>(String,Throwable).message","Parameter_1","Belong to org.apache.commons.jxpath.JXPathInvalidAccessException.<init>(String,Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathInvalidAccessException.<init>(String,Throwable).ex","Parameter_2","Belong to org.apache.commons.jxpath.JXPathInvalidAccessException.<init>(String,Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions","Class","* Extension functions provided by a Java class.
 *
 * Let's say we declared a ClassFunction like this:
 * <blockquote><pre>
 *     new ClassFunctions(Integer.class, ""int"")
 * </pre></blockquote>
 *
 * We can now use XPaths like:
 * <dl>
 *  <dt>{@code ""int:new(3)""}</dt>
 *  <dd>Equivalent to {@code Integer.valueOf(3)}</dd>
 *  <dt>{@code ""int:getInteger('foo')""}</dt>
 *  <dd>Equivalent to {@code Integer.getInteger(""foo"")}</dd>
 *  <dt>{@code ""int:floatValue(int:new(4))""}</dt>
 *  <dd>Equivalent to {@code Integer.valueOf(4).floatValue()}</dd>
 * </dl>
 *
 * <p>
 * If the first argument of a method is {@link ExpressionContext}, the
 * expression context in which the function is evaluated is passed to
 * the method.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.Functions"
"org.apache.commons.jxpath.ClassFunctions.EMPTY_ARRAY","Field","No Comment","private static final Object[] EMPTY_ARRAY = {};","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.functionClass","Field","No Comment","private final Class functionClass;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.namespace","Field","No Comment","private final String namespace;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.getUsedNamespaces()","Method","* Returns a set of one namespace - the one specified in the constructor.
     *
     * @return a singleton","@Override
public Set getUsedNamespaces() {
    return Collections.singleton(namespace);
}","Set","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.getFunction(String,String,Object[])","Method","* Returns a {@link Function}, if any, for the specified namespace,
     * name and parameter types.
     *
     * @param namespace if it is not the namespace specified in the constructor,
     *     the method returns null
     * @param name is a function name or ""new"" for a constructor.
     * @param parameters Object[] of parameters
     * @return a MethodFunction, a ConstructorFunction or null if there is no
     *      such function.","@Override
public Function getFunction(final String namespace, final String name, Object[] parameters) {
    if (namespace == null) {
        if (this.namespace != null) {
            return null;
        }
    } else if (!namespace.equals(this.namespace)) {
        return null;
    }
    if (parameters == null) {
        parameters = EMPTY_ARRAY;
    }
    if (name.equals(""new"")) {
        final Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters);
        if (constructor != null) {
            return new ConstructorFunction(constructor);
        }
    } else {
        Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters);
        if (method != null) {
            return new MethodFunction(method);
        }
        method = MethodLookupUtils.lookupMethod(functionClass, name, parameters);
        if (method != null) {
            return new MethodFunction(method);
        }
    }
    return null;
}","Function","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.getFunction(String,String,Object[]).namespace","Parameter_1","Belong to org.apache.commons.jxpath.ClassFunctions.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.getFunction(String,String,Object[]).name","Parameter_2","Belong to org.apache.commons.jxpath.ClassFunctions.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.getFunction(String,String,Object[]).parameters","Parameter_3","Belong to org.apache.commons.jxpath.ClassFunctions.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.<init>(Class,String)","Constructor","* Create a new ClassFunctions.
     * @param functionClass Class providing the functions
     * @param namespace assigned ns","public ClassFunctions(final Class functionClass, final String namespace) {
    this.functionClass = functionClass;
    this.namespace = namespace;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.<init>(Class,String).functionClass","Parameter_1","Belong to org.apache.commons.jxpath.ClassFunctions.<init>(Class,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ClassFunctions.<init>(Class,String).namespace","Parameter_2","Belong to org.apache.commons.jxpath.ClassFunctions.<init>(Class,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer","Class","* An XML document container reads and parses XML only when it is
 * accessed.  JXPath traverses Containers transparently -
 * you use the same paths to access objects in containers as you
 * do to access those objects directly.  You can create
 * XMLDocumentContainers for various XML documents that may or
 * may not be accessed by XPaths.  If they are, they will be automatically
 * read, parsed and traversed. If they are not - they won't be
 * read at all.
 *
 * @deprecated 1.1 Please use {@link DocumentContainer}","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.Container"
"org.apache.commons.jxpath.XMLDocumentContainer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.delegate","Field","No Comment","private DocumentContainer delegate;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.document","Field","No Comment","private Object document;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.xmlURL","Field","No Comment","private URL xmlURL;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.source","Field","No Comment","private Source source;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.getValue()","Method","* Reads XML, caches it internally and returns the Document.
     * @return Object value","@Override
public Object getValue() {
    if (document == null) {
        try {
            if (source != null) {
                final DOMResult result = new DOMResult();
                final Transformer trans = TransformerFactory.newInstance().newTransformer();
                trans.transform(source, result);
                document = result.getNode();
            } else {
                document = delegate.getValue();
            }
        } catch (final Exception ex) {
            throw new JXPathException(""Cannot read XML from: "" + (xmlURL != null ? xmlURL.toString() : source != null ? source.getSystemId() : ""<<undefined source>>""), ex);
        }
    }
    return document;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.setValue(Object)","Method","* Throws an UnsupportedOperationException
     * @param value to set","@Override
public void setValue(final Object value) {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.XMLDocumentContainer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.<init>(URL)","Constructor","* Create a new XMLDocumentContainer.
     * @param xmlURL a URL for an XML file. Use getClass().getResource(resourceName)
     *               to load XML from a resource file.","public XMLDocumentContainer(final URL xmlURL) {
    this.xmlURL = xmlURL;
    delegate = new DocumentContainer(xmlURL);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.<init>(URL).xmlURL","Parameter_1","Belong to org.apache.commons.jxpath.XMLDocumentContainer.<init>(URL)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.<init>(Source)","Constructor","* Create a new XMLDocumentContainer.
     * @param source XML source","public XMLDocumentContainer(final Source source) {
    this.source = Objects.requireNonNull(source);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.XMLDocumentContainer.<init>(Source).source","Parameter_1","Belong to org.apache.commons.jxpath.XMLDocumentContainer.<init>(Source)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.DynamicPropertyHandler","Interface","* A generic mechanism for accessing collections of name/value pairs.
 * Examples of such collections are HashMap, Properties,
 * ServletContext.  In order to add support for a new such collection
 * type to JXPath, perform the following two steps:
 * <ol>
 * <li>Build an implementation of the DynamicPropertyHandler interface
 * for the desired collection type.</li>
 * <li>Invoke the static method {@link JXPathIntrospector#registerDynamicClass
 * JXPathIntrospector.registerDynamicClass(class, handlerClass)}</li>
 * </ol>
 * JXPath allows access to dynamic properties using these three formats:
 * <ul>
 * <li>{@code ""myMap/myKey""}</li>
 * <li>{@code ""myMap[@name = 'myKey']""}</li>
 * <li>{@code ""myMap[name(.) = 'myKey']""}</li>
 * </ul>","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.DynamicPropertyHandler.getPropertyNames(Object)","Abstract Method","* Returns a list of dynamic property names for the supplied object.
     * @param object to inspect
     * @return String[]","String[] getPropertyNames(Object object);","String[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.DynamicPropertyHandler.getPropertyNames(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.DynamicPropertyHandler.getPropertyNames(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.DynamicPropertyHandler.getProperty(Object,String)","Abstract Method","* Returns the value of the specified dynamic property.
     * @param object to search
     * @param propertyName to retrieve
     * @return Object","Object getProperty(Object object, String propertyName);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.DynamicPropertyHandler.getProperty(Object,String).object","Parameter_1","Belong to org.apache.commons.jxpath.DynamicPropertyHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.DynamicPropertyHandler.getProperty(Object,String).propertyName","Parameter_2","Belong to org.apache.commons.jxpath.DynamicPropertyHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.DynamicPropertyHandler.setProperty(Object,String,Object)","Abstract Method","* Modifies the value of the specified dynamic property.
     * @param object to modify
     * @param propertyName to modify
     * @param value to set","void setProperty(Object object, String propertyName, Object value);","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.DynamicPropertyHandler.setProperty(Object,String,Object).object","Parameter_1","Belong to org.apache.commons.jxpath.DynamicPropertyHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.DynamicPropertyHandler.setProperty(Object,String,Object).propertyName","Parameter_2","Belong to org.apache.commons.jxpath.DynamicPropertyHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.DynamicPropertyHandler.setProperty(Object,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.DynamicPropertyHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Parser","Class","* XPath parser","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.Parser.PARSER","Field","No Comment","private static final XPathParser PARSER = new XPathParser(new StringReader(""""));","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Parser.parseExpression(String,Compiler)","Method","* Parses the XPath expression. Throws a JXPathException in case
     * of a syntax error.
     * @param expression to parse
     * @param compiler the compiler
     * @return parsed Object","public static Object parseExpression(final String expression, final Compiler compiler) {
    synchronized (PARSER) {
        PARSER.setCompiler(compiler);
        Object expr;
        try {
            PARSER.ReInit(new StringReader(expression));
            expr = PARSER.parseExpression();
        } catch (final TokenMgrError e) {
            throw new JXPathInvalidSyntaxException(""Invalid XPath: '"" + addEscapes(expression) + ""'. Invalid symbol '"" + addEscapes(String.valueOf(e.getCharacter())) + ""' "" + describePosition(expression, e.getPosition()));
        } catch (final ParseException e) {
            throw new JXPathInvalidSyntaxException(""Invalid XPath: '"" + addEscapes(expression) + ""'. Syntax error "" + describePosition(expression, e.currentToken.beginColumn));
        }
        return expr;
    }
}","Object","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Parser.parseExpression(String,Compiler).expression","Parameter_1","Belong to org.apache.commons.jxpath.ri.Parser.parseExpression(String,Compiler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Parser.parseExpression(String,Compiler).compiler","Parameter_2","Belong to org.apache.commons.jxpath.ri.Parser.parseExpression(String,Compiler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Parser.describePosition(String,int)","Method","* Describe a parse position.
     * @param expression to parse
     * @param position parse position
     * @return String","private static String describePosition(final String expression, final int position) {
    if (position <= 0) {
        return ""at the beginning of the expression"";
    }
    if (position >= expression.length()) {
        return ""- expression incomplete"";
    }
    return ""after: '"" + addEscapes(expression.substring(0, position)) + ""'"";
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Parser.describePosition(String,int).expression","Parameter_1","Belong to org.apache.commons.jxpath.ri.Parser.describePosition(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Parser.describePosition(String,int).position","Parameter_2","Belong to org.apache.commons.jxpath.ri.Parser.describePosition(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Parser.addEscapes(String)","Method","* Add escapes to the specified String.
     * @param string incoming String
     * @return String","private static String addEscapes(final String string) {
    // Piggy-back on the code generated by JavaCC
    return TokenMgrError.addEscapes(string);
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Parser.addEscapes(String).string","Parameter_1","Belong to org.apache.commons.jxpath.ri.Parser.addEscapes(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext","Class","* EvalContext that walks the ""ancestor::"" and ""ancestor-or-self::"" axes.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.AncestorContext.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.setStarted","Field","No Comment","private boolean setStarted = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.currentNodePointer","Field","No Comment","private NodePointer currentNodePointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.includeSelf","Field","No Comment","private final boolean includeSelf;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    return currentNodePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.getDocumentOrder()","Method","No Comment","@Override
public int getDocumentOrder() {
    return -1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.reset()","Method","No Comment","@Override
public void reset() {
    super.reset();
    setStarted = false;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (position < getCurrentPosition()) {
        reset();
    }
    while (getCurrentPosition() < position) {
        if (!nextNode()) {
            return false;
        }
    }
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.AncestorContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    if (!setStarted) {
        setStarted = true;
        currentNodePointer = parentContext.getCurrentNodePointer();
        if (includeSelf && currentNodePointer.testNode(nodeTest)) {
            position++;
            return true;
        }
    }
    while (true) {
        currentNodePointer = currentNodePointer.getImmediateParentPointer();
        if (currentNodePointer == null) {
            return false;
        }
        if (currentNodePointer.testNode(nodeTest)) {
            position++;
            return true;
        }
    }
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.<init>(EvalContext,boolean,NodeTest)","Constructor","* Create a new AncestorContext.
     * @param parentContext represents the previous step on the path
     * @param  includeSelf differentiates between ""ancestor::"" and
     *                     ""ancestor-or-self::"" axes
     * @param nodeTest is the name of the element(s) we are looking for","public AncestorContext(final EvalContext parentContext, final boolean includeSelf, final NodeTest nodeTest) {
    super(parentContext);
    this.includeSelf = includeSelf;
    this.nodeTest = nodeTest;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.<init>(EvalContext,boolean,NodeTest).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.AncestorContext.<init>(EvalContext,boolean,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.<init>(EvalContext,boolean,NodeTest).includeSelf","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.AncestorContext.<init>(EvalContext,boolean,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AncestorContext.<init>(EvalContext,boolean,NodeTest).nodeTest","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.AncestorContext.<init>(EvalContext,boolean,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext","Class","* EvalContext that walks the ""parent::"" axis.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.ParentContext.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.setStarted","Field","No Comment","private boolean setStarted = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.currentNodePointer","Field","No Comment","private NodePointer currentNodePointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    return currentNodePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.getCurrentPosition()","Method","No Comment","@Override
public int getCurrentPosition() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.getDocumentOrder()","Method","No Comment","@Override
public int getDocumentOrder() {
    return -1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.reset()","Method","No Comment","@Override
public void reset() {
    super.reset();
    setStarted = false;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    super.setPosition(position);
    return position == 1;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.ParentContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    // Each set contains exactly one node: the parent
    if (setStarted) {
        return false;
    }
    setStarted = true;
    final NodePointer thisLocation = parentContext.getCurrentNodePointer();
    currentNodePointer = thisLocation.getImmediateParentPointer();
    while (currentNodePointer != null && currentNodePointer.isContainer()) {
        currentNodePointer = currentNodePointer.getImmediateParentPointer();
    }
    if (currentNodePointer != null && currentNodePointer.testNode(nodeTest)) {
        position++;
        return true;
    }
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.<init>(EvalContext,NodeTest)","Constructor","* Create a new ParentContext.
     * @param parentContext parent context
     * @param nodeTest test","public ParentContext(final EvalContext parentContext, final NodeTest nodeTest) {
    super(parentContext);
    this.nodeTest = nodeTest;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.<init>(EvalContext,NodeTest).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.ParentContext.<init>(EvalContext,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ParentContext.<init>(EvalContext,NodeTest).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.ParentContext.<init>(EvalContext,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext","Class","* EvalContext that walks the ""preceding::"" and ""following::"" axes.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.setStarted","Field","No Comment","private boolean setStarted = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.stack","Field","No Comment","private Stack stack = null;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.currentNodePointer","Field","No Comment","private NodePointer currentNodePointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.currentRootLocation","Field","No Comment","private NodePointer currentRootLocation;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.reverse","Field","No Comment","private final boolean reverse;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    return currentNodePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.getDocumentOrder()","Method","No Comment","@Override
public int getDocumentOrder() {
    return reverse ? -1 : 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.reset()","Method","No Comment","@Override
public void reset() {
    super.reset();
    setStarted = false;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (position < this.position) {
        reset();
    }
    while (this.position < position) {
        if (!nextNode()) {
            return false;
        }
    }
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    if (!setStarted) {
        setStarted = true;
        if (stack == null) {
            stack = new Stack();
        } else {
            stack.clear();
        }
        currentRootLocation = parentContext.getCurrentNodePointer();
        final NodePointer parent = currentRootLocation.getParent();
        if (parent != null) {
            // TBD: check type
            stack.push(parent.childIterator(null, reverse, currentRootLocation));
        }
    }
    while (true) {
        if (stack.isEmpty()) {
            currentRootLocation = currentRootLocation.getParent();
            if (currentRootLocation == null || currentRootLocation.isRoot()) {
                break;
            }
            final NodePointer parent = currentRootLocation.getParent();
            if (parent != null) {
                stack.push(parent.childIterator(null, reverse, currentRootLocation));
            }
        }
        while (!stack.isEmpty()) {
            if (!reverse) {
                final NodeIterator it = (NodeIterator) stack.peek();
                if (it.setPosition(it.getPosition() + 1)) {
                    currentNodePointer = it.getNodePointer();
                    if (!currentNodePointer.isLeaf()) {
                        stack.push(currentNodePointer.childIterator(null, reverse, null));
                    }
                    if (currentNodePointer.testNode(nodeTest)) {
                        super.setPosition(getCurrentPosition() + 1);
                        return true;
                    }
                } else {
                    // We get here only if the name test failed
                    // and the iterator ended
                    stack.pop();
                }
            } else {
                NodeIterator it = (NodeIterator) stack.peek();
                if (it.setPosition(it.getPosition() + 1)) {
                    currentNodePointer = it.getNodePointer();
                    if (!currentNodePointer.isLeaf()) {
                        stack.push(currentNodePointer.childIterator(null, reverse, null));
                    } else if (currentNodePointer.testNode(nodeTest)) {
                        super.setPosition(getCurrentPosition() + 1);
                        return true;
                    }
                } else {
                    stack.pop();
                    if (!stack.isEmpty()) {
                        it = (NodeIterator) stack.peek();
                        currentNodePointer = it.getNodePointer();
                        if (currentNodePointer.testNode(nodeTest)) {
                            super.setPosition(getCurrentPosition() + 1);
                            return true;
                        }
                    }
                }
            }
        }
    }
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.<init>(EvalContext,NodeTest,boolean)","Constructor","* Create a new PrecedingOrFollowingContext.
     * @param parentContext parent context
     * @param nodeTest test
     * @param reverse whether to iterate in reverse order","public PrecedingOrFollowingContext(final EvalContext parentContext, final NodeTest nodeTest, final boolean reverse) {
    super(parentContext);
    this.nodeTest = nodeTest;
    this.reverse = reverse;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.<init>(EvalContext,NodeTest,boolean).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.<init>(EvalContext,NodeTest,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.<init>(EvalContext,NodeTest,boolean).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.<init>(EvalContext,NodeTest,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.<init>(EvalContext,NodeTest,boolean).reverse","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext.<init>(EvalContext,NodeTest,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext","Class","* EvalContext that walks the ""namespace::"" axis.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.NamespaceContext.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.setStarted","Field","No Comment","private boolean setStarted = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.iterator","Field","No Comment","private NodeIterator iterator;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.currentNodePointer","Field","No Comment","private NodePointer currentNodePointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    return currentNodePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.reset()","Method","No Comment","@Override
public void reset() {
    setStarted = false;
    iterator = null;
    super.reset();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (position < getCurrentPosition()) {
        reset();
    }
    while (getCurrentPosition() < position) {
        if (!nextNode()) {
            return false;
        }
    }
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.NamespaceContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    super.setPosition(getCurrentPosition() + 1);
    if (!setStarted) {
        setStarted = true;
        if (!(nodeTest instanceof NodeNameTest)) {
            return false;
        }
        final NodeNameTest nodeNameTest = (NodeNameTest) nodeTest;
        final QName testName = nodeNameTest.getNodeName();
        if (testName.getPrefix() != null) {
            return false;
        }
        if (nodeNameTest.isWildcard()) {
            iterator = parentContext.getCurrentNodePointer().namespaceIterator();
        } else {
            currentNodePointer = parentContext.getCurrentNodePointer().namespacePointer(testName.getName());
            return currentNodePointer != null;
        }
    }
    if (iterator == null) {
        return false;
    }
    if (!iterator.setPosition(iterator.getPosition() + 1)) {
        return false;
    }
    currentNodePointer = iterator.getNodePointer();
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.<init>(EvalContext,NodeTest)","Constructor","* @param parentContext represents the previous step on the path
     * @param nodeTest is the name of the namespace we are looking for","public NamespaceContext(final EvalContext parentContext, final NodeTest nodeTest) {
    super(parentContext);
    this.nodeTest = nodeTest;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.<init>(EvalContext,NodeTest).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.NamespaceContext.<init>(EvalContext,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NamespaceContext.<init>(EvalContext,NodeTest).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.NamespaceContext.<init>(EvalContext,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext","Class","* EvalContext that checks predicates.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.PredicateContext.expression","Field","No Comment","private final Expression expression;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.done","Field","No Comment","private boolean done = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.nameTestExpression","Field","No Comment","private Expression nameTestExpression;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.dynamicPropertyPointer","Field","No Comment","private PropertyPointer dynamicPropertyPointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    if (done) {
        return false;
    }
    while (parentContext.nextNode()) {
        if (setupDynamicPropertyPointer()) {
            final Object pred = nameTestExpression.computeValue(parentContext);
            final String propertyName = InfoSetUtil.stringValue(pred);
            // At this point it would be nice to say:
            // dynamicPropertyPointer.setPropertyName(propertyName)
            // and then: dynamicPropertyPointer.isActual().
            // However some PropertyPointers, e.g. DynamicPropertyPointer
            // will declare that any property you ask for is actual.
            // That's not acceptable for us: we really need to know
            // if the property is currently declared. Thus,
            // we'll need to perform a search.
            boolean ok = false;
            final String[] names = dynamicPropertyPointer.getPropertyNames();
            for (final String name : names) {
                if (name.equals(propertyName)) {
                    ok = true;
                    break;
                }
            }
            if (ok) {
                dynamicPropertyPointer.setPropertyName(propertyName);
                position++;
                return true;
            }
        } else {
            Object pred = expression.computeValue(parentContext);
            if (pred instanceof Iterator) {
                if (!((Iterator) pred).hasNext()) {
                    return false;
                }
                pred = ((Iterator) pred).next();
            }
            if (pred instanceof NodePointer) {
                pred = ((NodePointer) pred).getNode();
            }
            if (pred instanceof Number) {
                final int pos = (int) InfoSetUtil.doubleValue(pred);
                position++;
                done = true;
                return parentContext.setPosition(pos);
            }
            if (InfoSetUtil.booleanValue(pred)) {
                position++;
                return true;
            }
        }
    }
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.setupDynamicPropertyPointer()","Method","* Used for an optimized access to dynamic properties using the
     * ""map[@name = 'name']"" syntax
     * @return whether valid","private boolean setupDynamicPropertyPointer() {
    if (nameTestExpression == null) {
        return false;
    }
    NodePointer parent = parentContext.getCurrentNodePointer();
    if (parent == null) {
        return false;
    }
    parent = parent.getValuePointer();
    if (!(parent instanceof PropertyOwnerPointer)) {
        return false;
    }
    dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone();
    return true;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (nameTestExpression == null) {
        return setPositionStandard(position);
    }
    if (dynamicPropertyPointer == null && !setupDynamicPropertyPointer()) {
        return setPositionStandard(position);
    }
    if (position < 1 || position > dynamicPropertyPointer.getLength()) {
        return false;
    }
    dynamicPropertyPointer.setIndex(position - 1);
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.PredicateContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    if (position == 0 && !setPosition(1)) {
        return null;
    }
    if (dynamicPropertyPointer != null) {
        return dynamicPropertyPointer.getValuePointer();
    }
    return parentContext.getCurrentNodePointer();
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.reset()","Method","No Comment","@Override
public void reset() {
    super.reset();
    parentContext.reset();
    done = false;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.nextSet()","Method","No Comment","@Override
public boolean nextSet() {
    reset();
    return parentContext.nextSet();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.setPositionStandard(int)","Method","* Basic setPosition
     * @param position to set
     * @return whether valid","private boolean setPositionStandard(final int position) {
    if (this.position > position) {
        reset();
    }
    while (this.position < position) {
        if (!nextNode()) {
            return false;
        }
    }
    return true;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.setPositionStandard(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.PredicateContext.setPositionStandard(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.<init>(EvalContext,Expression)","Constructor","* Create a new PredicateContext.
     * @param parentContext parent context
     * @param expression compiled Expression","public PredicateContext(final EvalContext parentContext, final Expression expression) {
    super(parentContext);
    this.expression = expression;
    if (expression instanceof NameAttributeTest) {
        nameTestExpression = ((NameAttributeTest) expression).getNameTestExpression();
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.<init>(EvalContext,Expression).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.PredicateContext.<init>(EvalContext,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.PredicateContext.<init>(EvalContext,Expression).expression","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.PredicateContext.<init>(EvalContext,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext","Class","* A simple context that is based on a {@link NodeSet}.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.NodeSetContext.startedSet","Field","No Comment","private boolean startedSet = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.nodeSet","Field","No Comment","private final NodeSet nodeSet;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.getNodeSet()","Method","No Comment","@Override
public NodeSet getNodeSet() {
    return nodeSet;
}","NodeSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    if (position == 0 && !setPosition(1)) {
        return null;
    }
    return (NodePointer) nodeSet.getPointers().get(position - 1);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    super.setPosition(position);
    return position >= 1 && position <= nodeSet.getPointers().size();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.NodeSetContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.nextSet()","Method","No Comment","@Override
public boolean nextSet() {
    if (startedSet) {
        return false;
    }
    startedSet = true;
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    return setPosition(position + 1);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.<init>(EvalContext,NodeSet)","Constructor","* Create a new NodeSetContext.
     * @param parentContext parent context
     * @param nodeSet associated NodeSet","public NodeSetContext(final EvalContext parentContext, final NodeSet nodeSet) {
    super(parentContext);
    this.nodeSet = nodeSet;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.<init>(EvalContext,NodeSet).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.NodeSetContext.<init>(EvalContext,NodeSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.NodeSetContext.<init>(EvalContext,NodeSet).nodeSet","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.NodeSetContext.<init>(EvalContext,NodeSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter","Class","* An evaluation mechanism for simple XPaths, which
 * is much faster than the usual process. It is only used for
 * xpaths which have no context-dependent parts, consist entirely of
 * {@code child::name} and {@code self::node()} steps with
 * predicates that either integer or have the form {@code [@name = ...]}.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.QNAME_NAME","Field","No Comment","private static final QName QNAME_NAME = new QName(null, ""name"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.PERFECT_MATCH","Field","No Comment","private static final int PERFECT_MATCH = 1000;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleLocationPath(EvalContext,NodePointer,Step[])","Method","* Interpret a simple path that starts with the given root and
     * follows the given steps. All steps must have the axis ""child::""
     * and a name test.  They can also optionally have predicates
     * of type [@name=expression] or simply [expression] interpreted
     * as an index.
     * @param context evaluation context
     * @param root root pointer
     * @param steps path steps
     * @return NodePointer","public static NodePointer interpretSimpleLocationPath(final EvalContext context, final NodePointer root, final Step[] steps) {
    //        PATH = createNullPointer(context, root, steps, 0).toString();  // Dbg
    final NodePointer pointer = doStep(context, root, steps, 0);
    //        return valuePointer(pointer);
    return pointer;
}","NodePointer","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleLocationPath(EvalContext,NodePointer,Step[]).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleLocationPath(EvalContext,NodePointer,Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleLocationPath(EvalContext,NodePointer,Step[]).root","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleLocationPath(EvalContext,NodePointer,Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleLocationPath(EvalContext,NodePointer,Step[]).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleLocationPath(EvalContext,NodePointer,Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleExpressionPath(EvalContext,NodePointer,Expression[],Step[])","Method","* Interpret the steps of a simple expression path that
     * starts with the given root, which is the result of evaluation
     * of the root expression of the expression path, applies the
     * given predicates to it and then follows the given steps.
     * All steps must have the axis ""child::"" or ""attribute::""
     * and a name test.  They can also optionally have predicates
     * of type [@name=...] or simply [...] interpreted as an index.
     * @param context evaluation context
     * @param root root pointer
     * @param predicates predicates corresponding to {@code steps}
     * @param steps path steps
     * @return NodePointer","public static NodePointer interpretSimpleExpressionPath(final EvalContext context, final NodePointer root, final Expression[] predicates, final Step[] steps) {
    //        PATH = createNullPointerForPredicates(context, root,
    //                    steps, -1, predicates, 0).toString();  // Debugging
    final NodePointer pointer = doPredicate(context, root, steps, -1, predicates, 0);
    //        return valuePointer(pointer);
    return pointer;
}","NodePointer","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleExpressionPath(EvalContext,NodePointer,Expression[],Step[]).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleExpressionPath(EvalContext,NodePointer,Expression[],Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleExpressionPath(EvalContext,NodePointer,Expression[],Step[]).root","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleExpressionPath(EvalContext,NodePointer,Expression[],Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleExpressionPath(EvalContext,NodePointer,Expression[],Step[]).predicates","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleExpressionPath(EvalContext,NodePointer,Expression[],Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleExpressionPath(EvalContext,NodePointer,Expression[],Step[]).steps","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleExpressionPath(EvalContext,NodePointer,Expression[],Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(EvalContext,NodePointer,Step[],int)","Method","* Recursive evaluation of a path. The general plan is:
     * Look at the current step,
     * find nodes that match it,
     * iterate over those nodes and
     * for each of them call doStep again for subsequent steps.
     * @param context evaluation context
     * @param parent parent pointer
     * @param steps path steps
     * @param currentStep step number
     * @return NodePointer","private static NodePointer doStep(final EvalContext context, NodePointer parent, final Step[] steps, final int currentStep) {
    if (parent == null) {
        return null;
    }
    if (currentStep == steps.length) {
        // We have reached the end of the list of steps
        return parent;
    }
    // Open all containers
    parent = valuePointer(parent);
    final Step step = steps[currentStep];
    final Expression[] predicates = step.getPredicates();
    // Divide and conquer: the process is broken out into
    // four major use cases.
    // 1. Current step has no predicates and
    //    the root is a property owner (e.g. bean or map)
    // 2. Current step has predicates and
    //    the root is a property owner (e.g. bean or map)
    // 3. Current step has no predicates and
    //    the root is an InfoSet standard node (e.g. DOM Node)
    // 4. Current step has predicates and
    //    the root is an InfoSet standard node (e.g. DOM Node)
    if (parent instanceof PropertyOwnerPointer) {
        if (predicates == null || predicates.length == 0) {
            return doStepNoPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep);
        }
        return doStepPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep);
    }
    if (predicates == null || predicates.length == 0) {
        return doStepNoPredicatesStandard(context, parent, steps, currentStep);
    }
    return doStepPredicatesStandard(context, parent, steps, currentStep);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(EvalContext,NodePointer,Step[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(EvalContext,NodePointer,Step[],int).parent","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(EvalContext,NodePointer,Step[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(EvalContext,NodePointer,Step[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Method","* We have a step that starts with a property owner (bean, map, etc) and has
     * no predicates.  The name test of the step may map to a scalar property
     * or to a collection.  If it is a collection, we should apply the tail of
     * the path to each element until we find a match. If we don't find
     * a perfect match, we should return the ""best quality"" pointer, which
     * has the longest chain of steps mapping to existing nodes and the shortes
     * tail of Null* pointers.
     * @param context evaluation context
     * @param parentPointer property owner pointer
     * @param steps path steps
     * @param currentStep step number
     * @return NodePointer","private static NodePointer doStepNoPredicatesPropertyOwner(final EvalContext context, final PropertyOwnerPointer parentPointer, final Step[] steps, final int currentStep) {
    final Step step = steps[currentStep];
    NodePointer childPointer = createChildPointerForStep(parentPointer, step);
    if (childPointer == null) {
        return null;
    }
    if (!childPointer.isActual()) {
        // The property does not exist - create a null pointer.
        return createNullPointer(context, parentPointer, steps, currentStep);
    }
    if (currentStep == steps.length - 1) {
        // If this is the last step - we are done, we found it
        return childPointer;
    }
    if (childPointer.isCollection()) {
        // Iterate over all values and
        // execute remaining steps for each node,
        // looking for the best quality match
        int bestQuality = 0;
        childPointer = (NodePointer) childPointer.clone();
        NodePointer bestMatch = null;
        final int count = childPointer.getLength();
        for (int i = 0; i < count; i++) {
            childPointer.setIndex(i);
            final NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1);
            final int quality = computeQuality(pointer);
            if (quality == PERFECT_MATCH) {
                return pointer;
            } else if (quality > bestQuality) {
                bestQuality = quality;
                bestMatch = (NodePointer) pointer.clone();
            }
        }
        if (bestMatch != null) {
            return bestMatch;
        }
        // This step did not find anything - return a null pointer
        return createNullPointer(context, childPointer, steps, currentStep);
    }
    // Evaluate subsequent steps
    return doStep(context, childPointer, steps, currentStep + 1);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int).parentPointer","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(EvalContext,NodePointer,Step[],int)","Method","* A path that starts with a standard InfoSet node (e.g. DOM Node) and
     * has no predicates.  Get a child iterator and apply the tail of
     * the path to each element until we find a match. If we don't find
     * a perfect match, we should return the ""best quality"" pointer, which
     * has the longest chain of steps mapping to existing nodes and the shortes
     * tail of Null* pointers.
     * @param context evaluation context
     * @param parentPointer parent pointer
     * @param steps path steps
     * @param currentStep step number
     * @return NodePointer","private static NodePointer doStepNoPredicatesStandard(final EvalContext context, final NodePointer parentPointer, final Step[] steps, final int currentStep) {
    final Step step = steps[currentStep];
    if (step.getAxis() == Compiler.AXIS_SELF) {
        return doStep(context, parentPointer, steps, currentStep + 1);
    }
    int bestQuality = 0;
    NodePointer bestMatch = null;
    final NodeIterator it = getNodeIterator(context, parentPointer, step);
    if (it != null) {
        for (int i = 1; it.setPosition(i); i++) {
            final NodePointer childPointer = it.getNodePointer();
            if (steps.length == currentStep + 1) {
                // If this is the last step - we are done, we found it
                return childPointer;
            }
            final NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1);
            final int quality = computeQuality(pointer);
            if (quality == PERFECT_MATCH) {
                return pointer;
            }
            if (quality > bestQuality) {
                bestQuality = quality;
                bestMatch = (NodePointer) pointer.clone();
            }
        }
    }
    return bestMatch != null ? bestMatch : createNullPointer(context, parentPointer, steps, currentStep);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(EvalContext,NodePointer,Step[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(EvalContext,NodePointer,Step[],int).parentPointer","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(EvalContext,NodePointer,Step[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(EvalContext,NodePointer,Step[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Method","* A path that starts with a property owner. The method evaluates
     * the first predicate in a special way and then forwards to
     * a general predicate processing method.
     * @param context evaluation context
     * @param parentPointer parent pointer
     * @param steps path steps
     * @param currentStep step number
     * @return NodePointer","private static NodePointer doStepPredicatesPropertyOwner(final EvalContext context, final PropertyOwnerPointer parentPointer, final Step[] steps, final int currentStep) {
    final Step step = steps[currentStep];
    final Expression[] predicates = step.getPredicates();
    final NodePointer childPointer = createChildPointerForStep(parentPointer, step);
    if (!childPointer.isActual()) {
        // Property does not exist - return a null pointer
        return createNullPointer(context, parentPointer, steps, currentStep);
    }
    // Evaluate predicates
    return doPredicate(context, childPointer, steps, currentStep, predicates, 0);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int).parentPointer","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesPropertyOwner(EvalContext,PropertyOwnerPointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createChildPointerForStep(PropertyOwnerPointer,Step)","Method","* Create the child pointer for a given step.
     * @param parentPointer parent pointer
     * @param step associated step
     * @return NodePointer","private static NodePointer createChildPointerForStep(final PropertyOwnerPointer parentPointer, final Step step) {
    final int axis = step.getAxis();
    if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {
        final QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();
        if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) {
            return new LangAttributePointer(parentPointer);
        }
        if (parentPointer.isValidProperty(name)) {
            final NodePointer childPointer = parentPointer.getPropertyPointer();
            ((PropertyPointer) childPointer).setPropertyName(name.toString());
            childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);
            return childPointer;
        }
        //invalid property gets nothing, not even a NullPointer
        return null;
    }
    return parentPointer;
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createChildPointerForStep(PropertyOwnerPointer,Step).parentPointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createChildPointerForStep(PropertyOwnerPointer,Step)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createChildPointerForStep(PropertyOwnerPointer,Step).step","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createChildPointerForStep(PropertyOwnerPointer,Step)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesStandard(EvalContext,NodePointer,Step[],int)","Method","* A path that starts with a standard InfoSet node, e.g. a DOM Node.
     * The method evaluates the first predicate in a special way and
     * then forwards to a general predicate processing method.
     * @param context evaluation context
     * @param parent parent pointer
     * @param steps path steps
     * @param currentStep step number
     * @return NodePointer","private static NodePointer doStepPredicatesStandard(final EvalContext context, final NodePointer parent, final Step[] steps, final int currentStep) {
    final Step step = steps[currentStep];
    final Expression[] predicates = step.getPredicates();
    final int axis = step.getAxis();
    if (axis == Compiler.AXIS_SELF) {
        return doPredicate(context, parent, steps, currentStep, predicates, 0);
    }
    final Expression predicate = predicates[0];
    // Optimize for a single predicate to avoid building a list
    // and to allow the direct access to the index'th element
    // in the case of a simple subscript predecate
    // It is a very common use case, so it deserves individual
    // attention
    if (predicates.length == 1) {
        final NodeIterator it = getNodeIterator(context, parent, step);
        NodePointer pointer = null;
        if (it != null) {
            if (predicate instanceof NameAttributeTest) {
                // [@name = key]
                final String key = keyFromPredicate(context, predicate);
                for (int i = 1; it.setPosition(i); i++) {
                    final NodePointer ptr = it.getNodePointer();
                    if (isNameAttributeEqual(ptr, key)) {
                        pointer = ptr;
                        break;
                    }
                }
            } else {
                final int index = indexFromPredicate(context, predicate);
                if (it.setPosition(index + 1)) {
                    pointer = it.getNodePointer();
                }
            }
        }
        if (pointer != null) {
            return doStep(context, pointer, steps, currentStep + 1);
        }
    } else {
        final NodeIterator it = getNodeIterator(context, parent, step);
        if (it != null) {
            final List list = new ArrayList();
            for (int i = 1; it.setPosition(i); i++) {
                list.add(it.getNodePointer());
            }
            final NodePointer pointer = doPredicatesStandard(context, list, steps, currentStep, predicates, 0);
            if (pointer != null) {
                return pointer;
            }
        }
    }
    return createNullPointer(context, parent, steps, currentStep);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesStandard(EvalContext,NodePointer,Step[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesStandard(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesStandard(EvalContext,NodePointer,Step[],int).parent","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesStandard(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesStandard(EvalContext,NodePointer,Step[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesStandard(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesStandard(EvalContext,NodePointer,Step[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepPredicatesStandard(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int)","Method","* Evaluates predicates and proceeds with the subsequent steps
     * of the path.
     * @param context evaluation context
     * @param parent parent pointer
     * @param steps path steps
     * @param currentStep step number
     * @param predicates predicate expressions
     * @param currentPredicate int predicate number
     * @return NodePointer","private static NodePointer doPredicate(final EvalContext context, final NodePointer parent, final Step[] steps, final int currentStep, final Expression[] predicates, final int currentPredicate) {
    if (currentPredicate == predicates.length) {
        return doStep(context, parent, steps, currentStep + 1);
    }
    final Expression predicate = predicates[currentPredicate];
    if (predicate instanceof NameAttributeTest) {
        // [@name = key1]
        return doPredicateName(context, parent, steps, currentStep, predicates, currentPredicate);
    }
    // else [index]
    return doPredicateIndex(context, parent, steps, currentStep, predicates, currentPredicate);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int).parent","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int).predicates","Parameter_5","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int).currentPredicate","Parameter_6","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicate(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int)","Method","* Execute a NameAttributeTest predicate
     * @param context evaluation context
     * @param parent parent pointer
     * @param steps path steps
     * @param currentStep int step number
     * @param predicates predicates
     * @param currentPredicate int predicate number
     * @return NodePointer","private static NodePointer doPredicateName(final EvalContext context, final NodePointer parent, final Step[] steps, final int currentStep, final Expression[] predicates, final int currentPredicate) {
    final Expression predicate = predicates[currentPredicate];
    final String key = keyFromPredicate(context, predicate);
    NodePointer child = valuePointer(parent);
    if (child instanceof PropertyOwnerPointer) {
        final PropertyPointer pointer = ((PropertyOwnerPointer) child).getPropertyPointer();
        pointer.setPropertyName(key);
        if (pointer.isActual()) {
            return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1);
        }
    } else if (child.isCollection()) {
        // For each node in the collection, perform the following:
        // if the node is a property owner, apply this predicate to it;
        // if the node is a collection, apply this predicate to each elem.;
        // if the node is not a prop owner or a collection,
        //  see if it has the attribute ""name"" with the right value,
        //  if so - proceed to the next predicate
        NodePointer bestMatch = null;
        int bestQuality = 0;
        child = (NodePointer) child.clone();
        final int count = child.getLength();
        for (int i = 0; i < count; i++) {
            child.setIndex(i);
            final NodePointer valuePointer = valuePointer(child);
            NodePointer pointer;
            if (valuePointer instanceof PropertyOwnerPointer || valuePointer.isCollection()) {
                pointer = doPredicateName(context, valuePointer, steps, currentStep, predicates, currentPredicate);
            } else if (isNameAttributeEqual(valuePointer, key)) {
                pointer = doPredicate(context, valuePointer, steps, currentStep, predicates, currentPredicate + 1);
            } else {
                pointer = null;
            }
            if (pointer != null) {
                final int quality = computeQuality(pointer);
                if (quality == PERFECT_MATCH) {
                    return pointer;
                }
                if (quality > bestQuality) {
                    bestMatch = (NodePointer) pointer.clone();
                    bestQuality = quality;
                }
            }
        }
        if (bestMatch != null) {
            return bestMatch;
        }
    } else {
        // If the node is a standard InfoSet node (e.g. DOM Node),
        // employ doPredicates_standard, which will iterate through
        // the node's children and apply all predicates
        final NodePointer found = doPredicatesStandard(context, Collections.singletonList(child), steps, currentStep, predicates, currentPredicate);
        if (found != null) {
            return found;
        }
    }
    // If nothing worked - return a null pointer
    return createNullPointerForPredicates(context, child, steps, currentStep, predicates, currentPredicate);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int).parent","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int).predicates","Parameter_5","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int).currentPredicate","Parameter_6","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateName(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int)","Method","* Called exclusively for standard InfoSet nodes, e.g. DOM nodes
     * to evaluate predicate sequences like [@name=...][@name=...][index].
     * @param context evaluation context
     * @param parents List of parent pointers
     * @param steps path steps
     * @param currentStep step number
     * @param predicates predicates
     * @param currentPredicate int predicate number
     * @return NodePointer","private static NodePointer doPredicatesStandard(final EvalContext context, final List parents, final Step[] steps, final int currentStep, final Expression[] predicates, final int currentPredicate) {
    if (parents.isEmpty()) {
        return null;
    }
    // If all predicates have been processed, take the first
    // element from the list of results and proceed to the
    // remaining steps with that element.
    if (currentPredicate == predicates.length) {
        final NodePointer pointer = (NodePointer) parents.get(0);
        return doStep(context, pointer, steps, currentStep + 1);
    }
    final Expression predicate = predicates[currentPredicate];
    if (predicate instanceof NameAttributeTest) {
        final String key = keyFromPredicate(context, predicate);
        final List newList = new ArrayList();
        for (int i = 0; i < parents.size(); i++) {
            final NodePointer pointer = (NodePointer) parents.get(i);
            if (isNameAttributeEqual(pointer, key)) {
                newList.add(pointer);
            }
        }
        if (newList.isEmpty()) {
            return null;
        }
        return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1);
    }
    // For a subscript, simply take the corresponding
    // element from the list of results and
    // proceed to the remaining predicates with that element
    final int index = indexFromPredicate(context, predicate);
    if (index < 0 || index >= parents.size()) {
        return null;
    }
    final NodePointer ptr = (NodePointer) parents.get(index);
    return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int).parents","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int).predicates","Parameter_5","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int).currentPredicate","Parameter_6","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicatesStandard(EvalContext,List,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int)","Method","* Evaluate a subscript predicate: see if the node is a collection and
     * if the index is inside the collection.
     * @param context evaluation context
     * @param parent parent pointer
     * @param steps path steps
     * @param currentStep step number
     * @param predicates predicates
     * @param currentPredicate int predicate number
     * @return NodePointer","private static NodePointer doPredicateIndex(final EvalContext context, final NodePointer parent, final Step[] steps, final int currentStep, final Expression[] predicates, final int currentPredicate) {
    final Expression predicate = predicates[currentPredicate];
    final int index = indexFromPredicate(context, predicate);
    NodePointer pointer = parent;
    if (isCollectionElement(pointer, index)) {
        pointer = (NodePointer) pointer.clone();
        pointer.setIndex(index);
        return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1);
    }
    return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, currentPredicate);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int).parent","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int).predicates","Parameter_5","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int).currentPredicate","Parameter_6","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doPredicateIndex(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.indexFromPredicate(EvalContext,Expression)","Method","* Extract an integer from a subscript predicate. The returned index
     * starts with 0, even though the subscript starts with 1.
     * @param context evaluation context
     * @param predicate to evaluate
     * @return calculated index","private static int indexFromPredicate(final EvalContext context, final Expression predicate) {
    Object value = predicate.computeValue(context);
    if (value instanceof EvalContext) {
        value = ((EvalContext) value).getSingleNodePointer();
    }
    if (value instanceof NodePointer) {
        value = ((NodePointer) value).getValue();
    }
    if (value == null) {
        throw new JXPathException(""Predicate value is null: "" + predicate);
    }
    if (value instanceof Number) {
        final double round = 0.5;
        return (int) (InfoSetUtil.doubleValue(value) + round) - 1;
    }
    return InfoSetUtil.booleanValue(value) ? 0 : -1;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.indexFromPredicate(EvalContext,Expression).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.indexFromPredicate(EvalContext,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.indexFromPredicate(EvalContext,Expression).predicate","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.indexFromPredicate(EvalContext,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.keyFromPredicate(EvalContext,Expression)","Method","* Extracts the string value of the expression from a predicate like
     * [@name=expression].
     * @param context evaluation context
     * @param predicate predicate to evaluate
     * @return String key extracted","private static String keyFromPredicate(final EvalContext context, final Expression predicate) {
    final Expression expr = ((NameAttributeTest) predicate).getNameTestExpression();
    return InfoSetUtil.stringValue(expr.computeValue(context));
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.keyFromPredicate(EvalContext,Expression).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.keyFromPredicate(EvalContext,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.keyFromPredicate(EvalContext,Expression).predicate","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.keyFromPredicate(EvalContext,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.computeQuality(NodePointer)","Method","* For a pointer that matches an actual node, returns 0.
     * For a pointer that does not match an actual node, but whose
     * parent pointer does returns -1, etc.
     * @param pointer input pointer
     * @return int match quality code","private static int computeQuality(NodePointer pointer) {
    int quality = PERFECT_MATCH;
    while (pointer != null && !pointer.isActual()) {
        quality--;
        pointer = pointer.getImmediateParentPointer();
    }
    return quality;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.computeQuality(NodePointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.computeQuality(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isNameAttributeEqual(NodePointer,String)","Method","* Returns true if the pointer has an attribute called ""name"" and
     * its value is equal to the supplied string.
     * @param pointer input pointer
     * @param name name to check
     * @return boolean","private static boolean isNameAttributeEqual(final NodePointer pointer, final String name) {
    final NodeIterator it = pointer.attributeIterator(QNAME_NAME);
    return it != null && it.setPosition(1) && name.equals(it.getNodePointer().getValue());
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isNameAttributeEqual(NodePointer,String).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isNameAttributeEqual(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isNameAttributeEqual(NodePointer,String).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isNameAttributeEqual(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isCollectionElement(NodePointer,int)","Method","* Returns true if the pointer is a collection and the index is
     * withing the bounds of the collection.
     * @param pointer input pointer
     * @param index to check
     * @return boolean","private static boolean isCollectionElement(final NodePointer pointer, final int index) {
    return pointer.isActual() && (index == 0 || pointer.isCollection() && index >= 0 && index < pointer.getLength());
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isCollectionElement(NodePointer,int).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isCollectionElement(NodePointer,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isCollectionElement(NodePointer,int).index","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isCollectionElement(NodePointer,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.valuePointer(NodePointer)","Method","* For an intermediate pointer (e.g. PropertyPointer, ContainerPointer)
     * returns a pointer for the contained value.
     * @param pointer input pointer
     * @return NodePointer","private static NodePointer valuePointer(final NodePointer pointer) {
    return pointer == null ? null : pointer.getValuePointer();
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.valuePointer(NodePointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.valuePointer(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointer(EvalContext,NodePointer,Step[],int)","Method","* Creates a ""null pointer"" that
     * a) represents the requested path and
     * b) can be used for creation of missing nodes in the path.
     * @param context evaluation context
     * @param parent parent pointer
     * @param steps path steps
     * @param currentStep step number
     * @return NodePointer","public static NodePointer createNullPointer(final EvalContext context, NodePointer parent, final Step[] steps, final int currentStep) {
    if (currentStep == steps.length) {
        return parent;
    }
    parent = valuePointer(parent);
    final Step step = steps[currentStep];
    final int axis = step.getAxis();
    if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {
        final NullPropertyPointer pointer = new NullPropertyPointer(parent);
        final QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();
        pointer.setPropertyName(name.toString());
        pointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);
        parent = pointer;
    }
    // else { it is self::node() }
    final Expression[] predicates = step.getPredicates();
    return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, 0);
}","NodePointer","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointer(EvalContext,NodePointer,Step[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointer(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointer(EvalContext,NodePointer,Step[],int).parent","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointer(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointer(EvalContext,NodePointer,Step[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointer(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointer(EvalContext,NodePointer,Step[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointer(EvalContext,NodePointer,Step[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int)","Method","* Creates a ""null pointer"" that starts with predicates.
     * @param context evaluation context
     * @param parent parent pointer
     * @param steps path steps
     * @param currentStep step number
     * @param predicates predicates
     * @param currentPredicate int predicate number
     * @return NodePointer","private static NodePointer createNullPointerForPredicates(final EvalContext context, NodePointer parent, final Step[] steps, final int currentStep, final Expression[] predicates, final int currentPredicate) {
    for (int i = currentPredicate; i < predicates.length; i++) {
        final Expression predicate = predicates[i];
        if (predicate instanceof NameAttributeTest) {
            final String key = keyFromPredicate(context, predicate);
            parent = valuePointer(parent);
            final NullPropertyPointer pointer = new NullPropertyPointer(parent);
            pointer.setNameAttributeValue(key);
            parent = pointer;
        } else {
            final int index = indexFromPredicate(context, predicate);
            if (parent instanceof NullPropertyPointer) {
                parent.setIndex(index);
            } else {
                parent = new NullElementPointer(parent, index);
            }
        }
    }
    // Proceed with the remaining steps
    return createNullPointer(context, parent, steps, currentStep + 1);
}","NodePointer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int).parent","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int).currentStep","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int).predicates","Parameter_5","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int).currentPredicate","Parameter_6","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.createNullPointerForPredicates(EvalContext,NodePointer,Step[],int,Expression[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.getNodeIterator(EvalContext,NodePointer,Step)","Method","* Gets a NodeIterator.
     * @param context evaluation context
     * @param pointer owning pointer
     * @param step triggering step
     * @return NodeIterator","private static NodeIterator getNodeIterator(final EvalContext context, final NodePointer pointer, final Step step) {
    if (step.getAxis() == Compiler.AXIS_CHILD) {
        NodeTest nodeTest = step.getNodeTest();
        final QName qname = ((NodeNameTest) nodeTest).getNodeName();
        final String prefix = qname.getPrefix();
        if (prefix != null) {
            final String namespaceURI = context.getJXPathContext().getNamespaceURI(prefix);
            nodeTest = new NodeNameTest(qname, namespaceURI);
        }
        return pointer.childIterator(nodeTest, false, null);
    }
    // else Compiler.AXIS_ATTRIBUTE
    if (!(step.getNodeTest() instanceof NodeNameTest)) {
        throw new UnsupportedOperationException(""Not supported node test for attributes: "" + step.getNodeTest());
    }
    return pointer.attributeIterator(((NodeNameTest) step.getNodeTest()).getNodeName());
}","NodeIterator","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.getNodeIterator(EvalContext,NodePointer,Step).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.getNodeIterator(EvalContext,NodePointer,Step)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.getNodeIterator(EvalContext,NodePointer,Step).pointer","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.getNodeIterator(EvalContext,NodePointer,Step)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.getNodeIterator(EvalContext,NodePointer,Step).step","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.getNodeIterator(EvalContext,NodePointer,Step)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isLangAttribute(QName)","Method","* Learn whether {@code name} is a lang attribute.
     * @param name to compare
     * @return boolean","private static boolean isLangAttribute(final QName name) {
    return name.getPrefix() != null && name.getPrefix().equals(""xml"") && name.getName().equals(""lang"");
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isLangAttribute(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.isLangAttribute(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext","Class","* A single-set EvalContext that provides access to the current node of
 * the parent context and nothing else.  It does not pass the iteration
 * on to the parent context.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.InitialContext.started","Field","No Comment","private boolean started = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.collection","Field","No Comment","private boolean collection;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.nodePointer","Field","No Comment","private final NodePointer nodePointer;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.getSingleNodePointer()","Method","No Comment","@Override
public Pointer getSingleNodePointer() {
    return nodePointer;
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    return nodePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.getValue()","Method","No Comment","@Override
public Object getValue() {
    return nodePointer.getValue();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    return setPosition(position + 1);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    this.position = position;
    if (collection) {
        if (position >= 1 && position <= nodePointer.getLength()) {
            nodePointer.setIndex(position - 1);
            return true;
        }
        return false;
    }
    return position == 1;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.InitialContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.nextSet()","Method","No Comment","@Override
public boolean nextSet() {
    if (started) {
        return false;
    }
    started = true;
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.<init>(EvalContext)","Constructor","* Create a new InitialContext.
     * @param parentContext parent context","public InitialContext(final EvalContext parentContext) {
    super(parentContext);
    nodePointer = (NodePointer) parentContext.getCurrentNodePointer().clone();
    if (nodePointer != null) {
        collection = nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION;
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.InitialContext.<init>(EvalContext).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.InitialContext.<init>(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext","Class","* An EvalContext that walks the ""descendant::"" and ""descendant-or-self::""
 * axes.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.DescendantContext.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.setStarted","Field","No Comment","private boolean setStarted = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.stack","Field","No Comment","private Stack stack = null;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.currentNodePointer","Field","No Comment","private NodePointer currentNodePointer = null;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.includeSelf","Field","No Comment","private final boolean includeSelf;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.ELEMENT_NODE_TEST","Field","No Comment","private static final NodeTest ELEMENT_NODE_TEST = new NodeTypeTest(Compiler.NODE_TYPE_NODE);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.isChildOrderingRequired()","Method","No Comment","@Override
public boolean isChildOrderingRequired() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    if (position == 0 && !setPosition(1)) {
        return null;
    }
    return currentNodePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.reset()","Method","No Comment","@Override
public void reset() {
    super.reset();
    setStarted = false;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (position < this.position) {
        reset();
    }
    while (this.position < position) {
        if (!nextNode()) {
            return false;
        }
    }
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.DescendantContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    if (!setStarted) {
        setStarted = true;
        if (stack == null) {
            stack = new Stack();
        } else {
            stack.clear();
        }
        currentNodePointer = parentContext.getCurrentNodePointer();
        if (currentNodePointer != null) {
            if (!currentNodePointer.isLeaf()) {
                stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null));
            }
            if (includeSelf && currentNodePointer.testNode(nodeTest)) {
                position++;
                return true;
            }
        }
    }
    while (!stack.isEmpty()) {
        final NodeIterator it = (NodeIterator) stack.peek();
        if (it.setPosition(it.getPosition() + 1)) {
            currentNodePointer = it.getNodePointer();
            if (!isRecursive()) {
                if (!currentNodePointer.isLeaf()) {
                    stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null));
                }
                if (currentNodePointer.testNode(nodeTest)) {
                    position++;
                    return true;
                }
            }
        } else {
            // We get here only if the name test failed
            // and the iterator ended
            stack.pop();
        }
    }
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.isRecursive()","Method","* Checks if we are reentering a bean we have already seen and if so
     * returns true to prevent infinite recursion.
     * @return boolean","private boolean isRecursive() {
    final Object node = currentNodePointer.getNode();
    for (int i = stack.size() - 1; --i >= 0; ) {
        final NodeIterator it = (NodeIterator) stack.get(i);
        final Pointer pointer = it.getNodePointer();
        if (pointer != null && pointer.getNode() == node) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.<init>(EvalContext,boolean,NodeTest)","Constructor","* Create a new DescendantContext.
     * @param parentContext parent context
     * @param includeSelf whether to include this node
     * @param nodeTest test","public DescendantContext(final EvalContext parentContext, final boolean includeSelf, final NodeTest nodeTest) {
    super(parentContext);
    this.includeSelf = includeSelf;
    this.nodeTest = nodeTest;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.<init>(EvalContext,boolean,NodeTest).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.DescendantContext.<init>(EvalContext,boolean,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.<init>(EvalContext,boolean,NodeTest).includeSelf","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.DescendantContext.<init>(EvalContext,boolean,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.DescendantContext.<init>(EvalContext,boolean,NodeTest).nodeTest","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.DescendantContext.<init>(EvalContext,boolean,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext","Class","* EvalContext that is used to hold the root node for the path traversal.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.RootContext.jxpathContext","Field","No Comment","private final JXPathContextReferenceImpl jxpathContext;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.pointer","Field","No Comment","private final NodePointer pointer;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.registers","Field","No Comment","private Object[] registers;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.availableRegister","Field","No Comment","private int availableRegister = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.UNKNOWN_VALUE","Field","No Comment","public static final Object UNKNOWN_VALUE = new Object();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.MAX_REGISTER","Field","No Comment","private static final int MAX_REGISTER = 4;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getJXPathContext()","Method","No Comment","@Override
public JXPathContext getJXPathContext() {
    return jxpathContext;
}","JXPathContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getRootContext()","Method","No Comment","@Override
public RootContext getRootContext() {
    return this;
}","RootContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getAbsoluteRootContext()","Method","* Gets absolute root context
     * @return EvalContext","public EvalContext getAbsoluteRootContext() {
    return jxpathContext.getAbsoluteRootContext();
}","EvalContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    return pointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getValue()","Method","No Comment","@Override
public Object getValue() {
    return pointer;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getCurrentPosition()","Method","No Comment","@Override
public int getCurrentPosition() {
    throw new UnsupportedOperationException();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    throw new UnsupportedOperationException();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.nextSet()","Method","No Comment","@Override
public boolean nextSet() {
    throw new UnsupportedOperationException();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    throw new UnsupportedOperationException();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.RootContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getConstantContext(Object)","Method","* Gets a context that points to the specified object.
     * @param constant object
     * @return EvalContext","public EvalContext getConstantContext(final Object constant) {
    if (constant instanceof NodeSet) {
        return new NodeSetContext(new RootContext(jxpathContext, null), (NodeSet) constant);
    }
    NodePointer pointer;
    if (constant instanceof NodePointer) {
        pointer = (NodePointer) constant;
    } else {
        pointer = NodePointer.newNodePointer(new QName(null, """"), constant, null);
    }
    return new InitialContext(new RootContext(jxpathContext, pointer));
}","EvalContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getConstantContext(Object).constant","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.RootContext.getConstantContext(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getVariableContext(QName)","Method","* Gets variable context.
     * @param variableName variable name
     * @return EvalContext","public EvalContext getVariableContext(final QName variableName) {
    return new InitialContext(new RootContext(jxpathContext, jxpathContext.getVariablePointer(variableName)));
}","EvalContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getVariableContext(QName).variableName","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.RootContext.getVariableContext(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getFunction(QName,Object[])","Method","* Gets the specified function from the context.
     * @param functionName QName
     * @param parameters Object[]
     * @return Function","public Function getFunction(final QName functionName, final Object[] parameters) {
    return jxpathContext.getFunction(functionName, parameters);
}","Function","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getFunction(QName,Object[]).functionName","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.RootContext.getFunction(QName,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getFunction(QName,Object[]).parameters","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.RootContext.getFunction(QName,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getRegisteredValue(int)","Method","* Gets a registered value.
     * @param id int
     * @return Object","public Object getRegisteredValue(final int id) {
    if (registers == null || id >= MAX_REGISTER || id == -1) {
        return UNKNOWN_VALUE;
    }
    return registers[id];
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.getRegisteredValue(int).id","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.RootContext.getRegisteredValue(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.setRegisteredValue(Object)","Method","* Sets the next registered value.
     * @param value Object
     * @return the id that can reclaim value.","public int setRegisteredValue(final Object value) {
    if (registers == null) {
        registers = new Object[MAX_REGISTER];
        for (int i = 0; i < MAX_REGISTER; i++) {
            registers[i] = UNKNOWN_VALUE;
        }
    }
    if (availableRegister >= MAX_REGISTER) {
        return -1;
    }
    registers[availableRegister] = value;
    availableRegister++;
    return availableRegister - 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.setRegisteredValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.RootContext.setRegisteredValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.toString()","Method","No Comment","@Override
public String toString() {
    return super.toString() + "":"" + pointer.asPath();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.<init>(JXPathContextReferenceImpl,NodePointer)","Constructor","* Create a new RootContext.
     * @param jxpathContext context
     * @param pointer pointer","public RootContext(final JXPathContextReferenceImpl jxpathContext, final NodePointer pointer) {
    super(null);
    this.jxpathContext = jxpathContext;
    this.pointer = pointer;
    if (pointer != null) {
        pointer.setNamespaceResolver(jxpathContext.getNamespaceResolver());
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.<init>(JXPathContextReferenceImpl,NodePointer).jxpathContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.RootContext.<init>(JXPathContextReferenceImpl,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.RootContext.<init>(JXPathContextReferenceImpl,NodePointer).pointer","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.RootContext.<init>(JXPathContextReferenceImpl,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext","Class","* EvalContext that returns the current node from the parent context if the
 * test succeeds.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.SelfContext.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.startedSet","Field","No Comment","private boolean startedSet = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.nodePointer","Field","No Comment","private NodePointer nodePointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.getSingleNodePointer()","Method","No Comment","@Override
public Pointer getSingleNodePointer() {
    return parentContext.getSingleNodePointer();
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    if (position == 0 && !setPosition(1)) {
        return null;
    }
    return nodePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    return setPosition(getCurrentPosition() + 1);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.reset()","Method","No Comment","@Override
public void reset() {
    super.reset();
    startedSet = false;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (position != 1) {
        return false;
    }
    super.setPosition(position);
    if (!startedSet) {
        startedSet = true;
        nodePointer = parentContext.getCurrentNodePointer();
    }
    if (nodePointer == null) {
        return false;
    }
    return nodeTest == null || nodePointer.testNode(nodeTest);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SelfContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.<init>(EvalContext,NodeTest)","Constructor","* Create a new SelfContext.
     * @param parentContext EvalContext
     * @param nodeTest guard","public SelfContext(final EvalContext parentContext, final NodeTest nodeTest) {
    super(parentContext);
    this.nodeTest = nodeTest;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.<init>(EvalContext,NodeTest).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.SelfContext.<init>(EvalContext,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.SelfContext.<init>(EvalContext,NodeTest).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.SelfContext.<init>(EvalContext,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext","Class","* EvalContext that walks the ""attribute::"" axis.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.AttributeContext.WILDCARD","Field","No Comment","private static final QName WILDCARD = new QName(null, ""*"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.setStarted","Field","No Comment","private boolean setStarted = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.iterator","Field","No Comment","private NodeIterator iterator;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.currentNodePointer","Field","No Comment","private NodePointer currentNodePointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    return currentNodePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.reset()","Method","No Comment","@Override
public void reset() {
    setStarted = false;
    iterator = null;
    super.reset();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (position < getCurrentPosition()) {
        reset();
    }
    while (getCurrentPosition() < position) {
        if (!nextNode()) {
            return false;
        }
    }
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.AttributeContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    super.setPosition(getCurrentPosition() + 1);
    if (!setStarted) {
        setStarted = true;
        QName name;
        if (nodeTest instanceof NodeNameTest) {
            name = ((NodeNameTest) nodeTest).getNodeName();
        } else if (nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) {
            name = WILDCARD;
        } else {
            iterator = null;
            return false;
        }
        iterator = parentContext.getCurrentNodePointer().attributeIterator(name);
    }
    if (iterator == null) {
        return false;
    }
    if (!iterator.setPosition(iterator.getPosition() + 1)) {
        return false;
    }
    currentNodePointer = iterator.getNodePointer();
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.<init>(EvalContext,NodeTest)","Constructor","* Create a new AttributeContext.
     * @param parentContext represents the previous step on the path
     * @param nodeTest is the name of the attribute we are looking for","public AttributeContext(final EvalContext parentContext, final NodeTest nodeTest) {
    super(parentContext);
    this.nodeTest = nodeTest;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.<init>(EvalContext,NodeTest).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.AttributeContext.<init>(EvalContext,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.AttributeContext.<init>(EvalContext,NodeTest).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.AttributeContext.<init>(EvalContext,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.UnionContext","Class","* EvalContext that represents a union between other contexts - result
 * of a union operation like (a | b)","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.axes.NodeSetContext",""
"org.apache.commons.jxpath.ri.axes.UnionContext.contexts","Field","No Comment","private final EvalContext[] contexts;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.UnionContext.prepared","Field","No Comment","private boolean prepared;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.UnionContext.getDocumentOrder()","Method","No Comment","@Override
public int getDocumentOrder() {
    return contexts.length > 1 ? 1 : super.getDocumentOrder();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.UnionContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (!prepared) {
        prepared = true;
        final BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();
        final ArrayList pointers = new ArrayList();
        for (final EvalContext ctx : contexts) {
            while (ctx.nextSet()) {
                while (ctx.nextNode()) {
                    final NodePointer ptr = ctx.getCurrentNodePointer();
                    if (!pointers.contains(ptr)) {
                        pointers.add(ptr);
                    }
                }
            }
        }
        sortPointers(pointers);
        for (final Iterator it = pointers.iterator(); it.hasNext(); ) {
            nodeSet.add((Pointer) it.next());
        }
    }
    return super.setPosition(position);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.UnionContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.UnionContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.UnionContext.<init>(EvalContext,EvalContext[])","Constructor","* Create a new UnionContext.
     * @param parentContext parent context
     * @param contexts child contexts","public UnionContext(final EvalContext parentContext, final EvalContext[] contexts) {
    super(parentContext, new BasicNodeSet());
    this.contexts = contexts;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.UnionContext.<init>(EvalContext,EvalContext[]).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.UnionContext.<init>(EvalContext,EvalContext[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.UnionContext.<init>(EvalContext,EvalContext[]).contexts","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.UnionContext.<init>(EvalContext,EvalContext[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext","Class","* EvalContext that can walk the ""child::"", ""following-sibling::"" and
 * ""preceding-sibling::"" axes.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.EvalContext",""
"org.apache.commons.jxpath.ri.axes.ChildContext.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.startFromParentLocation","Field","No Comment","private final boolean startFromParentLocation;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.reverse","Field","No Comment","private final boolean reverse;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.iterator","Field","No Comment","private NodeIterator iterator;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.getCurrentNodePointer()","Method","No Comment","@Override
public NodePointer getCurrentNodePointer() {
    if (position == 0 && !setPosition(1)) {
        return null;
    }
    return iterator == null ? null : iterator.getNodePointer();
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.getSingleNodePointer()","Method","* This method is called on the last context on the path when only
     * one value is needed.  Note that this will return the whole property,
     * even if it is a collection. It will not extract the first element
     * of the collection.  For example, ""books"" will return the collection
     * of books rather than the first book from that collection.
     * @return Pointer","@Override
public Pointer getSingleNodePointer() {
    if (position == 0) {
        while (nextSet()) {
            prepare();
            if (iterator == null) {
                return null;
            }
            // See if there is a property there, singular or collection
            final NodePointer pointer = iterator.getNodePointer();
            if (pointer != null) {
                return pointer;
            }
        }
        return null;
    }
    return getCurrentNodePointer();
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.nextNode()","Method","No Comment","@Override
public boolean nextNode() {
    return setPosition(getCurrentPosition() + 1);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.reset()","Method","No Comment","@Override
public void reset() {
    super.reset();
    iterator = null;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    final int oldPosition = getCurrentPosition();
    super.setPosition(position);
    if (oldPosition == 0) {
        prepare();
    }
    return iterator != null && iterator.setPosition(position);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.ChildContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.prepare()","Method","* Allocates a PropertyIterator.","private void prepare() {
    final NodePointer parent = parentContext.getCurrentNodePointer();
    if (parent == null) {
        return;
    }
    final NodePointer useParent = startFromParentLocation ? parent.getParent() : parent;
    iterator = useParent == null ? null : useParent.childIterator(nodeTest, reverse, startFromParentLocation ? parent : null);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.<init>(EvalContext,NodeTest,boolean,boolean)","Constructor","* Create a new ChildContext.
     * @param parentContext parent EvalContext
     * @param nodeTest NodeTest
     * @param startFromParentLocation whether to start from parent location
     * @param reverse whether to iterate in reverse","public ChildContext(final EvalContext parentContext, final NodeTest nodeTest, final boolean startFromParentLocation, final boolean reverse) {
    super(parentContext);
    this.nodeTest = nodeTest;
    this.startFromParentLocation = startFromParentLocation;
    this.reverse = reverse;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.<init>(EvalContext,NodeTest,boolean,boolean).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.axes.ChildContext.<init>(EvalContext,NodeTest,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.<init>(EvalContext,NodeTest,boolean,boolean).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.axes.ChildContext.<init>(EvalContext,NodeTest,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.<init>(EvalContext,NodeTest,boolean,boolean).startFromParentLocation","Parameter_3","Belong to org.apache.commons.jxpath.ri.axes.ChildContext.<init>(EvalContext,NodeTest,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.axes.ChildContext.<init>(EvalContext,NodeTest,boolean,boolean).reverse","Parameter_4","Belong to org.apache.commons.jxpath.ri.axes.ChildContext.<init>(EvalContext,NodeTest,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl","Class","* Default implementation of JXPathContextFactory.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.JXPathContextFactory",""
"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl.newContext(JXPathContext,Object)","Method","No Comment","@Override
public JXPathContext newContext(final JXPathContext parentContext, final Object contextBean) {
    return new JXPathContextReferenceImpl(parentContext, contextBean);
}","JXPathContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl.newContext(JXPathContext,Object).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl.newContext(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl.newContext(JXPathContext,Object).contextBean","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl.newContext(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl.<init>()","Constructor","* Create a new JXPathContextFactoryReferenceImpl.","public JXPathContextFactoryReferenceImpl() {
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler","Interface","* The Compiler APIs are completely agnostic to the actual types of objects
 * produced and consumed by the APIs.  Arguments and return values are
 * declared as java.lang.Object.
 * <p>
 * Since objects returned by Compiler methods are passed as arguments to other
 * Compiler methods, the descriptions of these methods use virtual types.  There
 * are four virtual object types: EXPRESSION, QNAME, STEP and NODE_TEST.
 * <p>
 * The following example illustrates this notion.  This sequence compiles
 * the xpath ""foo[round(1 div 2)]/text()"":
 * <blockquote><pre>
 *      Object qname1 = compiler.qname(null, ""foo"")
 *      Object expr1 = compiler.number(""1"");
 *      Object expr2 = compiler.number(""2"");
 *      Object expr3 = compiler.div(expr1, expr2);
 *      Object expr4 = compiler.
 *              coreFunction(Compiler.FUNCTION_ROUND, new Object[]{expr3});
 *      Object test1 = compiler.nodeNameTest(qname1);
 *      Object step1 = compiler.
 *              step(Compiler.AXIS_CHILD, test1, new Object[]{expr4});
 *      Object test2 = compiler.nodeTypeTest(Compiler.NODE_TYPE_TEXT);
 *      Object step2 = compiler.nodeTypeTest(Compiler.AXIS_CHILD, test2, null);
 *      Object expr5 = compiler.locationPath(false, new Object[]{step1, step2});
 * </pre></blockquote>","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.Compiler.NODE_TYPE_NODE","Field","No Comment","int NODE_TYPE_NODE = 1;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.NODE_TYPE_TEXT","Field","No Comment","int NODE_TYPE_TEXT = 2;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.NODE_TYPE_COMMENT","Field","No Comment","int NODE_TYPE_COMMENT = 3;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.NODE_TYPE_PI","Field","No Comment","int NODE_TYPE_PI = 4;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_SELF","Field","No Comment","int AXIS_SELF = 1;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_CHILD","Field","No Comment","int AXIS_CHILD = 2;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_PARENT","Field","No Comment","int AXIS_PARENT = 3;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_ANCESTOR","Field","No Comment","int AXIS_ANCESTOR = 4;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_ATTRIBUTE","Field","No Comment","int AXIS_ATTRIBUTE = 5;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_NAMESPACE","Field","No Comment","int AXIS_NAMESPACE = 6;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_PRECEDING","Field","No Comment","int AXIS_PRECEDING = 7;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_FOLLOWING","Field","No Comment","int AXIS_FOLLOWING = 8;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_DESCENDANT","Field","No Comment","int AXIS_DESCENDANT = 9;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_ANCESTOR_OR_SELF","Field","No Comment","int AXIS_ANCESTOR_OR_SELF = 10;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_FOLLOWING_SIBLING","Field","No Comment","int AXIS_FOLLOWING_SIBLING = 11;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_PRECEDING_SIBLING","Field","No Comment","int AXIS_PRECEDING_SIBLING = 12;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.AXIS_DESCENDANT_OR_SELF","Field","No Comment","int AXIS_DESCENDANT_OR_SELF = 13;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_LAST","Field","No Comment","int FUNCTION_LAST = 1;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_POSITION","Field","No Comment","int FUNCTION_POSITION = 2;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_COUNT","Field","No Comment","int FUNCTION_COUNT = 3;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_ID","Field","No Comment","int FUNCTION_ID = 4;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_LOCAL_NAME","Field","No Comment","int FUNCTION_LOCAL_NAME = 5;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_NAMESPACE_URI","Field","No Comment","int FUNCTION_NAMESPACE_URI = 6;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_NAME","Field","No Comment","int FUNCTION_NAME = 7;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_STRING","Field","No Comment","int FUNCTION_STRING = 8;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_CONCAT","Field","No Comment","int FUNCTION_CONCAT = 9;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_STARTS_WITH","Field","No Comment","int FUNCTION_STARTS_WITH = 10;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_CONTAINS","Field","No Comment","int FUNCTION_CONTAINS = 11;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_SUBSTRING_BEFORE","Field","No Comment","int FUNCTION_SUBSTRING_BEFORE = 12;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_SUBSTRING_AFTER","Field","No Comment","int FUNCTION_SUBSTRING_AFTER = 13;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_SUBSTRING","Field","No Comment","int FUNCTION_SUBSTRING = 14;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_STRING_LENGTH","Field","No Comment","int FUNCTION_STRING_LENGTH = 15;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_NORMALIZE_SPACE","Field","No Comment","int FUNCTION_NORMALIZE_SPACE = 16;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_TRANSLATE","Field","No Comment","int FUNCTION_TRANSLATE = 17;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_BOOLEAN","Field","No Comment","int FUNCTION_BOOLEAN = 18;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_NOT","Field","No Comment","int FUNCTION_NOT = 19;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_TRUE","Field","No Comment","int FUNCTION_TRUE = 20;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_FALSE","Field","No Comment","int FUNCTION_FALSE = 21;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_LANG","Field","No Comment","int FUNCTION_LANG = 22;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_NUMBER","Field","No Comment","int FUNCTION_NUMBER = 23;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_SUM","Field","No Comment","int FUNCTION_SUM = 24;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_FLOOR","Field","No Comment","int FUNCTION_FLOOR = 25;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_CEILING","Field","No Comment","int FUNCTION_CEILING = 26;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_ROUND","Field","No Comment","int FUNCTION_ROUND = 27;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_NULL","Field","No Comment","int FUNCTION_NULL = 28;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_KEY","Field","No Comment","int FUNCTION_KEY = 29;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_FORMAT_NUMBER","Field","No Comment","int FUNCTION_FORMAT_NUMBER = 30;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.FUNCTION_ENDS_WITH","Field","No Comment","int FUNCTION_ENDS_WITH = 31;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.number(String)","Abstract Method","* Produces an EXPRESSION object that represents a numeric constant.
     * @param value numeric String
     * @return Object","Object number(String value);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.number(String).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.number(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.literal(String)","Abstract Method","* Produces an EXPRESSION object that represents a string constant.
     * @param value String literal
     * @return Object","Object literal(String value);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.literal(String).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.literal(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.qname(String,String)","Abstract Method","* Produces an QNAME that represents a name with an optional prefix.
     * @param prefix String prefix
     * @param name String name
     * @return Object","Object qname(String prefix, String name);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.qname(String,String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.qname(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.qname(String,String).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.qname(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.sum(Object[])","Abstract Method","* Produces an EXPRESSION object representing the sum of all argumens
     *
     * @param arguments are EXPRESSION objects
     * @return Object","Object sum(Object[] arguments);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.sum(Object[]).arguments","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.sum(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.minus(Object,Object)","Abstract Method","* Produces an EXPRESSION object representing <em>left</em> minus <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object minus(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.minus(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.minus(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.minus(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.minus(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.multiply(Object,Object)","Abstract Method","* Produces  an EXPRESSION object representing <em>left</em> multiplied by
     * <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object multiply(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.multiply(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.multiply(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.multiply(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.multiply(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.divide(Object,Object)","Abstract Method","* Produces  an EXPRESSION object representing <em>left</em> divided by
     * <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object divide(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.divide(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.divide(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.divide(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.divide(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.mod(Object,Object)","Abstract Method","* Produces  an EXPRESSION object representing <em>left</em> modulo
     * <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object mod(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.mod(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.mod(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.mod(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.mod(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.lessThan(Object,Object)","Abstract Method","* Produces an EXPRESSION object representing the comparison:
     * <em>left</em> less than <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object lessThan(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.lessThan(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.lessThan(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.lessThan(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.lessThan(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.lessThanOrEqual(Object,Object)","Abstract Method","* Produces an EXPRESSION object representing the comparison:
     * <em>left</em> less than or equal to <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object lessThanOrEqual(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.lessThanOrEqual(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.lessThanOrEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.lessThanOrEqual(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.lessThanOrEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.greaterThan(Object,Object)","Abstract Method","* Produces an EXPRESSION object representing the comparison:
     * <em>left</em> greater than <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object greaterThan(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.greaterThan(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.greaterThan(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.greaterThan(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.greaterThan(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.greaterThanOrEqual(Object,Object)","Abstract Method","* Produces an EXPRESSION object representing the comparison:
     * <em>left</em> greater than or equal to <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object greaterThanOrEqual(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.greaterThanOrEqual(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.greaterThanOrEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.greaterThanOrEqual(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.greaterThanOrEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.equal(Object,Object)","Abstract Method","* Produces an EXPRESSION object representing the comparison:
     * <em>left</em> equals to <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object equal(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.equal(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.equal(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.equal(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.equal(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.notEqual(Object,Object)","Abstract Method","* Produces an EXPRESSION object representing the comparison:
     * <em>left</em> is not equal to <em>right</em>
     *
     * @param left is an EXPRESSION object
     * @param right is an EXPRESSION object
     * @return Object","Object notEqual(Object left, Object right);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.notEqual(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.notEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.notEqual(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.notEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.minus(Object)","Abstract Method","* Produces an EXPRESSION object representing unary negation of the argument
     *
     * @param argument is an EXPRESSION object
     * @return Object","Object minus(Object argument);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.minus(Object).argument","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.minus(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.variableReference(Object)","Abstract Method","* Produces an EXPRESSION object representing variable reference
     *
     * @param qname is a QNAME object
     * @return Object","Object variableReference(Object qname);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.variableReference(Object).qname","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.variableReference(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.function(int,Object[])","Abstract Method","* Produces an EXPRESSION object representing the computation of
     * a core function with the supplied arguments.
     *
     * @param code is one of FUNCTION_... constants
     * @param args are EXPRESSION objects
     * @return Object","Object function(int code, Object[] args);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.function(int,Object[]).code","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.function(int,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.function(int,Object[]).args","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.function(int,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.function(Object,Object[])","Abstract Method","* Produces an EXPRESSION object representing the computation of
     * a library function with the supplied arguments.
     *
     * @param name is a QNAME object (function name)
     * @param args are EXPRESSION objects
     * @return Object","Object function(Object name, Object[] args);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.function(Object,Object[]).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.function(Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.function(Object,Object[]).args","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.function(Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.and(Object[])","Abstract Method","* Produces an EXPRESSION object representing logical conjunction of
     * all arguments
     *
     * @param arguments are EXPRESSION objects
     * @return Object","Object and(Object[] arguments);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.and(Object[]).arguments","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.and(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.or(Object[])","Abstract Method","* Produces an EXPRESSION object representing logical disjunction of
     * all arguments
     *
     * @param arguments are EXPRESSION objects
     * @return Object","Object or(Object[] arguments);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.or(Object[]).arguments","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.or(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.union(Object[])","Abstract Method","* Produces an EXPRESSION object representing union of all node sets
     *
     * @param arguments are EXPRESSION objects
     * @return Object","Object union(Object[] arguments);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.union(Object[]).arguments","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.union(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.nodeNameTest(Object)","Abstract Method","* Produces a NODE_TEST object that represents a node name test.
     *
     * @param qname is a QNAME object
     * @return Object","Object nodeNameTest(Object qname);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.nodeNameTest(Object).qname","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.nodeNameTest(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.nodeTypeTest(int)","Abstract Method","* Produces a NODE_TEST object that represents a node type test.
     *
     * @param nodeType is a NODE_TEST object
     * @return Object","Object nodeTypeTest(int nodeType);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.nodeTypeTest(int).nodeType","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.nodeTypeTest(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.processingInstructionTest(String)","Abstract Method","* Produces  a NODE_TEST object that represents a processing instruction
     * test.
     *
     * @param instruction is a NODE_TEST object
     * @return Object","Object processingInstructionTest(String instruction);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.processingInstructionTest(String).instruction","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.processingInstructionTest(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.step(int,Object,Object[])","Abstract Method","* Produces a STEP object that represents a node test.
     *
     * @param axis is one of the AXIS_... constants
     * @param nodeTest is a NODE_TEST object
     * @param predicates are EXPRESSION objects
     * @return Object","Object step(int axis, Object nodeTest, Object[] predicates);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.step(int,Object,Object[]).axis","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.step(int,Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.step(int,Object,Object[]).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.step(int,Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.step(int,Object,Object[]).predicates","Parameter_3","Belong to org.apache.commons.jxpath.ri.Compiler.step(int,Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.locationPath(boolean,Object[])","Abstract Method","* Produces an EXPRESSION object representing a location path
     *
     * @param absolute indicates whether the path is absolute
     * @param steps are STEP objects
     * @return Object","Object locationPath(boolean absolute, Object[] steps);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.locationPath(boolean,Object[]).absolute","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.locationPath(boolean,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.locationPath(boolean,Object[]).steps","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.locationPath(boolean,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.expressionPath(Object,Object[],Object[])","Abstract Method","* Produces an EXPRESSION object representing a filter expression
     *
     * @param expression is an EXPRESSION object
     * @param predicates are EXPRESSION objects
     * @param steps are STEP objects
     * @return Object","Object expressionPath(Object expression, Object[] predicates, Object[] steps);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.expressionPath(Object,Object[],Object[]).expression","Parameter_1","Belong to org.apache.commons.jxpath.ri.Compiler.expressionPath(Object,Object[],Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.expressionPath(Object,Object[],Object[]).predicates","Parameter_2","Belong to org.apache.commons.jxpath.ri.Compiler.expressionPath(Object,Object[],Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.Compiler.expressionPath(Object,Object[],Object[]).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.Compiler.expressionPath(Object,Object[],Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError","Class","No Comment","Class do not obtain Source Code","No return type","public ","java.lang.Error",""
"org.apache.commons.jxpath.ri.parser.TokenMgrError.serialVersionUID","Field","*","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.LEXICAL_ERROR","Field","* Lexical error occurred.","static final int LEXICAL_ERROR = 0;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.STATIC_LEXER_ERROR","Field","* An attempt wass made to create a second instance of a static token manager.","static final int STATIC_LEXER_ERROR = 1;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.INVALID_LEXICAL_STATE","Field","* Tried to change to an invalid lexical state.","static final int INVALID_LEXICAL_STATE = 2;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.LOOP_DETECTED","Field","* Detected (and bailed out of) an infinite loop in the token manager.","static final int LOOP_DETECTED = 3;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.errorCode","Field","* Indicates the reason why the exception is thrown. It will have
    * one of the above 4 values.","int errorCode;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.position","Field","No Comment","private int position;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.character","Field","No Comment","private char character;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.addEscapes(String)","Method","* Replaces unprintable characters by their escaped (or Unicode escaped) equivalents in the given string
    *
    * @param str TODO
    * @return TODO","public static final String addEscapes(final String str) {
    final StringBuilder retval = new StringBuilder();
    char ch;
    for (int i = 0; i < str.length(); i++) {
        switch(str.charAt(i)) {
            case 0:
                continue;
            case '\b':
                retval.append(""\\b"");
                continue;
            case '\t':
                retval.append(""\\t"");
                continue;
            case '\n':
                retval.append(""\\n"");
                continue;
            case '\f':
                retval.append(""\\f"");
                continue;
            case '\r':
                retval.append(""\\r"");
                continue;
            case '\""':
                retval.append(""\\\"""");
                continue;
            case '\'':
                retval.append(""\\\'"");
                continue;
            case '\\':
                retval.append(""\\\\"");
                continue;
            default:
                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                    final String s = ""0000"" + Integer.toString(ch, 16);
                    retval.append(""\\u"" + s.substring(s.length() - 4));
                } else {
                    retval.append(ch);
                }
                continue;
        }
    }
    return retval.toString();
}","String","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.addEscapes(String).str","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.addEscapes(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char)","Method","* Returns a detailed message for the Error when it is thrown by the token manager to indicate a lexical error.
    *
    * Note: You can customize the lexical error message by modifying this method.
    *
    * @param EOFSeen     indicates if EOF caused the lexicl error
    * @param lexState    lexical state in which this error occurred
    * @param errorLine   line number when the error occurred
    * @param errorColumn column number when the error occurred
    * @param errorAfter  prefix that was seen before this error occurred
    * @param curChar     the offending character
    * @return TODO","protected static String LexicalError(final boolean EOFSeen, final int lexState, final int errorLine, final int errorColumn, final String errorAfter, final char curChar) {
    return ""Lexical error at line "" + errorLine + "", column "" + errorColumn + "".  Encountered: "" + (EOFSeen ? ""<EOF> "" : ""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""" + "" ("" + (int) curChar + ""), "") + ""after : \"""" + addEscapes(errorAfter) + ""\"""";
}","String","protected , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char).EOFSeen","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char).lexState","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char).errorLine","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char).errorColumn","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char).errorAfter","Parameter_5","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char).curChar","Parameter_6","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.LexicalError(boolean,int,int,int,String,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.getMessage()","Method","* You can also modify the body of this method to customize your error messages.
    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
    * of end-users concern, so you can return something like :
    *
    *     ""Internal Error : Please file a bug report .... ""
    *
    * from this method for such cases in the release version of your parser.","@Override
public String getMessage() {
    return super.getMessage();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.getPosition()","Method","No Comment","public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.getCharacter()","Method","No Comment","public char getCharacter() {
    return character;
}","char","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>()","Constructor","No Comment","public TokenMgrError() {
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(String,int)","Constructor","No Comment","public TokenMgrError(final String message, final int reason) {
    super(message);
    errorCode = reason;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(String,int).message","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(String,int).reason","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int)","Constructor","No Comment","public TokenMgrError(final boolean EOFSeen, final int lexState, final int errorLine, final int errorColumn, final String errorAfter, final char curChar, final int reason) {
    this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
    // ADDED BY ME FROM THIS POINT TO THE EOF - DMITRI PLOTNIKOV
    position = errorColumn - 1;
    character = curChar;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int).EOFSeen","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int).lexState","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int).errorLine","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int).errorColumn","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int).errorAfter","Parameter_5","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int).curChar","Parameter_6","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int).reason","Parameter_7","Belong to org.apache.commons.jxpath.ri.parser.TokenMgrError.<init>(boolean,int,int,int,String,char,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException","Class","* This exception is thrown when parse errors are encountered.
 * You can explicitly create objects of this exception type by
 * calling the method generateParseException in the generated
 * parser.
 *
 * You can modify this class to customize your error reporting
 * mechanisms so long as you retain the public fields.","Class do not obtain Source Code","No return type","public ","java.lang.Exception",""
"org.apache.commons.jxpath.ri.parser.ParseException.serialVersionUID","Field","*","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.specialConstructor","Field","* This variable determines which constructor was used to create
   * this object and thereby affects the semantics of the
   * ""getMessage"" method (see below).","protected boolean specialConstructor;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.currentToken","Field","* This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error, the token
   * followng this token will (therefore) be the first error token.","public Token currentToken;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.expectedTokenSequences","Field","* Each entry in this array is an array of integers.  Each array
   * of integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.","public int[][] expectedTokenSequences;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.tokenImage","Field","* This is a reference to the ""tokenImage"" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in the generated ...Constants interface.","public String[] tokenImage;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.eol","Field","* The end of line string for this machine.","protected String eol = System.getProperty(""line.separator"", ""\n"");","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.getMessage()","Method","* This method has the standard behavior when this object has been
   * created using the standard constructors.  Otherwise, it uses
   * ""currentToken"" and ""expectedTokenSequences"" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch it (it gets thrown
   * from the parser), then this method is called during the printing
   * of the final stack trace, and hence the correct error message
   * gets displayed.","@Override
public String getMessage() {
    if (!specialConstructor) {
        return super.getMessage();
    }
    String expected = """";
    int maxSize = 0;
    for (final int[] element : expectedTokenSequences) {
        if (maxSize < element.length) {
            maxSize = element.length;
        }
        for (final int element2 : element) {
            expected += tokenImage[element2] + "" "";
        }
        if (element[element.length - 1] != 0) {
            expected += ""..."";
        }
        expected += eol + ""    "";
    }
    String retval = ""Encountered \"""";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
        if (i != 0) {
            retval += "" "";
        }
        if (tok.kind == 0) {
            retval += tokenImage[0];
            break;
        }
        retval += add_escapes(tok.image);
        tok = tok.next;
    }
    retval += ""\"" at line "" + currentToken.next.beginLine + "", column "" + currentToken.next.beginColumn;
    retval += ""."" + eol;
    if (expectedTokenSequences.length == 1) {
        retval += ""Was expecting:"" + eol + ""    "";
    } else {
        retval += ""Was expecting one of:"" + eol + ""    "";
    }
    retval += expected;
    return retval;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.add_escapes(String)","Method","* Used to convert raw characters to their escaped version
   * when these raw version cannot be used as part of an ASCII
   * string literal.
   *
   * @param str raw characters.
   * @return escaped version of the input.","protected String add_escapes(final String str) {
    final StringBuilder retval = new StringBuilder();
    char ch;
    for (int i = 0; i < str.length(); i++) {
        switch(str.charAt(i)) {
            case 0:
                continue;
            case '\b':
                retval.append(""\\b"");
                continue;
            case '\t':
                retval.append(""\\t"");
                continue;
            case '\n':
                retval.append(""\\n"");
                continue;
            case '\f':
                retval.append(""\\f"");
                continue;
            case '\r':
                retval.append(""\\r"");
                continue;
            case '\""':
                retval.append(""\\\"""");
                continue;
            case '\'':
                retval.append(""\\\'"");
                continue;
            case '\\':
                retval.append(""\\\\"");
                continue;
            default:
                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                    final String s = ""0000"" + Integer.toString(ch, 16);
                    retval.append(""\\u"" + s.substring(s.length() - 4));
                } else {
                    retval.append(ch);
                }
                continue;
        }
    }
    return retval.toString();
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.add_escapes(String).str","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.ParseException.add_escapes(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.<init>(Token,int[][],String[])","Constructor","* This constructor is used by the method ""generateParseException"" in the generated parser. Calling this constructor generates a new object of this type
     * with the fields ""currentToken"", ""expectedTokenSequences"", and ""tokenImage"" set. The boolean flag ""specialConstructor"" is also set to true to indicate
     * that this constructor was used to create this object. This constructor calls its super class with the empty string to force the ""toString"" method of
     * parent class ""Throwable"" to print the error message in the form: ParseException: ""result of getMessage""
     *
     * @param currentTokenVal TODO
     * @param expectedTokenSequencesVal TODO
     * @param tokenImageVal TODO","public ParseException(final Token currentTokenVal, final int[][] expectedTokenSequencesVal, final String[] tokenImageVal) {
    super("""");
    specialConstructor = true;
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.<init>(Token,int[][],String[]).currentTokenVal","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.ParseException.<init>(Token,int[][],String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.<init>(Token,int[][],String[]).expectedTokenSequencesVal","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.ParseException.<init>(Token,int[][],String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.<init>(Token,int[][],String[]).tokenImageVal","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.ParseException.<init>(Token,int[][],String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.<init>()","Constructor","No Comment","public ParseException() {
    specialConstructor = false;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.<init>(String)","Constructor","No Comment","public ParseException(final String message) {
    super(message);
    specialConstructor = false;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.ParseException.<init>(String).message","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.ParseException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser","Class","No Comment","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.parser.XPathParserConstants"
"org.apache.commons.jxpath.ri.parser.XPathParser.compiler","Field","No Comment","private Compiler compiler;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.token_source","Field","No Comment","public XPathParserTokenManager token_source;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_input_stream","Field","No Comment","SimpleCharStream jj_input_stream;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.token","Field","No Comment","public Token token, jj_nt;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_nt","Field","No Comment","public Token token, jj_nt;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_scanpos","Field","No Comment","private Token jj_scanpos, jj_lastpos;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_lastpos","Field","No Comment","private Token jj_scanpos, jj_lastpos;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_la","Field","No Comment","private int jj_la;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.lookingAhead","Field","No Comment","public boolean lookingAhead = false;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_semLA","Field","No Comment","private boolean jj_semLA;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_gen","Field","No Comment","private int jj_gen;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_la1","Field","No Comment","final private int[] jj_la1 = new int[39];","No return type","final , private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_la1_0","Field","No Comment","static private int[] jj_la1_0;","No return type","static , private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_la1_1","Field","No Comment","static private int[] jj_la1_1;","No return type","static , private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_la1_2","Field","No Comment","static private int[] jj_la1_2;","No return type","static , private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_rtns","Field","No Comment","final private JJCalls[] jj_2_rtns = new JJCalls[6];","No return type","final , private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_rescan","Field","No Comment","private boolean jj_rescan = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_gc","Field","No Comment","private int jj_gc = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_ls","Field","No Comment","final private LookaheadSuccess jj_ls = new LookaheadSuccess();","No return type","final , private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_expentries","Field","No Comment","private final java.util.Vector jj_expentries = new java.util.Vector();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_expentry","Field","No Comment","private int[] jj_expentry;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_kind","Field","No Comment","private int jj_kind = -1;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_lasttokens","Field","No Comment","private final int[] jj_lasttokens = new int[100];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_endpos","Field","No Comment","private int jj_endpos;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.setCompiler(Compiler)","Method","No Comment","public void setCompiler(final Compiler compiler) {
    this.compiler = compiler;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.setCompiler(Compiler).compiler","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.setCompiler(Compiler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.unescape(String)","Method","No Comment","private String unescape(String string) {
    int index = string.indexOf(""&apos;"");
    while (index != -1) {
        string = string.substring(0, index) + ""\'"" + string.substring(index + 6);
        index = string.indexOf(""&apos;"");
    }
    index = string.indexOf(""&quot;"");
    while (index != -1) {
        string = string.substring(0, index) + ""\"""" + string.substring(index + 6);
        index = string.indexOf(""&quot;"");
    }
    return string;
}","String","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.unescape(String).string","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.unescape(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.NCName()","Method","Note: XPath does not have reserved words, so we have to include all these terminals","final public String NCName() throws ParseException {
    switch(jj_nt.kind) {
        case OR:
        case AND:
        case MOD:
        case DIV:
        case NCName:
            NCName_Without_CoreFunctions();
            break;
        case NODE:
            jj_consume_token(NODE);
            break;
        case TEXT:
            jj_consume_token(TEXT);
            break;
        case COMMENT:
            jj_consume_token(COMMENT);
            break;
        case PI:
            jj_consume_token(PI);
            break;
        case FUNCTION_LAST:
            jj_consume_token(FUNCTION_LAST);
            break;
        case FUNCTION_POSITION:
            jj_consume_token(FUNCTION_POSITION);
            break;
        case FUNCTION_COUNT:
            jj_consume_token(FUNCTION_COUNT);
            break;
        case FUNCTION_ID:
            jj_consume_token(FUNCTION_ID);
            break;
        case FUNCTION_LOCAL_NAME:
            jj_consume_token(FUNCTION_LOCAL_NAME);
            break;
        case FUNCTION_NAMESPACE_URI:
            jj_consume_token(FUNCTION_NAMESPACE_URI);
            break;
        case FUNCTION_NAME:
            jj_consume_token(FUNCTION_NAME);
            break;
        case FUNCTION_STRING:
            jj_consume_token(FUNCTION_STRING);
            break;
        case FUNCTION_CONCAT:
            jj_consume_token(FUNCTION_CONCAT);
            break;
        case FUNCTION_STARTS_WITH:
            jj_consume_token(FUNCTION_STARTS_WITH);
            break;
        case FUNCTION_ENDS_WITH:
            jj_consume_token(FUNCTION_ENDS_WITH);
            break;
        case FUNCTION_CONTAINS:
            jj_consume_token(FUNCTION_CONTAINS);
            break;
        case FUNCTION_SUBSTRING_BEFORE:
            jj_consume_token(FUNCTION_SUBSTRING_BEFORE);
            break;
        case FUNCTION_SUBSTRING_AFTER:
            jj_consume_token(FUNCTION_SUBSTRING_AFTER);
            break;
        case FUNCTION_SUBSTRING:
            jj_consume_token(FUNCTION_SUBSTRING);
            break;
        case FUNCTION_STRING_LENGTH:
            jj_consume_token(FUNCTION_STRING_LENGTH);
            break;
        case FUNCTION_NORMALIZE_SPACE:
            jj_consume_token(FUNCTION_NORMALIZE_SPACE);
            break;
        case FUNCTION_TRANSLATE:
            jj_consume_token(FUNCTION_TRANSLATE);
            break;
        case FUNCTION_BOOLEAN:
            jj_consume_token(FUNCTION_BOOLEAN);
            break;
        case FUNCTION_NOT:
            jj_consume_token(FUNCTION_NOT);
            break;
        case FUNCTION_TRUE:
            jj_consume_token(FUNCTION_TRUE);
            break;
        case FUNCTION_FALSE:
            jj_consume_token(FUNCTION_FALSE);
            break;
        case FUNCTION_NULL:
            jj_consume_token(FUNCTION_NULL);
            break;
        case FUNCTION_LANG:
            jj_consume_token(FUNCTION_LANG);
            break;
        case FUNCTION_NUMBER:
            jj_consume_token(FUNCTION_NUMBER);
            break;
        case FUNCTION_SUM:
            jj_consume_token(FUNCTION_SUM);
            break;
        case FUNCTION_FLOOR:
            jj_consume_token(FUNCTION_FLOOR);
            break;
        case FUNCTION_CEILING:
            jj_consume_token(FUNCTION_CEILING);
            break;
        case FUNCTION_ROUND:
            jj_consume_token(FUNCTION_ROUND);
            break;
        case FUNCTION_KEY:
            jj_consume_token(FUNCTION_KEY);
            break;
        case FUNCTION_FORMAT_NUMBER:
            jj_consume_token(FUNCTION_FORMAT_NUMBER);
            break;
        default:
            jj_la1[0] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    {
        if (true) {
            return token.image;
        }
    }
    throw new Error(""Missing return statement in function"");
}","String","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.NCName_Without_CoreFunctions()","Method","No Comment","final public String NCName_Without_CoreFunctions() throws ParseException {
    switch(jj_nt.kind) {
        case NCName:
            jj_consume_token(NCName);
            break;
        case OR:
            jj_consume_token(OR);
            break;
        case AND:
            jj_consume_token(AND);
            break;
        case MOD:
            jj_consume_token(MOD);
            break;
        case DIV:
            jj_consume_token(DIV);
            break;
        default:
            jj_la1[1] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    {
        if (true) {
            return token.image;
        }
    }
    throw new Error(""Missing return statement in function"");
}","String","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.CoreFunctionName()","Method","No Comment","final public int CoreFunctionName() throws ParseException {
    int code;
    switch(jj_nt.kind) {
        case FUNCTION_LAST:
            jj_consume_token(FUNCTION_LAST);
            code = Compiler.FUNCTION_LAST;
            break;
        case FUNCTION_POSITION:
            jj_consume_token(FUNCTION_POSITION);
            code = Compiler.FUNCTION_POSITION;
            break;
        case FUNCTION_COUNT:
            jj_consume_token(FUNCTION_COUNT);
            code = Compiler.FUNCTION_COUNT;
            break;
        case FUNCTION_ID:
            jj_consume_token(FUNCTION_ID);
            code = Compiler.FUNCTION_ID;
            break;
        case FUNCTION_LOCAL_NAME:
            jj_consume_token(FUNCTION_LOCAL_NAME);
            code = Compiler.FUNCTION_LOCAL_NAME;
            break;
        case FUNCTION_NAMESPACE_URI:
            jj_consume_token(FUNCTION_NAMESPACE_URI);
            code = Compiler.FUNCTION_NAMESPACE_URI;
            break;
        case FUNCTION_NAME:
            jj_consume_token(FUNCTION_NAME);
            code = Compiler.FUNCTION_NAME;
            break;
        case FUNCTION_STRING:
            jj_consume_token(FUNCTION_STRING);
            code = Compiler.FUNCTION_STRING;
            break;
        case FUNCTION_CONCAT:
            jj_consume_token(FUNCTION_CONCAT);
            code = Compiler.FUNCTION_CONCAT;
            break;
        case FUNCTION_STARTS_WITH:
            jj_consume_token(FUNCTION_STARTS_WITH);
            code = Compiler.FUNCTION_STARTS_WITH;
            break;
        case FUNCTION_ENDS_WITH:
            jj_consume_token(FUNCTION_ENDS_WITH);
            code = Compiler.FUNCTION_ENDS_WITH;
            break;
        case FUNCTION_CONTAINS:
            jj_consume_token(FUNCTION_CONTAINS);
            code = Compiler.FUNCTION_CONTAINS;
            break;
        case FUNCTION_SUBSTRING_BEFORE:
            jj_consume_token(FUNCTION_SUBSTRING_BEFORE);
            code = Compiler.FUNCTION_SUBSTRING_BEFORE;
            break;
        case FUNCTION_SUBSTRING_AFTER:
            jj_consume_token(FUNCTION_SUBSTRING_AFTER);
            code = Compiler.FUNCTION_SUBSTRING_AFTER;
            break;
        case FUNCTION_SUBSTRING:
            jj_consume_token(FUNCTION_SUBSTRING);
            code = Compiler.FUNCTION_SUBSTRING;
            break;
        case FUNCTION_STRING_LENGTH:
            jj_consume_token(FUNCTION_STRING_LENGTH);
            code = Compiler.FUNCTION_STRING_LENGTH;
            break;
        case FUNCTION_NORMALIZE_SPACE:
            jj_consume_token(FUNCTION_NORMALIZE_SPACE);
            code = Compiler.FUNCTION_NORMALIZE_SPACE;
            break;
        case FUNCTION_TRANSLATE:
            jj_consume_token(FUNCTION_TRANSLATE);
            code = Compiler.FUNCTION_TRANSLATE;
            break;
        case FUNCTION_BOOLEAN:
            jj_consume_token(FUNCTION_BOOLEAN);
            code = Compiler.FUNCTION_BOOLEAN;
            break;
        case FUNCTION_NOT:
            jj_consume_token(FUNCTION_NOT);
            code = Compiler.FUNCTION_NOT;
            break;
        case FUNCTION_TRUE:
            jj_consume_token(FUNCTION_TRUE);
            code = Compiler.FUNCTION_TRUE;
            break;
        case FUNCTION_FALSE:
            jj_consume_token(FUNCTION_FALSE);
            code = Compiler.FUNCTION_FALSE;
            break;
        case FUNCTION_NULL:
            jj_consume_token(FUNCTION_NULL);
            code = Compiler.FUNCTION_NULL;
            break;
        case FUNCTION_LANG:
            jj_consume_token(FUNCTION_LANG);
            code = Compiler.FUNCTION_LANG;
            break;
        case FUNCTION_NUMBER:
            jj_consume_token(FUNCTION_NUMBER);
            code = Compiler.FUNCTION_NUMBER;
            break;
        case FUNCTION_SUM:
            jj_consume_token(FUNCTION_SUM);
            code = Compiler.FUNCTION_SUM;
            break;
        case FUNCTION_FLOOR:
            jj_consume_token(FUNCTION_FLOOR);
            code = Compiler.FUNCTION_FLOOR;
            break;
        case FUNCTION_CEILING:
            jj_consume_token(FUNCTION_CEILING);
            code = Compiler.FUNCTION_CEILING;
            break;
        case FUNCTION_ROUND:
            jj_consume_token(FUNCTION_ROUND);
            code = Compiler.FUNCTION_ROUND;
            break;
        case FUNCTION_KEY:
            jj_consume_token(FUNCTION_KEY);
            code = Compiler.FUNCTION_KEY;
            break;
        case FUNCTION_FORMAT_NUMBER:
            jj_consume_token(FUNCTION_FORMAT_NUMBER);
            code = Compiler.FUNCTION_FORMAT_NUMBER;
            break;
        default:
            jj_la1[2] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    {
        if (true) {
            return code;
        }
    }
    throw new Error(""Missing return statement in function"");
}","int","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.QName()","Method","No Comment","final public Object QName() throws ParseException {
    String nc1, nc2 = null;
    nc1 = NCName();
    switch(jj_nt.kind) {
        case 80:
            jj_consume_token(80);
            nc2 = NCName();
            break;
        default:
            jj_la1[3] = jj_gen;
            ;
    }
    if (nc2 == null) {
        {
            if (true) {
                return compiler.qname(null, nc1);
            }
        }
    } else {
        {
            if (true) {
                return compiler.qname(nc1, nc2);
            }
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.QName_Without_CoreFunctions()","Method","No Comment","final public Object QName_Without_CoreFunctions() throws ParseException {
    String nc1, nc2 = null;
    if (jj_2_1(2147483647)) {
        nc1 = NCName();
        jj_consume_token(80);
        nc2 = NCName();
    } else {
        switch(jj_nt.kind) {
            case OR:
            case AND:
            case MOD:
            case DIV:
            case NCName:
                nc1 = NCName_Without_CoreFunctions();
                break;
            default:
                jj_la1[4] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }
    if (nc2 == null) {
        {
            if (true) {
                return compiler.qname(null, nc1);
            }
        }
    } else {
        {
            if (true) {
                return compiler.qname(nc1, nc2);
            }
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.parseExpression()","Method","No Comment","final public Object parseExpression() throws ParseException {
    Object ex;
    ex = Expression();
    jj_consume_token(0);
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.LocationPath()","Method","[1] LocationPath ::= RelativeLocationPath | AbsoluteLocationPath","final public Object LocationPath() throws ParseException {
    Object ex = null;
    switch(jj_nt.kind) {
        case OR:
        case AND:
        case MOD:
        case DIV:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case AXIS_SELF:
        case AXIS_CHILD:
        case AXIS_PARENT:
        case AXIS_ANCESTOR:
        case AXIS_ATTRIBUTE:
        case AXIS_NAMESPACE:
        case AXIS_PRECEDING:
        case AXIS_FOLLOWING:
        case AXIS_DESCENDANT:
        case AXIS_ANCESTOR_OR_SELF:
        case AXIS_FOLLOWING_SIBLING:
        case AXIS_PRECEDING_SIBLING:
        case AXIS_DESCENDANT_OR_SELF:
        case FUNCTION_LAST:
        case FUNCTION_POSITION:
        case FUNCTION_COUNT:
        case FUNCTION_ID:
        case FUNCTION_KEY:
        case FUNCTION_LOCAL_NAME:
        case FUNCTION_NAMESPACE_URI:
        case FUNCTION_NAME:
        case FUNCTION_STRING:
        case FUNCTION_CONCAT:
        case FUNCTION_STARTS_WITH:
        case FUNCTION_ENDS_WITH:
        case FUNCTION_CONTAINS:
        case FUNCTION_SUBSTRING_BEFORE:
        case FUNCTION_SUBSTRING_AFTER:
        case FUNCTION_SUBSTRING:
        case FUNCTION_STRING_LENGTH:
        case FUNCTION_NORMALIZE_SPACE:
        case FUNCTION_TRANSLATE:
        case FUNCTION_BOOLEAN:
        case FUNCTION_NOT:
        case FUNCTION_TRUE:
        case FUNCTION_FALSE:
        case FUNCTION_NULL:
        case FUNCTION_LANG:
        case FUNCTION_NUMBER:
        case FUNCTION_SUM:
        case FUNCTION_FLOOR:
        case FUNCTION_CEILING:
        case FUNCTION_ROUND:
        case FUNCTION_FORMAT_NUMBER:
        case NCName:
        case 83:
        case 84:
        case 87:
        case 89:
            ex = RelativeLocationPath();
            break;
        case SLASH:
        case SLASHSLASH:
            ex = AbsoluteLocationPath();
            break;
        default:
            jj_la1[5] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.AbsoluteLocationPath()","Method","[10]    AbbreviatedAbsoluteLocationPath    ::=    '//' RelativeLocationPath","final public Object AbsoluteLocationPath() throws ParseException {
    final ArrayList steps = new ArrayList();
    if (jj_2_2(2147483647)) {
        LocationStep(steps);
        label_1: while (true) {
            switch(jj_nt.kind) {
                case SLASH:
                case SLASHSLASH:
                    ;
                    break;
                default:
                    jj_la1[6] = jj_gen;
                    break label_1;
            }
            LocationStep(steps);
        }
    } else {
        switch(jj_nt.kind) {
            case SLASH:
                jj_consume_token(SLASH);
                break;
            default:
                jj_la1[7] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }
    {
        if (true) {
            return compiler.locationPath(true, steps.toArray());
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.RelativeLocationPath()","Method","[3] RelativeLocationPath ::= Step | RelativeLocationPath '/' Step | AbbreviatedRelativeLocationPath","final public Object RelativeLocationPath() throws ParseException {
    final ArrayList steps = new ArrayList();
    NodeTest(steps);
    label_2: while (true) {
        switch(jj_nt.kind) {
            case SLASH:
            case SLASHSLASH:
                ;
                break;
            default:
                jj_la1[8] = jj_gen;
                break label_2;
        }
        LocationStep(steps);
    }
    {
        if (true) {
            return compiler.locationPath(false, steps.toArray());
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.LocationStep(ArrayList)","Method","[4] Step ::= AxisSpecifier NodeTest Predicate*   | AbbreviatedStep","final public void LocationStep(final ArrayList steps) throws ParseException {
    Object t;
    final Object s;
    switch(jj_nt.kind) {
        case SLASH:
            jj_consume_token(SLASH);
            break;
        case SLASHSLASH:
            jj_consume_token(SLASHSLASH);
            // Abbreviated step: descendant-or-self::node()
            t = compiler.nodeTypeTest(Compiler.NODE_TYPE_NODE);
            steps.add(compiler.step(Compiler.AXIS_DESCENDANT_OR_SELF, t, null));
            break;
        default:
            jj_la1[9] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    NodeTest(steps);
}","void","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.LocationStep(ArrayList).steps","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.LocationStep(ArrayList)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.NodeTest(ArrayList)","Method","[7] NodeTest ::= WildcardName | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'","final public void NodeTest(final ArrayList steps) throws ParseException {
    int axis;
    int type = -1;
    String instruction = null;
    Object name = null;
    Object s;
    Object p;
    final ArrayList ps = new ArrayList();
    switch(jj_nt.kind) {
        case OR:
        case AND:
        case MOD:
        case DIV:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case AXIS_SELF:
        case AXIS_CHILD:
        case AXIS_PARENT:
        case AXIS_ANCESTOR:
        case AXIS_ATTRIBUTE:
        case AXIS_NAMESPACE:
        case AXIS_PRECEDING:
        case AXIS_FOLLOWING:
        case AXIS_DESCENDANT:
        case AXIS_ANCESTOR_OR_SELF:
        case AXIS_FOLLOWING_SIBLING:
        case AXIS_PRECEDING_SIBLING:
        case AXIS_DESCENDANT_OR_SELF:
        case FUNCTION_LAST:
        case FUNCTION_POSITION:
        case FUNCTION_COUNT:
        case FUNCTION_ID:
        case FUNCTION_KEY:
        case FUNCTION_LOCAL_NAME:
        case FUNCTION_NAMESPACE_URI:
        case FUNCTION_NAME:
        case FUNCTION_STRING:
        case FUNCTION_CONCAT:
        case FUNCTION_STARTS_WITH:
        case FUNCTION_ENDS_WITH:
        case FUNCTION_CONTAINS:
        case FUNCTION_SUBSTRING_BEFORE:
        case FUNCTION_SUBSTRING_AFTER:
        case FUNCTION_SUBSTRING:
        case FUNCTION_STRING_LENGTH:
        case FUNCTION_NORMALIZE_SPACE:
        case FUNCTION_TRANSLATE:
        case FUNCTION_BOOLEAN:
        case FUNCTION_NOT:
        case FUNCTION_TRUE:
        case FUNCTION_FALSE:
        case FUNCTION_NULL:
        case FUNCTION_LANG:
        case FUNCTION_NUMBER:
        case FUNCTION_SUM:
        case FUNCTION_FLOOR:
        case FUNCTION_CEILING:
        case FUNCTION_ROUND:
        case FUNCTION_FORMAT_NUMBER:
        case NCName:
        case 87:
        case 89:
            axis = AxisSpecifier();
            if (jj_2_3(2147483647)) {
                type = NodeType();
                jj_consume_token(81);
                jj_consume_token(82);
            } else if (jj_2_4(2147483647)) {
                jj_consume_token(PI);
                jj_consume_token(81);
                jj_consume_token(Literal);
                instruction = unescape(token.image.substring(1, token.image.length() - 1));
                jj_consume_token(82);
            } else {
                switch(jj_nt.kind) {
                    case OR:
                    case AND:
                    case MOD:
                    case DIV:
                    case NODE:
                    case TEXT:
                    case COMMENT:
                    case PI:
                    case FUNCTION_LAST:
                    case FUNCTION_POSITION:
                    case FUNCTION_COUNT:
                    case FUNCTION_ID:
                    case FUNCTION_KEY:
                    case FUNCTION_LOCAL_NAME:
                    case FUNCTION_NAMESPACE_URI:
                    case FUNCTION_NAME:
                    case FUNCTION_STRING:
                    case FUNCTION_CONCAT:
                    case FUNCTION_STARTS_WITH:
                    case FUNCTION_ENDS_WITH:
                    case FUNCTION_CONTAINS:
                    case FUNCTION_SUBSTRING_BEFORE:
                    case FUNCTION_SUBSTRING_AFTER:
                    case FUNCTION_SUBSTRING:
                    case FUNCTION_STRING_LENGTH:
                    case FUNCTION_NORMALIZE_SPACE:
                    case FUNCTION_TRANSLATE:
                    case FUNCTION_BOOLEAN:
                    case FUNCTION_NOT:
                    case FUNCTION_TRUE:
                    case FUNCTION_FALSE:
                    case FUNCTION_NULL:
                    case FUNCTION_LANG:
                    case FUNCTION_NUMBER:
                    case FUNCTION_SUM:
                    case FUNCTION_FLOOR:
                    case FUNCTION_CEILING:
                    case FUNCTION_ROUND:
                    case FUNCTION_FORMAT_NUMBER:
                    case NCName:
                    case 89:
                        name = WildcardName();
                        break;
                    default:
                        jj_la1[10] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
            break;
        case 83:
            jj_consume_token(83);
            axis = Compiler.AXIS_SELF;
            type = Compiler.NODE_TYPE_NODE;
            break;
        case 84:
            jj_consume_token(84);
            axis = Compiler.AXIS_PARENT;
            type = Compiler.NODE_TYPE_NODE;
            break;
        default:
            jj_la1[11] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    label_3: while (true) {
        switch(jj_nt.kind) {
            case 85:
                ;
                break;
            default:
                jj_la1[12] = jj_gen;
                break label_3;
        }
        p = Predicate();
        ps.add(p);
    }
    if (name != null) {
        s = compiler.nodeNameTest(name);
    } else if (instruction != null) {
        s = compiler.processingInstructionTest(instruction);
    } else {
        s = compiler.nodeTypeTest(type);
    }
    steps.add(compiler.step(axis, s, ps.toArray()));
}","void","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.NodeTest(ArrayList).steps","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.NodeTest(ArrayList)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.AxisSpecifier()","Method","[5] AxisSpecifier ::=    AxisName '::' | AbbreviatedAxisSpecifier","final public int AxisSpecifier() throws ParseException {
    int axis;
    switch(jj_nt.kind) {
        case AXIS_SELF:
        case AXIS_CHILD:
        case AXIS_PARENT:
        case AXIS_ANCESTOR:
        case AXIS_ATTRIBUTE:
        case AXIS_NAMESPACE:
        case AXIS_PRECEDING:
        case AXIS_FOLLOWING:
        case AXIS_DESCENDANT:
        case AXIS_ANCESTOR_OR_SELF:
        case AXIS_FOLLOWING_SIBLING:
        case AXIS_PRECEDING_SIBLING:
        case AXIS_DESCENDANT_OR_SELF:
            axis = AxisName();
            break;
        default:
            jj_la1[13] = jj_gen;
            axis = AbbreviatedAxisSpecifier();
    }
    {
        if (true) {
            return axis;
        }
    }
    throw new Error(""Missing return statement in function"");
}","int","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.AxisName()","Method","[6] AxisName ::= 'ancestor' | 'ancestor-or-self' | 'attribute'  | 'child' | 'descendant'
                    | 'descendant-or-self' | 'following' | 'following-sibling' | 'namespace'
                       | 'parent' | 'preceding' | 'preceding-sibling' | 'self'","final public int AxisName() throws ParseException {
    int axis = 0;
    switch(jj_nt.kind) {
        case AXIS_SELF:
            jj_consume_token(AXIS_SELF);
            axis = Compiler.AXIS_SELF;
            break;
        case AXIS_CHILD:
            jj_consume_token(AXIS_CHILD);
            axis = Compiler.AXIS_CHILD;
            break;
        case AXIS_PARENT:
            jj_consume_token(AXIS_PARENT);
            axis = Compiler.AXIS_PARENT;
            break;
        case AXIS_ANCESTOR:
            jj_consume_token(AXIS_ANCESTOR);
            axis = Compiler.AXIS_ANCESTOR;
            break;
        case AXIS_ATTRIBUTE:
            jj_consume_token(AXIS_ATTRIBUTE);
            axis = Compiler.AXIS_ATTRIBUTE;
            break;
        case AXIS_NAMESPACE:
            jj_consume_token(AXIS_NAMESPACE);
            axis = Compiler.AXIS_NAMESPACE;
            break;
        case AXIS_PRECEDING:
            jj_consume_token(AXIS_PRECEDING);
            axis = Compiler.AXIS_PRECEDING;
            break;
        case AXIS_FOLLOWING:
            jj_consume_token(AXIS_FOLLOWING);
            axis = Compiler.AXIS_FOLLOWING;
            break;
        case AXIS_DESCENDANT:
            jj_consume_token(AXIS_DESCENDANT);
            axis = Compiler.AXIS_DESCENDANT;
            break;
        case AXIS_ANCESTOR_OR_SELF:
            jj_consume_token(AXIS_ANCESTOR_OR_SELF);
            axis = Compiler.AXIS_ANCESTOR_OR_SELF;
            break;
        case AXIS_FOLLOWING_SIBLING:
            jj_consume_token(AXIS_FOLLOWING_SIBLING);
            axis = Compiler.AXIS_FOLLOWING_SIBLING;
            break;
        case AXIS_PRECEDING_SIBLING:
            jj_consume_token(AXIS_PRECEDING_SIBLING);
            axis = Compiler.AXIS_PRECEDING_SIBLING;
            break;
        case AXIS_DESCENDANT_OR_SELF:
            jj_consume_token(AXIS_DESCENDANT_OR_SELF);
            axis = Compiler.AXIS_DESCENDANT_OR_SELF;
            break;
        default:
            jj_la1[14] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    {
        if (true) {
            return axis;
        }
    }
    throw new Error(""Missing return statement in function"");
}","int","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.Predicate()","Method","[9] PredicateExpr ::=  Expr","final public Object Predicate() throws ParseException {
    Object ex;
    jj_consume_token(85);
    ex = Expression();
    jj_consume_token(86);
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.AbbreviatedAxisSpecifier()","Method","[13]    AbbreviatedAxisSpecifier    ::=    '@'?","final public int AbbreviatedAxisSpecifier() throws ParseException {
    int axis = Compiler.AXIS_CHILD;
    switch(jj_nt.kind) {
        case 87:
            jj_consume_token(87);
            axis = Compiler.AXIS_ATTRIBUTE;
            break;
        default:
            jj_la1[15] = jj_gen;
            ;
    }
    {
        if (true) {
            return axis;
        }
    }
    throw new Error(""Missing return statement in function"");
}","int","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.Expression()","Method","[14] Expr ::= OrExpr","final public Object Expression() throws ParseException {
    Object ex;
    ex = OrExpr();
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.PrimaryExpr()","Method","[15] PrimaryExpr ::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall","final public Object PrimaryExpr() throws ParseException {
    Object ex = null;
    switch(jj_nt.kind) {
        case VARIABLE:
            ex = VariableReference();
            break;
        case 81:
            jj_consume_token(81);
            ex = Expression();
            jj_consume_token(82);
            break;
        case Literal:
            jj_consume_token(Literal);
            ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1)));
            break;
        case Number:
            jj_consume_token(Number);
            ex = compiler.number(token.image);
            break;
        default:
            jj_la1[16] = jj_gen;
            if (jj_2_5(2147483647)) {
                ex = CoreFunctionCall();
            } else {
                switch(jj_nt.kind) {
                    case OR:
                    case AND:
                    case MOD:
                    case DIV:
                    case NODE:
                    case TEXT:
                    case COMMENT:
                    case PI:
                    case FUNCTION_LAST:
                    case FUNCTION_POSITION:
                    case FUNCTION_COUNT:
                    case FUNCTION_ID:
                    case FUNCTION_KEY:
                    case FUNCTION_LOCAL_NAME:
                    case FUNCTION_NAMESPACE_URI:
                    case FUNCTION_NAME:
                    case FUNCTION_STRING:
                    case FUNCTION_CONCAT:
                    case FUNCTION_STARTS_WITH:
                    case FUNCTION_ENDS_WITH:
                    case FUNCTION_CONTAINS:
                    case FUNCTION_SUBSTRING_BEFORE:
                    case FUNCTION_SUBSTRING_AFTER:
                    case FUNCTION_SUBSTRING:
                    case FUNCTION_STRING_LENGTH:
                    case FUNCTION_NORMALIZE_SPACE:
                    case FUNCTION_TRANSLATE:
                    case FUNCTION_BOOLEAN:
                    case FUNCTION_NOT:
                    case FUNCTION_TRUE:
                    case FUNCTION_FALSE:
                    case FUNCTION_NULL:
                    case FUNCTION_LANG:
                    case FUNCTION_NUMBER:
                    case FUNCTION_SUM:
                    case FUNCTION_FLOOR:
                    case FUNCTION_CEILING:
                    case FUNCTION_ROUND:
                    case FUNCTION_FORMAT_NUMBER:
                    case NCName:
                        ex = FunctionCall();
                        break;
                    default:
                        jj_la1[17] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.FunctionCall()","Method","[16]    FunctionCall    ::=    FunctionName '(' ( Argument ( ',' Argument)*)? ')'","final public Object FunctionCall() throws ParseException {
    Object name;
    ArrayList args;
    name = FunctionName();
    args = ArgumentList();
    if (args == null) {
        {
            if (true) {
                return compiler.function(name, null);
            }
        }
    } else {
        {
            if (true) {
                return compiler.function(name, args.toArray());
            }
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.CoreFunctionCall()","Method","No Comment","final public Object CoreFunctionCall() throws ParseException {
    int code = 0;
    ArrayList args;
    code = CoreFunctionName();
    args = ArgumentList();
    if (args == null) {
        {
            if (true) {
                return compiler.function(code, null);
            }
        }
    } else {
        {
            if (true) {
                return compiler.function(code, args.toArray());
            }
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.ArgumentList()","Method","No Comment","final public ArrayList ArgumentList() throws ParseException {
    ArrayList args = null;
    Object arg;
    jj_consume_token(81);
    switch(jj_nt.kind) {
        case SLASH:
        case SLASHSLASH:
        case MINUS:
        case VARIABLE:
        case Literal:
        case Number:
        case OR:
        case AND:
        case MOD:
        case DIV:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case AXIS_SELF:
        case AXIS_CHILD:
        case AXIS_PARENT:
        case AXIS_ANCESTOR:
        case AXIS_ATTRIBUTE:
        case AXIS_NAMESPACE:
        case AXIS_PRECEDING:
        case AXIS_FOLLOWING:
        case AXIS_DESCENDANT:
        case AXIS_ANCESTOR_OR_SELF:
        case AXIS_FOLLOWING_SIBLING:
        case AXIS_PRECEDING_SIBLING:
        case AXIS_DESCENDANT_OR_SELF:
        case FUNCTION_LAST:
        case FUNCTION_POSITION:
        case FUNCTION_COUNT:
        case FUNCTION_ID:
        case FUNCTION_KEY:
        case FUNCTION_LOCAL_NAME:
        case FUNCTION_NAMESPACE_URI:
        case FUNCTION_NAME:
        case FUNCTION_STRING:
        case FUNCTION_CONCAT:
        case FUNCTION_STARTS_WITH:
        case FUNCTION_ENDS_WITH:
        case FUNCTION_CONTAINS:
        case FUNCTION_SUBSTRING_BEFORE:
        case FUNCTION_SUBSTRING_AFTER:
        case FUNCTION_SUBSTRING:
        case FUNCTION_STRING_LENGTH:
        case FUNCTION_NORMALIZE_SPACE:
        case FUNCTION_TRANSLATE:
        case FUNCTION_BOOLEAN:
        case FUNCTION_NOT:
        case FUNCTION_TRUE:
        case FUNCTION_FALSE:
        case FUNCTION_NULL:
        case FUNCTION_LANG:
        case FUNCTION_NUMBER:
        case FUNCTION_SUM:
        case FUNCTION_FLOOR:
        case FUNCTION_CEILING:
        case FUNCTION_ROUND:
        case FUNCTION_FORMAT_NUMBER:
        case NCName:
        case 81:
        case 83:
        case 84:
        case 87:
        case 89:
            arg = Argument();
            args = new ArrayList();
            args.add(arg);
            label_4: while (true) {
                switch(jj_nt.kind) {
                    case 88:
                        ;
                        break;
                    default:
                        jj_la1[18] = jj_gen;
                        break label_4;
                }
                jj_consume_token(88);
                arg = Argument();
                args.add(arg);
            }
            break;
        default:
            jj_la1[19] = jj_gen;
            ;
    }
    jj_consume_token(82);
    {
        if (true) {
            return args;
        }
    }
    throw new Error(""Missing return statement in function"");
}","ArrayList","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.Argument()","Method","[17]    Argument    ::=    Expr","final public Object Argument() throws ParseException {
    Object ex;
    ex = Expression();
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.UnionExpr()","Method","[18] UnionExpr    ::=    PathExpr | UnionExpr '|' PathExpr","final public Object UnionExpr() throws ParseException {
    Object ex, r;
    ArrayList list = null;
    ex = PathExpr();
    label_5: while (true) {
        switch(jj_nt.kind) {
            case UNION:
                ;
                break;
            default:
                jj_la1[20] = jj_gen;
                break label_5;
        }
        jj_consume_token(UNION);
        r = PathExpr();
        if (list == null) {
            list = new ArrayList();
            list.add(ex);
        }
        list.add(r);
    }
    if (list != null) {
        ex = compiler.union(list.toArray());
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.PathExpr()","Method","[19] PathExpr ::= LocationPath | FilterExpr | FilterExpr '/' RelativeLocationPath | FilterExpr '//' RelativeLocationPath","final public Object PathExpr() throws ParseException {
    Object ex = null;
    final Object[] steps;
    if (jj_2_6(2147483647)) {
        ex = FilterExpr();
    } else {
        switch(jj_nt.kind) {
            case SLASH:
            case SLASHSLASH:
            case OR:
            case AND:
            case MOD:
            case DIV:
            case NODE:
            case TEXT:
            case COMMENT:
            case PI:
            case AXIS_SELF:
            case AXIS_CHILD:
            case AXIS_PARENT:
            case AXIS_ANCESTOR:
            case AXIS_ATTRIBUTE:
            case AXIS_NAMESPACE:
            case AXIS_PRECEDING:
            case AXIS_FOLLOWING:
            case AXIS_DESCENDANT:
            case AXIS_ANCESTOR_OR_SELF:
            case AXIS_FOLLOWING_SIBLING:
            case AXIS_PRECEDING_SIBLING:
            case AXIS_DESCENDANT_OR_SELF:
            case FUNCTION_LAST:
            case FUNCTION_POSITION:
            case FUNCTION_COUNT:
            case FUNCTION_ID:
            case FUNCTION_KEY:
            case FUNCTION_LOCAL_NAME:
            case FUNCTION_NAMESPACE_URI:
            case FUNCTION_NAME:
            case FUNCTION_STRING:
            case FUNCTION_CONCAT:
            case FUNCTION_STARTS_WITH:
            case FUNCTION_ENDS_WITH:
            case FUNCTION_CONTAINS:
            case FUNCTION_SUBSTRING_BEFORE:
            case FUNCTION_SUBSTRING_AFTER:
            case FUNCTION_SUBSTRING:
            case FUNCTION_STRING_LENGTH:
            case FUNCTION_NORMALIZE_SPACE:
            case FUNCTION_TRANSLATE:
            case FUNCTION_BOOLEAN:
            case FUNCTION_NOT:
            case FUNCTION_TRUE:
            case FUNCTION_FALSE:
            case FUNCTION_NULL:
            case FUNCTION_LANG:
            case FUNCTION_NUMBER:
            case FUNCTION_SUM:
            case FUNCTION_FLOOR:
            case FUNCTION_CEILING:
            case FUNCTION_ROUND:
            case FUNCTION_FORMAT_NUMBER:
            case NCName:
            case 83:
            case 84:
            case 87:
            case 89:
                ex = LocationPath();
                break;
            default:
                jj_la1[21] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.FilterExpr()","Method","[20]    FilterExpr    ::=    PrimaryExpr    | FilterExpr Predicate","final public Object FilterExpr() throws ParseException {
    Object ex, p;
    final ArrayList ps = new ArrayList();
    boolean path = false;
    final ArrayList steps = new ArrayList();
    ex = PrimaryExpr();
    label_6: while (true) {
        switch(jj_nt.kind) {
            case 85:
                ;
                break;
            default:
                jj_la1[22] = jj_gen;
                break label_6;
        }
        p = Predicate();
        path = true;
        ps.add(p);
    }
    label_7: while (true) {
        switch(jj_nt.kind) {
            case SLASH:
            case SLASHSLASH:
                ;
                break;
            default:
                jj_la1[23] = jj_gen;
                break label_7;
        }
        LocationStep(steps);
        path = true;
    }
    if (path) {
        {
            if (true) {
                return compiler.expressionPath(ex, ps.toArray(), steps.toArray());
            }
        }
    } else {
        {
            if (true) {
                return ex;
            }
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.OrExpr()","Method","[21] OrExpr    ::=    AndExpr | OrExpr 'or' AndExpr","final public Object OrExpr() throws ParseException {
    Object ex, r;
    ArrayList list = null;
    ex = AndExpr();
    label_8: while (true) {
        switch(jj_nt.kind) {
            case OR:
                ;
                break;
            default:
                jj_la1[24] = jj_gen;
                break label_8;
        }
        jj_consume_token(OR);
        r = AndExpr();
        if (list == null) {
            list = new ArrayList();
            list.add(ex);
        }
        list.add(r);
    }
    if (list != null) {
        ex = compiler.or(list.toArray());
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.AndExpr()","Method","[22] AndExpr    ::=    EqualityExpr  | AndExpr 'and' EqualityExpr","final public Object AndExpr() throws ParseException {
    Object ex, r;
    ArrayList list = null;
    ex = EqualityExpr();
    label_9: while (true) {
        switch(jj_nt.kind) {
            case AND:
                ;
                break;
            default:
                jj_la1[25] = jj_gen;
                break label_9;
        }
        jj_consume_token(AND);
        r = EqualityExpr();
        if (list == null) {
            list = new ArrayList();
            list.add(ex);
        }
        list.add(r);
    }
    if (list != null) {
        ex = compiler.and(list.toArray());
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.EqualityExpr()","Method","[23] EqualityExpr    ::=    RelationalExpr | EqualityExpr '=' RelationalExpr | EqualityExpr '!=' RelationalExpr","final public Object EqualityExpr() throws ParseException {
    Object ex, r;
    ex = RelationalExpr();
    label_10: while (true) {
        switch(jj_nt.kind) {
            case EQ:
            case NEQ:
                ;
                break;
            default:
                jj_la1[26] = jj_gen;
                break label_10;
        }
        switch(jj_nt.kind) {
            case EQ:
                jj_consume_token(EQ);
                r = RelationalExpr();
                ex = compiler.equal(ex, r);
                break;
            case NEQ:
                jj_consume_token(NEQ);
                r = RelationalExpr();
                ex = compiler.notEqual(ex, r);
                break;
            default:
                jj_la1[27] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.RelationalExpr()","Method","[24] RelationalExpr    ::=    AdditiveExpr | RelationalExpr '<' AdditiveExpr | RelationalExpr '>' AdditiveExpr
                       | RelationalExpr '<=' AdditiveExpr  | RelationalExpr '>=' AdditiveExpr","final public Object RelationalExpr() throws ParseException {
    Object ex, r;
    ex = AdditiveExpr();
    label_11: while (true) {
        switch(jj_nt.kind) {
            case LT:
            case LTE:
            case GT:
            case GTE:
                ;
                break;
            default:
                jj_la1[28] = jj_gen;
                break label_11;
        }
        switch(jj_nt.kind) {
            case LT:
                jj_consume_token(LT);
                r = AdditiveExpr();
                ex = compiler.lessThan(ex, r);
                break;
            case GT:
                jj_consume_token(GT);
                r = AdditiveExpr();
                ex = compiler.greaterThan(ex, r);
                break;
            case LTE:
                jj_consume_token(LTE);
                r = AdditiveExpr();
                ex = compiler.lessThanOrEqual(ex, r);
                break;
            case GTE:
                jj_consume_token(GTE);
                r = AdditiveExpr();
                ex = compiler.greaterThanOrEqual(ex, r);
                break;
            default:
                jj_la1[29] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.AdditiveExpr()","Method","[25] AdditiveExpr ::= MultiplicativeExpr  | AdditiveExpr '+' MultiplicativeExpr  | AdditiveExpr '-' MultiplicativeExpr","final public Object AdditiveExpr() throws ParseException {
    Object ex, r;
    ArrayList list = null;
    ex = SubtractiveExpr();
    label_12: while (true) {
        switch(jj_nt.kind) {
            case PLUS:
                ;
                break;
            default:
                jj_la1[30] = jj_gen;
                break label_12;
        }
        jj_consume_token(PLUS);
        r = SubtractiveExpr();
        if (list == null) {
            list = new ArrayList();
            list.add(ex);
        }
        list.add(r);
    }
    if (list != null) {
        ex = compiler.sum(list.toArray());
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.SubtractiveExpr()","Method","No Comment","final public Object SubtractiveExpr() throws ParseException {
    Object ex, r = null;
    ex = MultiplicativeExpr();
    label_13: while (true) {
        switch(jj_nt.kind) {
            case MINUS:
                ;
                break;
            default:
                jj_la1[31] = jj_gen;
                break label_13;
        }
        jj_consume_token(MINUS);
        r = MultiplicativeExpr();
        ex = compiler.minus(ex, r);
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.MultiplicativeExpr()","Method","[26] MultiplicativeExpr ::= UnaryExpr | MultiplicativeExpr MultiplyOperator UnaryExpr
            | MultiplicativeExpr 'div' UnaryExpr | MultiplicativeExpr 'mod' UnaryExpr","final public Object MultiplicativeExpr() throws ParseException {
    Object ex, r;
    ex = UnaryExpr();
    label_14: while (true) {
        switch(jj_nt.kind) {
            case MOD:
            case DIV:
            case 89:
                ;
                break;
            default:
                jj_la1[32] = jj_gen;
                break label_14;
        }
        switch(jj_nt.kind) {
            case 89:
                jj_consume_token(89);
                r = UnaryExpr();
                ex = compiler.multiply(ex, r);
                break;
            case DIV:
                jj_consume_token(DIV);
                r = UnaryExpr();
                ex = compiler.divide(ex, r);
                break;
            case MOD:
                jj_consume_token(MOD);
                r = UnaryExpr();
                ex = compiler.mod(ex, r);
                break;
            default:
                jj_la1[33] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.UnaryExpr()","Method","[27]    UnaryExpr    ::=    UnionExpr  | '-' UnaryExpr","final public Object UnaryExpr() throws ParseException {
    Object ex;
    switch(jj_nt.kind) {
        case SLASH:
        case SLASHSLASH:
        case VARIABLE:
        case Literal:
        case Number:
        case OR:
        case AND:
        case MOD:
        case DIV:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case AXIS_SELF:
        case AXIS_CHILD:
        case AXIS_PARENT:
        case AXIS_ANCESTOR:
        case AXIS_ATTRIBUTE:
        case AXIS_NAMESPACE:
        case AXIS_PRECEDING:
        case AXIS_FOLLOWING:
        case AXIS_DESCENDANT:
        case AXIS_ANCESTOR_OR_SELF:
        case AXIS_FOLLOWING_SIBLING:
        case AXIS_PRECEDING_SIBLING:
        case AXIS_DESCENDANT_OR_SELF:
        case FUNCTION_LAST:
        case FUNCTION_POSITION:
        case FUNCTION_COUNT:
        case FUNCTION_ID:
        case FUNCTION_KEY:
        case FUNCTION_LOCAL_NAME:
        case FUNCTION_NAMESPACE_URI:
        case FUNCTION_NAME:
        case FUNCTION_STRING:
        case FUNCTION_CONCAT:
        case FUNCTION_STARTS_WITH:
        case FUNCTION_ENDS_WITH:
        case FUNCTION_CONTAINS:
        case FUNCTION_SUBSTRING_BEFORE:
        case FUNCTION_SUBSTRING_AFTER:
        case FUNCTION_SUBSTRING:
        case FUNCTION_STRING_LENGTH:
        case FUNCTION_NORMALIZE_SPACE:
        case FUNCTION_TRANSLATE:
        case FUNCTION_BOOLEAN:
        case FUNCTION_NOT:
        case FUNCTION_TRUE:
        case FUNCTION_FALSE:
        case FUNCTION_NULL:
        case FUNCTION_LANG:
        case FUNCTION_NUMBER:
        case FUNCTION_SUM:
        case FUNCTION_FLOOR:
        case FUNCTION_CEILING:
        case FUNCTION_ROUND:
        case FUNCTION_FORMAT_NUMBER:
        case NCName:
        case 81:
        case 83:
        case 84:
        case 87:
        case 89:
            ex = UnionExpr();
            break;
        case MINUS:
            jj_consume_token(MINUS);
            ex = UnaryExpr();
            ex = compiler.minus(ex);
            break;
        default:
            jj_la1[34] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    {
        if (true) {
            return ex;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.FunctionName()","Method","[35]    FunctionName    ::=    QName - NodeType","final public Object FunctionName() throws ParseException {
    Object qname;
    qname = QName_Without_CoreFunctions();
    {
        if (true) {
            return qname;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.VariableReference()","Method","[36]    VariableReference    ::=    '$' QName","final public Object VariableReference() throws ParseException {
    Object ex;
    jj_consume_token(VARIABLE);
    ex = QName();
    {
        if (true) {
            return compiler.variableReference(ex);
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.WildcardName()","Method","[37]    WildcardName    ::=    '*'     | NCName ':' '*'     | QName","final public Object WildcardName() throws ParseException {
    Object qn;
    String nc1, nc2 = null;
    switch(jj_nt.kind) {
        case 89:
            jj_consume_token(89);
            break;
        case OR:
        case AND:
        case MOD:
        case DIV:
        case NODE:
        case TEXT:
        case COMMENT:
        case PI:
        case FUNCTION_LAST:
        case FUNCTION_POSITION:
        case FUNCTION_COUNT:
        case FUNCTION_ID:
        case FUNCTION_KEY:
        case FUNCTION_LOCAL_NAME:
        case FUNCTION_NAMESPACE_URI:
        case FUNCTION_NAME:
        case FUNCTION_STRING:
        case FUNCTION_CONCAT:
        case FUNCTION_STARTS_WITH:
        case FUNCTION_ENDS_WITH:
        case FUNCTION_CONTAINS:
        case FUNCTION_SUBSTRING_BEFORE:
        case FUNCTION_SUBSTRING_AFTER:
        case FUNCTION_SUBSTRING:
        case FUNCTION_STRING_LENGTH:
        case FUNCTION_NORMALIZE_SPACE:
        case FUNCTION_TRANSLATE:
        case FUNCTION_BOOLEAN:
        case FUNCTION_NOT:
        case FUNCTION_TRUE:
        case FUNCTION_FALSE:
        case FUNCTION_NULL:
        case FUNCTION_LANG:
        case FUNCTION_NUMBER:
        case FUNCTION_SUM:
        case FUNCTION_FLOOR:
        case FUNCTION_CEILING:
        case FUNCTION_ROUND:
        case FUNCTION_FORMAT_NUMBER:
        case NCName:
            NCName();
            break;
        default:
            jj_la1[35] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    nc1 = token.image;
    switch(jj_nt.kind) {
        case 80:
            jj_consume_token(80);
            switch(jj_nt.kind) {
                case 89:
                    jj_consume_token(89);
                    break;
                case OR:
                case AND:
                case MOD:
                case DIV:
                case NODE:
                case TEXT:
                case COMMENT:
                case PI:
                case FUNCTION_LAST:
                case FUNCTION_POSITION:
                case FUNCTION_COUNT:
                case FUNCTION_ID:
                case FUNCTION_KEY:
                case FUNCTION_LOCAL_NAME:
                case FUNCTION_NAMESPACE_URI:
                case FUNCTION_NAME:
                case FUNCTION_STRING:
                case FUNCTION_CONCAT:
                case FUNCTION_STARTS_WITH:
                case FUNCTION_ENDS_WITH:
                case FUNCTION_CONTAINS:
                case FUNCTION_SUBSTRING_BEFORE:
                case FUNCTION_SUBSTRING_AFTER:
                case FUNCTION_SUBSTRING:
                case FUNCTION_STRING_LENGTH:
                case FUNCTION_NORMALIZE_SPACE:
                case FUNCTION_TRANSLATE:
                case FUNCTION_BOOLEAN:
                case FUNCTION_NOT:
                case FUNCTION_TRUE:
                case FUNCTION_FALSE:
                case FUNCTION_NULL:
                case FUNCTION_LANG:
                case FUNCTION_NUMBER:
                case FUNCTION_SUM:
                case FUNCTION_FLOOR:
                case FUNCTION_CEILING:
                case FUNCTION_ROUND:
                case FUNCTION_FORMAT_NUMBER:
                case NCName:
                    NCName();
                    break;
                default:
                    jj_la1[36] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            nc2 = token.image;
            break;
        default:
            jj_la1[37] = jj_gen;
            ;
    }
    if (nc2 != null) {
        qn = compiler.qname(nc1, nc2);
    } else {
        qn = compiler.qname(null, nc1);
    }
    {
        if (true) {
            return qn;
        }
    }
    throw new Error(""Missing return statement in function"");
}","Object","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.NodeType()","Method","[38]    NodeType    ::=    'comment' | 'text'  | 'processing-instruction'  | 'node'","final public int NodeType() throws ParseException {
    int type;
    switch(jj_nt.kind) {
        case TEXT:
            jj_consume_token(TEXT);
            type = Compiler.NODE_TYPE_TEXT;
            break;
        case NODE:
            jj_consume_token(NODE);
            type = Compiler.NODE_TYPE_NODE;
            break;
        case COMMENT:
            jj_consume_token(COMMENT);
            type = Compiler.NODE_TYPE_COMMENT;
            break;
        case PI:
            jj_consume_token(PI);
            type = Compiler.NODE_TYPE_PI;
            break;
        default:
            jj_la1[38] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
    }
    {
        if (true) {
            return type;
        }
    }
    throw new Error(""Missing return statement in function"");
}","int","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_1(int)","Method","No Comment","private boolean jj_2_1(final int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    try {
        return !jj_3_1();
    } catch (final LookaheadSuccess ls) {
        return true;
    } finally {
        jj_save(0, xla);
    }
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_1(int).xla","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_1(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_2(int)","Method","No Comment","private boolean jj_2_2(final int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    try {
        return !jj_3_2();
    } catch (final LookaheadSuccess ls) {
        return true;
    } finally {
        jj_save(1, xla);
    }
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_2(int).xla","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_2(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_3(int)","Method","No Comment","private boolean jj_2_3(final int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    try {
        return !jj_3_3();
    } catch (final LookaheadSuccess ls) {
        return true;
    } finally {
        jj_save(2, xla);
    }
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_3(int).xla","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_3(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_4(int)","Method","No Comment","private boolean jj_2_4(final int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    try {
        return !jj_3_4();
    } catch (final LookaheadSuccess ls) {
        return true;
    } finally {
        jj_save(3, xla);
    }
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_4(int).xla","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_4(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_5(int)","Method","No Comment","private boolean jj_2_5(final int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    try {
        return !jj_3_5();
    } catch (final LookaheadSuccess ls) {
        return true;
    } finally {
        jj_save(4, xla);
    }
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_5(int).xla","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_5(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_6(int)","Method","No Comment","private boolean jj_2_6(final int xla) {
    jj_la = xla;
    jj_lastpos = jj_scanpos = token;
    try {
        return !jj_3_6();
    } catch (final LookaheadSuccess ls) {
        return true;
    } finally {
        jj_save(5, xla);
    }
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_6(int).xla","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_2_6(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3_2()","Method","No Comment","private boolean jj_3_2() {
    if (jj_3R_16()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_144()","Method","No Comment","private boolean jj_3R_144() {
    if (jj_3R_16()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_143()","Method","No Comment","private boolean jj_3R_143() {
    if (jj_3R_77()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_150()","Method","No Comment","private boolean jj_3R_150() {
    if (jj_3R_16()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_151()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_132()","Method","No Comment","private boolean jj_3R_132() {
    if (jj_scan_token(MINUS)) {
        return true;
    }
    if (jj_3R_129()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_130()","Method","No Comment","private boolean jj_3R_130() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_133()) {
        jj_scanpos = xsp;
        if (jj_3R_134()) {
            jj_scanpos = xsp;
            if (jj_3R_135()) {
                return true;
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_148()","Method","No Comment","private boolean jj_3R_148() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_150()) {
        jj_scanpos = xsp;
        if (jj_scan_token(6)) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_131()","Method","No Comment","private boolean jj_3R_131() {
    if (jj_3R_136()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_64()","Method","No Comment","private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
        jj_scanpos = xsp;
        if (jj_scan_token(27)) {
            jj_scanpos = xsp;
            if (jj_scan_token(28)) {
                jj_scanpos = xsp;
                if (jj_scan_token(29)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(30)) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_113()","Method","No Comment","private boolean jj_3R_113() {
    if (jj_scan_token(87)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_91()","Method","No Comment","private boolean jj_3R_91() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_113()) {
        jj_scanpos = xsp;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_141()","Method","No Comment","private boolean jj_3R_141() {
    if (jj_3R_19()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_143()) {
            jj_scanpos = xsp;
            break;
        }
    }
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_144()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_129()","Method","No Comment","private boolean jj_3R_129() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_131()) {
        jj_scanpos = xsp;
        if (jj_3R_132()) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3_6()","Method","No Comment","private boolean jj_3_6() {
    if (jj_3R_19()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_146()","Method","No Comment","private boolean jj_3R_146() {
    if (jj_3R_148()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_135()","Method","No Comment","private boolean jj_3R_135() {
    if (jj_scan_token(MOD)) {
        return true;
    }
    if (jj_3R_129()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_145()","Method","No Comment","private boolean jj_3R_145() {
    if (jj_3R_147()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_134()","Method","No Comment","private boolean jj_3R_134() {
    if (jj_scan_token(DIV)) {
        return true;
    }
    if (jj_3R_129()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_133()","Method","No Comment","private boolean jj_3R_133() {
    if (jj_scan_token(89)) {
        return true;
    }
    if (jj_3R_129()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_142()","Method","No Comment","private boolean jj_3R_142() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) {
        jj_scanpos = xsp;
        if (jj_3R_146()) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_140()","Method","No Comment","private boolean jj_3R_140() {
    if (jj_3R_142()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_139()","Method","No Comment","private boolean jj_3R_139() {
    if (jj_3R_141()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_77()","Method","No Comment","private boolean jj_3R_77() {
    if (jj_scan_token(85)) {
        return true;
    }
    if (jj_3R_70()) {
        return true;
    }
    if (jj_scan_token(86)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_127()","Method","No Comment","private boolean jj_3R_127() {
    if (jj_3R_129()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_130()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_137()","Method","No Comment","private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_139()) {
        jj_scanpos = xsp;
        if (jj_3R_140()) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_128()","Method","No Comment","private boolean jj_3R_128() {
    if (jj_scan_token(MINUS)) {
        return true;
    }
    if (jj_3R_127()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_112()","Method","No Comment","private boolean jj_3R_112() {
    if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_111()","Method","No Comment","private boolean jj_3R_111() {
    if (jj_scan_token(AXIS_PRECEDING_SIBLING)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_110()","Method","No Comment","private boolean jj_3R_110() {
    if (jj_scan_token(AXIS_FOLLOWING_SIBLING)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_122()","Method","No Comment","private boolean jj_3R_122() {
    if (jj_scan_token(PLUS)) {
        return true;
    }
    if (jj_3R_121()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_109()","Method","No Comment","private boolean jj_3R_109() {
    if (jj_scan_token(AXIS_ANCESTOR_OR_SELF)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_108()","Method","No Comment","private boolean jj_3R_108() {
    if (jj_scan_token(AXIS_DESCENDANT)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_107()","Method","No Comment","private boolean jj_3R_107() {
    if (jj_scan_token(AXIS_FOLLOWING)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_106()","Method","No Comment","private boolean jj_3R_106() {
    if (jj_scan_token(AXIS_PRECEDING)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_121()","Method","No Comment","private boolean jj_3R_121() {
    if (jj_3R_127()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_128()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_105()","Method","No Comment","private boolean jj_3R_105() {
    if (jj_scan_token(AXIS_NAMESPACE)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_104()","Method","No Comment","private boolean jj_3R_104() {
    if (jj_scan_token(AXIS_ATTRIBUTE)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_103()","Method","No Comment","private boolean jj_3R_103() {
    if (jj_scan_token(AXIS_ANCESTOR)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_20()","Method","No Comment","private boolean jj_3R_20() {
    if (jj_3R_64()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_102()","Method","No Comment","private boolean jj_3R_102() {
    if (jj_scan_token(AXIS_PARENT)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_101()","Method","No Comment","private boolean jj_3R_101() {
    if (jj_scan_token(AXIS_CHILD)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_100()","Method","No Comment","private boolean jj_3R_100() {
    if (jj_scan_token(AXIS_SELF)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_138()","Method","No Comment","private boolean jj_3R_138() {
    if (jj_scan_token(UNION)) {
        return true;
    }
    if (jj_3R_137()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_15()","Method","No Comment","private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) {
        jj_scanpos = xsp;
        if (jj_scan_token(31)) {
            jj_scanpos = xsp;
            if (jj_scan_token(32)) {
                jj_scanpos = xsp;
                if (jj_scan_token(33)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(34)) {
                        jj_scanpos = xsp;
                        if (jj_scan_token(48)) {
                            jj_scanpos = xsp;
                            if (jj_scan_token(49)) {
                                jj_scanpos = xsp;
                                if (jj_scan_token(50)) {
                                    jj_scanpos = xsp;
                                    if (jj_scan_token(51)) {
                                        jj_scanpos = xsp;
                                        if (jj_scan_token(53)) {
                                            jj_scanpos = xsp;
                                            if (jj_scan_token(54)) {
                                                jj_scanpos = xsp;
                                                if (jj_scan_token(55)) {
                                                    jj_scanpos = xsp;
                                                    if (jj_scan_token(56)) {
                                                        jj_scanpos = xsp;
                                                        if (jj_scan_token(57)) {
                                                            jj_scanpos = xsp;
                                                            if (jj_scan_token(58)) {
                                                                jj_scanpos = xsp;
                                                                if (jj_scan_token(59)) {
                                                                    jj_scanpos = xsp;
                                                                    if (jj_scan_token(60)) {
                                                                        jj_scanpos = xsp;
                                                                        if (jj_scan_token(61)) {
                                                                            jj_scanpos = xsp;
                                                                            if (jj_scan_token(62)) {
                                                                                jj_scanpos = xsp;
                                                                                if (jj_scan_token(63)) {
                                                                                    jj_scanpos = xsp;
                                                                                    if (jj_scan_token(64)) {
                                                                                        jj_scanpos = xsp;
                                                                                        if (jj_scan_token(65)) {
                                                                                            jj_scanpos = xsp;
                                                                                            if (jj_scan_token(66)) {
                                                                                                jj_scanpos = xsp;
                                                                                                if (jj_scan_token(67)) {
                                                                                                    jj_scanpos = xsp;
                                                                                                    if (jj_scan_token(68)) {
                                                                                                        jj_scanpos = xsp;
                                                                                                        if (jj_scan_token(69)) {
                                                                                                            jj_scanpos = xsp;
                                                                                                            if (jj_scan_token(70)) {
                                                                                                                jj_scanpos = xsp;
                                                                                                                if (jj_scan_token(71)) {
                                                                                                                    jj_scanpos = xsp;
                                                                                                                    if (jj_scan_token(72)) {
                                                                                                                        jj_scanpos = xsp;
                                                                                                                        if (jj_scan_token(73)) {
                                                                                                                            jj_scanpos = xsp;
                                                                                                                            if (jj_scan_token(74)) {
                                                                                                                                jj_scanpos = xsp;
                                                                                                                                if (jj_scan_token(75)) {
                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                    if (jj_scan_token(76)) {
                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                        if (jj_scan_token(77)) {
                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                            if (jj_scan_token(52)) {
                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                if (jj_scan_token(78)) {
                                                                                                                                                    return true;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_90()","Method","No Comment","private boolean jj_3R_90() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) {
        jj_scanpos = xsp;
        if (jj_3R_101()) {
            jj_scanpos = xsp;
            if (jj_3R_102()) {
                jj_scanpos = xsp;
                if (jj_3R_103()) {
                    jj_scanpos = xsp;
                    if (jj_3R_104()) {
                        jj_scanpos = xsp;
                        if (jj_3R_105()) {
                            jj_scanpos = xsp;
                            if (jj_3R_106()) {
                                jj_scanpos = xsp;
                                if (jj_3R_107()) {
                                    jj_scanpos = xsp;
                                    if (jj_3R_108()) {
                                        jj_scanpos = xsp;
                                        if (jj_3R_109()) {
                                            jj_scanpos = xsp;
                                            if (jj_3R_110()) {
                                                jj_scanpos = xsp;
                                                if (jj_3R_111()) {
                                                    jj_scanpos = xsp;
                                                    if (jj_3R_112()) {
                                                        return true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_136()","Method","No Comment","private boolean jj_3R_136() {
    if (jj_3R_137()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_138()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_118()","Method","No Comment","private boolean jj_3R_118() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_123()) {
        jj_scanpos = xsp;
        if (jj_3R_124()) {
            jj_scanpos = xsp;
            if (jj_3R_125()) {
                jj_scanpos = xsp;
                if (jj_3R_126()) {
                    return true;
                }
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_117()","Method","No Comment","private boolean jj_3R_117() {
    if (jj_3R_121()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_122()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_83()","Method","No Comment","private boolean jj_3R_83() {
    if (jj_3R_91()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_82()","Method","No Comment","private boolean jj_3R_82() {
    if (jj_3R_90()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_96()","Method","No Comment","private boolean jj_3R_96() {
    if (jj_3R_70()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_126()","Method","No Comment","private boolean jj_3R_126() {
    if (jj_scan_token(GTE)) {
        return true;
    }
    if (jj_3R_117()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_97()","Method","No Comment","private boolean jj_3R_97() {
    if (jj_scan_token(88)) {
        return true;
    }
    if (jj_3R_96()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_125()","Method","No Comment","private boolean jj_3R_125() {
    if (jj_scan_token(LTE)) {
        return true;
    }
    if (jj_3R_117()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_73()","Method","No Comment","private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) {
        jj_scanpos = xsp;
        if (jj_3R_83()) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_124()","Method","No Comment","private boolean jj_3R_124() {
    if (jj_scan_token(GT)) {
        return true;
    }
    if (jj_3R_117()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_116()","Method","No Comment","private boolean jj_3R_116() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_119()) {
        jj_scanpos = xsp;
        if (jj_3R_120()) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_123()","Method","No Comment","private boolean jj_3R_123() {
    if (jj_scan_token(LT)) {
        return true;
    }
    if (jj_3R_117()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_88()","Method","No Comment","private boolean jj_3R_88() {
    if (jj_3R_96()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_97()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_115()","Method","No Comment","private boolean jj_3R_115() {
    if (jj_3R_117()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_118()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_26()","Method","No Comment","private boolean jj_3R_26() {
    if (jj_scan_token(PI)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_80()","Method","No Comment","private boolean jj_3R_80() {
    if (jj_scan_token(81)) {
        return true;
    }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_88()) {
        jj_scanpos = xsp;
    }
    if (jj_scan_token(82)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_25()","Method","No Comment","private boolean jj_3R_25() {
    if (jj_scan_token(COMMENT)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_24()","Method","No Comment","private boolean jj_3R_24() {
    if (jj_scan_token(NODE)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_120()","Method","No Comment","private boolean jj_3R_120() {
    if (jj_scan_token(NEQ)) {
        return true;
    }
    if (jj_3R_115()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_23()","Method","No Comment","private boolean jj_3R_23() {
    if (jj_scan_token(TEXT)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_119()","Method","No Comment","private boolean jj_3R_119() {
    if (jj_scan_token(EQ)) {
        return true;
    }
    if (jj_3R_115()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_68()","Method","No Comment","private boolean jj_3R_68() {
    if (jj_3R_77()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3_1()","Method","No Comment","private boolean jj_3_1() {
    if (jj_3R_15()) {
        return true;
    }
    if (jj_scan_token(80)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3_4()","Method","No Comment","private boolean jj_3_4() {
    if (jj_scan_token(PI)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3_3()","Method","No Comment","private boolean jj_3_3() {
    if (jj_3R_17()) {
        return true;
    }
    if (jj_scan_token(81)) {
        return true;
    }
    if (jj_scan_token(82)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_17()","Method","No Comment","private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) {
        jj_scanpos = xsp;
        if (jj_3R_24()) {
            jj_scanpos = xsp;
            if (jj_3R_25()) {
                jj_scanpos = xsp;
                if (jj_3R_26()) {
                    return true;
                }
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_67()","Method","No Comment","private boolean jj_3R_67() {
    if (jj_scan_token(84)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_114()","Method","No Comment","private boolean jj_3R_114() {
    if (jj_3R_15()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_66()","Method","No Comment","private boolean jj_3R_66() {
    if (jj_scan_token(83)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_94()","Method","No Comment","private boolean jj_3R_94() {
    if (jj_3R_115()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_116()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_76()","Method","No Comment","private boolean jj_3R_76() {
    if (jj_3R_84()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_99()","Method","No Comment","private boolean jj_3R_99() {
    if (jj_3R_64()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_98()","Method","No Comment","private boolean jj_3R_98() {
    if (jj_3R_15()) {
        return true;
    }
    if (jj_scan_token(80)) {
        return true;
    }
    if (jj_3R_15()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_75()","Method","No Comment","private boolean jj_3R_75() {
    if (jj_scan_token(PI)) {
        return true;
    }
    if (jj_scan_token(81)) {
        return true;
    }
    if (jj_scan_token(Literal)) {
        return true;
    }
    if (jj_scan_token(82)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_92()","Method","No Comment","private boolean jj_3R_92() {
    if (jj_3R_15()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_74()","Method","No Comment","private boolean jj_3R_74() {
    if (jj_3R_17()) {
        return true;
    }
    if (jj_scan_token(81)) {
        return true;
    }
    if (jj_scan_token(82)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_71()","Method","No Comment","private boolean jj_3R_71() {
    if (jj_3R_18()) {
        return true;
    }
    if (jj_3R_80()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_93()","Method","No Comment","private boolean jj_3R_93() {
    if (jj_scan_token(80)) {
        return true;
    }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(89)) {
        jj_scanpos = xsp;
        if (jj_3R_114()) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_65()","Method","No Comment","private boolean jj_3R_65() {
    if (jj_3R_73()) {
        return true;
    }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
        jj_scanpos = xsp;
        if (jj_3R_75()) {
            jj_scanpos = xsp;
            if (jj_3R_76()) {
                return true;
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_85()","Method","No Comment","private boolean jj_3R_85() {
    if (jj_scan_token(80)) {
        return true;
    }
    if (jj_3R_15()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_89()","Method","No Comment","private boolean jj_3R_89() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) {
        jj_scanpos = xsp;
        if (jj_3R_99()) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_95()","Method","No Comment","private boolean jj_3R_95() {
    if (jj_scan_token(AND)) {
        return true;
    }
    if (jj_3R_94()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_84()","Method","No Comment","private boolean jj_3R_84() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(89)) {
        jj_scanpos = xsp;
        if (jj_3R_92()) {
            return true;
        }
    }
    xsp = jj_scanpos;
    if (jj_3R_93()) {
        jj_scanpos = xsp;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_22()","Method","No Comment","private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) {
        jj_scanpos = xsp;
        if (jj_3R_66()) {
            jj_scanpos = xsp;
            if (jj_3R_67()) {
                return true;
            }
        }
    }
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_68()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_72()","Method","No Comment","private boolean jj_3R_72() {
    if (jj_3R_81()) {
        return true;
    }
    if (jj_3R_80()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_86()","Method","No Comment","private boolean jj_3R_86() {
    if (jj_3R_94()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_95()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_151()","Method","No Comment","private boolean jj_3R_151() {
    if (jj_3R_16()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3_5()","Method","No Comment","private boolean jj_3_5() {
    if (jj_3R_18()) {
        return true;
    }
    if (jj_scan_token(81)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_78()","Method","No Comment","private boolean jj_3R_78() {
    if (jj_3R_15()) {
        return true;
    }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) {
        jj_scanpos = xsp;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_69()","Method","No Comment","private boolean jj_3R_69() {
    if (jj_scan_token(VARIABLE)) {
        return true;
    }
    if (jj_3R_78()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_57()","Method","No Comment","private boolean jj_3R_57() {
    if (jj_scan_token(FUNCTION_FORMAT_NUMBER)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_56()","Method","No Comment","private boolean jj_3R_56() {
    if (jj_scan_token(FUNCTION_KEY)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_55()","Method","No Comment","private boolean jj_3R_55() {
    if (jj_scan_token(FUNCTION_ROUND)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_63()","Method","No Comment","private boolean jj_3R_63() {
    if (jj_3R_72()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_54()","Method","No Comment","private boolean jj_3R_54() {
    if (jj_scan_token(FUNCTION_CEILING)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_62()","Method","No Comment","private boolean jj_3R_62() {
    if (jj_3R_71()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_53()","Method","No Comment","private boolean jj_3R_53() {
    if (jj_scan_token(FUNCTION_FLOOR)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_61()","Method","No Comment","private boolean jj_3R_61() {
    if (jj_scan_token(Number)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_52()","Method","No Comment","private boolean jj_3R_52() {
    if (jj_scan_token(FUNCTION_SUM)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_21()","Method","No Comment","private boolean jj_3R_21() {
    if (jj_scan_token(SLASHSLASH)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_60()","Method","No Comment","private boolean jj_3R_60() {
    if (jj_scan_token(Literal)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_51()","Method","No Comment","private boolean jj_3R_51() {
    if (jj_scan_token(FUNCTION_NUMBER)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_59()","Method","No Comment","private boolean jj_3R_59() {
    if (jj_scan_token(81)) {
        return true;
    }
    if (jj_3R_70()) {
        return true;
    }
    if (jj_scan_token(82)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_87()","Method","No Comment","private boolean jj_3R_87() {
    if (jj_scan_token(OR)) {
        return true;
    }
    if (jj_3R_86()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_50()","Method","No Comment","private boolean jj_3R_50() {
    if (jj_scan_token(FUNCTION_LANG)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_58()","Method","No Comment","private boolean jj_3R_58() {
    if (jj_3R_69()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_81()","Method","No Comment","private boolean jj_3R_81() {
    if (jj_3R_89()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_49()","Method","No Comment","private boolean jj_3R_49() {
    if (jj_scan_token(FUNCTION_NULL)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_48()","Method","No Comment","private boolean jj_3R_48() {
    if (jj_scan_token(FUNCTION_FALSE)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_47()","Method","No Comment","private boolean jj_3R_47() {
    if (jj_scan_token(FUNCTION_TRUE)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_46()","Method","No Comment","private boolean jj_3R_46() {
    if (jj_scan_token(FUNCTION_NOT)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_16()","Method","No Comment","private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(6)) {
        jj_scanpos = xsp;
        if (jj_3R_21()) {
            return true;
        }
    }
    if (jj_3R_22()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_149()","Method","No Comment","private boolean jj_3R_149() {
    if (jj_3R_16()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_45()","Method","No Comment","private boolean jj_3R_45() {
    if (jj_scan_token(FUNCTION_BOOLEAN)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_44()","Method","No Comment","private boolean jj_3R_44() {
    if (jj_scan_token(FUNCTION_TRANSLATE)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_19()","Method","No Comment","private boolean jj_3R_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
        jj_scanpos = xsp;
        if (jj_3R_59()) {
            jj_scanpos = xsp;
            if (jj_3R_60()) {
                jj_scanpos = xsp;
                if (jj_3R_61()) {
                    jj_scanpos = xsp;
                    if (jj_3R_62()) {
                        jj_scanpos = xsp;
                        if (jj_3R_63()) {
                            return true;
                        }
                    }
                }
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_43()","Method","No Comment","private boolean jj_3R_43() {
    if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_42()","Method","No Comment","private boolean jj_3R_42() {
    if (jj_scan_token(FUNCTION_STRING_LENGTH)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_41()","Method","No Comment","private boolean jj_3R_41() {
    if (jj_scan_token(FUNCTION_SUBSTRING)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_40()","Method","No Comment","private boolean jj_3R_40() {
    if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_79()","Method","No Comment","private boolean jj_3R_79() {
    if (jj_3R_86()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_87()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_39()","Method","No Comment","private boolean jj_3R_39() {
    if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_38()","Method","No Comment","private boolean jj_3R_38() {
    if (jj_scan_token(FUNCTION_CONTAINS)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_37()","Method","No Comment","private boolean jj_3R_37() {
    if (jj_scan_token(FUNCTION_ENDS_WITH)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_36()","Method","No Comment","private boolean jj_3R_36() {
    if (jj_scan_token(FUNCTION_STARTS_WITH)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_35()","Method","No Comment","private boolean jj_3R_35() {
    if (jj_scan_token(FUNCTION_CONCAT)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_34()","Method","No Comment","private boolean jj_3R_34() {
    if (jj_scan_token(FUNCTION_STRING)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_33()","Method","No Comment","private boolean jj_3R_33() {
    if (jj_scan_token(FUNCTION_NAME)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_32()","Method","No Comment","private boolean jj_3R_32() {
    if (jj_scan_token(FUNCTION_NAMESPACE_URI)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_31()","Method","No Comment","private boolean jj_3R_31() {
    if (jj_scan_token(FUNCTION_LOCAL_NAME)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_70()","Method","No Comment","private boolean jj_3R_70() {
    if (jj_3R_79()) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_30()","Method","No Comment","private boolean jj_3R_30() {
    if (jj_scan_token(FUNCTION_ID)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_29()","Method","No Comment","private boolean jj_3R_29() {
    if (jj_scan_token(FUNCTION_COUNT)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_28()","Method","No Comment","private boolean jj_3R_28() {
    if (jj_scan_token(FUNCTION_POSITION)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_27()","Method","No Comment","private boolean jj_3R_27() {
    if (jj_scan_token(FUNCTION_LAST)) {
        return true;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_147()","Method","No Comment","private boolean jj_3R_147() {
    if (jj_3R_22()) {
        return true;
    }
    Token xsp;
    while (true) {
        xsp = jj_scanpos;
        if (jj_3R_149()) {
            jj_scanpos = xsp;
            break;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_3R_18()","Method","No Comment","private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_27()) {
        jj_scanpos = xsp;
        if (jj_3R_28()) {
            jj_scanpos = xsp;
            if (jj_3R_29()) {
                jj_scanpos = xsp;
                if (jj_3R_30()) {
                    jj_scanpos = xsp;
                    if (jj_3R_31()) {
                        jj_scanpos = xsp;
                        if (jj_3R_32()) {
                            jj_scanpos = xsp;
                            if (jj_3R_33()) {
                                jj_scanpos = xsp;
                                if (jj_3R_34()) {
                                    jj_scanpos = xsp;
                                    if (jj_3R_35()) {
                                        jj_scanpos = xsp;
                                        if (jj_3R_36()) {
                                            jj_scanpos = xsp;
                                            if (jj_3R_37()) {
                                                jj_scanpos = xsp;
                                                if (jj_3R_38()) {
                                                    jj_scanpos = xsp;
                                                    if (jj_3R_39()) {
                                                        jj_scanpos = xsp;
                                                        if (jj_3R_40()) {
                                                            jj_scanpos = xsp;
                                                            if (jj_3R_41()) {
                                                                jj_scanpos = xsp;
                                                                if (jj_3R_42()) {
                                                                    jj_scanpos = xsp;
                                                                    if (jj_3R_43()) {
                                                                        jj_scanpos = xsp;
                                                                        if (jj_3R_44()) {
                                                                            jj_scanpos = xsp;
                                                                            if (jj_3R_45()) {
                                                                                jj_scanpos = xsp;
                                                                                if (jj_3R_46()) {
                                                                                    jj_scanpos = xsp;
                                                                                    if (jj_3R_47()) {
                                                                                        jj_scanpos = xsp;
                                                                                        if (jj_3R_48()) {
                                                                                            jj_scanpos = xsp;
                                                                                            if (jj_3R_49()) {
                                                                                                jj_scanpos = xsp;
                                                                                                if (jj_3R_50()) {
                                                                                                    jj_scanpos = xsp;
                                                                                                    if (jj_3R_51()) {
                                                                                                        jj_scanpos = xsp;
                                                                                                        if (jj_3R_52()) {
                                                                                                            jj_scanpos = xsp;
                                                                                                            if (jj_3R_53()) {
                                                                                                                jj_scanpos = xsp;
                                                                                                                if (jj_3R_54()) {
                                                                                                                    jj_scanpos = xsp;
                                                                                                                    if (jj_3R_55()) {
                                                                                                                        jj_scanpos = xsp;
                                                                                                                        if (jj_3R_56()) {
                                                                                                                            jj_scanpos = xsp;
                                                                                                                            if (jj_3R_57()) {
                                                                                                                                return true;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_la1_0()","Method","No Comment","private static void jj_la1_0() {
    jj_la1_0 = new int[] { 0xf8000000, 0x78000000, 0x0, 0x0, 0x78000000, 0xf80000c0, 0xc0, 0x40, 0xc0, 0xc0, 0xf8000000, 0xf8000000, 0x0, 0x0, 0x0, 0x0, 0x160000, 0xf8000000, 0x0, 0xf81604c0, 0x100, 0xf80000c0, 0x0, 0xc0, 0x8000000, 0x10000000, 0x1800, 0x1800, 0x1e000, 0x1e000, 0x200, 0x400, 0x60000000, 0x60000000, 0xf81604c0, 0xf8000000, 0xf8000000, 0x0, 0x80000000 };
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_la1_1()","Method","No Comment","private static void jj_la1_1() {
    jj_la1_1 = new int[] { 0xffff0007, 0x0, 0xffff0000, 0x0, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0xffff0007, 0xffffffff, 0x0, 0xfff8, 0xfff8, 0x0, 0x0, 0xffff0007, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0xffff0007, 0xffff0007, 0x0, 0x7 };
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_la1_2()","Method","No Comment","private static void jj_la1_2() {
    jj_la1_2 = new int[] { 0xffff, 0x8000, 0x7fff, 0x10000, 0x8000, 0x298ffff, 0x0, 0x0, 0x0, 0x0, 0x200ffff, 0x298ffff, 0x200000, 0x0, 0x0, 0x800000, 0x20000, 0xffff, 0x1000000, 0x29affff, 0x0, 0x298ffff, 0x200000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2000000, 0x2000000, 0x29affff, 0x200ffff, 0x200ffff, 0x10000, 0x0 };
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.ReInit(java.io.InputStream)","Method","No Comment","public void ReInit(final java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 39; i++) {
        jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
        jj_2_rtns[i] = new JJCalls();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.ReInit(java.io.InputStream).stream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.ReInit(java.io.InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.ReInit(java.io.Reader)","Method","No Comment","public void ReInit(final java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 39; i++) {
        jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
        jj_2_rtns[i] = new JJCalls();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.ReInit(java.io.Reader).stream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.ReInit(java.io.Reader)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.ReInit(XPathParserTokenManager)","Method","No Comment","public void ReInit(final XPathParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 39; i++) {
        jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
        jj_2_rtns[i] = new JJCalls();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.ReInit(XPathParserTokenManager).tm","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.ReInit(XPathParserTokenManager)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_consume_token(int)","Method","No Comment","private Token jj_consume_token(final int kind) throws ParseException {
    final Token oldToken = token;
    if ((token = jj_nt).next != null) {
        jj_nt = jj_nt.next;
    } else {
        jj_nt = jj_nt.next = token_source.getNextToken();
    }
    if (token.kind == kind) {
        jj_gen++;
        if (++jj_gc > 100) {
            jj_gc = 0;
            for (final JJCalls jj_2_rtn : jj_2_rtns) {
                JJCalls c = jj_2_rtn;
                while (c != null) {
                    if (c.gen < jj_gen) {
                        c.first = null;
                    }
                    c = c.next;
                }
            }
        }
        return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
}","Token","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_consume_token(int).kind","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_consume_token(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_scan_token(int)","Method","No Comment","private boolean jj_scan_token(final int kind) {
    if (jj_scanpos == jj_lastpos) {
        jj_la--;
        if (jj_scanpos.next == null) {
            jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
        } else {
            jj_lastpos = jj_scanpos = jj_scanpos.next;
        }
    } else {
        jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
        int i = 0;
        Token tok = token;
        while (tok != null && tok != jj_scanpos) {
            i++;
            tok = tok.next;
        }
        if (tok != null) {
            jj_add_error_token(kind, i);
        }
    }
    if (jj_scanpos.kind != kind) {
        return true;
    }
    if (jj_la == 0 && jj_scanpos == jj_lastpos) {
        throw jj_ls;
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_scan_token(int).kind","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_scan_token(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.getNextToken()","Method","No Comment","final public Token getNextToken() {
    if ((token = jj_nt).next != null) {
        jj_nt = jj_nt.next;
    } else {
        jj_nt = jj_nt.next = token_source.getNextToken();
    }
    jj_gen++;
    return token;
}","Token","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.getToken(int)","Method","No Comment","final public Token getToken(final int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
        if (t.next != null) {
            t = t.next;
        } else {
            t = t.next = token_source.getNextToken();
        }
    }
    return t;
}","Token","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.getToken(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.getToken(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_add_error_token(int,int)","Method","No Comment","private void jj_add_error_token(final int kind, final int pos) {
    if (pos >= 100) {
        return;
    }
    if (pos == jj_endpos + 1) {
        jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
        jj_expentry = new int[jj_endpos];
        for (int i = 0; i < jj_endpos; i++) {
            jj_expentry[i] = jj_lasttokens[i];
        }
        boolean exists = false;
        for (final java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements(); ) {
            final int[] oldentry = (int[]) e.nextElement();
            if (oldentry.length == jj_expentry.length) {
                exists = true;
                for (int i = 0; i < jj_expentry.length; i++) {
                    if (oldentry[i] != jj_expentry[i]) {
                        exists = false;
                        break;
                    }
                }
                if (exists) {
                    break;
                }
            }
        }
        if (!exists) {
            jj_expentries.addElement(jj_expentry);
        }
        if (pos != 0) {
            jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_add_error_token(int,int).kind","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_add_error_token(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_add_error_token(int,int).pos","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_add_error_token(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.generateParseException()","Method","No Comment","public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    final boolean[] la1tokens = new boolean[90];
    for (int i = 0; i < 90; i++) {
        la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
        la1tokens[jj_kind] = true;
        jj_kind = -1;
    }
    for (int i = 0; i < 39; i++) {
        if (jj_la1[i] == jj_gen) {
            for (int j = 0; j < 32; j++) {
                if ((jj_la1_0[i] & 1 << j) != 0) {
                    la1tokens[j] = true;
                }
                if ((jj_la1_1[i] & 1 << j) != 0) {
                    la1tokens[32 + j] = true;
                }
                if ((jj_la1_2[i] & 1 << j) != 0) {
                    la1tokens[64 + j] = true;
                }
            }
        }
    }
    for (int i = 0; i < 90; i++) {
        if (la1tokens[i]) {
            jj_expentry = new int[1];
            jj_expentry[0] = i;
            jj_expentries.addElement(jj_expentry);
        }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    final int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
        exptokseq[i] = (int[]) jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
}","ParseException","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.enable_tracing()","Method","No Comment","final public void enable_tracing() {
}","void","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.disable_tracing()","Method","No Comment","final public void disable_tracing() {
}","void","final , public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_rescan_token()","Method","No Comment","private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 6; i++) {
        JJCalls p = jj_2_rtns[i];
        do {
            if (p.gen > jj_gen) {
                jj_la = p.arg;
                jj_lastpos = jj_scanpos = p.first;
                switch(i) {
                    case 0:
                        jj_3_1();
                        break;
                    case 1:
                        jj_3_2();
                        break;
                    case 2:
                        jj_3_3();
                        break;
                    case 3:
                        jj_3_4();
                        break;
                    case 4:
                        jj_3_5();
                        break;
                    case 5:
                        jj_3_6();
                        break;
                }
            }
            p = p.next;
        } while (p != null);
    }
    jj_rescan = false;
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_save(int,int)","Method","No Comment","private void jj_save(final int index, final int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
        if (p.next == null) {
            p = p.next = new JJCalls();
            break;
        }
        p = p.next;
    }
    p.gen = jj_gen + xla - jj_la;
    p.first = token;
    p.arg = xla;
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_save(int,int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_save(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.jj_save(int,int).xla","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.jj_save(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.<init>(java.io.InputStream)","Constructor","No Comment","public XPathParser(final java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XPathParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 39; i++) {
        jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
        jj_2_rtns[i] = new JJCalls();
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.<init>(java.io.InputStream).stream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.<init>(java.io.InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.<init>(java.io.Reader)","Constructor","No Comment","public XPathParser(final java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XPathParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 39; i++) {
        jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
        jj_2_rtns[i] = new JJCalls();
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.<init>(java.io.Reader).stream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.<init>(java.io.Reader)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.<init>(XPathParserTokenManager)","Constructor","No Comment","public XPathParser(final XPathParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 39; i++) {
        jj_la1[i] = -1;
    }
    for (int i = 0; i < jj_2_rtns.length; i++) {
        jj_2_rtns[i] = new JJCalls();
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.<init>(XPathParserTokenManager).tm","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParser.<init>(XPathParserTokenManager)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser$LookaheadSuccess","Class","No Comment","Class do not obtain Source Code","No return type","static , private , final ","java.lang.Error",""
"org.apache.commons.jxpath.ri.parser.XPathParser$LookaheadSuccess.serialVersionUID","Field","*","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser$JJCalls","Class","No Comment","Class do not obtain Source Code","No return type","static , final ","",""
"org.apache.commons.jxpath.ri.parser.XPathParser$JJCalls.gen","Field","No Comment","int gen;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser$JJCalls.first","Field","No Comment","Token first;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser$JJCalls.arg","Field","No Comment","int arg;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser$JJCalls.next","Field","No Comment","JJCalls next;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.LookaheadSuccess","Class","No Comment","Class do not obtain Source Code","No return type","static , private , final ","java.lang.Error",""
"org.apache.commons.jxpath.ri.parser.XPathParser.LookaheadSuccess.serialVersionUID","Field","*","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.JJCalls","Class","No Comment","Class do not obtain Source Code","No return type","static , final ","",""
"org.apache.commons.jxpath.ri.parser.XPathParser.JJCalls.gen","Field","No Comment","int gen;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.JJCalls.first","Field","No Comment","Token first;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.JJCalls.arg","Field","No Comment","int arg;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParser.JJCalls.next","Field","No Comment","JJCalls next;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream","Class","No Comment","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.staticFlag","Field","No Comment","public static final boolean staticFlag = false;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.bufsize","Field","No Comment","int bufsize;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.available","Field","No Comment","int available;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.tokenBegin","Field","No Comment","int tokenBegin;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.bufpos","Field","No Comment","public int bufpos = -1;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.bufline","Field","No Comment","protected int[] bufline;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.bufcolumn","Field","No Comment","protected int[] bufcolumn;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.column","Field","No Comment","protected int column = 0;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.line","Field","No Comment","protected int line = 1;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.prevCharIsCR","Field","No Comment","protected boolean prevCharIsCR = false;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.prevCharIsLF","Field","No Comment","protected boolean prevCharIsLF = false;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.inputStream","Field","No Comment","protected java.io.Reader inputStream;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.buffer","Field","No Comment","protected char[] buffer;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.maxNextCharInd","Field","No Comment","protected int maxNextCharInd = 0;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.inBuf","Field","No Comment","protected int inBuf = 0;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ExpandBuff(boolean)","Method","No Comment","protected void ExpandBuff(final boolean wrapAround) {
    final char[] newbuffer = new char[bufsize + 2048];
    final int[] newbufline = new int[bufsize + 2048];
    final int[] newbufcolumn = new int[bufsize + 2048];
    try {
        if (wrapAround) {
            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
            System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
            buffer = newbuffer;
            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
            bufline = newbufline;
            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
            bufcolumn = newbufcolumn;
            maxNextCharInd = bufpos += bufsize - tokenBegin;
        } else {
            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
            buffer = newbuffer;
            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
            bufline = newbufline;
            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
            bufcolumn = newbufcolumn;
            maxNextCharInd = bufpos -= tokenBegin;
        }
    } catch (final Throwable t) {
        throw new Error(t.getMessage());
    }
    bufsize += 2048;
    available = bufsize;
    tokenBegin = 0;
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ExpandBuff(boolean).wrapAround","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ExpandBuff(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.FillBuff()","Method","No Comment","protected void FillBuff() throws java.io.IOException {
    if (maxNextCharInd == available) {
        if (available == bufsize) {
            if (tokenBegin > 2048) {
                bufpos = maxNextCharInd = 0;
                available = tokenBegin;
            } else if (tokenBegin < 0) {
                bufpos = maxNextCharInd = 0;
            } else {
                ExpandBuff(false);
            }
        } else if (available > tokenBegin) {
            available = bufsize;
        } else if (tokenBegin - available < 2048) {
            ExpandBuff(true);
        } else {
            available = tokenBegin;
        }
    }
    int i;
    try {
        if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
            inputStream.close();
            throw new java.io.IOException();
        }
        maxNextCharInd += i;
    } catch (final java.io.IOException e) {
        --bufpos;
        backup(0);
        if (tokenBegin == -1) {
            tokenBegin = bufpos;
        }
        throw e;
    }
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.BeginToken()","Method","No Comment","public char BeginToken() throws java.io.IOException {
    tokenBegin = -1;
    final char c = readChar();
    tokenBegin = bufpos;
    return c;
}","char","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.UpdateLineColumn(char)","Method","No Comment","protected void UpdateLineColumn(final char c) {
    column++;
    if (prevCharIsLF) {
        prevCharIsLF = false;
        line += column = 1;
    } else if (prevCharIsCR) {
        prevCharIsCR = false;
        if (c == '\n') {
            prevCharIsLF = true;
        } else {
            line += column = 1;
        }
    }
    switch(c) {
        case '\r':
            prevCharIsCR = true;
            break;
        case '\n':
            prevCharIsLF = true;
            break;
        case '\t':
            column--;
            column += 8 - (column & 07);
            break;
        default:
            break;
    }
    bufline[bufpos] = line;
    bufcolumn[bufpos] = column;
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.UpdateLineColumn(char).c","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.UpdateLineColumn(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.readChar()","Method","No Comment","public char readChar() throws java.io.IOException {
    if (inBuf > 0) {
        --inBuf;
        if (++bufpos == bufsize) {
            bufpos = 0;
        }
        return buffer[bufpos];
    }
    if (++bufpos >= maxNextCharInd) {
        FillBuff();
    }
    final char c = buffer[bufpos];
    UpdateLineColumn(c);
    return c;
}","char","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.getColumn()","Method","* @deprecated
   * @return the end column.
   * @see #getEndColumn","@Deprecated
public int getColumn() {
    return bufcolumn[bufpos];
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.getLine()","Method","* @deprecated
   * @return the line number.
   * @see #getEndLine","@Deprecated
public int getLine() {
    return bufline[bufpos];
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.getEndColumn()","Method","No Comment","public int getEndColumn() {
    return bufcolumn[bufpos];
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.getEndLine()","Method","No Comment","public int getEndLine() {
    return bufline[bufpos];
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.getBeginColumn()","Method","No Comment","public int getBeginColumn() {
    return bufcolumn[tokenBegin];
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.getBeginLine()","Method","No Comment","public int getBeginLine() {
    return bufline[tokenBegin];
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.backup(int)","Method","No Comment","public void backup(final int amount) {
    inBuf += amount;
    if ((bufpos -= amount) < 0) {
        bufpos += bufsize;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.backup(int).amount","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.backup(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int,int)","Method","No Comment","public void ReInit(final java.io.Reader dstream, final int startLine, final int startColumn, final int bufferSize) {
    inputStream = dstream;
    line = startLine;
    column = startColumn - 1;
    if (buffer == null || bufferSize != buffer.length) {
        available = bufsize = bufferSize;
        buffer = new char[bufferSize];
        bufline = new int[bufferSize];
        bufcolumn = new int[bufferSize];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    bufpos = -1;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int,int).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int,int).startLine","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int,int).startColumn","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int,int).bufferSize","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int)","Method","No Comment","public void ReInit(final java.io.Reader dstream, final int startLine, final int startColumn) {
    ReInit(dstream, startLine, startColumn, 4096);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int).startLine","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int).startColumn","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader)","Method","No Comment","public void ReInit(final java.io.Reader dstream) {
    ReInit(dstream, 1, 1, 4096);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.Reader)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int,int)","Method","No Comment","public void ReInit(final java.io.InputStream dstream, final int startLine, final int startColumn, final int buffersize) {
    ReInit(new java.io.InputStreamReader(dstream), startLine, startColumn, 4096);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int,int).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int,int).startLine","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int,int).startColumn","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int,int).buffersize","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream)","Method","No Comment","public void ReInit(final java.io.InputStream dstream) {
    ReInit(dstream, 1, 1, 4096);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int)","Method","No Comment","public void ReInit(final java.io.InputStream dstream, final int startLine, final int startColumn) {
    ReInit(dstream, startLine, startColumn, 4096);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int).startLine","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int).startColumn","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.ReInit(java.io.InputStream,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.GetImage()","Method","No Comment","public String GetImage() {
    if (bufpos >= tokenBegin) {
        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
    }
    return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.GetSuffix(int)","Method","No Comment","public char[] GetSuffix(final int len) {
    final char[] ret = new char[len];
    if (bufpos + 1 >= len) {
        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
    } else {
        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
    }
    return ret;
}","char[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.GetSuffix(int).len","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.GetSuffix(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.Done()","Method","No Comment","public void Done() {
    buffer = null;
    bufline = null;
    bufcolumn = null;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.adjustBeginLineColumn(int,int)","Method","* Method to adjust line and column numbers for the start of a token.<BR>
   *
   * @param newLine TODO
   * @param newCol  TODO","public void adjustBeginLineColumn(int newLine, final int newCol) {
    int start = tokenBegin;
    int len;
    if (bufpos >= tokenBegin) {
        len = bufpos - tokenBegin + inBuf + 1;
    } else {
        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
    }
    int i = 0, j = 0, k = 0;
    int nextColDiff = 0, columnDiff = 0;
    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {
        bufline[j] = newLine;
        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
        bufcolumn[j] = newCol + columnDiff;
        columnDiff = nextColDiff;
        i++;
    }
    if (i < len) {
        bufline[j] = newLine++;
        bufcolumn[j] = newCol + columnDiff;
        while (i++ < len) {
            if (bufline[j = start % bufsize] != bufline[++start % bufsize]) {
                bufline[j] = newLine++;
            } else {
                bufline[j] = newLine;
            }
        }
    }
    line = bufline[j];
    column = bufcolumn[j];
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.adjustBeginLineColumn(int,int).newLine","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.adjustBeginLineColumn(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.adjustBeginLineColumn(int,int).newCol","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.adjustBeginLineColumn(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int,int)","Constructor","No Comment","public SimpleCharStream(final java.io.Reader dstream, final int startLine, final int startColumn, final int bufferSize) {
    inputStream = dstream;
    line = startLine;
    column = startColumn - 1;
    available = bufsize = bufferSize;
    buffer = new char[bufferSize];
    bufline = new int[bufferSize];
    bufcolumn = new int[bufferSize];
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int,int).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int,int).startLine","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int,int).startColumn","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int,int).bufferSize","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int)","Constructor","No Comment","public SimpleCharStream(final java.io.Reader dstream, final int startLine, final int startColumn) {
    this(dstream, startLine, startColumn, 4096);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int).startLine","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int).startColumn","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader)","Constructor","No Comment","public SimpleCharStream(final java.io.Reader dstream) {
    this(dstream, 1, 1, 4096);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.Reader)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int,int)","Constructor","No Comment","public SimpleCharStream(final java.io.InputStream dstream, final int startLine, final int startColumn, final int buffersize) {
    this(new java.io.InputStreamReader(dstream), startLine, startColumn, 4096);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int,int).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int,int).startLine","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int,int).startColumn","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int,int).buffersize","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int)","Constructor","No Comment","public SimpleCharStream(final java.io.InputStream dstream, final int startLine, final int startColumn) {
    this(dstream, startLine, startColumn, 4096);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int).startLine","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int).startColumn","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream)","Constructor","No Comment","public SimpleCharStream(final java.io.InputStream dstream) {
    this(dstream, 1, 1, 4096);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream).dstream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.SimpleCharStream.<init>(java.io.InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token","Class","* Describes the input token stream.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.parser.Token.kind","Field","* An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.","public int kind;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.beginLine","Field","* beginLine and beginColumn describe the position of the first character
   * of this token; endLine and endColumn describe the position of the
   * last character of this token.","public int beginLine, beginColumn, endLine, endColumn;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.beginColumn","Field","* beginLine and beginColumn describe the position of the first character
   * of this token; endLine and endColumn describe the position of the
   * last character of this token.","public int beginLine, beginColumn, endLine, endColumn;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.endLine","Field","* beginLine and beginColumn describe the position of the first character
   * of this token; endLine and endColumn describe the position of the
   * last character of this token.","public int beginLine, beginColumn, endLine, endColumn;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.endColumn","Field","* beginLine and beginColumn describe the position of the first character
   * of this token; endLine and endColumn describe the position of the
   * last character of this token.","public int beginLine, beginColumn, endLine, endColumn;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.image","Field","* The string image of the token.","public String image;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.next","Field","* A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.","public Token next;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.specialToken","Field","* This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.","public Token specialToken;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.toString()","Method","* Returns the image.","@Override
public String toString() {
    return image;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.newToken(int)","Method","* Returns a new Token object, by default. However, if you want, you can create and return subclass objects based on the value of ofKind. Simply add the cases
   * to the switch for all those special cases. For example, if you have a subclass of Token called IDToken that you want to create if ofKind is ID, simlpy add
   * something like :
   *
   * <pre>
   *    case MyParserConstants.ID : return new IDToken();
   * </pre>
   *
   * to the following switch statement. Then you can cast matchedToken variable to the appropriate type and use it in your lexical actions.
   *
   * @param ofKind TODO
   * @return TODO","public static final Token newToken(final int ofKind) {
    switch(ofKind) {
        default:
            return new Token();
    }
}","Token","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.Token.newToken(int).ofKind","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.Token.newToken(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager","Class","No Comment","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.parser.XPathParserConstants"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.debugStream","Field","No Comment","public java.io.PrintStream debugStream = System.out;","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec0","Field","No Comment","static final long[] jjbitVec0 = { 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec2","Field","No Comment","static final long[] jjbitVec2 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec3","Field","No Comment","static final long[] jjbitVec3 = { 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec4","Field","No Comment","static final long[] jjbitVec4 = { 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec5","Field","No Comment","static final long[] jjbitVec5 = { 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec6","Field","No Comment","static final long[] jjbitVec6 = { 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec7","Field","No Comment","static final long[] jjbitVec7 = { 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec8","Field","No Comment","static final long[] jjbitVec8 = { 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec9","Field","No Comment","static final long[] jjbitVec9 = { 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec10","Field","No Comment","static final long[] jjbitVec10 = { 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec11","Field","No Comment","static final long[] jjbitVec11 = { 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec12","Field","No Comment","static final long[] jjbitVec12 = { 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec13","Field","No Comment","static final long[] jjbitVec13 = { 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec14","Field","No Comment","static final long[] jjbitVec14 = { 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec15","Field","No Comment","static final long[] jjbitVec15 = { 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec16","Field","No Comment","static final long[] jjbitVec16 = { 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec17","Field","No Comment","static final long[] jjbitVec17 = { 0x0L, 0x3fffffffeffL, 0x0L, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec18","Field","No Comment","static final long[] jjbitVec18 = { 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec19","Field","No Comment","static final long[] jjbitVec19 = { 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec20","Field","No Comment","static final long[] jjbitVec20 = { 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec21","Field","No Comment","static final long[] jjbitVec21 = { 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec22","Field","No Comment","static final long[] jjbitVec22 = { 0x4c4000000000L, 0x0L, 0x7L, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec23","Field","No Comment","static final long[] jjbitVec23 = { 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec24","Field","No Comment","static final long[] jjbitVec24 = { 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec25","Field","No Comment","static final long[] jjbitVec25 = { 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec26","Field","No Comment","static final long[] jjbitVec26 = { 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec27","Field","No Comment","static final long[] jjbitVec27 = { 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec28","Field","No Comment","static final long[] jjbitVec28 = { 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec29","Field","No Comment","static final long[] jjbitVec29 = { 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec30","Field","No Comment","static final long[] jjbitVec30 = { 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec31","Field","No Comment","static final long[] jjbitVec31 = { 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec32","Field","No Comment","static final long[] jjbitVec32 = { 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec33","Field","No Comment","static final long[] jjbitVec33 = { 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec34","Field","No Comment","static final long[] jjbitVec34 = { 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec35","Field","No Comment","static final long[] jjbitVec35 = { 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec36","Field","No Comment","static final long[] jjbitVec36 = { 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec37","Field","No Comment","static final long[] jjbitVec37 = { 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec38","Field","No Comment","static final long[] jjbitVec38 = { 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec39","Field","No Comment","static final long[] jjbitVec39 = { 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec40","Field","No Comment","static final long[] jjbitVec40 = { 0x0L, 0x0L, 0x0L, 0x21fff0000L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjbitVec41","Field","No Comment","static final long[] jjbitVec41 = { 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjnextStates","Field","No Comment","static final int[] jjnextStates = { 1, 2, 4, 5 };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjstrLiteralImages","Field","No Comment","public static final String[] jjstrLiteralImages = { """", null, null, null, null, null, ""\57"", ""\57\57"", ""\174"", ""\53"", ""\55"", ""\75"", ""\41\75"", ""\74"", ""\74\75"", ""\76"", ""\76\75"", ""\44"", null, null, null, null, null, null, null, null, null, ""\157\162"", ""\141\156\144"", ""\155\157\144"", ""\144\151\166"", ""\156\157\144\145"", ""\164\145\170\164"", ""\143\157\155\155\145\156\164"", ""\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156"", ""\163\145\154\146\72\72"", ""\143\150\151\154\144\72\72"", ""\160\141\162\145\156\164\72\72"", ""\141\156\143\145\163\164\157\162\72\72"", ""\141\164\164\162\151\142\165\164\145\72\72"", ""\156\141\155\145\163\160\141\143\145\72\72"", ""\160\162\145\143\145\144\151\156\147\72\72"", ""\146\157\154\154\157\167\151\156\147\72\72"", ""\144\145\163\143\145\156\144\141\156\164\72\72"", ""\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72"", ""\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72"", ""\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72"", ""\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72"", ""\154\141\163\164"", ""\160\157\163\151\164\151\157\156"", ""\143\157\165\156\164"", ""\151\144"", ""\153\145\171"", ""\154\157\143\141\154\55\156\141\155\145"", ""\156\141\155\145\163\160\141\143\145\55\165\162\151"", ""\156\141\155\145"", ""\163\164\162\151\156\147"", ""\143\157\156\143\141\164"", ""\163\164\141\162\164\163\55\167\151\164\150"", ""\145\156\144\163\55\167\151\164\150"", ""\143\157\156\164\141\151\156\163"", ""\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145"", ""\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162"", ""\163\165\142\163\164\162\151\156\147"", ""\163\164\162\151\156\147\55\154\145\156\147\164\150"", ""\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145"", ""\164\162\141\156\163\154\141\164\145"", ""\142\157\157\154\145\141\156"", ""\156\157\164"", ""\164\162\165\145"", ""\146\141\154\163\145"", ""\156\165\154\154"", ""\154\141\156\147"", ""\156\165\155\142\145\162"", ""\163\165\155"", ""\146\154\157\157\162"", ""\143\145\151\154\151\156\147"", ""\162\157\165\156\144"", ""\146\157\162\155\141\164\55\156\165\155\142\145\162"", null, ""\72"", ""\50"", ""\51"", ""\56"", ""\56\56"", ""\133"", ""\135"", ""\100"", ""\54"", ""\52"" };","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.lexStateNames","Field","No Comment","public static final String[] lexStateNames = { ""DEFAULT"" };","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjtoToken","Field","No Comment","static final long[] jjtoToken = { 0xfffffffff817ffc1L, 0x3ffffffL };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjtoSkip","Field","No Comment","static final long[] jjtoSkip = { 0x3eL, 0x0L };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.input_stream","Field","No Comment","protected SimpleCharStream input_stream;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjrounds","Field","No Comment","private final int[] jjrounds = new int[13];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjstateSet","Field","No Comment","private final int[] jjstateSet = new int[26];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.curChar","Field","No Comment","protected char curChar;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.curLexState","Field","No Comment","int curLexState = 0;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.defaultLexState","Field","No Comment","int defaultLexState = 0;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjnewStateCnt","Field","No Comment","int jjnewStateCnt;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjround","Field","No Comment","int jjround;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjmatchedPos","Field","No Comment","int jjmatchedPos;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjmatchedKind","Field","No Comment","int jjmatchedKind;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.setDebugStream(java.io.PrintStream)","Method","No Comment","public void setDebugStream(final java.io.PrintStream ds) {
    debugStream = ds;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.setDebugStream(java.io.PrintStream).ds","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.setDebugStream(java.io.PrintStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopStringLiteralDfa_0(int,long,long)","Method","No Comment","private int jjStopStringLiteralDfa_0(final int pos, final long active0, final long active1) {
    switch(pos) {
        case 0:
            if ((active1 & 0x180000L) != 0L) {
                return 10;
            }
            if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x7fffL) != 0L) {
                jjmatchedKind = 79;
                return 12;
            }
            return -1;
        case 1:
            if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x7fffL) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 1;
                return 12;
            }
            if ((active0 & 0x8000008000000L) != 0L) {
                return 12;
            }
            return -1;
        case 2:
            if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x410L) != 0L) {
                return 12;
            }
            if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x7befL) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 2;
                return 12;
            }
            return -1;
        case 3:
            if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0x1a0L) != 0L) {
                return 12;
            }
            if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x7a4fL) != 0L) {
                if (jjmatchedPos != 3) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 3;
                }
                return 12;
            }
            return -1;
        case 4:
            if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x520fL) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 4;
                return 12;
            }
            if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x2840L) != 0L) {
                return 12;
            }
            if ((active0 & 0x800000000L) != 0L) {
                if (jjmatchedPos < 3) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 3;
                }
                return -1;
            }
            return -1;
        case 5:
            if ((active0 & 0x300000000000000L) != 0L || (active1 & 0x201L) != 0L) {
                return 12;
            }
            if ((active0 & 0xfc62ffe600000000L) != 0L || (active1 & 0x500eL) != 0L) {
                if (jjmatchedPos != 5) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 5;
                }
                return 12;
            }
            if ((active0 & 0x1000000000L) != 0L) {
                if (jjmatchedPos < 4) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 4;
                }
                return -1;
            }
            if ((active0 & 0x800000000L) != 0L) {
                if (jjmatchedPos < 3) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 3;
                }
                return -1;
            }
            return -1;
        case 6:
            if ((active0 & 0x200000000L) != 0L || (active1 & 0x1008L) != 0L) {
                return 12;
            }
            if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x4007L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 6;
                return 12;
            }
            if ((active0 & 0x2000000000L) != 0L) {
                if (jjmatchedPos < 5) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 5;
                }
                return -1;
            }
            if ((active0 & 0x1000000000L) != 0L) {
                if (jjmatchedPos < 4) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 4;
                }
                return -1;
            }
            return -1;
        case 7:
            if ((active0 & 0x1002000000000000L) != 0L) {
                return 12;
            }
            if ((active0 & 0x2000000000L) != 0L) {
                if (jjmatchedPos < 5) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 5;
                }
                return -1;
            }
            if ((active0 & 0xec60ffc400000000L) != 0L || (active1 & 0x4007L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 7;
                return 12;
            }
            return -1;
        case 8:
            if ((active0 & 0xe800000000000000L) != 0L || (active1 & 0x4L) != 0L) {
                return 12;
            }
            if ((active0 & 0x460ff8400000000L) != 0L || (active1 & 0x4003L) != 0L) {
                if (jjmatchedPos != 8) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 8;
                }
                return 12;
            }
            if ((active0 & 0x4000000000L) != 0L) {
                if (jjmatchedPos < 7) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 7;
                }
                return -1;
            }
            return -1;
        case 9:
            if ((active0 & 0x20000000000000L) != 0L) {
                return 12;
            }
            if ((active0 & 0x78000000000L) != 0L) {
                if (jjmatchedPos < 8) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 8;
                }
                return -1;
            }
            if ((active0 & 0x4000000000L) != 0L) {
                if (jjmatchedPos < 7) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 7;
                }
                return -1;
            }
            if ((active0 & 0x6440f80400000000L) != 0L || (active1 & 0x4003L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 9;
                return 12;
            }
            return -1;
        case 10:
            if ((active0 & 0x400000000000000L) != 0L) {
                return 12;
            }
            if ((active0 & 0x6040f00400000000L) != 0L || (active1 & 0x4003L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 10;
                return 12;
            }
            if ((active0 & 0x80000000000L) != 0L) {
                if (jjmatchedPos < 9) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 9;
                }
                return -1;
            }
            if ((active0 & 0x78000000000L) != 0L) {
                if (jjmatchedPos < 8) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 8;
                }
                return -1;
            }
            return -1;
        case 11:
            if ((active0 & 0x80000000000L) != 0L) {
                if (jjmatchedPos < 9) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 9;
                }
                return -1;
            }
            if ((active0 & 0x6040f00400000000L) != 0L || (active1 & 0x4003L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 11;
                return 12;
            }
            return -1;
        case 12:
            if ((active0 & 0x6000f00400000000L) != 0L || (active1 & 0x2L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 12;
                return 12;
            }
            if ((active0 & 0x40000000000000L) != 0L || (active1 & 0x4001L) != 0L) {
                return 12;
            }
            return -1;
        case 13:
            if ((active0 & 0x6000f00400000000L) != 0L || (active1 & 0x2L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 13;
                return 12;
            }
            return -1;
        case 14:
            if ((active0 & 0x4000000000000000L) != 0L || (active1 & 0x2L) != 0L) {
                return 12;
            }
            if ((active0 & 0x2000f00400000000L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 14;
                return 12;
            }
            return -1;
        case 15:
            if ((active0 & 0x2000000000000000L) != 0L) {
                return 12;
            }
            if ((active0 & 0xf00400000000L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 15;
                return 12;
            }
            return -1;
        case 16:
            if ((active0 & 0xe00400000000L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 16;
                return 12;
            }
            if ((active0 & 0x100000000000L) != 0L) {
                if (jjmatchedPos < 15) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 15;
                }
                return -1;
            }
            return -1;
        case 17:
            if ((active0 & 0x600000000000L) != 0L) {
                if (jjmatchedPos < 16) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 16;
                }
                return -1;
            }
            if ((active0 & 0x100000000000L) != 0L) {
                if (jjmatchedPos < 15) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 15;
                }
                return -1;
            }
            if ((active0 & 0x800400000000L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 17;
                return 12;
            }
            return -1;
        case 18:
            if ((active0 & 0x800000000000L) != 0L) {
                if (jjmatchedPos < 17) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 17;
                }
                return -1;
            }
            if ((active0 & 0x600000000000L) != 0L) {
                if (jjmatchedPos < 16) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 16;
                }
                return -1;
            }
            if ((active0 & 0x400000000L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 18;
                return 12;
            }
            return -1;
        case 19:
            if ((active0 & 0x400000000L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 19;
                return 12;
            }
            if ((active0 & 0x800000000000L) != 0L) {
                if (jjmatchedPos < 17) {
                    jjmatchedKind = 79;
                    jjmatchedPos = 17;
                }
                return -1;
            }
            return -1;
        case 20:
            if ((active0 & 0x400000000L) != 0L) {
                jjmatchedKind = 79;
                jjmatchedPos = 20;
                return 12;
            }
            return -1;
        default:
            return -1;
    }
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopStringLiteralDfa_0(int,long,long).pos","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopStringLiteralDfa_0(int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopStringLiteralDfa_0(int,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopStringLiteralDfa_0(int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopStringLiteralDfa_0(int,long,long).active1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopStringLiteralDfa_0(int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfa_0(int,long,long)","Method","No Comment","private int jjStartNfa_0(final int pos, final long active0, final long active1) {
    return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfa_0(int,long,long).pos","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfa_0(int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfa_0(int,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfa_0(int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfa_0(int,long,long).active1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfa_0(int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopAtPos(int,int)","Method","No Comment","private int jjStopAtPos(final int pos, final int kind) {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    return pos + 1;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopAtPos(int,int).pos","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopAtPos(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopAtPos(int,int).kind","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStopAtPos(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfaWithStates_0(int,int,int)","Method","No Comment","private int jjStartNfaWithStates_0(final int pos, final int kind, final int state) {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        return pos + 1;
    }
    return jjMoveNfa_0(state, pos + 1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfaWithStates_0(int,int,int).pos","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfaWithStates_0(int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfaWithStates_0(int,int,int).kind","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfaWithStates_0(int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfaWithStates_0(int,int,int).state","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjStartNfaWithStates_0(int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa0_0()","Method","No Comment","private int jjMoveStringLiteralDfa0_0() {
    switch(curChar) {
        case 33:
            return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L);
        case 36:
            return jjStopAtPos(0, 17);
        case 40:
            return jjStopAtPos(0, 81);
        case 41:
            return jjStopAtPos(0, 82);
        case 42:
            return jjStopAtPos(0, 89);
        case 43:
            return jjStopAtPos(0, 9);
        case 44:
            return jjStopAtPos(0, 88);
        case 45:
            return jjStopAtPos(0, 10);
        case 46:
            jjmatchedKind = 83;
            return jjMoveStringLiteralDfa1_0(0x0L, 0x100000L);
        case 47:
            jjmatchedKind = 6;
            return jjMoveStringLiteralDfa1_0(0x80L, 0x0L);
        case 58:
            return jjStopAtPos(0, 80);
        case 60:
            jjmatchedKind = 13;
            return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L);
        case 61:
            return jjStopAtPos(0, 11);
        case 62:
            jjmatchedKind = 15;
            return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L);
        case 64:
            return jjStopAtPos(0, 87);
        case 91:
            return jjStopAtPos(0, 85);
        case 93:
            return jjStopAtPos(0, 86);
        case 97:
            return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L);
        case 98:
            return jjMoveStringLiteralDfa1_0(0x0L, 0x8L);
        case 99:
            return jjMoveStringLiteralDfa1_0(0x1204001200000000L, 0x1000L);
        case 100:
            return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L);
        case 101:
            return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L);
        case 102:
            return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x4840L);
        case 105:
            return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L);
        case 107:
            return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L);
        case 108:
            return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x100L);
        case 109:
            return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L);
        case 110:
            return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x292L);
        case 111:
            return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L);
        case 112:
            return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L);
        case 114:
            return jjMoveStringLiteralDfa1_0(0x0L, 0x2000L);
        case 115:
            return jjMoveStringLiteralDfa1_0(0xe500000800000000L, 0x401L);
        case 116:
            return jjMoveStringLiteralDfa1_0(0x100000000L, 0x24L);
        case 124:
            return jjStopAtPos(0, 8);
        default:
            return jjMoveNfa_0(0, 0);
    }
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa1_0(long,long)","Method","No Comment","private int jjMoveStringLiteralDfa1_0(final long active0, final long active1) {
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(0, active0, active1);
        return 1;
    }
    switch(curChar) {
        case 46:
            if ((active1 & 0x100000L) != 0L) {
                return jjStopAtPos(1, 84);
            }
            break;
        case 47:
            if ((active0 & 0x80L) != 0L) {
                return jjStopAtPos(1, 7);
            }
            break;
        case 61:
            if ((active0 & 0x1000L) != 0L) {
                return jjStopAtPos(1, 12);
            } else if ((active0 & 0x4000L) != 0L) {
                return jjStopAtPos(1, 14);
            } else if ((active0 & 0x10000L) != 0L) {
                return jjStopAtPos(1, 16);
            }
            break;
        case 97:
            return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0x140L);
        case 100:
            if ((active0 & 0x8000000000000L) != 0L) {
                return jjStartNfaWithStates_0(1, 51, 12);
            }
            break;
        case 101:
            return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x1000L);
        case 104:
            return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L);
        case 105:
            return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L);
        case 108:
            return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x800L);
        case 110:
            return jjMoveStringLiteralDfa2_0(active0, 0x800104010000000L, active1, 0L);
        case 111:
            return jjMoveStringLiteralDfa2_0(active0, 0x12262402a0000000L, active1, 0x601aL);
        case 114:
            if ((active0 & 0x8000000L) != 0L) {
                return jjStartNfaWithStates_0(1, 27, 12);
            }
            return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x24L);
        case 116:
            return jjMoveStringLiteralDfa2_0(active0, 0x500008000000000L, active1, 0x1L);
        case 117:
            return jjMoveStringLiteralDfa2_0(active0, 0xe000000000000000L, active1, 0x680L);
        default:
            break;
    }
    return jjStartNfa_0(0, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa1_0(long,long).active0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa1_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa1_0(long,long).active1","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa1_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa2_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa2_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(0, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(1, active0, active1);
        return 2;
    }
    switch(curChar) {
        case 97:
            return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x4L);
        case 98:
            return jjMoveStringLiteralDfa3_0(active0, 0xe000000000000000L, active1, 0L);
        case 99:
            return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L);
        case 100:
            if ((active0 & 0x10000000L) != 0L) {
                return jjStartNfaWithStates_0(2, 28, 12);
            } else if ((active0 & 0x20000000L) != 0L) {
                return jjStartNfaWithStates_0(2, 29, 12);
            }
            return jjMoveStringLiteralDfa3_0(active0, 0x800000080000000L, active1, 0L);
        case 101:
            return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L);
        case 105:
            return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x1000L);
        case 108:
            return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0xc0L);
        case 109:
            if ((active1 & 0x400L) != 0L) {
                return jjStartNfaWithStates_0(2, 74, 12);
            }
            return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x200L);
        case 110:
            return jjMoveStringLiteralDfa3_0(active0, 0x1200000000000000L, active1, 0x100L);
        case 111:
            return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x808L);
        case 114:
            return jjMoveStringLiteralDfa3_0(active0, 0x100002000000000L, active1, 0x4003L);
        case 115:
            return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L);
        case 116:
            if ((active1 & 0x10L) != 0L) {
                return jjStartNfaWithStates_0(2, 68, 12);
            }
            return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L);
        case 117:
            return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x2020L);
        case 118:
            if ((active0 & 0x40000000L) != 0L) {
                return jjStartNfaWithStates_0(2, 30, 12);
            }
            break;
        case 120:
            return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L);
        case 121:
            if ((active0 & 0x10000000000000L) != 0L) {
                return jjStartNfaWithStates_0(2, 52, 12);
            }
            break;
        default:
            break;
    }
    return jjStartNfa_0(1, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa2_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa2_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa2_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa2_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa2_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa2_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa2_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa2_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa3_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa3_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(1, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(2, active0, active1);
        return 3;
    }
    switch(curChar) {
        case 97:
            return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L);
        case 98:
            return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x200L);
        case 99:
            return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L);
        case 101:
            if ((active0 & 0x80000000L) != 0L) {
                return jjStartNfaWithStates_0(3, 31, 12);
            } else if ((active0 & 0x80000000000000L) != 0L) {
                jjmatchedKind = 55;
                jjmatchedPos = 3;
            } else if ((active1 & 0x20L) != 0L) {
                return jjStartNfaWithStates_0(3, 69, 12);
            }
            return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L);
        case 102:
            return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L);
        case 103:
            if ((active1 & 0x100L) != 0L) {
                return jjStartNfaWithStates_0(3, 72, 12);
            }
            break;
        case 105:
            return jjMoveStringLiteralDfa4_0(active0, 0x102000000000000L, active1, 0x1L);
        case 108:
            if ((active1 & 0x80L) != 0L) {
                return jjStartNfaWithStates_0(3, 71, 12);
            }
            return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x1008L);
        case 109:
            return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x4002L);
        case 110:
            return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x2004L);
        case 111:
            return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x800L);
        case 114:
            return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L);
        case 115:
            return jjMoveStringLiteralDfa4_0(active0, 0xe800000000000000L, active1, 0x40L);
        case 116:
            if ((active0 & 0x100000000L) != 0L) {
                return jjStartNfaWithStates_0(3, 32, 12);
            } else if ((active0 & 0x1000000000000L) != 0L) {
                return jjStartNfaWithStates_0(3, 48, 12);
            }
            return jjMoveStringLiteralDfa4_0(active0, 0x1000000000000000L, active1, 0L);
        default:
            break;
    }
    return jjStartNfa_0(2, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa3_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa3_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa3_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa3_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa3_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa3_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa3_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa3_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa4_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa4_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(2, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(3, active0, active1);
        return 4;
    }
    switch(curChar) {
        case 45:
            return jjMoveStringLiteralDfa5_0(active0, 0x800000000000000L, active1, 0L);
        case 58:
            return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0L);
        case 97:
            return jjMoveStringLiteralDfa5_0(active0, 0x1200000000000000L, active1, 0x4002L);
        case 100:
            if ((active1 & 0x2000L) != 0L) {
                return jjStartNfaWithStates_0(4, 77, 12);
            }
            return jjMoveStringLiteralDfa5_0(active0, 0x1000000000L, active1, 0L);
        case 101:
            if ((active1 & 0x40L) != 0L) {
                return jjStartNfaWithStates_0(4, 70, 12);
            }
            return jjMoveStringLiteralDfa5_0(active0, 0xca0600000000L, active1, 0x208L);
        case 105:
            return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0x1000L);
        case 108:
            return jjMoveStringLiteralDfa5_0(active0, 0x20000000000000L, active1, 0L);
        case 110:
            return jjMoveStringLiteralDfa5_0(active0, 0x100002000000000L, active1, 0x1L);
        case 111:
            return jjMoveStringLiteralDfa5_0(active0, 0x240000000000L, active1, 0L);
        case 114:
            if ((active1 & 0x800L) != 0L) {
                return jjStartNfaWithStates_0(4, 75, 12);
            }
            break;
        case 115:
            return jjMoveStringLiteralDfa5_0(active0, 0x40114000000000L, active1, 0x4L);
        case 116:
            if ((active0 & 0x4000000000000L) != 0L) {
                return jjStartNfaWithStates_0(4, 50, 12);
            }
            return jjMoveStringLiteralDfa5_0(active0, 0xe402000000000000L, active1, 0L);
        default:
            break;
    }
    return jjStartNfa_0(3, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa4_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa4_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa4_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa4_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa4_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa4_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa4_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa4_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa5_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa5_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(3, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(4, active0, active1);
        return 5;
    }
    switch(curChar) {
        case 45:
            return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L);
        case 58:
            if ((active0 & 0x800000000L) != 0L) {
                return jjStopAtPos(5, 35);
            }
            return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L);
        case 97:
            return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x8L);
        case 98:
            return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L);
        case 100:
            return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L);
        case 103:
            if ((active0 & 0x100000000000000L) != 0L) {
                jjmatchedKind = 56;
                jjmatchedPos = 5;
            }
            return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x1L);
        case 105:
            return jjMoveStringLiteralDfa6_0(active0, 0x1002000000000000L, active1, 0L);
        case 108:
            return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x6L);
        case 110:
            return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x1000L);
        case 112:
            return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L);
        case 114:
            if ((active1 & 0x200L) != 0L) {
                return jjStartNfaWithStates_0(5, 73, 12);
            }
            return jjMoveStringLiteralDfa6_0(active0, 0xe000000000000000L, active1, 0L);
        case 115:
            return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L);
        case 116:
            if ((active0 & 0x200000000000000L) != 0L) {
                return jjStartNfaWithStates_0(5, 57, 12);
            }
            return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x4000L);
        case 119:
            return jjMoveStringLiteralDfa6_0(active0, 0x800240000000000L, active1, 0L);
        default:
            break;
    }
    return jjStartNfa_0(4, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa5_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa5_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa5_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa5_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa5_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa5_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa5_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa5_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa6_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa6_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(4, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(5, active0, active1);
        return 6;
    }
    switch(curChar) {
        case 45:
            return jjMoveStringLiteralDfa7_0(active0, 0x400000000000000L, active1, 0x4001L);
        case 58:
            if ((active0 & 0x1000000000L) != 0L) {
                return jjStopAtPos(6, 36);
            }
            return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L);
        case 97:
            return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x4L);
        case 100:
            return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L);
        case 103:
            if ((active1 & 0x1000L) != 0L) {
                return jjStartNfaWithStates_0(6, 76, 12);
            }
            break;
        case 105:
            return jjMoveStringLiteralDfa7_0(active0, 0xe800660000000000L, active1, 0x2L);
        case 110:
            if ((active1 & 0x8L) != 0L) {
                return jjStartNfaWithStates_0(6, 67, 12);
            }
            return jjMoveStringLiteralDfa7_0(active0, 0x1020000000000000L, active1, 0L);
        case 111:
            return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L);
        case 115:
            return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L);
        case 116:
            if ((active0 & 0x200000000L) != 0L) {
                return jjStartNfaWithStates_0(6, 33, 12);
            }
            break;
        case 117:
            return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L);
        default:
            break;
    }
    return jjStartNfa_0(5, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa6_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa6_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa6_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa6_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa6_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa6_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa6_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa6_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa7_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa7_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(5, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(6, active0, active1);
        return 7;
    }
    switch(curChar) {
        case 58:
            if ((active0 & 0x2000000000L) != 0L) {
                return jjStopAtPos(7, 37);
            }
            break;
        case 97:
            return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L);
        case 99:
            return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L);
        case 105:
            return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L);
        case 108:
            return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L);
        case 110:
            if ((active0 & 0x2000000000000L) != 0L) {
                return jjStartNfaWithStates_0(7, 49, 12);
            }
            return jjMoveStringLiteralDfa8_0(active0, 0xe000660000000000L, active1, 0x4000L);
        case 114:
            return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L);
        case 115:
            if ((active0 & 0x1000000000000000L) != 0L) {
                return jjStartNfaWithStates_0(7, 60, 12);
            }
            break;
        case 116:
            return jjMoveStringLiteralDfa8_0(active0, 0x800008000000000L, active1, 0x4L);
        case 119:
            return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L);
        case 122:
            return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2L);
        default:
            break;
    }
    return jjStartNfa_0(6, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa7_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa7_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa7_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa7_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa7_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa7_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa7_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa7_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa8_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa8_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(6, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(7, active0, active1);
        return 8;
    }
    switch(curChar) {
        case 45:
            return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L);
        case 58:
            return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L);
        case 101:
            if ((active1 & 0x4L) != 0L) {
                return jjStartNfaWithStates_0(8, 66, 12);
            }
            return jjMoveStringLiteralDfa9_0(active0, 0x40018000000000L, active1, 0x3L);
        case 103:
            if ((active0 & 0x8000000000000000L) != 0L) {
                jjmatchedKind = 63;
                jjmatchedPos = 8;
            }
            return jjMoveStringLiteralDfa9_0(active0, 0x6000660000000000L, active1, 0L);
        case 104:
            if ((active0 & 0x800000000000000L) != 0L) {
                return jjStartNfaWithStates_0(8, 59, 12);
            }
            break;
        case 105:
            return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L);
        case 109:
            return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L);
        case 110:
            return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L);
        case 117:
            return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x4000L);
        default:
            break;
    }
    return jjStartNfa_0(7, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa8_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa8_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa8_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa8_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa8_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa8_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa8_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa8_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa9_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa9_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(7, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(8, active0, active1);
        return 9;
    }
    switch(curChar) {
        case 45:
            return jjMoveStringLiteralDfa10_0(active0, 0x6040600000000000L, active1, 0x2L);
        case 58:
            if ((active0 & 0x4000000000L) != 0L) {
                return jjStopAtPos(9, 38);
            }
            return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L);
        case 101:
            if ((active0 & 0x20000000000000L) != 0L) {
                return jjStartNfaWithStates_0(9, 53, 12);
            }
            break;
        case 103:
            return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L);
        case 109:
            return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x4000L);
        case 110:
            return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x1L);
        case 111:
            return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L);
        case 116:
            return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L);
        default:
            break;
    }
    return jjStartNfa_0(8, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa9_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa9_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa9_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa9_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa9_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa9_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa9_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa9_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa10_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa10_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(8, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(9, active0, active1);
        return 10;
    }
    switch(curChar) {
        case 45:
            return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L);
        case 58:
            if ((active0 & 0x8000000000L) != 0L) {
                return jjStopAtPos(10, 39);
            } else if ((active0 & 0x10000000000L) != 0L) {
                return jjStopAtPos(10, 40);
            } else if ((active0 & 0x20000000000L) != 0L) {
                return jjStopAtPos(10, 41);
            } else if ((active0 & 0x40000000000L) != 0L) {
                return jjStopAtPos(10, 42);
            }
            return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L);
        case 97:
            return jjMoveStringLiteralDfa11_0(active0, 0x4000000000000000L, active1, 0L);
        case 98:
            return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0x4000L);
        case 103:
            return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x1L);
        case 104:
            if ((active0 & 0x400000000000000L) != 0L) {
                return jjStartNfaWithStates_0(10, 58, 12);
            }
            break;
        case 114:
            return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L);
        case 115:
            return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x2L);
        case 117:
            return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L);
        default:
            break;
    }
    return jjStartNfa_0(9, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa10_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa10_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa10_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa10_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa10_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa10_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa10_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa10_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa11_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa11_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(9, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(10, active0, active1);
        return 11;
    }
    switch(curChar) {
        case 45:
            return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L);
        case 58:
            if ((active0 & 0x80000000000L) != 0L) {
                return jjStopAtPos(11, 43);
            }
            break;
        case 101:
            return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0x4000L);
        case 102:
            return jjMoveStringLiteralDfa12_0(active0, 0x4000000000000000L, active1, 0L);
        case 105:
            return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L);
        case 111:
            return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L);
        case 112:
            return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x2L);
        case 114:
            return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L);
        case 116:
            return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L);
        default:
            break;
    }
    return jjStartNfa_0(10, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa11_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa11_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa11_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa11_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa11_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa11_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa11_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa11_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa12_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa12_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(10, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(11, active0, active1);
        return 12;
    }
    switch(curChar) {
        case 97:
            return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x2L);
        case 98:
            return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L);
        case 102:
            return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L);
        case 104:
            if ((active1 & 0x1L) != 0L) {
                return jjStartNfaWithStates_0(12, 64, 12);
            }
            break;
        case 105:
            if ((active0 & 0x40000000000000L) != 0L) {
                return jjStartNfaWithStates_0(12, 54, 12);
            }
            break;
        case 110:
            return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L);
        case 114:
            if ((active1 & 0x4000L) != 0L) {
                return jjStartNfaWithStates_0(12, 78, 12);
            }
            return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L);
        case 115:
            return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L);
        case 116:
            return jjMoveStringLiteralDfa13_0(active0, 0x4000000000000000L, active1, 0L);
        default:
            break;
    }
    return jjStartNfa_0(11, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa12_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa12_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa12_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa12_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa12_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa12_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa12_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa12_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa13_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa13_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(11, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(12, active0, active1);
        return 13;
    }
    switch(curChar) {
        case 45:
            return jjMoveStringLiteralDfa14_0(active0, 0x800000000000L, active1, 0L);
        case 99:
            return jjMoveStringLiteralDfa14_0(active0, 0L, active1, 0x2L);
        case 101:
            return jjMoveStringLiteralDfa14_0(active0, 0x4000100000000000L, active1, 0L);
        case 108:
            return jjMoveStringLiteralDfa14_0(active0, 0x600000000000L, active1, 0L);
        case 111:
            return jjMoveStringLiteralDfa14_0(active0, 0x2000000000000000L, active1, 0L);
        case 115:
            return jjMoveStringLiteralDfa14_0(active0, 0x400000000L, active1, 0L);
        default:
            break;
    }
    return jjStartNfa_0(12, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa13_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa13_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa13_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa13_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa13_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa13_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa13_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa13_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa14_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa14_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(12, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(13, active0, active1);
        return 14;
    }
    switch(curChar) {
        case 101:
            if ((active1 & 0x2L) != 0L) {
                return jjStartNfaWithStates_0(14, 65, 12);
            }
            break;
        case 105:
            return jjMoveStringLiteralDfa15_0(active0, 0x600000000000L, active1, 0L);
        case 108:
            return jjMoveStringLiteralDfa15_0(active0, 0x100000000000L, active1, 0L);
        case 114:
            if ((active0 & 0x4000000000000000L) != 0L) {
                return jjStartNfaWithStates_0(14, 62, 12);
            }
            return jjMoveStringLiteralDfa15_0(active0, 0x2000000000000000L, active1, 0L);
        case 115:
            return jjMoveStringLiteralDfa15_0(active0, 0x800000000000L, active1, 0L);
        case 116:
            return jjMoveStringLiteralDfa15_0(active0, 0x400000000L, active1, 0L);
        default:
            break;
    }
    return jjStartNfa_0(13, active0, active1);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa14_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa14_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa14_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa14_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa14_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa14_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa14_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa14_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa15_0(long,long,long,long)","Method","No Comment","private int jjMoveStringLiteralDfa15_0(final long old0, long active0, final long old1, long active1) {
    if (((active0 &= old0) | (active1 &= old1)) == 0L) {
        return jjStartNfa_0(13, old0, old1);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(14, active0, 0L);
        return 15;
    }
    switch(curChar) {
        case 101:
            if ((active0 & 0x2000000000000000L) != 0L) {
                return jjStartNfaWithStates_0(15, 61, 12);
            }
            return jjMoveStringLiteralDfa16_0(active0, 0x800000000000L);
        case 102:
            return jjMoveStringLiteralDfa16_0(active0, 0x100000000000L);
        case 110:
            return jjMoveStringLiteralDfa16_0(active0, 0x600000000000L);
        case 114:
            return jjMoveStringLiteralDfa16_0(active0, 0x400000000L);
        default:
            break;
    }
    return jjStartNfa_0(14, active0, 0L);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa15_0(long,long,long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa15_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa15_0(long,long,long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa15_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa15_0(long,long,long,long).old1","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa15_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa15_0(long,long,long,long).active1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa15_0(long,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa16_0(long,long)","Method","No Comment","private int jjMoveStringLiteralDfa16_0(final long old0, long active0) {
    if ((active0 &= old0) == 0L) {
        return jjStartNfa_0(14, old0, 0L);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(15, active0, 0L);
        return 16;
    }
    switch(curChar) {
        case 58:
            return jjMoveStringLiteralDfa17_0(active0, 0x100000000000L);
        case 103:
            return jjMoveStringLiteralDfa17_0(active0, 0x600000000000L);
        case 108:
            return jjMoveStringLiteralDfa17_0(active0, 0x800000000000L);
        case 117:
            return jjMoveStringLiteralDfa17_0(active0, 0x400000000L);
        default:
            break;
    }
    return jjStartNfa_0(15, active0, 0L);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa16_0(long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa16_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa16_0(long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa16_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa17_0(long,long)","Method","No Comment","private int jjMoveStringLiteralDfa17_0(final long old0, long active0) {
    if ((active0 &= old0) == 0L) {
        return jjStartNfa_0(15, old0, 0L);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(16, active0, 0L);
        return 17;
    }
    switch(curChar) {
        case 58:
            if ((active0 & 0x100000000000L) != 0L) {
                return jjStopAtPos(17, 44);
            }
            return jjMoveStringLiteralDfa18_0(active0, 0x600000000000L);
        case 99:
            return jjMoveStringLiteralDfa18_0(active0, 0x400000000L);
        case 102:
            return jjMoveStringLiteralDfa18_0(active0, 0x800000000000L);
        default:
            break;
    }
    return jjStartNfa_0(16, active0, 0L);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa17_0(long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa17_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa17_0(long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa17_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa18_0(long,long)","Method","No Comment","private int jjMoveStringLiteralDfa18_0(final long old0, long active0) {
    if ((active0 &= old0) == 0L) {
        return jjStartNfa_0(16, old0, 0L);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(17, active0, 0L);
        return 18;
    }
    switch(curChar) {
        case 58:
            if ((active0 & 0x200000000000L) != 0L) {
                return jjStopAtPos(18, 45);
            } else if ((active0 & 0x400000000000L) != 0L) {
                return jjStopAtPos(18, 46);
            }
            return jjMoveStringLiteralDfa19_0(active0, 0x800000000000L);
        case 116:
            return jjMoveStringLiteralDfa19_0(active0, 0x400000000L);
        default:
            break;
    }
    return jjStartNfa_0(17, active0, 0L);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa18_0(long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa18_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa18_0(long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa18_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa19_0(long,long)","Method","No Comment","private int jjMoveStringLiteralDfa19_0(final long old0, long active0) {
    if ((active0 &= old0) == 0L) {
        return jjStartNfa_0(17, old0, 0L);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(18, active0, 0L);
        return 19;
    }
    switch(curChar) {
        case 58:
            if ((active0 & 0x800000000000L) != 0L) {
                return jjStopAtPos(19, 47);
            }
            break;
        case 105:
            return jjMoveStringLiteralDfa20_0(active0, 0x400000000L);
        default:
            break;
    }
    return jjStartNfa_0(18, active0, 0L);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa19_0(long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa19_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa19_0(long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa19_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa20_0(long,long)","Method","No Comment","private int jjMoveStringLiteralDfa20_0(final long old0, long active0) {
    if ((active0 &= old0) == 0L) {
        return jjStartNfa_0(18, old0, 0L);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(19, active0, 0L);
        return 20;
    }
    switch(curChar) {
        case 111:
            return jjMoveStringLiteralDfa21_0(active0, 0x400000000L);
        default:
            break;
    }
    return jjStartNfa_0(19, active0, 0L);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa20_0(long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa20_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa20_0(long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa20_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa21_0(long,long)","Method","No Comment","private int jjMoveStringLiteralDfa21_0(final long old0, long active0) {
    if ((active0 &= old0) == 0L) {
        return jjStartNfa_0(19, old0, 0L);
    }
    try {
        curChar = input_stream.readChar();
    } catch (final java.io.IOException e) {
        jjStopStringLiteralDfa_0(20, active0, 0L);
        return 21;
    }
    switch(curChar) {
        case 110:
            if ((active0 & 0x400000000L) != 0L) {
                return jjStartNfaWithStates_0(21, 34, 12);
            }
            break;
        default:
            break;
    }
    return jjStartNfa_0(20, active0, 0L);
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa21_0(long,long).old0","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa21_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa21_0(long,long).active0","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveStringLiteralDfa21_0(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCheckNAdd(int)","Method","No Comment","private void jjCheckNAdd(final int state) {
    if (jjrounds[state] != jjround) {
        jjstateSet[jjnewStateCnt++] = state;
        jjrounds[state] = jjround;
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCheckNAdd(int).state","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCheckNAdd(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjAddStates(int,int)","Method","No Comment","private void jjAddStates(int start, final int end) {
    do {
        jjstateSet[jjnewStateCnt++] = jjnextStates[start];
    } while (start++ != end);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjAddStates(int,int).start","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjAddStates(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjAddStates(int,int).end","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjAddStates(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCheckNAddTwoStates(int,int)","Method","No Comment","private void jjCheckNAddTwoStates(final int state1, final int state2) {
    jjCheckNAdd(state1);
    jjCheckNAdd(state2);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCheckNAddTwoStates(int,int).state1","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCheckNAddTwoStates(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCheckNAddTwoStates(int,int).state2","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCheckNAddTwoStates(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveNfa_0(int,int)","Method","No Comment","private int jjMoveNfa_0(final int startState, int curPos) {
    int startsAt = 0;
    jjnewStateCnt = 13;
    int i = 1;
    jjstateSet[0] = startState;
    int kind = 0x7fffffff;
    for (; ; ) {
        if (++jjround == 0x7fffffff) {
            ReInitRounds();
        }
        if (curChar < 64) {
            final long l = 1L << curChar;
            MatchLoop: do {
                switch(jjstateSet[--i]) {
                    case 0:
                        if ((0x3ff000000000000L & l) != 0L) {
                            if (kind > 20) {
                                kind = 20;
                            }
                            jjCheckNAddTwoStates(6, 7);
                        } else {
                            switch(curChar) {
                                case 46:
                                    jjCheckNAdd(10);
                                    break;
                                case 39:
                                    jjCheckNAddTwoStates(4, 5);
                                    break;
                                case 34:
                                    jjCheckNAddTwoStates(1, 2);
                                    break;
                                default:
                                    break;
                            }
                        }
                        break;
                    case 1:
                        if ((0xfffffffbffffffffL & l) != 0L) {
                            jjCheckNAddTwoStates(1, 2);
                        }
                        break;
                    case 2:
                        if (curChar == 34 && kind > 18) {
                            kind = 18;
                        }
                        break;
                    case 3:
                        if (curChar == 39) {
                            jjCheckNAddTwoStates(4, 5);
                        }
                        break;
                    case 4:
                        if ((0xffffff7fffffffffL & l) != 0L) {
                            jjCheckNAddTwoStates(4, 5);
                        }
                        break;
                    case 5:
                        if (curChar == 39 && kind > 18) {
                            kind = 18;
                        }
                        break;
                    case 6:
                        if ((0x3ff000000000000L & l) == 0L) {
                            break;
                        }
                        if (kind > 20) {
                            kind = 20;
                        }
                        jjCheckNAddTwoStates(6, 7);
                        break;
                    case 7:
                        if (curChar != 46) {
                            break;
                        }
                        if (kind > 20) {
                            kind = 20;
                        }
                        jjCheckNAdd(8);
                        break;
                    case 8:
                        if ((0x3ff000000000000L & l) == 0L) {
                            break;
                        }
                        if (kind > 20) {
                            kind = 20;
                        }
                        jjCheckNAdd(8);
                        break;
                    case 9:
                        if (curChar == 46) {
                            jjCheckNAdd(10);
                        }
                        break;
                    case 10:
                        if ((0x3ff000000000000L & l) == 0L) {
                            break;
                        }
                        if (kind > 20) {
                            kind = 20;
                        }
                        jjCheckNAdd(10);
                        break;
                    case 12:
                        if ((0x3ff600000000000L & l) == 0L) {
                            break;
                        }
                        if (kind > 79) {
                            kind = 79;
                        }
                        jjstateSet[jjnewStateCnt++] = 12;
                        break;
                    default:
                        break;
                }
            } while (i != startsAt);
        } else if (curChar < 128) {
            final long l = 1L << (curChar & 077);
            MatchLoop: do {
                switch(jjstateSet[--i]) {
                    case 0:
                    case 12:
                        if ((0x7fffffe87fffffeL & l) == 0L) {
                            break;
                        }
                        if (kind > 79) {
                            kind = 79;
                        }
                        jjCheckNAdd(12);
                        break;
                    case 1:
                        jjAddStates(0, 1);
                        break;
                    case 4:
                        jjAddStates(2, 3);
                        break;
                    default:
                        break;
                }
            } while (i != startsAt);
        } else {
            final int hiByte = curChar >> 8;
            final int i1 = hiByte >> 6;
            final long l1 = 1L << (hiByte & 077);
            final int i2 = (curChar & 0xff) >> 6;
            final long l2 = 1L << (curChar & 077);
            MatchLoop: do {
                switch(jjstateSet[--i]) {
                    case 0:
                        if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) {
                            break;
                        }
                        if (kind > 79) {
                            kind = 79;
                        }
                        jjCheckNAdd(12);
                        break;
                    case 1:
                        if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
                            jjAddStates(0, 1);
                        }
                        break;
                    case 4:
                        if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
                            jjAddStates(2, 3);
                        }
                        break;
                    case 12:
                        if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) {
                            break;
                        }
                        if (kind > 79) {
                            kind = 79;
                        }
                        jjCheckNAdd(12);
                        break;
                    default:
                        break;
                }
            } while (i != startsAt);
        }
        if (kind != 0x7fffffff) {
            jjmatchedKind = kind;
            jjmatchedPos = curPos;
            kind = 0x7fffffff;
        }
        ++curPos;
        if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) {
            return curPos;
        }
        try {
            curChar = input_stream.readChar();
        } catch (final java.io.IOException e) {
            return curPos;
        }
    }
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveNfa_0(int,int).startState","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveNfa_0(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveNfa_0(int,int).curPos","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjMoveNfa_0(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long)","Method","No Comment","private static boolean jjCanMove_0(final int hiByte, final int i1, final int i2, final long l1, final long l2) {
    switch(hiByte) {
        case 0:
            return (jjbitVec2[i2] & l2) != 0L;
        default:
            if ((jjbitVec0[i1] & l1) != 0L) {
                return true;
            }
            return false;
    }
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long).hiByte","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long).i1","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long).i2","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long).l1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long).l2","Parameter_5","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_0(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long)","Method","No Comment","private static boolean jjCanMove_1(final int hiByte, final int i1, final int i2, final long l1, final long l2) {
    switch(hiByte) {
        case 0:
            return (jjbitVec4[i2] & l2) != 0L;
        case 1:
            return (jjbitVec5[i2] & l2) != 0L;
        case 2:
            return (jjbitVec6[i2] & l2) != 0L;
        case 3:
            return (jjbitVec7[i2] & l2) != 0L;
        case 4:
            return (jjbitVec8[i2] & l2) != 0L;
        case 5:
            return (jjbitVec9[i2] & l2) != 0L;
        case 6:
            return (jjbitVec10[i2] & l2) != 0L;
        case 9:
            return (jjbitVec11[i2] & l2) != 0L;
        case 10:
            return (jjbitVec12[i2] & l2) != 0L;
        case 11:
            return (jjbitVec13[i2] & l2) != 0L;
        case 12:
            return (jjbitVec14[i2] & l2) != 0L;
        case 13:
            return (jjbitVec15[i2] & l2) != 0L;
        case 14:
            return (jjbitVec16[i2] & l2) != 0L;
        case 15:
            return (jjbitVec17[i2] & l2) != 0L;
        case 16:
            return (jjbitVec18[i2] & l2) != 0L;
        case 17:
            return (jjbitVec19[i2] & l2) != 0L;
        case 30:
            return (jjbitVec20[i2] & l2) != 0L;
        case 31:
            return (jjbitVec21[i2] & l2) != 0L;
        case 33:
            return (jjbitVec22[i2] & l2) != 0L;
        case 48:
            return (jjbitVec23[i2] & l2) != 0L;
        case 49:
            return (jjbitVec24[i2] & l2) != 0L;
        case 159:
            return (jjbitVec25[i2] & l2) != 0L;
        case 215:
            return (jjbitVec26[i2] & l2) != 0L;
        default:
            if ((jjbitVec3[i1] & l1) != 0L) {
                return true;
            }
            return false;
    }
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long).hiByte","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long).i1","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long).i2","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long).l1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long).l2","Parameter_5","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_1(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long)","Method","No Comment","private static boolean jjCanMove_2(final int hiByte, final int i1, final int i2, final long l1, final long l2) {
    switch(hiByte) {
        case 0:
            return (jjbitVec27[i2] & l2) != 0L;
        case 1:
            return (jjbitVec5[i2] & l2) != 0L;
        case 2:
            return (jjbitVec28[i2] & l2) != 0L;
        case 3:
            return (jjbitVec29[i2] & l2) != 0L;
        case 4:
            return (jjbitVec30[i2] & l2) != 0L;
        case 5:
            return (jjbitVec31[i2] & l2) != 0L;
        case 6:
            return (jjbitVec32[i2] & l2) != 0L;
        case 9:
            return (jjbitVec33[i2] & l2) != 0L;
        case 10:
            return (jjbitVec34[i2] & l2) != 0L;
        case 11:
            return (jjbitVec35[i2] & l2) != 0L;
        case 12:
            return (jjbitVec36[i2] & l2) != 0L;
        case 13:
            return (jjbitVec37[i2] & l2) != 0L;
        case 14:
            return (jjbitVec38[i2] & l2) != 0L;
        case 15:
            return (jjbitVec39[i2] & l2) != 0L;
        case 16:
            return (jjbitVec18[i2] & l2) != 0L;
        case 17:
            return (jjbitVec19[i2] & l2) != 0L;
        case 30:
            return (jjbitVec20[i2] & l2) != 0L;
        case 31:
            return (jjbitVec21[i2] & l2) != 0L;
        case 32:
            return (jjbitVec40[i2] & l2) != 0L;
        case 33:
            return (jjbitVec22[i2] & l2) != 0L;
        case 48:
            return (jjbitVec41[i2] & l2) != 0L;
        case 49:
            return (jjbitVec24[i2] & l2) != 0L;
        case 159:
            return (jjbitVec25[i2] & l2) != 0L;
        case 215:
            return (jjbitVec26[i2] & l2) != 0L;
        default:
            if ((jjbitVec3[i1] & l1) != 0L) {
                return true;
            }
            return false;
    }
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long).hiByte","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long).i1","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long).i2","Parameter_3","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long).l1","Parameter_4","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long).l2","Parameter_5","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjCanMove_2(int,int,int,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.ReInit(SimpleCharStream)","Method","No Comment","public void ReInit(final SimpleCharStream stream) {
    jjmatchedPos = jjnewStateCnt = 0;
    curLexState = defaultLexState;
    input_stream = stream;
    ReInitRounds();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.ReInit(SimpleCharStream).stream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.ReInit(SimpleCharStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.ReInitRounds()","Method","No Comment","private void ReInitRounds() {
    int i;
    jjround = 0x80000001;
    for (i = 13; i-- > 0; ) {
        jjrounds[i] = 0x80000000;
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.ReInit(SimpleCharStream,int)","Method","No Comment","public void ReInit(final SimpleCharStream stream, final int lexState) {
    ReInit(stream);
    SwitchTo(lexState);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.ReInit(SimpleCharStream,int).stream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.ReInit(SimpleCharStream,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.ReInit(SimpleCharStream,int).lexState","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.ReInit(SimpleCharStream,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.SwitchTo(int)","Method","No Comment","public void SwitchTo(final int lexState) {
    if (lexState >= 1 || lexState < 0) {
        throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
    }
    curLexState = lexState;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.SwitchTo(int).lexState","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.SwitchTo(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.jjFillToken()","Method","No Comment","protected Token jjFillToken() {
    final Token t = Token.newToken(jjmatchedKind);
    t.kind = jjmatchedKind;
    final String im = jjstrLiteralImages[jjmatchedKind];
    t.image = im == null ? input_stream.GetImage() : im;
    t.beginLine = input_stream.getBeginLine();
    t.beginColumn = input_stream.getBeginColumn();
    t.endLine = input_stream.getEndLine();
    t.endColumn = input_stream.getEndColumn();
    return t;
}","Token","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.getNextToken()","Method","No Comment","public Token getNextToken() {
    Token matchedToken;
    int curPos = 0;
    EOFLoop: for (; ; ) {
        try {
            curChar = input_stream.BeginToken();
        } catch (final java.io.IOException e) {
            jjmatchedKind = 0;
            matchedToken = jjFillToken();
            return matchedToken;
        }
        try {
            input_stream.backup(0);
            while (curChar <= 32 && (0x100003600L & 1L << curChar) != 0L) {
                curChar = input_stream.BeginToken();
            }
        } catch (final java.io.IOException e1) {
            continue EOFLoop;
        }
        jjmatchedKind = 0x7fffffff;
        jjmatchedPos = 0;
        curPos = jjMoveStringLiteralDfa0_0();
        if (jjmatchedKind != 0x7fffffff) {
            if (jjmatchedPos + 1 < curPos) {
                input_stream.backup(curPos - jjmatchedPos - 1);
            }
            if ((jjtoToken[jjmatchedKind >> 6] & 1L << (jjmatchedKind & 077)) != 0L) {
                matchedToken = jjFillToken();
                return matchedToken;
            }
            continue EOFLoop;
        }
        int error_line = input_stream.getEndLine();
        int error_column = input_stream.getEndColumn();
        String error_after = null;
        boolean EOFSeen = false;
        try {
            input_stream.readChar();
            input_stream.backup(1);
        } catch (final java.io.IOException e1) {
            EOFSeen = true;
            error_after = curPos <= 1 ? """" : input_stream.GetImage();
            if (curChar == '\n' || curChar == '\r') {
                error_line++;
                error_column = 0;
            } else {
                error_column++;
            }
        }
        if (!EOFSeen) {
            input_stream.backup(1);
            error_after = curPos <= 1 ? """" : input_stream.GetImage();
        }
        throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
    }
}","Token","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.<init>(SimpleCharStream)","Constructor","No Comment","public XPathParserTokenManager(final SimpleCharStream stream) {
    if (SimpleCharStream.staticFlag) {
        throw new Error(""ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."");
    }
    input_stream = stream;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.<init>(SimpleCharStream).stream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.<init>(SimpleCharStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.<init>(SimpleCharStream,int)","Constructor","No Comment","public XPathParserTokenManager(final SimpleCharStream stream, final int lexState) {
    this(stream);
    SwitchTo(lexState);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.<init>(SimpleCharStream,int).stream","Parameter_1","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.<init>(SimpleCharStream,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.<init>(SimpleCharStream,int).lexState","Parameter_2","Belong to org.apache.commons.jxpath.ri.parser.XPathParserTokenManager.<init>(SimpleCharStream,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants","Interface","No Comment","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.EOF","Field","No Comment","int EOF = 0;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.SLASH","Field","No Comment","int SLASH = 6;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.SLASHSLASH","Field","No Comment","int SLASHSLASH = 7;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.UNION","Field","No Comment","int UNION = 8;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.PLUS","Field","No Comment","int PLUS = 9;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.MINUS","Field","No Comment","int MINUS = 10;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.EQ","Field","No Comment","int EQ = 11;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.NEQ","Field","No Comment","int NEQ = 12;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.LT","Field","No Comment","int LT = 13;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.LTE","Field","No Comment","int LTE = 14;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.GT","Field","No Comment","int GT = 15;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.GTE","Field","No Comment","int GTE = 16;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.VARIABLE","Field","No Comment","int VARIABLE = 17;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.Literal","Field","No Comment","int Literal = 18;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.Digit","Field","No Comment","int Digit = 19;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.Number","Field","No Comment","int Number = 20;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.Letter","Field","No Comment","int Letter = 21;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.BaseChar","Field","No Comment","int BaseChar = 22;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.Ideographic","Field","No Comment","int Ideographic = 23;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.CombiningChar","Field","No Comment","int CombiningChar = 24;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.UnicodeDigit","Field","No Comment","int UnicodeDigit = 25;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.Extender","Field","No Comment","int Extender = 26;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.OR","Field","No Comment","int OR = 27;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AND","Field","No Comment","int AND = 28;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.MOD","Field","No Comment","int MOD = 29;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.DIV","Field","No Comment","int DIV = 30;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.NODE","Field","No Comment","int NODE = 31;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.TEXT","Field","No Comment","int TEXT = 32;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.COMMENT","Field","No Comment","int COMMENT = 33;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.PI","Field","No Comment","int PI = 34;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_SELF","Field","No Comment","int AXIS_SELF = 35;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_CHILD","Field","No Comment","int AXIS_CHILD = 36;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_PARENT","Field","No Comment","int AXIS_PARENT = 37;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_ANCESTOR","Field","No Comment","int AXIS_ANCESTOR = 38;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_ATTRIBUTE","Field","No Comment","int AXIS_ATTRIBUTE = 39;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_NAMESPACE","Field","No Comment","int AXIS_NAMESPACE = 40;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_PRECEDING","Field","No Comment","int AXIS_PRECEDING = 41;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_FOLLOWING","Field","No Comment","int AXIS_FOLLOWING = 42;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_DESCENDANT","Field","No Comment","int AXIS_DESCENDANT = 43;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_ANCESTOR_OR_SELF","Field","No Comment","int AXIS_ANCESTOR_OR_SELF = 44;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_FOLLOWING_SIBLING","Field","No Comment","int AXIS_FOLLOWING_SIBLING = 45;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_PRECEDING_SIBLING","Field","No Comment","int AXIS_PRECEDING_SIBLING = 46;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.AXIS_DESCENDANT_OR_SELF","Field","No Comment","int AXIS_DESCENDANT_OR_SELF = 47;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_LAST","Field","No Comment","int FUNCTION_LAST = 48;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_POSITION","Field","No Comment","int FUNCTION_POSITION = 49;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_COUNT","Field","No Comment","int FUNCTION_COUNT = 50;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_ID","Field","No Comment","int FUNCTION_ID = 51;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_KEY","Field","No Comment","int FUNCTION_KEY = 52;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_LOCAL_NAME","Field","No Comment","int FUNCTION_LOCAL_NAME = 53;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_NAMESPACE_URI","Field","No Comment","int FUNCTION_NAMESPACE_URI = 54;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_NAME","Field","No Comment","int FUNCTION_NAME = 55;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_STRING","Field","No Comment","int FUNCTION_STRING = 56;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_CONCAT","Field","No Comment","int FUNCTION_CONCAT = 57;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_STARTS_WITH","Field","No Comment","int FUNCTION_STARTS_WITH = 58;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_ENDS_WITH","Field","No Comment","int FUNCTION_ENDS_WITH = 59;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_CONTAINS","Field","No Comment","int FUNCTION_CONTAINS = 60;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_SUBSTRING_BEFORE","Field","No Comment","int FUNCTION_SUBSTRING_BEFORE = 61;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_SUBSTRING_AFTER","Field","No Comment","int FUNCTION_SUBSTRING_AFTER = 62;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_SUBSTRING","Field","No Comment","int FUNCTION_SUBSTRING = 63;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_STRING_LENGTH","Field","No Comment","int FUNCTION_STRING_LENGTH = 64;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_NORMALIZE_SPACE","Field","No Comment","int FUNCTION_NORMALIZE_SPACE = 65;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_TRANSLATE","Field","No Comment","int FUNCTION_TRANSLATE = 66;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_BOOLEAN","Field","No Comment","int FUNCTION_BOOLEAN = 67;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_NOT","Field","No Comment","int FUNCTION_NOT = 68;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_TRUE","Field","No Comment","int FUNCTION_TRUE = 69;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_FALSE","Field","No Comment","int FUNCTION_FALSE = 70;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_NULL","Field","No Comment","int FUNCTION_NULL = 71;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_LANG","Field","No Comment","int FUNCTION_LANG = 72;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_NUMBER","Field","No Comment","int FUNCTION_NUMBER = 73;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_SUM","Field","No Comment","int FUNCTION_SUM = 74;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_FLOOR","Field","No Comment","int FUNCTION_FLOOR = 75;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_CEILING","Field","No Comment","int FUNCTION_CEILING = 76;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_ROUND","Field","No Comment","int FUNCTION_ROUND = 77;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.FUNCTION_FORMAT_NUMBER","Field","No Comment","int FUNCTION_FORMAT_NUMBER = 78;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.NCName","Field","No Comment","int NCName = 79;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.DEFAULT","Field","No Comment","int DEFAULT = 0;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.parser.XPathParserConstants.tokenImage","Field","No Comment","String[] tokenImage = { ""<EOF>"", ""\"" \"""", ""\""\\t\"""", ""\""\\n\"""", ""\""\\r\"""", ""\""\\f\"""", ""\""/\"""", ""\""//\"""", ""\""|\"""", ""\""+\"""", ""\""-\"""", ""\""=\"""", ""\""!=\"""", ""\""<\"""", ""\""<=\"""", ""\"">\"""", ""\"">=\"""", ""\""$\"""", ""<Literal>"", ""<Digit>"", ""<Number>"", ""<Letter>"", ""<BaseChar>"", ""<Ideographic>"", ""<CombiningChar>"", ""<UnicodeDigit>"", ""<Extender>"", ""\""or\"""", ""\""and\"""", ""\""mod\"""", ""\""div\"""", ""\""node\"""", ""\""text\"""", ""\""comment\"""", ""\""processing-instruction\"""", ""\""self::\"""", ""\""child::\"""", ""\""parent::\"""", ""\""ancestor::\"""", ""\""attribute::\"""", ""\""namespace::\"""", ""\""preceding::\"""", ""\""following::\"""", ""\""descendant::\"""", ""\""ancestor-or-self::\"""", ""\""following-sibling::\"""", ""\""preceding-sibling::\"""", ""\""descendant-or-self::\"""", ""\""last\"""", ""\""position\"""", ""\""count\"""", ""\""id\"""", ""\""key\"""", ""\""local-name\"""", ""\""namespace-uri\"""", ""\""name\"""", ""\""string\"""", ""\""concat\"""", ""\""starts-with\"""", ""\""ends-with\"""", ""\""contains\"""", ""\""substring-before\"""", ""\""substring-after\"""", ""\""substring\"""", ""\""string-length\"""", ""\""normalize-space\"""", ""\""translate\"""", ""\""boolean\"""", ""\""not\"""", ""\""true\"""", ""\""false\"""", ""\""null\"""", ""\""lang\"""", ""\""number\"""", ""\""sum\"""", ""\""floor\"""", ""\""ceiling\"""", ""\""round\"""", ""\""format-number\"""", ""<NCName>"", ""\"":\"""", ""\""(\"""", ""\"")\"""", ""\"".\"""", ""\""..\"""", ""\""[\"""", ""\""]\"""", ""\""@\"""", ""\"",\"""", ""\""*\"""" };","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression","Class","* RI of CompiledExpression.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.CompiledExpression"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.xpath","Field","No Comment","private final String xpath;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.expression","Field","No Comment","private final Expression expression;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getXPath()","Method","* Gets the source expression.
     * @return String","protected String getXPath() {
    return xpath;
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getExpression()","Method","* Gets the compiled expression.
     * @return Expression","protected Expression getExpression() {
    return expression;
}","Expression","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.toString()","Method","No Comment","@Override
public String toString() {
    return xpath;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getValue(JXPathContext)","Method","No Comment","@Override
public Object getValue(final JXPathContext context) {
    return ((JXPathContextReferenceImpl) context).getValue(xpath, expression);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getValue(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.getValue(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getValue(JXPathContext,Class)","Method","No Comment","@Override
public Object getValue(final JXPathContext context, final Class requiredType) {
    return ((JXPathContextReferenceImpl) context).getValue(xpath, expression, requiredType);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getValue(JXPathContext,Class).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.getValue(JXPathContext,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getValue(JXPathContext,Class).requiredType","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.getValue(JXPathContext,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.setValue(JXPathContext,Object)","Method","No Comment","@Override
public void setValue(final JXPathContext context, final Object value) {
    ((JXPathContextReferenceImpl) context).setValue(xpath, expression, value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.setValue(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.setValue(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.setValue(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.setValue(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.createPath(JXPathContext)","Method","No Comment","@Override
public Pointer createPath(final JXPathContext context) {
    return ((JXPathContextReferenceImpl) context).createPath(xpath, expression);
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.createPathAndSetValue(JXPathContext,Object)","Method","No Comment","@Override
public Pointer createPathAndSetValue(final JXPathContext context, final Object value) {
    return ((JXPathContextReferenceImpl) context).createPathAndSetValue(xpath, expression, value);
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.createPathAndSetValue(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.createPathAndSetValue(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.createPathAndSetValue(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.createPathAndSetValue(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.iterate(JXPathContext)","Method","No Comment","@Override
public Iterator iterate(final JXPathContext context) {
    return ((JXPathContextReferenceImpl) context).iterate(xpath, expression);
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.iterate(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.iterate(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getPointer(JXPathContext,String)","Method","No Comment","@Override
public Pointer getPointer(final JXPathContext context, final String xpath) {
    return ((JXPathContextReferenceImpl) context).getPointer(xpath, expression);
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getPointer(JXPathContext,String).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.getPointer(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.getPointer(JXPathContext,String).xpath","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.getPointer(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.iteratePointers(JXPathContext)","Method","No Comment","@Override
public Iterator iteratePointers(final JXPathContext context) {
    return ((JXPathContextReferenceImpl) context).iteratePointers(xpath, expression);
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.iteratePointers(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.iteratePointers(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.removePath(JXPathContext)","Method","No Comment","@Override
public void removePath(final JXPathContext context) {
    ((JXPathContextReferenceImpl) context).removePath(xpath, expression);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.removePath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.removePath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.removeAll(JXPathContext)","Method","No Comment","@Override
public void removeAll(final JXPathContext context) {
    ((JXPathContextReferenceImpl) context).removeAll(xpath, expression);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.removeAll(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.removeAll(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.<init>(String,Expression)","Constructor","* Create a new JXPathCompiledExpression.
     * @param xpath source
     * @param expression compiled","public JXPathCompiledExpression(final String xpath, final Expression expression) {
    this.xpath = xpath;
    this.expression = expression;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.<init>(String,Expression).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.<init>(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathCompiledExpression.<init>(String,Expression).expression","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathCompiledExpression.<init>(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer","Class","* Pointer pointing to a property of an object with dynamic properties.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyPointer",""
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -5720585681149150822L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.handler","Field","No Comment","private final DynamicPropertyHandler handler;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.name","Field","No Comment","private String name;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.names","Field","No Comment","private String[] names;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.requiredPropertyName","Field","No Comment","private String requiredPropertyName;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.isContainer()","Method","* This type of node is auxiliary.
     * @return true","@Override
public boolean isContainer() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.getPropertyCount()","Method","* Number of the DP object's properties.
     * @return int","@Override
public int getPropertyCount() {
    return getPropertyNames().length;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.getPropertyNames()","Method","* Names of all properties, sorted alphabetically.
     * @return String[]","@Override
public String[] getPropertyNames() {
    if (names == null) {
        String[] allNames = handler.getPropertyNames(getBean());
        names = new String[allNames.length];
        System.arraycopy(allNames, 0, names, 0, names.length);
        Arrays.sort(names);
        if (requiredPropertyName != null) {
            final int inx = Arrays.binarySearch(names, requiredPropertyName);
            if (inx < 0) {
                allNames = names;
                names = new String[allNames.length + 1];
                names[0] = requiredPropertyName;
                System.arraycopy(allNames, 0, names, 1, allNames.length);
                Arrays.sort(names);
            }
        }
    }
    return names;
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.getPropertyName()","Method","* Returns the name of the currently selected property or ""*""
     * if none has been selected.
     * @return String","@Override
public String getPropertyName() {
    if (name == null) {
        final String[] names = getPropertyNames();
        name = propertyIndex >= 0 && propertyIndex < names.length ? names[propertyIndex] : ""*"";
    }
    return name;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.setPropertyName(String)","Method","* Select a property by name.  If the supplied name is
     * not one of the object's existing properties, it implicitly
     * adds this name to the object's property name list. It does not
     * set the property value though. In order to set the property
     * value, call setValue().
     * @param propertyName to set","@Override
public void setPropertyName(final String propertyName) {
    setPropertyIndex(UNSPECIFIED_PROPERTY);
    this.name = propertyName;
    requiredPropertyName = propertyName;
    if (names != null && Arrays.binarySearch(names, propertyName) < 0) {
        names = null;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.setPropertyName(String).propertyName","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.setPropertyName(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.getPropertyIndex()","Method","* Index of the currently selected property in the list of all
     * properties sorted alphabetically.
     * @return int","@Override
public int getPropertyIndex() {
    if (propertyIndex == UNSPECIFIED_PROPERTY) {
        final String[] names = getPropertyNames();
        for (int i = 0; i < names.length; i++) {
            if (names[i].equals(name)) {
                setPropertyIndex(i);
                break;
            }
        }
    }
    return super.getPropertyIndex();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.setPropertyIndex(int)","Method","* Index a property by its index in the list of all
     * properties sorted alphabetically.
     * @param index to set","@Override
public void setPropertyIndex(final int index) {
    if (propertyIndex != index) {
        super.setPropertyIndex(index);
        name = null;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.setPropertyIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.setPropertyIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.getBaseValue()","Method","* Returns the value of the property, not an element of the collection
     * represented by the property, if any.
     * @return Object","@Override
public Object getBaseValue() {
    return handler.getProperty(getBean(), getPropertyName());
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.getImmediateNode()","Method","* If index == WHOLE_COLLECTION, the value of the property, otherwise
     * the value of the index'th element of the collection represented by the
     * property. If the property is not a collection, index should be zero
     * and the value will be the property itself.
     * @return Object","@Override
public Object getImmediateNode() {
    Object value;
    if (index == WHOLE_COLLECTION) {
        value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName()));
    } else {
        value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName()), index);
    }
    return value;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.isActualProperty()","Method","* A dynamic property is always considered actual - all keys are apparently
     * existing with possibly the value of null.
     * @return boolean","@Override
protected boolean isActualProperty() {
    return true;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.setValue(Object)","Method","* If index == WHOLE_COLLECTION, change the value of the property, otherwise
     * change the value of the index'th element of the collection
     * represented by the property.
     * @param value to set","@Override
public void setValue(final Object value) {
    if (index == WHOLE_COLLECTION) {
        handler.setProperty(getBean(), getPropertyName(), value);
    } else {
        ValueUtils.setValue(handler.getProperty(getBean(), getPropertyName()), index, value);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.createPath(JXPathContext)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context) {
    // Ignore the name passed to us, use our own data
    Object collection = getBaseValue();
    if (collection == null) {
        final AbstractFactory factory = getAbstractFactory(context);
        final boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0);
        if (!success) {
            throw new JXPathAbstractFactoryException(""Factory could not create an object for path: "" + asPath());
        }
        collection = getBaseValue();
    }
    if (index != WHOLE_COLLECTION) {
        if (index < 0) {
            throw new JXPathInvalidAccessException(""Index is less than 1: "" + asPath());
        }
        if (index >= getLength()) {
            collection = ValueUtils.expandCollection(collection, index + 1);
            handler.setProperty(getBean(), getPropertyName(), collection);
        }
    }
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.createPath(JXPathContext,Object)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context, final Object value) {
    if (index == WHOLE_COLLECTION) {
        handler.setProperty(getBean(), getPropertyName(), value);
    } else {
        createPath(context);
        ValueUtils.setValue(getBaseValue(), index, value);
    }
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.createPath(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.createPath(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.remove()","Method","No Comment","@Override
public void remove() {
    if (index == WHOLE_COLLECTION) {
        removeKey();
    } else if (isCollection()) {
        final Object collection = ValueUtils.remove(getBaseValue(), index);
        handler.setProperty(getBean(), getPropertyName(), collection);
    } else if (index == 0) {
        removeKey();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.removeKey()","Method","* Remove the current property.","private void removeKey() {
    final Object bean = getBean();
    if (bean instanceof Map) {
        ((Map) bean).remove(getPropertyName());
    } else {
        handler.setProperty(bean, getPropertyName(), null);
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.asPath()","Method","No Comment","@Override
public String asPath() {
    final StringBuilder buffer = new StringBuilder();
    buffer.append(getImmediateParentPointer().asPath());
    if (buffer.length() == 0) {
        buffer.append(""/."");
    } else if (buffer.charAt(buffer.length() - 1) == '/') {
        buffer.append('.');
    }
    buffer.append(""[@name='"");
    buffer.append(escape(getPropertyName()));
    buffer.append(""']"");
    if (index != WHOLE_COLLECTION && isCollection()) {
        buffer.append('[').append(index + 1).append(']');
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.<init>(NodePointer,DynamicPropertyHandler)","Constructor","* Create a new DynamicPropertyPointer.
     * @param parent pointer
     * @param handler DynamicPropertyHandler","public DynamicPropertyPointer(final NodePointer parent, final DynamicPropertyHandler handler) {
    super(parent);
    this.handler = handler;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.<init>(NodePointer,DynamicPropertyHandler).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.<init>(NodePointer,DynamicPropertyHandler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.<init>(NodePointer,DynamicPropertyHandler).handler","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer.<init>(NodePointer,DynamicPropertyHandler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory","Class","* Implements NodePointerFactory for Dynamic classes like Map.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodePointerFactory"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.DYNAMIC_POINTER_FACTORY_ORDER","Field","* Factory order constant.","public static final int DYNAMIC_POINTER_FACTORY_ORDER = 800;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.getOrder()","Method","No Comment","@Override
public int getOrder() {
    return DYNAMIC_POINTER_FACTORY_ORDER;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(QName,Object,Locale)","Method","No Comment","@Override
public NodePointer createNodePointer(final QName name, final Object bean, final Locale locale) {
    final JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());
    if (bi.isDynamic()) {
        final DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());
        return new DynamicPointer(name, bean, handler, locale);
    }
    return null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(QName,Object,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(NodePointer,QName,Object)","Method","No Comment","@Override
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object bean) {
    if (bean == null) {
        return new NullPointer(parent, name);
    }
    final JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());
    if (bi.isDynamic()) {
        final DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());
        return new DynamicPointer(parent, name, bean, handler);
    }
    return null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(NodePointer,QName,Object).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator","Class","* @deprecated - no longer needed, as it is identical to PropertyIterator.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyIterator",""
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Constructor","* Create a new DynamicPropertyIterator
     * @param pointer PropertyOwnerPointer
     * @param name String
     * @param reverse iteration order
     * @param startWith beginning child","public DynamicPropertyIterator(final PropertyOwnerPointer pointer, final String name, final boolean reverse, final NodePointer startWith) {
    super(pointer, name, reverse, startWith);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer).reverse","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer).startWith","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer","Class","* A Pointer that points to an object with Dynamic Properties. It is used for
 * the first element of a path; following elements will by of type
 * {@link PropertyPointer}.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer",""
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.name","Field","No Comment","private final QName name;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.bean","Field","No Comment","private final Object bean;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.handler","Field","No Comment","private final DynamicPropertyHandler handler;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -1842347025295904256L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.getPropertyPointer()","Method","No Comment","@Override
public PropertyPointer getPropertyPointer() {
    return new DynamicPropertyPointer(this, handler);
}","PropertyPointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.createNodeIterator(String,boolean,NodePointer)","Method","No Comment","@Override
public NodeIterator createNodeIterator(final String property, final boolean reverse, final NodePointer startWith) {
    return new PropertyIterator(this, property, reverse, startWith);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.createNodeIterator(String,boolean,NodePointer).property","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.createNodeIterator(String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.createNodeIterator(String,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.createNodeIterator(String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.createNodeIterator(String,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.createNodeIterator(String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.attributeIterator(QName)","Method","No Comment","@Override
public NodeIterator attributeIterator(final QName name) {
    return new DynamicAttributeIterator(this, name);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.attributeIterator(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.attributeIterator(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.getName()","Method","No Comment","@Override
public QName getName() {
    return name;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.isDynamicPropertyDeclarationSupported()","Method","No Comment","@Override
public boolean isDynamicPropertyDeclarationSupported() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.getBaseValue()","Method","* Returns the DP object iself.
     * @return Object","@Override
public Object getBaseValue() {
    return bean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    final Object value = getNode();
    return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.getLength()","Method","* Returns 1.
     * @return int","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.asPath()","Method","No Comment","@Override
public String asPath() {
    return parent == null ? ""/"" : super.asPath();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return System.identityHashCode(bean) + (name == null ? 0 : name.hashCode());
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof DynamicPointer)) {
        return false;
    }
    final DynamicPointer other = (DynamicPointer) object;
    if (bean != other.bean) {
        return false;
    }
    return name == other.name || name != null && name.equals(other.name);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(QName,Object,DynamicPropertyHandler,Locale)","Constructor","* Create a new DynamicPointer.
     * @param name property name
     * @param bean owning bean
     * @param handler DynamicPropertyHandler
     * @param locale Locale","public DynamicPointer(final QName name, final Object bean, final DynamicPropertyHandler handler, final Locale locale) {
    super(null, locale);
    this.name = name;
    this.bean = bean;
    this.handler = handler;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(QName,Object,DynamicPropertyHandler,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(QName,Object,DynamicPropertyHandler,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(QName,Object,DynamicPropertyHandler,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(QName,Object,DynamicPropertyHandler,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(QName,Object,DynamicPropertyHandler,Locale).handler","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(QName,Object,DynamicPropertyHandler,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(QName,Object,DynamicPropertyHandler,Locale).locale","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(QName,Object,DynamicPropertyHandler,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(NodePointer,QName,Object,DynamicPropertyHandler)","Constructor","* Create a new DynamicPointer.
     * @param parent parent pointer
     * @param name property name
     * @param bean owning bean
     * @param handler DynamicPropertyHandler","public DynamicPointer(final NodePointer parent, final QName name, final Object bean, final DynamicPropertyHandler handler) {
    super(parent);
    this.name = name;
    this.bean = bean;
    this.handler = handler;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(NodePointer,QName,Object,DynamicPropertyHandler).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(NodePointer,QName,Object,DynamicPropertyHandler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(NodePointer,QName,Object,DynamicPropertyHandler).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(NodePointer,QName,Object,DynamicPropertyHandler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(NodePointer,QName,Object,DynamicPropertyHandler).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(NodePointer,QName,Object,DynamicPropertyHandler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(NodePointer,QName,Object,DynamicPropertyHandler).handler","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.<init>(NodePointer,QName,Object,DynamicPropertyHandler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator","Class","* {@code DynamicAttributeIterator} is different from a regular
 * {@code BeanAttributeIterator} in that given a property name it
 * will always find that property (albeit with a null value).","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator",""
"org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator.prepareForIndividualProperty(String)","Method","No Comment","@Override
protected void prepareForIndividualProperty(final String name) {
    ((DynamicPropertyPointer) getPropertyPointer()).setPropertyName(name);
    super.prepareForIndividualProperty(name);
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator.prepareForIndividualProperty(String).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator.prepareForIndividualProperty(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator.<init>(PropertyOwnerPointer,QName)","Constructor","* Create a new DynamicAttributeIterator.
     * @param parent pointer
     * @param name to match properties","public DynamicAttributeIterator(final PropertyOwnerPointer parent, final QName name) {
    super(parent, name);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator.<init>(PropertyOwnerPointer,QName).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator.<init>(PropertyOwnerPointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator.<init>(PropertyOwnerPointer,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator.<init>(PropertyOwnerPointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodeIterator","Interface","* Definition for an iterator for all kinds of Nodes.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.model.NodeIterator.getPosition()","Abstract Method","* Gets the current iterator position.
     * @return int position","int getPosition();","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodeIterator.setPosition(int)","Abstract Method","* Sets the new current position.
     * @param position the position to set
     * @return {@code true} if there is a node at {@code position}.","boolean setPosition(int position);","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodeIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodeIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodeIterator.getNodePointer()","Abstract Method","* Gets the NodePointer at the current position.
     * @return NodePointer","NodePointer getNodePointer();","NodePointer","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory","Class","* Implemented in response to [JXPATH-144]. Optionally pluggable
 * {@code NodePointerFactory} that returns a special type of
 * {@code NodePointer} for {@code LazyDynaBean}s. The
 * {@code PropertyPointer}s returned by these will respect
 * {@link LazyDynaClass#isDynaProperty(String)} when determining
 * {@link PropertyPointer#isActual()}.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodePointerFactory"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.getOrder()","Method","* {@inheritDoc}","@Override
public int getOrder() {
    return DynaBeanPointerFactory.DYNA_BEAN_POINTER_FACTORY_ORDER - 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(QName,Object,Locale)","Method","* {@inheritDoc}","@Override
public NodePointer createNodePointer(final QName name, final Object object, final Locale locale) {
    return object instanceof LazyDynaBean ? new StrictLazyDynaBeanPointer(name, (LazyDynaBean) object, locale) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(QName,Object,Locale).object","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Method","* {@inheritDoc}","@Override
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object object) {
    return object instanceof LazyDynaBean ? new StrictLazyDynaBeanPointer(parent, name, (LazyDynaBean) object) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object).object","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer","Class","* Pointer implementation.","Class do not obtain Source Code","No return type","private , static , final ","org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer",""
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.lazyDynaBean","Field","No Comment","private final LazyDynaBean lazyDynaBean;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.getPropertyPointer()","Method","* {@inheritDoc}","@Override
public PropertyPointer getPropertyPointer() {
    return new DynaBeanPropertyPointer(this, lazyDynaBean) {

        private static final long serialVersionUID = 1L;

        @Override
        protected boolean isActualProperty() {
            return ((LazyDynaClass) lazyDynaBean.getDynaClass()).isDynaProperty(getPropertyName());
        }
    };
}","PropertyPointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean)","Constructor","* Create a new StrictLazyDynaBeanPointer instance.
         *
         * @param parent pointer
         * @param name is the name given to the first node
         * @param lazyDynaBean pointed","public StrictLazyDynaBeanPointer(final NodePointer parent, final QName name, final LazyDynaBean lazyDynaBean) {
    super(parent, name, lazyDynaBean);
    this.lazyDynaBean = lazyDynaBean;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean).lazyDynaBean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale)","Constructor","* Create a new StrictLazyDynaBeanPointer instance.
         *
         * @param name is the name given to the first node
         * @param lazyDynaBean pointed
         * @param locale Locale","public StrictLazyDynaBeanPointer(final QName name, final LazyDynaBean lazyDynaBean, final Locale locale) {
    super(name, lazyDynaBean, locale);
    this.lazyDynaBean = lazyDynaBean;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale).lazyDynaBean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer","Class","* Pointer implementation.","Class do not obtain Source Code","No return type","private , static , final ","org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer",""
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.lazyDynaBean","Field","No Comment","private final LazyDynaBean lazyDynaBean;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.getPropertyPointer()","Method","* {@inheritDoc}","@Override
public PropertyPointer getPropertyPointer() {
    return new DynaBeanPropertyPointer(this, lazyDynaBean) {

        private static final long serialVersionUID = 1L;

        @Override
        protected boolean isActualProperty() {
            return ((LazyDynaClass) lazyDynaBean.getDynaClass()).isDynaProperty(getPropertyName());
        }
    };
}","PropertyPointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean)","Constructor","* Create a new StrictLazyDynaBeanPointer instance.
         *
         * @param parent pointer
         * @param name is the name given to the first node
         * @param lazyDynaBean pointed","public StrictLazyDynaBeanPointer(final NodePointer parent, final QName name, final LazyDynaBean lazyDynaBean) {
    super(parent, name, lazyDynaBean);
    this.lazyDynaBean = lazyDynaBean;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean).lazyDynaBean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(NodePointer,QName,LazyDynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale)","Constructor","* Create a new StrictLazyDynaBeanPointer instance.
         *
         * @param name is the name given to the first node
         * @param lazyDynaBean pointed
         * @param locale Locale","public StrictLazyDynaBeanPointer(final QName name, final LazyDynaBean lazyDynaBean, final Locale locale) {
    super(name, lazyDynaBean, locale);
    this.lazyDynaBean = lazyDynaBean;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale).lazyDynaBean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory.StrictLazyDynaBeanPointer.<init>(QName,LazyDynaBean,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory","Class","* Implements NodePointerFactory for DynaBeans.
 * See <a href=""https://commons.apache.org/beanutils/"">
 * Apache Commons BeanUtils
 * </a>","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodePointerFactory"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.DYNA_BEAN_POINTER_FACTORY_ORDER","Field","Factory order constant","public static final int DYNA_BEAN_POINTER_FACTORY_ORDER = 700;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.getOrder()","Method","No Comment","@Override
public int getOrder() {
    return DYNA_BEAN_POINTER_FACTORY_ORDER;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(QName,Object,Locale)","Method","No Comment","@Override
public NodePointer createNodePointer(final QName name, final Object bean, final Locale locale) {
    return bean instanceof DynaBean ? new DynaBeanPointer(name, (DynaBean) bean, locale) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(QName,Object,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Method","No Comment","@Override
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object bean) {
    return bean instanceof DynaBean ? new DynaBeanPointer(parent, name, (DynaBean) bean) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer","Class","* A Pointer that points to a {@link DynaBean}.  If the target DynaBean is Serializable,
 * so should this instance be.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer",""
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -9135052498044877965L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.name","Field","No Comment","private final QName name;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.dynaBean","Field","No Comment","private final DynaBean dynaBean;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.getPropertyPointer()","Method","No Comment","@Override
public PropertyPointer getPropertyPointer() {
    return new DynaBeanPropertyPointer(this, dynaBean);
}","PropertyPointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.getName()","Method","No Comment","@Override
public QName getName() {
    return name;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return dynaBean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return dynaBean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return name == null ? 0 : name.hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof DynaBeanPointer)) {
        return false;
    }
    final DynaBeanPointer other = (DynaBeanPointer) object;
    if (!(equalObjects(parent, other.parent) && equalObjects(name, other.name))) {
        return false;
    }
    final int iThis = index == WHOLE_COLLECTION ? 0 : index;
    final int iOther = other.index == WHOLE_COLLECTION ? 0 : other.index;
    return iThis == iOther && dynaBean == other.dynaBean;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.asPath()","Method","No Comment","@Override
public String asPath() {
    return parent == null ? ""/"" : super.asPath();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.equalObjects(Object,Object)","Method","* Learn whether two objects are == || .equals().
     * @param o1 first object
     * @param o2 second object
     * @return boolean","private static boolean equalObjects(final Object o1, final Object o2) {
    return o1 == o2 || o1 != null && o1.equals(o2);
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.equalObjects(Object,Object).o1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.equalObjects(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.equalObjects(Object,Object).o2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.equalObjects(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(QName,DynaBean,Locale)","Constructor","* Create a new DynaBeanPointer.
     * @param name is the name given to the first node
     * @param dynaBean pointed
     * @param locale Locale","public DynaBeanPointer(final QName name, final DynaBean dynaBean, final Locale locale) {
    super(null, locale);
    this.name = name;
    this.dynaBean = dynaBean;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(QName,DynaBean,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(QName,DynaBean,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(QName,DynaBean,Locale).dynaBean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(QName,DynaBean,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(QName,DynaBean,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(QName,DynaBean,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(NodePointer,QName,DynaBean)","Constructor","* Create a new DynaBeanPointer.
     * @param parent pointer
     * @param name is the name given to the first node
     * @param dynaBean pointed","public DynaBeanPointer(final NodePointer parent, final QName name, final DynaBean dynaBean) {
    super(parent);
    this.name = name;
    this.dynaBean = dynaBean;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(NodePointer,QName,DynaBean).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(NodePointer,QName,DynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(NodePointer,QName,DynaBean).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(NodePointer,QName,DynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(NodePointer,QName,DynaBean).dynaBean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer.<init>(NodePointer,QName,DynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer","Class","* Pointer pointing to a property of a {@link DynaBean}. If the target DynaBean is
 * Serializable, so should this instance be.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyPointer",""
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.CLASS","Field","No Comment","private static final String CLASS = ""class"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.dynaBean","Field","No Comment","private final DynaBean dynaBean;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.name","Field","No Comment","private String name;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.names","Field","No Comment","private String[] names;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 2094421509141267239L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return dynaBean.get(getPropertyName());
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.isContainer()","Method","* This type of node is auxiliary.
     * @return true","@Override
public boolean isContainer() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.getPropertyCount()","Method","No Comment","@Override
public int getPropertyCount() {
    return getPropertyNames().length;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.getPropertyNames()","Method","No Comment","@Override
public String[] getPropertyNames() {
    /* @todo do something about the sorting - LIKE WHAT? - MJB */
    if (names == null) {
        final DynaClass dynaClass = dynaBean.getDynaClass();
        final DynaProperty[] dynaProperties = dynaClass.getDynaProperties();
        final ArrayList properties = new ArrayList(dynaProperties.length);
        for (final DynaProperty element : dynaProperties) {
            final String name = element.getName();
            if (!CLASS.equals(name)) {
                properties.add(name);
            }
        }
        names = (String[]) properties.toArray(new String[properties.size()]);
        Arrays.sort(names);
    }
    return names;
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.getPropertyName()","Method","* Returns the name of the currently selected property or ""*""
     * if none has been selected.
     * @return String","@Override
public String getPropertyName() {
    if (name == null) {
        final String[] names = getPropertyNames();
        name = propertyIndex >= 0 && propertyIndex < names.length ? names[propertyIndex] : ""*"";
    }
    return name;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setPropertyName(String)","Method","* Select a property by name.
     * @param propertyName to select","@Override
public void setPropertyName(final String propertyName) {
    setPropertyIndex(UNSPECIFIED_PROPERTY);
    this.name = propertyName;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setPropertyName(String).propertyName","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setPropertyName(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.getPropertyIndex()","Method","* Index of the currently selected property in the list of all
     * properties sorted alphabetically.
     * @return int","@Override
public int getPropertyIndex() {
    if (propertyIndex == UNSPECIFIED_PROPERTY) {
        final String[] names = getPropertyNames();
        for (int i = 0; i < names.length; i++) {
            if (names[i].equals(name)) {
                propertyIndex = i;
                name = null;
                break;
            }
        }
    }
    return super.getPropertyIndex();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setPropertyIndex(int)","Method","* Index a property by its index in the list of all
     * properties sorted alphabetically.
     * @param index to set","@Override
public void setPropertyIndex(final int index) {
    if (propertyIndex != index) {
        super.setPropertyIndex(index);
        name = null;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setPropertyIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setPropertyIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.getImmediateNode()","Method","* If index == WHOLE_COLLECTION, the value of the property, otherwise
     * the value of the index'th element of the collection represented by the
     * property. If the property is not a collection, index should be zero
     * and the value will be the property itself.
     * @return Object","@Override
public Object getImmediateNode() {
    final String name = getPropertyName();
    if (name.equals(""*"")) {
        return null;
    }
    Object value;
    if (index == WHOLE_COLLECTION) {
        value = ValueUtils.getValue(dynaBean.get(name));
    } else if (isIndexedProperty()) {
        // DynaClass at this point is not based on whether
        // the property is indeed indexed, but rather on
        // whether it is an array or List. Therefore
        // the indexed set may fail.
        try {
            value = ValueUtils.getValue(dynaBean.get(name, index));
        } catch (final ArrayIndexOutOfBoundsException ex) {
            value = null;
        } catch (final IllegalArgumentException ex) {
            value = dynaBean.get(name);
            value = ValueUtils.getValue(value, index);
        }
    } else {
        value = dynaBean.get(name);
        if (ValueUtils.isCollection(value)) {
            value = ValueUtils.getValue(value, index);
        } else if (index != 0) {
            value = null;
        }
    }
    return value;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.isActualProperty()","Method","* Returns true if the bean has the currently selected property.
     * @return boolean","@Override
protected boolean isActualProperty() {
    final DynaClass dynaClass = dynaBean.getDynaClass();
    return dynaClass.getDynaProperty(getPropertyName()) != null;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.isIndexedProperty()","Method","* Learn whether the property referenced is an indexed property.
     * @return boolean","protected boolean isIndexedProperty() {
    final DynaClass dynaClass = dynaBean.getDynaClass();
    final DynaProperty property = dynaClass.getDynaProperty(name);
    return property.isIndexed();
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setValue(Object)","Method","* If index == WHOLE_COLLECTION, change the value of the property, otherwise
     * change the value of the index'th element of the collection
     * represented by the property.
     * @param value to set","@Override
public void setValue(final Object value) {
    setValue(index, value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.remove()","Method","No Comment","@Override
public void remove() {
    if (index == WHOLE_COLLECTION) {
        dynaBean.set(getPropertyName(), null);
    } else if (isIndexedProperty()) {
        dynaBean.set(getPropertyName(), index, null);
    } else if (isCollection()) {
        final Object collection = ValueUtils.remove(getBaseValue(), index);
        dynaBean.set(getPropertyName(), collection);
    } else if (index == 0) {
        dynaBean.set(getPropertyName(), null);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setValue(int,Object)","Method","* Sets an indexed value.
     * @param index to change
     * @param value to set","private void setValue(final int index, final Object value) {
    if (index == WHOLE_COLLECTION) {
        dynaBean.set(getPropertyName(), convert(value, false));
    } else if (isIndexedProperty()) {
        dynaBean.set(getPropertyName(), index, convert(value, true));
    } else {
        final Object baseValue = dynaBean.get(getPropertyName());
        ValueUtils.setValue(baseValue, index, value);
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setValue(int,Object).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setValue(int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setValue(int,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.setValue(int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.convert(Object,boolean)","Method","* Convert a value to the appropriate property type.
     * @param value to convert
     * @param element whether this should be a collection element.
     * @return conversion result","private Object convert(final Object value, final boolean element) {
    final DynaClass dynaClass = dynaBean.getDynaClass();
    final DynaProperty property = dynaClass.getDynaProperty(getPropertyName());
    Class type = property.getType();
    if (element) {
        if (type.isArray()) {
            type = type.getComponentType();
        } else {
            // No need to convert
            return value;
        }
    }
    try {
        return TypeUtils.convert(value, type);
    } catch (final Exception ex) {
        final String string = value == null ? ""null"" : value.getClass().getName();
        throw new JXPathTypeConversionException(""Cannot convert value of class "" + string + "" to type "" + type, ex);
    }
}","Object","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.convert(Object,boolean).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.convert(Object,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.convert(Object,boolean).element","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.convert(Object,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.<init>(NodePointer,DynaBean)","Constructor","* Create a new DynaBeanPropertyPointer.
     * @param parent pointer
     * @param dynaBean pointed","public DynaBeanPropertyPointer(final NodePointer parent, final DynaBean dynaBean) {
    super(parent);
    this.dynaBean = dynaBean;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.<init>(NodePointer,DynaBean).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.<init>(NodePointer,DynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.<init>(NodePointer,DynaBean).dynaBean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.<init>(NodePointer,DynaBean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory","Class","* Implements NodePointerFactory for {@link Container} objects.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodePointerFactory"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.CONTAINER_POINTER_FACTORY_ORDER","Field","Factory order for this factory","public static final int CONTAINER_POINTER_FACTORY_ORDER = 200;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.getOrder()","Method","No Comment","@Override
public int getOrder() {
    return CONTAINER_POINTER_FACTORY_ORDER;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(QName,Object,Locale)","Method","No Comment","@Override
public NodePointer createNodePointer(final QName name, final Object bean, final Locale locale) {
    return bean instanceof Container ? new ContainerPointer((Container) bean, locale) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(QName,Object,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(NodePointer,QName,Object)","Method","No Comment","@Override
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object bean) {
    return bean instanceof Container ? new ContainerPointer(parent, (Container) bean) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(NodePointer,QName,Object).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer","Class","* Transparent pointer to a Container. The {@link #getValue()} method
 * returns the contents of the container, rather than the container
 * itself.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.container","Field","No Comment","private final Container container;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.valuePointer","Field","No Comment","private NodePointer valuePointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 6140752946621686118L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.isContainer()","Method","* This type of node is auxiliary.
     * @return {@code true}.","@Override
public boolean isContainer() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.getName()","Method","No Comment","@Override
public QName getName() {
    return null;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return container;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    final Object value = getBaseValue();
    return value != null && ValueUtils.isCollection(value);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.getLength()","Method","No Comment","@Override
public int getLength() {
    final Object value = getBaseValue();
    return value == null ? 1 : ValueUtils.getLength(value);
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return getValuePointer().isLeaf();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    final Object value = getBaseValue();
    if (index != WHOLE_COLLECTION) {
        return index >= 0 && index < getLength() ? ValueUtils.getValue(value, index) : null;
    }
    return ValueUtils.getValue(value);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.setValue(Object)","Method","No Comment","@Override
public void setValue(final Object value) {
    // TODO: what if this is a collection?
    container.setValue(value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.getImmediateValuePointer()","Method","No Comment","@Override
public NodePointer getImmediateValuePointer() {
    if (valuePointer == null) {
        final Object value = getImmediateNode();
        valuePointer = newChildNodePointer(this, getName(), value);
    }
    return valuePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return System.identityHashCode(container) + index;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof ContainerPointer)) {
        return false;
    }
    final ContainerPointer other = (ContainerPointer) object;
    return container == other.container && index == other.index;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.childIterator(NodeTest,boolean,NodePointer)","Method","No Comment","@Override
public NodeIterator childIterator(final NodeTest test, final boolean reverse, final NodePointer startWith) {
    return getValuePointer().childIterator(test, reverse, startWith);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.childIterator(NodeTest,boolean,NodePointer).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.childIterator(NodeTest,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.childIterator(NodeTest,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.attributeIterator(QName)","Method","No Comment","@Override
public NodeIterator attributeIterator(final QName name) {
    return getValuePointer().attributeIterator(name);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.attributeIterator(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.attributeIterator(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.namespaceIterator()","Method","No Comment","@Override
public NodeIterator namespaceIterator() {
    return getValuePointer().namespaceIterator();
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.namespacePointer(String)","Method","No Comment","@Override
public NodePointer namespacePointer(final String namespace) {
    return getValuePointer().namespacePointer(namespace);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.namespacePointer(String).namespace","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.namespacePointer(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.testNode(NodeTest)","Method","No Comment","@Override
public boolean testNode(final NodeTest nodeTest) {
    return getValuePointer().testNode(nodeTest);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.testNode(NodeTest).nodeTest","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.testNode(NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    return pointer1.getIndex() - pointer2.getIndex();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.getNamespaceURI(String)","Method","No Comment","@Override
public String getNamespaceURI(final String prefix) {
    return getValuePointer().getNamespaceURI(prefix);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.getNamespaceURI(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.getNamespaceURI(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.asPath()","Method","No Comment","@Override
public String asPath() {
    return parent == null ? ""/"" : parent.asPath();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(Container,Locale)","Constructor","* Create a new ContainerPointer.
     * @param container Container object
     * @param locale Locale","public ContainerPointer(final Container container, final Locale locale) {
    super(null, locale);
    this.container = container;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(Container,Locale).container","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(Container,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(Container,Locale).locale","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(Container,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(NodePointer,Container)","Constructor","* Create a new ContainerPointer.
     * @param parent parent pointer
     * @param container Container object","public ContainerPointer(final NodePointer parent, final Container container) {
    super(parent);
    this.container = container;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(NodePointer,Container).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(NodePointer,Container)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(NodePointer,Container).container","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.container.ContainerPointer.<init>(NodePointer,Container)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer","Class","* Pointer to a context variable.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.VariablePointer.variables","Field","No Comment","private Variables variables;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.name","Field","No Comment","private final QName name;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.valuePointer","Field","No Comment","private NodePointer valuePointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.actual","Field","No Comment","private boolean actual;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -454731297397189293L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.isContainer()","Method","No Comment","@Override
public boolean isContainer() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.getName()","Method","No Comment","@Override
public QName getName() {
    return name;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    if (!actual) {
        throw new JXPathException(""Undefined variable: "" + name);
    }
    return variables.getVariable(name.toString());
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    final Object value = getNode();
    return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    final Object value = getBaseValue();
    return value != null && ValueUtils.isCollection(value);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    final Object value = getBaseValue();
    return index == WHOLE_COLLECTION ? ValueUtils.getValue(value) : ValueUtils.getValue(value, index);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.setValue(Object)","Method","No Comment","@Override
public void setValue(final Object value) {
    if (!actual) {
        throw new JXPathException(""Cannot set undefined variable: "" + name);
    }
    valuePointer = null;
    if (index != WHOLE_COLLECTION) {
        final Object collection = getBaseValue();
        ValueUtils.setValue(collection, index, value);
    } else {
        variables.declareVariable(name.toString(), value);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.isActual()","Method","No Comment","@Override
public boolean isActual() {
    return actual;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.setIndex(int)","Method","No Comment","@Override
public void setIndex(final int index) {
    super.setIndex(index);
    valuePointer = null;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.setIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.setIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.getImmediateValuePointer()","Method","No Comment","@Override
public NodePointer getImmediateValuePointer() {
    if (valuePointer == null) {
        Object value;
        if (actual) {
            value = getImmediateNode();
            valuePointer = newChildNodePointer(this, null, value);
        } else {
            return new NullPointer(this, getName()) {

                private static final long serialVersionUID = 1L;

                @Override
                public Object getImmediateNode() {
                    throw new JXPathException(""Undefined variable: "" + name);
                }
            };
        }
    }
    return valuePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.getLength()","Method","No Comment","@Override
public int getLength() {
    if (actual) {
        final Object value = getBaseValue();
        return value == null ? 1 : ValueUtils.getLength(value);
    }
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createPath(JXPathContext,Object)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context, final Object value) {
    if (actual) {
        setValue(value);
        return this;
    }
    final NodePointer ptr = createPath(context);
    ptr.setValue(value);
    return ptr;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createPath(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createPath(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createPath(JXPathContext)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context) {
    if (!actual) {
        final AbstractFactory factory = getAbstractFactory(context);
        if (!factory.declareVariable(context, name.toString())) {
            throw new JXPathAbstractFactoryException(""Factory cannot define variable '"" + name + ""' for path: "" + asPath());
        }
        findVariables(context);
        // Assert: actual == true
    }
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index) {
    final Object collection = createCollection(context, index);
    if (!isActual() || index != 0 && index != WHOLE_COLLECTION) {
        final AbstractFactory factory = getAbstractFactory(context);
        final boolean success = factory.createObject(context, this, collection, getName().toString(), index);
        if (!success) {
            throw new JXPathAbstractFactoryException(""Factory could not create object path: "" + asPath());
        }
        final NodePointer cln = (NodePointer) clone();
        cln.setIndex(index);
        return cln;
    }
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int,Object)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index, final Object value) {
    final Object collection = createCollection(context, index);
    ValueUtils.setValue(collection, index, value);
    final NodePointer cl = (NodePointer) clone();
    cl.setIndex(index);
    return cl;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int,Object).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int,Object).value","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createCollection(JXPathContext,int)","Method","* Create a collection.
     * @param context JXPathContext
     * @param index collection index
     * @return Object","private Object createCollection(final JXPathContext context, int index) {
    createPath(context);
    Object collection = getBaseValue();
    if (collection == null) {
        throw new JXPathAbstractFactoryException(""Factory did not assign a collection to variable '"" + name + ""' for path: "" + asPath());
    }
    if (index == WHOLE_COLLECTION) {
        index = 0;
    } else if (index < 0) {
        throw new JXPathInvalidAccessException(""Index is less than 1: "" + asPath());
    }
    if (index >= getLength()) {
        collection = ValueUtils.expandCollection(collection, index + 1);
        variables.declareVariable(name.toString(), collection);
    }
    return collection;
}","Object","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createCollection(JXPathContext,int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createCollection(JXPathContext,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.createCollection(JXPathContext,int).index","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.createCollection(JXPathContext,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.remove()","Method","No Comment","@Override
public void remove() {
    if (actual) {
        if (index == WHOLE_COLLECTION) {
            variables.undeclareVariable(name.toString());
        } else {
            if (index < 0) {
                throw new JXPathInvalidAccessException(""Index is less than 1: "" + asPath());
            }
            Object collection = getBaseValue();
            if (collection != null && index < getLength()) {
                collection = ValueUtils.remove(collection, index);
                variables.declareVariable(name.toString(), collection);
            }
        }
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.findVariables(JXPathContext)","Method","* Assimilate the Variables instance associated with the specified context.
     * @param context JXPathContext to search","protected void findVariables(final JXPathContext context) {
    valuePointer = null;
    JXPathContext varCtx = context;
    while (varCtx != null) {
        variables = varCtx.getVariables();
        if (variables.isDeclaredVariable(name.toString())) {
            actual = true;
            break;
        }
        varCtx = varCtx.getParentContext();
        variables = null;
    }
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.findVariables(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.findVariables(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return (actual ? System.identityHashCode(variables) : 0) + name.hashCode() + index;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof VariablePointer)) {
        return false;
    }
    final VariablePointer other = (VariablePointer) object;
    return variables == other.variables && name.equals(other.name) && index == other.index;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    final StringBuilder buffer = new StringBuilder();
    buffer.append('$');
    buffer.append(name);
    if (!actual) {
        if (index != WHOLE_COLLECTION) {
            buffer.append('[').append(index + 1).append(']');
        }
    } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) {
        buffer.append('[').append(index + 1).append(']');
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.childIterator(NodeTest,boolean,NodePointer)","Method","No Comment","@Override
public NodeIterator childIterator(final NodeTest test, final boolean reverse, final NodePointer startWith) {
    return getValuePointer().childIterator(test, reverse, startWith);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.childIterator(NodeTest,boolean,NodePointer).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.childIterator(NodeTest,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.childIterator(NodeTest,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.attributeIterator(QName)","Method","No Comment","@Override
public NodeIterator attributeIterator(final QName name) {
    return getValuePointer().attributeIterator(name);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.attributeIterator(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.attributeIterator(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.namespaceIterator()","Method","No Comment","@Override
public NodeIterator namespaceIterator() {
    return getValuePointer().namespaceIterator();
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.namespacePointer(String)","Method","No Comment","@Override
public NodePointer namespacePointer(final String name) {
    return getValuePointer().namespacePointer(name);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.namespacePointer(String).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.namespacePointer(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.testNode(NodeTest)","Method","No Comment","@Override
public boolean testNode(final NodeTest nodeTest) {
    return getValuePointer().testNode(nodeTest);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.testNode(NodeTest).nodeTest","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.testNode(NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    return pointer1.getIndex() - pointer2.getIndex();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.<init>(Variables,QName)","Constructor","* Create a new VariablePointer.
     * @param variables Variables instance
     * @param name variable name","public VariablePointer(final Variables variables, final QName name) {
    super(null);
    this.variables = variables;
    this.name = name;
    actual = true;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.<init>(Variables,QName).variables","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.<init>(Variables,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.<init>(Variables,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.<init>(Variables,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.<init>(QName)","Constructor","* Create a new (non-actual) VariablePointer.
     * @param name variable name","public VariablePointer(final QName name) {
    super(null);
    this.name = name;
    actual = false;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointer.<init>(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointer.<init>(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer","Abstract Class","* Common superclass for Pointers of all kinds.  A NodePointer maps to
 * a deterministic XPath that represents the location of a node in an
 * object graph. This XPath uses only simple axes: child, namespace and
 * attribute and only simple, context-independent predicates.","Abstract Class do not obtain Source Code","No return type","public , abstract ","","org.apache.commons.jxpath.Pointer"
"org.apache.commons.jxpath.ri.model.NodePointer.serialVersionUID","Field","Serialization version","private static final long serialVersionUID = 8117201322861007777L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.WHOLE_COLLECTION","Field","Whole collection index.","public static final int WHOLE_COLLECTION = Integer.MIN_VALUE;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.UNKNOWN_NAMESPACE","Field","Constant to indicate unknown namespace","public static final String UNKNOWN_NAMESPACE = ""<<unknown namespace>>"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.index","Field","Index for this NodePointer","protected int index = WHOLE_COLLECTION;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.attribute","Field","No Comment","private boolean attribute = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.namespaceResolver","Field","No Comment","private NamespaceResolver namespaceResolver;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.exceptionHandler","Field","No Comment","private ExceptionHandler exceptionHandler;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.rootNode","Field","No Comment","private transient Object rootNode;","No return type","private , transient ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.parent","Field","Parent pointer","protected NodePointer parent;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.locale","Field","Locale","protected Locale locale;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.newNodePointer(QName,Object,Locale)","Method","* Allocates an entirely new NodePointer by iterating through all installed
     * NodePointerFactories until it finds one that can create a pointer.
     * @param name QName
     * @param bean Object
     * @param locale Locale
     * @return NodePointer","public static NodePointer newNodePointer(final QName name, final Object bean, final Locale locale) {
    NodePointer pointer;
    if (bean == null) {
        pointer = new NullPointer(name, locale);
        return pointer;
    }
    final NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories();
    for (final NodePointerFactory element : factories) {
        pointer = element.createNodePointer(name, bean, locale);
        if (pointer != null) {
            return pointer;
        }
    }
    throw new JXPathException(""Could not allocate a NodePointer for object of "" + bean.getClass());
}","NodePointer","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.newNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.newNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.newNodePointer(QName,Object,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.newNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.newNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointer.newNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.newChildNodePointer(NodePointer,QName,Object)","Method","* Allocates an new child NodePointer by iterating through all installed
     * NodePointerFactories until it finds one that can create a pointer.
     * @param parent pointer
     * @param name QName
     * @param bean Object
     * @return NodePointer","public static NodePointer newChildNodePointer(final NodePointer parent, final QName name, final Object bean) {
    final NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories();
    for (final NodePointerFactory element : factories) {
        final NodePointer pointer = element.createNodePointer(parent, name, bean);
        if (pointer != null) {
            return pointer;
        }
    }
    throw new JXPathException(""Could not allocate a NodePointer for object of "" + bean.getClass());
}","NodePointer","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.newChildNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.newChildNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.newChildNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.newChildNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.newChildNodePointer(NodePointer,QName,Object).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointer.newChildNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNamespaceResolver()","Method","* Gets the NamespaceResolver associated with this NodePointer.
     * @return NamespaceResolver","public NamespaceResolver getNamespaceResolver() {
    if (namespaceResolver == null && parent != null) {
        namespaceResolver = parent.getNamespaceResolver();
    }
    return namespaceResolver;
}","NamespaceResolver","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setNamespaceResolver(NamespaceResolver)","Method","* Sets the NamespaceResolver for this NodePointer.
     * @param namespaceResolver NamespaceResolver","public void setNamespaceResolver(final NamespaceResolver namespaceResolver) {
    this.namespaceResolver = namespaceResolver;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setNamespaceResolver(NamespaceResolver).namespaceResolver","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.setNamespaceResolver(NamespaceResolver)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getParent()","Method","* Gets the parent pointer.
     * @return NodePointer","public NodePointer getParent() {
    NodePointer pointer = parent;
    while (pointer != null && pointer.isContainer()) {
        pointer = pointer.getImmediateParentPointer();
    }
    return pointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getImmediateParentPointer()","Method","* Gets the immediate parent pointer.
     * @return NodePointer","public NodePointer getImmediateParentPointer() {
    return parent;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setAttribute(boolean)","Method","* Sets to true if the pointer represents the ""attribute::"" axis.
     * @param attribute boolean","public void setAttribute(final boolean attribute) {
    this.attribute = attribute;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setAttribute(boolean).attribute","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.setAttribute(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isAttribute()","Method","* Returns true if the pointer represents the ""attribute::"" axis.
     * @return boolean","public boolean isAttribute() {
    return attribute;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isRoot()","Method","* Returns true if this Pointer has no parent.
     * @return boolean","public boolean isRoot() {
    return parent == null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isLeaf()","Abstract Method","* If true, this node does not have children
     * @return boolean","public abstract boolean isLeaf();","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isNode()","Method","* Learn whether this pointer is considered to be a node.
     * @return boolean
     * @deprecated Please use !isContainer()","@Deprecated
public boolean isNode() {
    return !isContainer();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isContainer()","Method","* If true, this node is auxiliary and can only be used as an intermediate in
     * the chain of pointers.
     * @return boolean","public boolean isContainer() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getIndex()","Method","* If the pointer represents a collection, the index identifies
     * an element of that collection.  The default value of {@code index}
     * is {@code WHOLE_COLLECTION}, which just means that the pointer
     * is not indexed at all.
     * Note: the index on NodePointer starts with 0, not 1.
     * @return int","public int getIndex() {
    return index;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setIndex(int)","Method","* Sets the index of this NodePointer.
     * @param index int","public void setIndex(final int index) {
    this.index = index;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.setIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isCollection()","Abstract Method","* Returns {@code true} if the value of the pointer is an array or
     * a Collection.
     * @return boolean","public abstract boolean isCollection();","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getLength()","Abstract Method","* If the pointer represents a collection (or collection element),
     * returns the length of the collection.
     * Otherwise returns 1 (even if the value is null).
     * @return int","public abstract int getLength();","int","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getValue()","Method","* By default, returns {@code getNode()}, can be overridden to
     * return a ""canonical"" value, like for instance a DOM element should
     * return its string value.
     * @return Object value","@Override
public Object getValue() {
    final NodePointer valuePointer = getValuePointer();
    if (valuePointer != this) {
        return valuePointer.getValue();
    }
    // Default behavior is to return the same as getNode()
    return getNode();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getValuePointer()","Method","* If this pointer manages a transparent container, like a variable,
     * this method returns the pointer to the contents.
     * Only an auxiliary (non-node) pointer can (and should) return a
     * value pointer other than itself.
     * Note that you probably don't want to override
     * {@code getValuePointer()} directly.  Override the
     * {@code getImmediateValuePointer()} method instead.  The
     * {@code getValuePointer()} method is calls
     * {@code getImmediateValuePointer()} and, if the result is not
     * {@code this}, invokes {@code getValuePointer()} recursively.
     * The idea here is to open all nested containers. Let's say we have a
     * container within a container within a container. The
     * {@code getValuePointer()} method should then open all those
     * containers and return the pointer to the ultimate contents. It does so
     * with the above recursion.
     * @return NodePointer","public NodePointer getValuePointer() {
    final NodePointer ivp = getImmediateValuePointer();
    return ivp == this ? this : ivp.getValuePointer();
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getImmediateValuePointer()","Method","* @see #getValuePointer()
     * @return NodePointer is either {@code this} or a pointer
     *   for the immediately contained value.","public NodePointer getImmediateValuePointer() {
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isActual()","Method","* An actual pointer points to an existing part of an object graph, even
     * if it is null. A non-actual pointer represents a part that does not exist
     * at all.
     * For instance consider the pointer ""/address/street"".
     * If both <em>address</em> and <em>street</em> are not null,
     * the pointer is actual.
     * If <em>address</em> is not null, but <em>street</em> is null,
     * the pointer is still actual.
     * If <em>address</em> is null, the pointer is not actual.
     * (In JavaBeans) if <em>address</em> is not a property of the root bean,
     * a Pointer for this path cannot be obtained at all - actual or otherwise.
     * @return boolean","public boolean isActual() {
    return index == WHOLE_COLLECTION || index >= 0 && index < getLength();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getName()","Abstract Method","* Returns the name of this node. Can be null.
     * @return QName","public abstract QName getName();","QName","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getBaseValue()","Abstract Method","* Returns the value represented by the pointer before indexing.
     * So, if the node represents an element of a collection, this
     * method returns the collection itself.
     * @return Object value","public abstract Object getBaseValue();","Object","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNodeValue()","Method","* Returns the object the pointer points to; does not convert it
     * to a ""canonical"" type.
     * @return Object node value
     * @deprecated 1.1 Please use getNode()","@Deprecated
public Object getNodeValue() {
    return getNode();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNode()","Method","* Returns the object the pointer points to; does not convert it
     * to a ""canonical"" type. Opens containers, properties etc and returns
     * the ultimate contents.
     * @return Object node","@Override
public Object getNode() {
    return getValuePointer().getImmediateNode();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getRootNode()","Method","* Gets the root node.
     * @return Object value of this pointer's root (top parent).","@Override
public synchronized Object getRootNode() {
    if (rootNode == null) {
        rootNode = parent == null ? getImmediateNode() : parent.getRootNode();
    }
    return rootNode;
}","Object","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getImmediateNode()","Abstract Method","* Returns the object the pointer points to; does not convert it
     * to a ""canonical"" type.
     * @return Object node","public abstract Object getImmediateNode();","Object","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setValue(Object)","Abstract Method","* Converts the value to the required type and changes the corresponding
     * object to that value.
     * @param value the value to set","@Override
public abstract void setValue(Object value);","void","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareChildNodePointers(NodePointer,NodePointer)","Abstract Method","* Compares two child NodePointers and returns a positive number,
     * zero or a positive number according to the order of the pointers.
     * @param pointer1 first pointer to be compared
     * @param pointer2 second pointer to be compared
     * @return int per Java comparison conventions","public abstract int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2);","int","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.testNode(NodeTest)","Method","* Checks if this Pointer matches the supplied NodeTest.
     * @param test the NodeTest to execute
     * @return true if a match","public boolean testNode(final NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (isContainer()) {
            return false;
        }
        final NodeNameTest nodeNameTest = (NodeNameTest) test;
        final QName testName = nodeNameTest.getNodeName();
        final QName nodeName = getName();
        if (nodeName == null) {
            return false;
        }
        final String testPrefix = testName.getPrefix();
        final String nodePrefix = nodeName.getPrefix();
        if (!safeEquals(testPrefix, nodePrefix)) {
            final String testNS = getNamespaceURI(testPrefix);
            final String nodeNS = getNamespaceURI(nodePrefix);
            if (!safeEquals(testNS, nodeNS)) {
                return false;
            }
        }
        if (nodeNameTest.isWildcard()) {
            return true;
        }
        return testName.getName().equals(nodeName.getName());
    }
    return test instanceof NodeTypeTest && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.testNode(NodeTest).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.testNode(NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createPath(JXPathContext,Object)","Method","*  Called directly by JXPathContext. Must create path and
     *  set value.
     *  @param context the owning JXPathContext
     *  @param value the new value to set
     *  @return created NodePointer","public NodePointer createPath(final JXPathContext context, final Object value) {
    setValue(value);
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createPath(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createPath(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.remove()","Method","* Remove the node of the object graph this pointer points to.","public void remove() {
    // It is a no-op
    //        System.err.println(""REMOVING: "" + asPath() + "" "" + getClass());
    //        printPointerChain();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createPath(JXPathContext)","Method","* Called by a child pointer when it needs to create a parent object.
     * Must create an object described by this pointer and return
     * a new pointer that properly describes the new object.
     * @param context the owning JXPathContext
     * @return created NodePointer","public NodePointer createPath(final JXPathContext context) {
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int,Object)","Method","* Called by a child pointer if that child needs to assign the value
     * supplied in the createPath(context, value) call to a non-existent
     * node. This method may have to expand the collection in order to assign
     * the element.
     * @param context the owning JXPathCOntext
     * @param name the QName at which a child should be created
     * @param index child index.
     * @param value node value to set
     * @return created NodePointer","public NodePointer createChild(final JXPathContext context, final QName name, final int index, final Object value) {
    throw new JXPathException(""Cannot create an object for path "" + asPath() + ""/"" + name + ""["" + (index + 1) + ""]"" + "", operation is not allowed for this type of node"");
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int,Object).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int,Object).value","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int)","Method","* Called by a child pointer when it needs to create a parent object for a
     * non-existent collection element. It may have to expand the collection,
     * then create an element object and return a new pointer describing the
     * newly created element.
     * @param context the owning JXPathCOntext
     * @param name the QName at which a child should be created
     * @param index child index.
     * @return created NodePointer","public NodePointer createChild(final JXPathContext context, final QName name, final int index) {
    throw new JXPathException(""Cannot create an object for path "" + asPath() + ""/"" + name + ""["" + (index + 1) + ""]"" + "", operation is not allowed for this type of node"");
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createAttribute(JXPathContext,QName)","Method","* Called to create a non-existing attribute
     * @param context the owning JXPathCOntext
     * @param name the QName at which an attribute should be created
     * @return created NodePointer","public NodePointer createAttribute(final JXPathContext context, final QName name) {
    throw new JXPathException(""Cannot create an attribute for path "" + asPath() + ""/@"" + name + "", operation is not allowed for this type of node"");
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createAttribute(JXPathContext,QName).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createAttribute(JXPathContext,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.createAttribute(JXPathContext,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.createAttribute(JXPathContext,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getLocale()","Method","* If the Pointer has a parent, returns the parent's locale; otherwise
     * returns the locale specified when this Pointer was created.
     * @return Locale for this NodePointer","public Locale getLocale() {
    if (locale == null && parent != null) {
        locale = parent.getLocale();
    }
    return locale;
}","Locale","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isLanguage(String)","Method","* Check whether our locale matches the specified language.
     * @param lang String language to check
     * @return true if the selected locale name starts
     *              with the specified prefix <em>lang</em>, case-insensitive.","public boolean isLanguage(final String lang) {
    final Locale loc = getLocale();
    final String name = loc.toString().replace('_', '-');
    return name.toUpperCase(Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isLanguage(String).lang","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.isLanguage(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.childIterator(NodeTest,boolean,NodePointer)","Method","* Returns a NodeIterator that iterates over all children or all children
     * that match the given NodeTest, starting with the specified one.
     * @param test NodeTest to filter children
     * @param reverse specified iteration direction
     * @param startWith the NodePointer to start with
     * @return NodeIterator","public NodeIterator childIterator(final NodeTest test, final boolean reverse, final NodePointer startWith) {
    final NodePointer valuePointer = getValuePointer();
    return valuePointer == null || valuePointer == this ? null : valuePointer.childIterator(test, reverse, startWith);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.childIterator(NodeTest,boolean,NodePointer).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.childIterator(NodeTest,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.childIterator(NodeTest,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.attributeIterator(QName)","Method","* Returns a NodeIterator that iterates over all attributes of the current
     * node matching the supplied node name (could have a wildcard).
     * May return null if the object does not support the attributes.
     * @param qname the attribute name to test
     * @return NodeIterator","public NodeIterator attributeIterator(final QName qname) {
    final NodePointer valuePointer = getValuePointer();
    return valuePointer == null || valuePointer == this ? null : valuePointer.attributeIterator(qname);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.attributeIterator(QName).qname","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.attributeIterator(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.namespaceIterator()","Method","* Returns a NodeIterator that iterates over all namespaces of the value
     * currently pointed at.
     * May return null if the object does not support the namespaces.
     * @return NodeIterator","public NodeIterator namespaceIterator() {
    return null;
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.namespacePointer(String)","Method","* Returns a NodePointer for the specified namespace. Will return null
     * if namespaces are not supported.
     * Will return UNKNOWN_NAMESPACE if there is no such namespace.
     * @param namespace incoming namespace
     * @return NodePointer for {@code namespace}","public NodePointer namespacePointer(final String namespace) {
    return null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.namespacePointer(String).namespace","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.namespacePointer(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNamespaceURI(String)","Method","* Decodes a namespace prefix to the corresponding URI.
     * @param prefix prefix to decode
     * @return String uri","public String getNamespaceURI(final String prefix) {
    return null;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNamespaceURI(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getNamespaceURI(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNamespaceURI()","Method","* Returns the namespace URI associated with this Pointer.
     * @return String uri","public String getNamespaceURI() {
    return null;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isDefaultNamespace(String)","Method","* Returns true if the supplied prefix represents the
     * default namespace in the context of the current node.
     * @param prefix the prefix to check
     * @return {@code true} if prefix is default","protected boolean isDefaultNamespace(final String prefix) {
    if (prefix == null) {
        return true;
    }
    final String namespace = getNamespaceURI(prefix);
    return namespace != null && namespace.equals(getDefaultNamespaceURI());
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.isDefaultNamespace(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.isDefaultNamespace(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getDefaultNamespaceURI()","Method","* Gets the default ns uri
     * @return String uri","protected String getDefaultNamespaceURI() {
    return null;
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getPointerByID(JXPathContext,String)","Method","* Locates a node by ID.
     * @param context JXPathContext owning context
     * @param id String id
     * @return Pointer found","public Pointer getPointerByID(final JXPathContext context, final String id) {
    return context.getPointerByID(id);
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getPointerByID(JXPathContext,String).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getPointerByID(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getPointerByID(JXPathContext,String).id","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getPointerByID(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getPointerByKey(JXPathContext,String,String)","Method","* Locates a node by key and value.
     * @param context owning JXPathContext
     * @param key key to search for
     * @param value value to match
     * @return Pointer found","public Pointer getPointerByKey(final JXPathContext context, final String key, final String value) {
    return context.getPointerByKey(key, value);
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getPointerByKey(JXPathContext,String,String).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getPointerByKey(JXPathContext,String,String).key","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getPointerByKey(JXPathContext,String,String).value","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNodeSetByKey(JXPathContext,String,Object)","Method","* Find a NodeSet by key/value.
     * @param context owning JXPathContext
     * @param key key to search for
     * @param value value to match
     * @return NodeSet found","public NodeSet getNodeSetByKey(final JXPathContext context, final String key, final Object value) {
    return context.getNodeSetByKey(key, value);
}","NodeSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNodeSetByKey(JXPathContext,String,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNodeSetByKey(JXPathContext,String,Object).key","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getNodeSetByKey(JXPathContext,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.asPath()","Method","* Returns an XPath that maps to this Pointer.
     * @return String xpath expression","@Override
public String asPath() {
    // If the parent of this node is a container, it is responsible
    // for appended this node's part of the path.
    if (parent != null && parent.isContainer()) {
        return parent.asPath();
    }
    final StringBuilder buffer = new StringBuilder();
    if (parent != null) {
        buffer.append(parent.asPath());
    }
    if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') {
        buffer.append('/');
    }
    if (attribute) {
        buffer.append('@');
    }
    buffer.append(getName());
    if (index != WHOLE_COLLECTION && isCollection()) {
        buffer.append('[').append(index + 1).append(']');
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.clone()","Method","* Clone this NodePointer.
     * @return cloned NodePointer","@Override
public Object clone() {
    try {
        final NodePointer ptr = (NodePointer) super.clone();
        if (parent != null) {
            ptr.parent = (NodePointer) parent.clone();
        }
        return ptr;
    } catch (final CloneNotSupportedException ex) {
        // Of course it is supported
        ex.printStackTrace();
    }
    return null;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.toString()","Method","No Comment","@Override
public String toString() {
    return asPath();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareTo(Object)","Method","No Comment","@Override
public int compareTo(final Object object) {
    if (object == this) {
        return 0;
    }
    // Let it throw a ClassCastException
    final NodePointer pointer = (NodePointer) object;
    if (safeEquals(parent, pointer.parent)) {
        return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);
    }
    // Task 1: find the common parent
    int depth1 = 0;
    NodePointer p1 = this;
    final HashSet parents1 = new HashSet();
    while (p1 != null) {
        depth1++;
        p1 = p1.parent;
        if (p1 != null) {
            parents1.add(p1);
        }
    }
    boolean commonParentFound = false;
    int depth2 = 0;
    NodePointer p2 = pointer;
    while (p2 != null) {
        depth2++;
        p2 = p2.parent;
        if (parents1.contains(p2)) {
            commonParentFound = true;
        }
    }
    //nodes from different graphs are equal, else continue comparison:
    return commonParentFound ? compareNodePointers(this, depth1, pointer, depth2) : 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareTo(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.compareTo(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer,int,NodePointer,int)","Method","* Compare node pointers.
     * @param p1 pointer 1
     * @param depth1 depth 1
     * @param p2 pointer 2
     * @param depth2 depth 2
     * @return comparison result: (< 0) -> (p1 lt p2); (0) -> (p1 eq p2); (> 0) -> (p1 gt p2)","private int compareNodePointers(final NodePointer p1, final int depth1, final NodePointer p2, final int depth2) {
    if (depth1 < depth2) {
        final int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);
        return r == 0 ? -1 : r;
    }
    if (depth1 > depth2) {
        final int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);
        return r == 0 ? 1 : r;
    }
    //henceforth depth1 == depth2:
    if (safeEquals(p1, p2)) {
        return 0;
    }
    if (depth1 == 1) {
        throw new JXPathException(""Cannot compare pointers that do not belong to the same tree: '"" + p1 + ""' and '"" + p2 + ""'"");
    }
    final int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);
    return r == 0 ? p1.parent.compareChildNodePointers(p1, p2) : r;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer,int,NodePointer,int).p1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer,int,NodePointer,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer,int,NodePointer,int).depth1","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer,int,NodePointer,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer,int,NodePointer,int).p2","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer,int,NodePointer,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer,int,NodePointer,int).depth2","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer,int,NodePointer,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.printPointerChain()","Method","* Print internal structure of a pointer for debugging","public void printPointerChain() {
    printDeep(this, """");
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setExceptionHandler(ExceptionHandler)","Method","* Sets the exceptionHandler of this NodePointer.
     * @param exceptionHandler the ExceptionHandler to set","public void setExceptionHandler(final ExceptionHandler exceptionHandler) {
    this.exceptionHandler = exceptionHandler;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.setExceptionHandler(ExceptionHandler).exceptionHandler","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.setExceptionHandler(ExceptionHandler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.handle(Throwable,NodePointer)","Method","* Handle a Throwable using an installed ExceptionHandler, if available.
     * Public to facilitate calling for RI support; not truly intended for public consumption.
     * @param t to handle
     * @param originator context","public void handle(final Throwable t, final NodePointer originator) {
    if (exceptionHandler != null) {
        exceptionHandler.handle(t, originator);
        return;
    }
    if (parent != null) {
        parent.handle(t, originator);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.handle(Throwable,NodePointer).t","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.handle(Throwable,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.handle(Throwable,NodePointer).originator","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.handle(Throwable,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.handle(Throwable)","Method","* Handle a Throwable using an installed ExceptionHandler, if available.
     * Public to facilitate calling for RI support; not truly intended for public consumption.
     * @param t to handle","public void handle(final Throwable t) {
    handle(t, this);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.handle(Throwable).t","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.handle(Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.escape(String)","Method","* Return a string escaping single and double quotes.
     * @param string string to treat
     * @return string with any necessary changes made.","protected String escape(final String string) {
    final char[] c = { '\'', '""' };
    final String[] esc = { ""&apos;"", ""&quot;"" };
    StringBuilder sb = null;
    for (int i = 0; sb == null && i < c.length; i++) {
        if (string.indexOf(c[i]) >= 0) {
            sb = new StringBuilder(string);
        }
    }
    if (sb == null) {
        return string;
    }
    for (int i = 0; i < c.length; i++) {
        if (string.indexOf(c[i]) < 0) {
            continue;
        }
        int pos = 0;
        while (pos < sb.length()) {
            if (sb.charAt(pos) == c[i]) {
                sb.replace(pos, pos + 1, esc[i]);
                pos += esc[i].length();
            } else {
                pos++;
            }
        }
    }
    return sb.toString();
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.escape(String).string","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.escape(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getAbstractFactory(JXPathContext)","Method","* Gets the AbstractFactory associated with the specified JXPathContext.
     * @param context JXPathContext
     * @return AbstractFactory","protected AbstractFactory getAbstractFactory(final JXPathContext context) {
    final AbstractFactory factory = context.getFactory();
    if (factory == null) {
        throw new JXPathException(""Factory is not set on the JXPathContext - cannot create path: "" + asPath());
    }
    return factory;
}","AbstractFactory","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.getAbstractFactory(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.getAbstractFactory(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.printDeep(NodePointer,String)","Method","* Print deep
     * @param pointer to print
     * @param indent indentation level","private static void printDeep(final NodePointer pointer, final String indent) {
    if (indent.length() == 0) {
        System.err.println(""POINTER: "" + pointer + ""("" + pointer.getClass().getName() + "")"");
    } else {
        System.err.println(indent + "" of "" + pointer + ""("" + pointer.getClass().getName() + "")"");
    }
    if (pointer.getImmediateParentPointer() != null) {
        printDeep(pointer.getImmediateParentPointer(), indent + ""  "");
    }
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.printDeep(NodePointer,String).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.printDeep(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.printDeep(NodePointer,String).indent","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.printDeep(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.safeEquals(Object,Object)","Method","No Comment","private static boolean safeEquals(final Object o1, final Object o2) {
    return o1 == o2 || o1 != null && o1.equals(o2);
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.safeEquals(Object,Object).o1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.safeEquals(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.safeEquals(Object,Object).o2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.safeEquals(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.verify(NodePointer)","Method","* Verify the structure of a given NodePointer.
     * @param nodePointer to check
     * @return nodePointer
     * @throws JXPathNotFoundException Thrown when there is no value at the NodePointer.","public static NodePointer verify(final NodePointer nodePointer) {
    if (!nodePointer.isActual()) {
        // We need to differentiate between pointers representing
        // a non-existing property and ones representing a property
        // whose value is null.  In the latter case, the pointer
        // is going to have isActual == false, but its parent,
        // which is a non-node pointer identifying the bean property,
        // will return isActual() == true.
        final NodePointer parent = nodePointer.getImmediateParentPointer();
        if (parent == null || !parent.isContainer() || !parent.isActual()) {
            throw new JXPathNotFoundException(""No value for xpath: "" + nodePointer);
        }
    }
    return nodePointer;
}","NodePointer","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.verify(NodePointer).nodePointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.verify(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.<init>(NodePointer)","Constructor","* Create a new NodePointer.
     * @param parent Pointer","protected NodePointer(final NodePointer parent) {
    this.parent = parent;
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.<init>(NodePointer).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.<init>(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.<init>(NodePointer,Locale)","Constructor","* Create a new NodePointer.
     * @param parent Pointer
     * @param locale Locale","protected NodePointer(final NodePointer parent, final Locale locale) {
    this.parent = parent;
    this.locale = locale;
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.<init>(NodePointer,Locale).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointer.<init>(NodePointer,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointer.<init>(NodePointer,Locale).locale","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointer.<init>(NodePointer,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer","Class","* Pointer pointing to a property of a JavaBean.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyPointer",""
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -6008991447676468786L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.UNINITIALIZED","Field","No Comment","private static final Object UNINITIALIZED = new Object();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.propertyName","Field","No Comment","private String propertyName;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.beanInfo","Field","No Comment","private final JXPathBeanInfo beanInfo;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.baseValue","Field","No Comment","private Object baseValue = UNINITIALIZED;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.value","Field","No Comment","private Object value = UNINITIALIZED;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.names","Field","No Comment","private transient String[] names;","No return type","private , transient ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.propertyDescriptors","Field","No Comment","private transient PropertyDescriptor[] propertyDescriptors;","No return type","private , transient ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.propertyDescriptor","Field","No Comment","private transient PropertyDescriptor propertyDescriptor;","No return type","private , transient ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.isContainer()","Method","* This type of node is auxiliary.
     * @return true","@Override
public boolean isContainer() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getPropertyCount()","Method","No Comment","@Override
public int getPropertyCount() {
    if (beanInfo.isAtomic()) {
        return 0;
    }
    return getPropertyDescriptors().length;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getPropertyNames()","Method","* Gets the names of all properties, sorted alphabetically
     * @return String[]","@Override
public String[] getPropertyNames() {
    if (names == null) {
        final PropertyDescriptor[] pds = getPropertyDescriptors();
        names = new String[pds.length];
        for (int i = 0; i < names.length; i++) {
            names[i] = pds[i].getName();
        }
    }
    return names;
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setPropertyName(String)","Method","* Select a property by name.
     * @param propertyName String name","@Override
public void setPropertyName(final String propertyName) {
    setPropertyIndex(UNSPECIFIED_PROPERTY);
    this.propertyName = propertyName;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setPropertyName(String).propertyName","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setPropertyName(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setPropertyIndex(int)","Method","* Selects a property by its offset in the alphabetically sorted list.
     * @param index property index","@Override
public void setPropertyIndex(final int index) {
    if (propertyIndex != index) {
        super.setPropertyIndex(index);
        propertyName = null;
        propertyDescriptor = null;
        baseValue = UNINITIALIZED;
        value = UNINITIALIZED;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setPropertyIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setPropertyIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getBaseValue()","Method","* Gets the value of the currently selected property.
     * @return Object value","@Override
public Object getBaseValue() {
    if (baseValue == UNINITIALIZED) {
        final PropertyDescriptor pd = getPropertyDescriptor();
        if (pd == null) {
            return null;
        }
        baseValue = ValueUtils.getValue(getBean(), pd);
    }
    return baseValue;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setIndex(int)","Method","No Comment","@Override
public void setIndex(final int index) {
    if (this.index == index) {
        return;
    }
    // When dealing with a scalar, index == 0 is equivalent to
    // WHOLE_COLLECTION, so do not change it.
    if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) {
        super.setIndex(index);
        value = UNINITIALIZED;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getImmediateNode()","Method","* If index == WHOLE_COLLECTION, the value of the property, otherwise
     * the value of the index'th element of the collection represented by the
     * property. If the property is not a collection, index should be zero
     * and the value will be the property itself.
     * @return Object","@Override
public Object getImmediateNode() {
    if (value == UNINITIALIZED) {
        if (index == WHOLE_COLLECTION) {
            value = ValueUtils.getValue(getBaseValue());
        } else {
            final PropertyDescriptor pd = getPropertyDescriptor();
            if (pd == null) {
                value = null;
            } else {
                value = ValueUtils.getValue(getBean(), pd, index);
            }
        }
    }
    return value;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.isActualProperty()","Method","No Comment","@Override
protected boolean isActualProperty() {
    return getPropertyDescriptor() != null;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    final PropertyDescriptor pd = getPropertyDescriptor();
    if (pd == null) {
        return false;
    }
    if (pd instanceof IndexedPropertyDescriptor) {
        return true;
    }
    final int hint = ValueUtils.getCollectionHint(pd.getPropertyType());
    if (hint == -1) {
        return false;
    }
    if (hint == 1) {
        return true;
    }
    final Object value = getBaseValue();
    return value != null && ValueUtils.isCollection(value);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getLength()","Method","* If the property contains a collection, then the length of that
     * collection, otherwise - 1.
     * @return int length","@Override
public int getLength() {
    final PropertyDescriptor pd = getPropertyDescriptor();
    if (pd == null) {
        return 1;
    }
    if (pd instanceof IndexedPropertyDescriptor) {
        return ValueUtils.getIndexedPropertyLength(getBean(), (IndexedPropertyDescriptor) pd);
    }
    final int hint = ValueUtils.getCollectionHint(pd.getPropertyType());
    if (hint == -1) {
        return 1;
    }
    return super.getLength();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setValue(Object)","Method","* If index == WHOLE_COLLECTION, change the value of the property, otherwise
     * change the value of the index'th element of the collection
     * represented by the property.
     * @param value value to set","@Override
public void setValue(final Object value) {
    final PropertyDescriptor pd = getPropertyDescriptor();
    if (pd == null) {
        throw new JXPathInvalidAccessException(""Cannot set property: "" + asPath() + "" - no such property"");
    }
    if (index == WHOLE_COLLECTION) {
        ValueUtils.setValue(getBean(), pd, value);
    } else {
        ValueUtils.setValue(getBean(), pd, index, value);
    }
    this.value = value;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.createPath(JXPathContext)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context) {
    if (getImmediateNode() == null) {
        super.createPath(context);
        baseValue = UNINITIALIZED;
        value = UNINITIALIZED;
    }
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.remove()","Method","No Comment","@Override
public void remove() {
    if (index == WHOLE_COLLECTION) {
        setValue(null);
    } else if (isCollection()) {
        final Object o = getBaseValue();
        final Object collection = ValueUtils.remove(getBaseValue(), index);
        if (collection != o) {
            ValueUtils.setValue(getBean(), getPropertyDescriptor(), collection);
        }
    } else if (index == 0) {
        index = WHOLE_COLLECTION;
        setValue(null);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getPropertyName()","Method","* Gets the name of the currently selected property.
     * @return String property name","@Override
public String getPropertyName() {
    if (propertyName == null) {
        final PropertyDescriptor pd = getPropertyDescriptor();
        if (pd != null) {
            propertyName = pd.getName();
        }
    }
    return propertyName != null ? propertyName : ""*"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getPropertyDescriptor()","Method","* Finds the property descriptor corresponding to the current property
     * index.
     * @return PropertyDescriptor","private PropertyDescriptor getPropertyDescriptor() {
    if (propertyDescriptor == null) {
        final int inx = getPropertyIndex();
        if (inx == UNSPECIFIED_PROPERTY) {
            propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName);
        } else {
            final PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors();
            if (inx >= 0 && inx < propertyDescriptors.length) {
                propertyDescriptor = propertyDescriptors[inx];
            } else {
                propertyDescriptor = null;
            }
        }
    }
    return propertyDescriptor;
}","PropertyDescriptor","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getPropertyDescriptors()","Method","* Gets all PropertyDescriptors.
     * @return PropertyDescriptor[]","protected synchronized PropertyDescriptor[] getPropertyDescriptors() {
    if (propertyDescriptors == null) {
        propertyDescriptors = beanInfo.getPropertyDescriptors();
    }
    return propertyDescriptors;
}","PropertyDescriptor[]","protected , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.<init>(NodePointer,JXPathBeanInfo)","Constructor","* Create a new BeanPropertyPointer.
     * @param parent parent pointer
     * @param beanInfo describes the target property/ies.","public BeanPropertyPointer(final NodePointer parent, final JXPathBeanInfo beanInfo) {
    super(parent);
    this.beanInfo = beanInfo;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.<init>(NodePointer,JXPathBeanInfo).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.<init>(NodePointer,JXPathBeanInfo)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.<init>(NodePointer,JXPathBeanInfo).beanInfo","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.<init>(NodePointer,JXPathBeanInfo)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer","Class","* A Pointer that points to the ""lang"" attribute of a JavaBean. The value
 * of the attribute is based on the locale supplied to it in the constructor.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -8665319197100034134L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.getName()","Method","No Comment","@Override
public QName getName() {
    return new QName(""xml"", ""lang"");
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.getNamespaceURI()","Method","No Comment","@Override
public String getNamespaceURI() {
    return null;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return parent.getLocale().toString().replace('_', '-');
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return getBaseValue();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.setValue(Object)","Method","* {@inheritDoc}
     *
     * Throws UnsupportedOperationException.
     * @param value Object","@Override
public void setValue(final Object value) {
    throw new UnsupportedOperationException(""Cannot change locale using the 'lang' attribute"");
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    final StringBuilder buffer = new StringBuilder();
    if (parent != null) {
        buffer.append(parent.asPath());
        if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') {
            buffer.append('/');
        }
    }
    buffer.append(""@xml:lang"");
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    return object instanceof LangAttributePointer;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.testNode(NodeTest)","Method","No Comment","@Override
public boolean testNode(final NodeTest test) {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.testNode(NodeTest).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.testNode(NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    // Won't happen - lang attributes don't have children
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.<init>(NodePointer)","Constructor","* Create a new LangAttributePointer.
     * @param parent parent pointer.","public LangAttributePointer(final NodePointer parent) {
    super(parent);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.<init>(NodePointer).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.LangAttributePointer.<init>(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator","Abstract Class","* Combines node iterators of all elements of a collection into one
 * aggregate node iterator.","Abstract Class do not obtain Source Code","No return type","public , abstract ","","org.apache.commons.jxpath.ri.model.NodeIterator"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.pointer","Field","No Comment","private final CollectionPointer pointer;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.reverse","Field","No Comment","private final boolean reverse;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.startWith","Field","No Comment","private final NodePointer startWith;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.position","Field","No Comment","private int position;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.collection","Field","No Comment","private List collection;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.getElementNodeIterator(NodePointer)","Abstract Method","* Implemented by subclasses to produce child/attribute node iterators.
     * @param elementPointer owning pointer
     * @return NodeIterator","protected abstract NodeIterator getElementNodeIterator(NodePointer elementPointer);","NodeIterator","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.getElementNodeIterator(NodePointer).elementPointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.getElementNodeIterator(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (collection == null) {
        prepare();
    }
    if (position < 1 || position > collection.size()) {
        return false;
    }
    this.position = position;
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.getNodePointer()","Method","No Comment","@Override
public NodePointer getNodePointer() {
    if (position == 0) {
        return null;
    }
    return (NodePointer) collection.get(position - 1);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.prepare()","Method","* Prepare...","private void prepare() {
    collection = new ArrayList();
    final NodePointer ptr = (NodePointer) pointer.clone();
    final int length = ptr.getLength();
    for (int i = 0; i < length; i++) {
        ptr.setIndex(i);
        final NodePointer elementPointer = ptr.getValuePointer();
        final NodeIterator iter = getElementNodeIterator(elementPointer);
        for (int j = 1; iter.setPosition(j); j++) {
            final NodePointer childPointer = iter.getNodePointer();
            if (reverse) {
                collection.add(0, childPointer);
            } else {
                collection.add(childPointer);
            }
        }
    }
    if (startWith != null) {
        final int index = collection.indexOf(startWith);
        if (index == -1) {
            throw new JXPathException(""Invalid starting pointer for iterator: "" + startWith);
        }
        while (collection.size() > index) {
            if (!reverse) {
                collection.remove(collection.size() - 1);
            } else {
                collection.remove(0);
            }
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.<init>(CollectionPointer,boolean,NodePointer)","Constructor","* Create a new CollectionNodeIterator.
     * @param pointer collection pointer
     * @param reverse iteration order
     * @param startWith starting pointer","protected CollectionNodeIterator(final CollectionPointer pointer, final boolean reverse, final NodePointer startWith) {
    this.pointer = pointer;
    this.reverse = reverse;
    this.startWith = startWith;
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.<init>(CollectionPointer,boolean,NodePointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.<init>(CollectionPointer,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.<init>(CollectionPointer,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.<init>(CollectionPointer,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.<init>(CollectionPointer,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator.<init>(CollectionPointer,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer","Class","* Transparent pointer to a collection (array or Collection).","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.collection","Field","No Comment","private Object collection;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.valuePointer","Field","No Comment","private NodePointer valuePointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 8620254915563256588L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.getName()","Method","No Comment","@Override
public QName getName() {
    return null;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return collection;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return ValueUtils.getLength(getBaseValue());
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    final Object value = getNode();
    return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.isContainer()","Method","No Comment","@Override
public boolean isContainer() {
    return index != WHOLE_COLLECTION;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return index == WHOLE_COLLECTION ? ValueUtils.getValue(collection) : ValueUtils.getValue(collection, index);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.setValue(Object)","Method","No Comment","@Override
public void setValue(final Object value) {
    if (index == WHOLE_COLLECTION) {
        parent.setValue(value);
    } else {
        ValueUtils.setValue(collection, index, value);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.setIndex(int)","Method","No Comment","@Override
public void setIndex(final int index) {
    super.setIndex(index);
    valuePointer = null;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.setIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.setIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.getValuePointer()","Method","No Comment","@Override
public NodePointer getValuePointer() {
    if (valuePointer == null) {
        if (index == WHOLE_COLLECTION) {
            valuePointer = this;
        } else {
            final Object value = getImmediateNode();
            valuePointer = newChildNodePointer(this, getName(), value);
        }
    }
    return valuePointer;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createPath(JXPathContext)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context) {
    if (ValueUtils.getLength(getBaseValue()) <= index) {
        collection = ValueUtils.expandCollection(getNode(), index + 1);
    }
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createPath(JXPathContext,Object)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context, final Object value) {
    final NodePointer ptr = createPath(context);
    ptr.setValue(value);
    return ptr;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createPath(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createPath(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int,Object)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index, final Object value) {
    final NodePointer ptr = (NodePointer) clone();
    ptr.setIndex(index);
    return ptr.createPath(context, value);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int,Object).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int,Object).value","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index) {
    final NodePointer ptr = (NodePointer) clone();
    ptr.setIndex(index);
    return ptr.createPath(context);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return System.identityHashCode(collection) + index;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof CollectionPointer)) {
        return false;
    }
    final CollectionPointer other = (CollectionPointer) object;
    return collection == other.collection && index == other.index;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.childIterator(NodeTest,boolean,NodePointer)","Method","No Comment","@Override
public NodeIterator childIterator(final NodeTest test, final boolean reverse, final NodePointer startWith) {
    if (index == WHOLE_COLLECTION) {
        return new CollectionChildNodeIterator(this, test, reverse, startWith);
    }
    return getValuePointer().childIterator(test, reverse, startWith);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.childIterator(NodeTest,boolean,NodePointer).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.childIterator(NodeTest,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.childIterator(NodeTest,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.attributeIterator(QName)","Method","No Comment","@Override
public NodeIterator attributeIterator(final QName name) {
    return index == WHOLE_COLLECTION ? new CollectionAttributeNodeIterator(this, name) : getValuePointer().attributeIterator(name);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.attributeIterator(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.attributeIterator(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.namespaceIterator()","Method","No Comment","@Override
public NodeIterator namespaceIterator() {
    return index == WHOLE_COLLECTION ? null : getValuePointer().namespaceIterator();
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.namespacePointer(String)","Method","No Comment","@Override
public NodePointer namespacePointer(final String namespace) {
    return index == WHOLE_COLLECTION ? null : getValuePointer().namespacePointer(namespace);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.namespacePointer(String).namespace","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.namespacePointer(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.testNode(NodeTest)","Method","No Comment","@Override
public boolean testNode(final NodeTest test) {
    if (index == WHOLE_COLLECTION) {
        if (test == null) {
            return true;
        }
        if (test instanceof NodeNameTest) {
            return false;
        }
        return test instanceof NodeTypeTest && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE;
    }
    return getValuePointer().testNode(test);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.testNode(NodeTest).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.testNode(NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    return pointer1.getIndex() - pointer2.getIndex();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.asPath()","Method","No Comment","@Override
public String asPath() {
    final StringBuilder buffer = new StringBuilder();
    final NodePointer parent = getImmediateParentPointer();
    if (parent != null) {
        buffer.append(parent.asPath());
        if (index != WHOLE_COLLECTION) {
            // Address the list[1][2] case
            if (parent.getIndex() != WHOLE_COLLECTION) {
                buffer.append(""/."");
            }
            buffer.append(""["").append(index + 1).append(']');
        }
    } else if (index != WHOLE_COLLECTION) {
        buffer.append(""/.["").append(index + 1).append(']');
    } else {
        buffer.append(""/"");
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(Object,Locale)","Constructor","* Create a new CollectionPointer.
     * @param collection value
     * @param locale Locale","public CollectionPointer(final Object collection, final Locale locale) {
    super(null, locale);
    this.collection = collection;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(Object,Locale).collection","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(Object,Locale).locale","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(NodePointer,Object)","Constructor","* Create a new CollectionPointer.
     * @param parent parent NodePointer
     * @param collection value","public CollectionPointer(final NodePointer parent, final Object collection) {
    super(parent);
    this.collection = collection;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(NodePointer,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(NodePointer,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(NodePointer,Object).collection","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointer.<init>(NodePointer,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator","Class","* Combines child node iterators of all elements of a collection into one
 * aggregate child node iterator.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator",""
"org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.test","Field","No Comment","private final NodeTest test;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.getElementNodeIterator(NodePointer)","Method","No Comment","@Override
protected NodeIterator getElementNodeIterator(final NodePointer elementPointer) {
    return elementPointer.childIterator(test, false, null);
}","NodeIterator","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.getElementNodeIterator(NodePointer).elementPointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.getElementNodeIterator(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.<init>(CollectionPointer,NodeTest,boolean,NodePointer)","Constructor","* Create a new CollectionChildNodeIterator.
     * @param pointer CollectionPointer
     * @param test child test
     * @param reverse iteration order
     * @param startWith starting pointer","public CollectionChildNodeIterator(final CollectionPointer pointer, final NodeTest test, final boolean reverse, final NodePointer startWith) {
    super(pointer, reverse, startWith);
    this.test = test;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.<init>(CollectionPointer,NodeTest,boolean,NodePointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.<init>(CollectionPointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.<init>(CollectionPointer,NodeTest,boolean,NodePointer).test","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.<init>(CollectionPointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.<init>(CollectionPointer,NodeTest,boolean,NodePointer).reverse","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.<init>(CollectionPointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.<init>(CollectionPointer,NodeTest,boolean,NodePointer).startWith","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator.<init>(CollectionPointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator","Class","* An iterator of attributes of a JavaBean. Returns bean properties as
 * well as the ""xml:lang"" attribute.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyIterator",""
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.parent","Field","No Comment","private final NodePointer parent;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.position","Field","No Comment","private int position = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.includeXmlLang","Field","No Comment","private final boolean includeXmlLang;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.getNodePointer()","Method","No Comment","@Override
public NodePointer getNodePointer() {
    return includeXmlLang && position == 1 ? new LangAttributePointer(parent) : super.getNodePointer();
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    this.position = position;
    if (includeXmlLang) {
        return position == 1 || super.setPosition(position - 1);
    }
    return super.setPosition(position);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.<init>(PropertyOwnerPointer,QName)","Constructor","* Create a new BeanAttributeIterator.
     * @param parent parent pointer
     * @param name name of this bean","public BeanAttributeIterator(final PropertyOwnerPointer parent, final QName name) {
    super(parent, name.getPrefix() == null && (name.getName() == null || name.getName().equals(""*"")) ? null : name.toString(), false, null);
    this.parent = parent;
    includeXmlLang = name.getPrefix() != null && name.getPrefix().equals(""xml"") && (name.getName().equals(""lang"") || name.getName().equals(""*""));
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.<init>(PropertyOwnerPointer,QName).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.<init>(PropertyOwnerPointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.<init>(PropertyOwnerPointer,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator.<init>(PropertyOwnerPointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator","Class","* Combines attribute node iterators of all elements of a collection into one
 * aggregate attribute node iterator.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator",""
"org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator.name","Field","No Comment","private final QName name;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator.getElementNodeIterator(NodePointer)","Method","No Comment","@Override
protected NodeIterator getElementNodeIterator(final NodePointer elementPointer) {
    return elementPointer.attributeIterator(name);
}","NodeIterator","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator.getElementNodeIterator(NodePointer).elementPointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator.getElementNodeIterator(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator.<init>(CollectionPointer,QName)","Constructor","* Create a new CollectionAttributeNodeIterator.
     * @param pointer collection pointer
     * @param name attribute name","public CollectionAttributeNodeIterator(final CollectionPointer pointer, final QName name) {
    super(pointer, false, null);
    this.name = name;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator.<init>(CollectionPointer,QName).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator.<init>(CollectionPointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator.<init>(CollectionPointer,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator.<init>(CollectionPointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer","Class","","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyPointer",""
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.propertyName","Field","No Comment","private String propertyName = ""*"";","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.byNameAttribute","Field","No Comment","private boolean byNameAttribute = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 5296593071854982754L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.getName()","Method","No Comment","@Override
public QName getName() {
    return new QName(propertyName);
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setPropertyIndex(int)","Method","No Comment","@Override
public void setPropertyIndex(final int index) {
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setPropertyIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setPropertyIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return null;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return null;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.getValuePointer()","Method","No Comment","@Override
public NodePointer getValuePointer() {
    return new NullPointer(this, new QName(getPropertyName()));
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.isActualProperty()","Method","No Comment","@Override
protected boolean isActualProperty() {
    return false;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.isActual()","Method","No Comment","@Override
public boolean isActual() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.isContainer()","Method","No Comment","@Override
public boolean isContainer() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setValue(Object)","Method","No Comment","@Override
public void setValue(final Object value) {
    if (parent == null || parent.isContainer()) {
        throw new JXPathInvalidAccessException(""Cannot set property "" + asPath() + "", the target object is null"");
    }
    if (parent instanceof PropertyOwnerPointer && ((PropertyOwnerPointer) parent).isDynamicPropertyDeclarationSupported()) {
        // If the parent property owner can create
        // a property automatically - let it do so
        final PropertyPointer propertyPointer = ((PropertyOwnerPointer) parent).getPropertyPointer();
        propertyPointer.setPropertyName(propertyName);
        propertyPointer.setValue(value);
    } else {
        throw new JXPathInvalidAccessException(""Cannot set property "" + asPath() + "", path does not match a changeable location"");
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createPath(JXPathContext)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context) {
    NodePointer newParent = parent.createPath(context);
    if (isAttribute()) {
        return newParent.createAttribute(context, getName());
    }
    if (parent instanceof NullPointer && parent.equals(newParent)) {
        throw createBadFactoryException(context.getFactory());
    }
    // Consider these two use cases:
    // 1. The parent pointer of NullPropertyPointer is
    //    a PropertyOwnerPointer other than NullPointer. When we call
    //    createPath on it, it most likely returns itself. We then
    //    take a PropertyPointer from it and get the PropertyPointer
    //    to expand the collection for the corresponding property.
    //
    // 2. The parent pointer of NullPropertyPointer is a NullPointer.
    //    When we call createPath, it may return a PropertyOwnerPointer
    //    or it may return anything else, like a DOMNodePointer.
    //    In the former case we need to do exactly what we did in use
    //    case 1.  In the latter case, we simply request that the
    //    non-property pointer expand the collection by itself.
    if (newParent instanceof PropertyOwnerPointer) {
        final PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
        newParent = pop.getPropertyPointer();
    }
    return newParent.createChild(context, getName(), getIndex());
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createPath(JXPathContext,Object)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context, final Object value) {
    NodePointer newParent = parent.createPath(context);
    if (isAttribute()) {
        final NodePointer pointer = newParent.createAttribute(context, getName());
        pointer.setValue(value);
        return pointer;
    }
    if (parent instanceof NullPointer && parent.equals(newParent)) {
        throw createBadFactoryException(context.getFactory());
    }
    if (newParent instanceof PropertyOwnerPointer) {
        final PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
        newParent = pop.getPropertyPointer();
    }
    return newParent.createChild(context, getName(), index, value);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createPath(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createPath(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index) {
    return createPath(context).createChild(context, name, index);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int,Object)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index, final Object value) {
    return createPath(context).createChild(context, name, index, value);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int,Object).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int,Object).value","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.getPropertyName()","Method","No Comment","@Override
public String getPropertyName() {
    return propertyName;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setPropertyName(String)","Method","No Comment","@Override
public void setPropertyName(final String propertyName) {
    this.propertyName = propertyName;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setPropertyName(String).propertyName","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setPropertyName(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setNameAttributeValue(String)","Method","* Sets the name attribute.
     * @param attributeValue value to set","public void setNameAttributeValue(final String attributeValue) {
    this.propertyName = attributeValue;
    byNameAttribute = true;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setNameAttributeValue(String).attributeValue","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.setNameAttributeValue(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return getIndex() != WHOLE_COLLECTION;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.getPropertyCount()","Method","No Comment","@Override
public int getPropertyCount() {
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.getPropertyNames()","Method","No Comment","@Override
public String[] getPropertyNames() {
    return new String[0];
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.asPath()","Method","No Comment","@Override
public String asPath() {
    if (!byNameAttribute) {
        return super.asPath();
    }
    final StringBuilder buffer = new StringBuilder();
    buffer.append(getImmediateParentPointer().asPath());
    buffer.append(""[@name='"");
    buffer.append(escape(getPropertyName()));
    buffer.append(""']"");
    if (index != WHOLE_COLLECTION) {
        buffer.append('[').append(index + 1).append(']');
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createBadFactoryException(AbstractFactory)","Method","* Create a ""bad factory"" JXPathAbstractFactoryException for the specified AbstractFactory.
     * @param factory AbstractFactory
     * @return JXPathAbstractFactoryException","private JXPathAbstractFactoryException createBadFactoryException(final AbstractFactory factory) {
    return new JXPathAbstractFactoryException(""Factory "" + factory + "" reported success creating object for path: "" + asPath() + "" but object was null.  Terminating to avoid stack recursion."");
}","JXPathAbstractFactoryException","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createBadFactoryException(AbstractFactory).factory","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.createBadFactoryException(AbstractFactory)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.<init>(NodePointer)","Constructor","* Create a new NullPropertyPointer.
     * @param parent pointer","public NullPropertyPointer(final NodePointer parent) {
    super(parent);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.<init>(NodePointer).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer.<init>(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer","Class","* Used when there is a need to construct a Pointer for a collection element
 * that does not exist.  For example, if the path is ""foo[3]"", but the
 * collection ""foo"" only has one element or is empty or is null, the
 * NullElementPointer can be used to capture this situation without putting a
 * regular NodePointer into an invalid state.  Just create a NullElementPointer
 * with index 2 (= 3 - 1) and a ""foo"" pointer as the parent.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.CollectionPointer",""
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 8714236818791036721L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.getName()","Method","No Comment","@Override
public QName getName() {
    return null;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return null;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return null;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.getPropertyPointer()","Method","* Gets the property pointer for this.
     * @return PropertyPointer","public PropertyPointer getPropertyPointer() {
    return new NullPropertyPointer(this);
}","PropertyPointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.getValuePointer()","Method","No Comment","@Override
public NodePointer getValuePointer() {
    return new NullPointer(this, getName());
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.setValue(Object)","Method","No Comment","@Override
public void setValue(final Object value) {
    throw new UnsupportedOperationException(""Collection element does not exist: "" + this);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullElementPointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.isActual()","Method","No Comment","@Override
public boolean isActual() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.isContainer()","Method","No Comment","@Override
public boolean isContainer() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createPath(JXPathContext)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context) {
    return parent.createChild(context, null, index);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createPath(JXPathContext,Object)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context, final Object value) {
    return parent.createChild(context, null, index, value);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createPath(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createPath(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return getImmediateParentPointer().hashCode() + index;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof NullElementPointer)) {
        return false;
    }
    final NullElementPointer other = (NullElementPointer) object;
    return getImmediateParentPointer() == other.getImmediateParentPointer() && index == other.index;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullElementPointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.asPath()","Method","No Comment","@Override
public String asPath() {
    final StringBuilder buffer = new StringBuilder();
    final NodePointer parent = getImmediateParentPointer();
    if (parent != null) {
        buffer.append(parent.asPath());
    }
    if (index != WHOLE_COLLECTION) {
        // Address the list[1][2] case
        if (parent != null && parent.getIndex() != WHOLE_COLLECTION) {
            buffer.append(""/."");
        } else if (parent != null && parent.getImmediateParentPointer() != null && parent.getImmediateParentPointer().getIndex() != WHOLE_COLLECTION) {
            buffer.append(""/."");
        }
        buffer.append(""["").append(index + 1).append(']');
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.<init>(NodePointer,int)","Constructor","* Create a new NullElementPointer.
     * @param parent parent pointer
     * @param index int","public NullElementPointer(final NodePointer parent, final int index) {
    super(parent, (Object) null);
    this.index = index;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.<init>(NodePointer,int).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullElementPointer.<init>(NodePointer,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullElementPointer.<init>(NodePointer,int).index","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullElementPointer.<init>(NodePointer,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer","Class","* Pointer whose value is {@code null}.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer",""
"org.apache.commons.jxpath.ri.model.beans.NullPointer.name","Field","No Comment","private QName name;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.id","Field","No Comment","private String id;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 2193425983220679887L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.getName()","Method","No Comment","@Override
public QName getName() {
    return name;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return null;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.isActual()","Method","No Comment","@Override
public boolean isActual() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.getPropertyPointer()","Method","No Comment","@Override
public PropertyPointer getPropertyPointer() {
    return new NullPropertyPointer(this);
}","PropertyPointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath(JXPathContext,Object)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context, final Object value) {
    if (parent != null) {
        return parent.createPath(context, value).getValuePointer();
    }
    throw new UnsupportedOperationException(""Cannot create the root object: "" + asPath());
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath(JXPathContext)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context) {
    if (parent != null) {
        return parent.createPath(context).getValuePointer();
    }
    throw new UnsupportedOperationException(""Cannot create the root object: "" + asPath());
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index) {
    return createPath(context).createChild(context, name, index);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int,Object)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index, final Object value) {
    return createPath(context).createChild(context, name, index, value);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int,Object).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int,Object).value","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return name == null ? 0 : name.hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof NullPointer)) {
        return false;
    }
    final NullPointer other = (NullPointer) object;
    return name == other.name || name != null && name.equals(other.name);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.asPath()","Method","No Comment","@Override
public String asPath() {
    if (id != null) {
        return ""id("" + id + "")"";
    }
    return parent == null ? ""null()"" : super.asPath();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(QName,Locale)","Constructor","* Create a new NullPointer.
     * @param name node name
     * @param locale Locale","public NullPointer(final QName name, final Locale locale) {
    super(null, locale);
    this.name = name;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(QName,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(QName,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(QName,Locale).locale","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(QName,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(NodePointer,QName)","Constructor","* Used for the root node.
     * @param parent parent pointer
     * @param name node name","public NullPointer(final NodePointer parent, final QName name) {
    super(parent);
    this.name = name;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(NodePointer,QName).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(NodePointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(NodePointer,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(NodePointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(Locale,String)","Constructor","* Create a new NullPointer.
     * @param locale Locale
     * @param id String","public NullPointer(final Locale locale, final String id) {
    super(null, locale);
    this.id = id;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(Locale,String).locale","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(Locale,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(Locale,String).id","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.NullPointer.<init>(Locale,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer","Class","* A Pointer that points to a JavaBean or a collection. It is either
 * the first element of a path or a pointer for a property value.
 * Typically there is a {@link BeanPropertyPointer} between two BeanPointers
 * in the chain.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer",""
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.name","Field","No Comment","private final QName name;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.bean","Field","No Comment","private final Object bean;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.beanInfo","Field","No Comment","private final JXPathBeanInfo beanInfo;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -8227317938284982440L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.getPropertyPointer()","Method","No Comment","@Override
public PropertyPointer getPropertyPointer() {
    return new BeanPropertyPointer(this, beanInfo);
}","PropertyPointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.getName()","Method","No Comment","@Override
public QName getName() {
    return name;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return bean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.isCollection()","Method","* {@inheritDoc}
     * @return false","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.getLength()","Method","* {@inheritDoc}
     * @return 1","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    final Object value = getNode();
    return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return name == null ? 0 : name.hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof BeanPointer)) {
        return false;
    }
    final BeanPointer other = (BeanPointer) object;
    if (parent != other.parent && (parent == null || !parent.equals(other.parent))) {
        return false;
    }
    if (name == null && other.name != null || name != null && !name.equals(other.name)) {
        return false;
    }
    final int iThis = index == WHOLE_COLLECTION ? 0 : index;
    final int iOther = other.index == WHOLE_COLLECTION ? 0 : other.index;
    if (iThis != iOther) {
        return false;
    }
    if (bean instanceof Number || bean instanceof String || bean instanceof Boolean) {
        return bean.equals(other.bean);
    }
    return bean == other.bean;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.asPath()","Method","* {@inheritDoc}
     * If the pointer has a parent, then parent's path.
     * If the bean is null, ""null()"".
     * If the bean is a primitive value, the value itself.
     * Otherwise - an empty string.","@Override
public String asPath() {
    if (parent != null) {
        return super.asPath();
    }
    if (bean == null) {
        return ""null()"";
    }
    if (bean instanceof Number) {
        String string = bean.toString();
        if (string.endsWith("".0"")) {
            string = string.substring(0, string.length() - 2);
        }
        return string;
    }
    if (bean instanceof Boolean) {
        return ((Boolean) bean).booleanValue() ? ""true()"" : ""false()"";
    }
    if (bean instanceof String) {
        return ""'"" + bean + ""'"";
    }
    return ""/"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(QName,Object,JXPathBeanInfo,Locale)","Constructor","* Create a new BeanPointer.
     * @param name is the name given to the first node
     * @param bean pointed
     * @param beanInfo JXPathBeanInfo
     * @param locale Locale","public BeanPointer(final QName name, final Object bean, final JXPathBeanInfo beanInfo, final Locale locale) {
    super(null, locale);
    this.name = name;
    this.bean = bean;
    this.beanInfo = beanInfo;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(QName,Object,JXPathBeanInfo,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(QName,Object,JXPathBeanInfo,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(QName,Object,JXPathBeanInfo,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(QName,Object,JXPathBeanInfo,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(QName,Object,JXPathBeanInfo,Locale).beanInfo","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(QName,Object,JXPathBeanInfo,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(QName,Object,JXPathBeanInfo,Locale).locale","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(QName,Object,JXPathBeanInfo,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(NodePointer,QName,Object,JXPathBeanInfo)","Constructor","* Create a new BeanPointer.
     * @param parent pointer
     * @param name is the name given to the first node
     * @param bean pointed
     * @param beanInfo JXPathBeanInfo","public BeanPointer(final NodePointer parent, final QName name, final Object bean, final JXPathBeanInfo beanInfo) {
    super(parent);
    this.name = name;
    this.bean = bean;
    this.beanInfo = beanInfo;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(NodePointer,QName,Object,JXPathBeanInfo).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(NodePointer,QName,Object,JXPathBeanInfo)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(NodePointer,QName,Object,JXPathBeanInfo).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(NodePointer,QName,Object,JXPathBeanInfo)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(NodePointer,QName,Object,JXPathBeanInfo).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(NodePointer,QName,Object,JXPathBeanInfo)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(NodePointer,QName,Object,JXPathBeanInfo).beanInfo","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointer.<init>(NodePointer,QName,Object,JXPathBeanInfo)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator","Class","* Iterates property values of an object pointed at with a {@link PropertyOwnerPointer}.
 * Examples of such objects are JavaBeans and objects with Dynamic Properties.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodeIterator"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.empty","Field","No Comment","private boolean empty = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.reverse","Field","No Comment","private final boolean reverse;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.name","Field","No Comment","private final String name;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.startIndex","Field","No Comment","private int startIndex = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.targetReady","Field","No Comment","private boolean targetReady = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.position","Field","No Comment","private int position = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.propertyNodePointer","Field","No Comment","private final PropertyPointer propertyNodePointer;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.startPropertyIndex","Field","No Comment","private int startPropertyIndex;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.includeStart","Field","No Comment","private boolean includeStart = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.getPropertyPointer()","Method","* Gets the property pointer.
     * @return NodePointer","protected NodePointer getPropertyPointer() {
    return propertyNodePointer;
}","NodePointer","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.reset()","Method","* Reset property iteration.","public void reset() {
    position = 0;
    targetReady = false;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.getNodePointer()","Method","No Comment","@Override
public NodePointer getNodePointer() {
    if (position == 0) {
        if (name != null) {
            if (!targetReady) {
                prepareForIndividualProperty(name);
            }
            // If there is no such property - return null
            if (empty) {
                return null;
            }
        } else {
            if (!setPosition(1)) {
                return null;
            }
            reset();
        }
    }
    try {
        return propertyNodePointer.getValuePointer();
    } catch (final Throwable t) {
        propertyNodePointer.handle(t);
        final NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer());
        npp.setPropertyName(propertyNodePointer.getPropertyName());
        npp.setIndex(propertyNodePointer.getIndex());
        return npp.getValuePointer();
    }
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    return name == null ? setPositionAllProperties(position) : setPositionIndividualProperty(position);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPositionIndividualProperty(int)","Method","* Sets position for an individual property.
     * @param position int position
     * @return whether this was a valid position","private boolean setPositionIndividualProperty(final int position) {
    this.position = position;
    if (position < 1) {
        return false;
    }
    if (!targetReady) {
        prepareForIndividualProperty(name);
    }
    if (empty) {
        return false;
    }
    final int length = getLength();
    int index;
    if (!reverse) {
        index = position + startIndex;
        if (!includeStart) {
            index++;
        }
        if (index > length) {
            return false;
        }
    } else {
        int end = startIndex;
        if (end == -1) {
            end = length - 1;
        }
        index = end - position + 2;
        if (!includeStart) {
            index--;
        }
        if (index < 1) {
            return false;
        }
    }
    propertyNodePointer.setIndex(index - 1);
    return true;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPositionIndividualProperty(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPositionIndividualProperty(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPositionAllProperties(int)","Method","* Sets position for all properties
     * @param position int position
     * @return whether this was a valid position","private boolean setPositionAllProperties(final int position) {
    this.position = position;
    if (position < 1) {
        return false;
    }
    int offset;
    final int count = propertyNodePointer.getPropertyCount();
    if (!reverse) {
        int index = 1;
        for (int i = startPropertyIndex; i < count; i++) {
            propertyNodePointer.setPropertyIndex(i);
            int length = getLength();
            if (i == startPropertyIndex) {
                length -= startIndex;
                if (!includeStart) {
                    length--;
                }
                offset = startIndex + position - index;
                if (!includeStart) {
                    offset++;
                }
            } else {
                offset = position - index;
            }
            if (index <= position && position < index + length) {
                propertyNodePointer.setIndex(offset);
                return true;
            }
            index += length;
        }
    } else {
        int index = 1;
        int start = startPropertyIndex;
        if (start == PropertyPointer.UNSPECIFIED_PROPERTY) {
            start = count - 1;
        }
        for (int i = start; i >= 0; i--) {
            propertyNodePointer.setPropertyIndex(i);
            int length = getLength();
            if (i == startPropertyIndex) {
                int end = startIndex;
                if (end == -1) {
                    end = length - 1;
                }
                length = end + 1;
                offset = end - position + 1;
                if (!includeStart) {
                    offset--;
                    length--;
                }
            } else {
                offset = length - (position - index) - 1;
            }
            if (index <= position && position < index + length) {
                propertyNodePointer.setIndex(offset);
                return true;
            }
            index += length;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPositionAllProperties(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPositionAllProperties(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.prepareForIndividualProperty(String)","Method","* Prepare for an individual property.
     * @param name property name","protected void prepareForIndividualProperty(final String name) {
    targetReady = true;
    empty = true;
    final String[] names = propertyNodePointer.getPropertyNames();
    if (!reverse) {
        if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY) {
            startPropertyIndex = 0;
        }
        if (startIndex == NodePointer.WHOLE_COLLECTION) {
            startIndex = 0;
        }
        for (int i = startPropertyIndex; i < names.length; i++) {
            if (names[i].equals(name)) {
                propertyNodePointer.setPropertyIndex(i);
                if (i != startPropertyIndex) {
                    startIndex = 0;
                    includeStart = true;
                }
                empty = false;
                break;
            }
        }
    } else {
        if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY) {
            startPropertyIndex = names.length - 1;
        }
        if (startIndex == NodePointer.WHOLE_COLLECTION) {
            startIndex = -1;
        }
        for (int i = startPropertyIndex; i >= 0; i--) {
            if (names[i].equals(name)) {
                propertyNodePointer.setPropertyIndex(i);
                if (i != startPropertyIndex) {
                    startIndex = -1;
                    includeStart = true;
                }
                empty = false;
                break;
            }
        }
    }
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.prepareForIndividualProperty(String).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyIterator.prepareForIndividualProperty(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.getLength()","Method","* Computes length for the current pointer - ignores any exceptions.
     * @return length","private int getLength() {
    int length;
    try {
        // TBD: cache length
        length = propertyNodePointer.getLength();
    } catch (final Throwable t) {
        propertyNodePointer.handle(t);
        length = 0;
    }
    return length;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Constructor","* Create a new PropertyIterator.
     * @param pointer owning pointer
     * @param name property name
     * @param reverse iteration order
     * @param startWith beginning pointer","public PropertyIterator(final PropertyOwnerPointer pointer, final String name, final boolean reverse, NodePointer startWith) {
    propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone();
    this.name = name;
    this.reverse = reverse;
    this.includeStart = true;
    if (reverse) {
        this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY;
        this.startIndex = -1;
    }
    if (startWith != null) {
        while (startWith != null && startWith.getImmediateParentPointer() != pointer) {
            startWith = startWith.getImmediateParentPointer();
        }
        if (startWith == null) {
            throw new JXPathException(""PropertyIerator startWith parameter is "" + ""not a child of the supplied parent"");
        }
        this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex();
        this.startIndex = startWith.getIndex();
        if (this.startIndex == NodePointer.WHOLE_COLLECTION) {
            this.startIndex = 0;
        }
        this.includeStart = false;
        if (reverse && startIndex == -1) {
            this.includeStart = true;
        }
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer).reverse","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer).startWith","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyIterator.<init>(PropertyOwnerPointer,String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer","Abstract Class","* A pointer describing a node that has properties, each of which could be
 * a collection.","Abstract Class do not obtain Source Code","No return type","public , abstract ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.UNINITIALIZED","Field","No Comment","private static final Object UNINITIALIZED = new Object();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.value","Field","No Comment","private Object value = UNINITIALIZED;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.childIterator(NodeTest,boolean,NodePointer)","Method","No Comment","@Override
public NodeIterator childIterator(final NodeTest test, final boolean reverse, final NodePointer startWith) {
    if (test == null) {
        return createNodeIterator(null, reverse, startWith);
    }
    if (test instanceof NodeNameTest) {
        final NodeNameTest nodeNameTest = (NodeNameTest) test;
        final QName testName = nodeNameTest.getNodeName();
        if (isValidProperty(testName)) {
            return createNodeIterator(nodeNameTest.isWildcard() ? null : testName.toString(), reverse, startWith);
        }
        return null;
    }
    return test instanceof NodeTypeTest && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE ? createNodeIterator(null, reverse, startWith) : null;
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.childIterator(NodeTest,boolean,NodePointer).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.childIterator(NodeTest,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.childIterator(NodeTest,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.createNodeIterator(String,boolean,NodePointer)","Method","* Create a NodeIterator.
     * @param property property name
     * @param reverse whether to iterate in reverse
     * @param startWith first pointer to return
     * @return NodeIterator","public NodeIterator createNodeIterator(final String property, final boolean reverse, final NodePointer startWith) {
    return new PropertyIterator(this, property, reverse, startWith);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.createNodeIterator(String,boolean,NodePointer).property","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.createNodeIterator(String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.createNodeIterator(String,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.createNodeIterator(String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.createNodeIterator(String,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.createNodeIterator(String,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.attributeIterator(QName)","Method","No Comment","@Override
public NodeIterator attributeIterator(final QName name) {
    return new BeanAttributeIterator(this, name);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.attributeIterator(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.attributeIterator(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.setIndex(int)","Method","No Comment","@Override
public void setIndex(final int index) {
    if (this.index != index) {
        super.setIndex(index);
        value = UNINITIALIZED;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.setIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.setIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    if (value == UNINITIALIZED) {
        value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue()) : ValueUtils.getValue(getBaseValue(), index);
    }
    return value;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.getName()","Abstract Method","No Comment","@Override
public abstract QName getName();","QName","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.isValidProperty(QName)","Method","* Learn whether {@code name} is a valid child name for this PropertyOwnerPointer.
     * @param name the QName to test
     * @return {@code true} if {@code QName} is a valid property name.
     * @since JXPath 1.3","public boolean isValidProperty(final QName name) {
    return isDefaultNamespace(name.getPrefix());
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.isValidProperty(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.isValidProperty(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.setValue(Object)","Method","* Throws an exception if you try to change the root element, otherwise
     * forwards the call to the parent pointer.
     * @param value to set","@Override
public void setValue(final Object value) {
    this.value = value;
    if (parent != null) {
        if (parent.isContainer()) {
            parent.setValue(value);
        } else {
            if (index == WHOLE_COLLECTION) {
                throw new UnsupportedOperationException(""Cannot setValue of an object that is not "" + ""some other object's property"");
            }
            throw new JXPathInvalidAccessException(""The specified collection element does not exist: "" + this);
        }
    } else {
        throw new UnsupportedOperationException(""Cannot replace the root object"");
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.remove()","Method","* If this is a root node pointer, throws an exception; otherwise
     * forwards the call to the parent node.","@Override
public void remove() {
    this.value = null;
    if (parent != null) {
        parent.remove();
    } else {
        throw new UnsupportedOperationException(""Cannot remove an object that is not "" + ""some other object's property or a collection element"");
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.getPropertyPointer()","Abstract Method","* Gets a PropertyPointer for this PropertyOwnerPointer.
     * @return PropertyPointer","public abstract PropertyPointer getPropertyPointer();","PropertyPointer","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.isDynamicPropertyDeclarationSupported()","Method","* Learn whether dynamic property declaration is supported.
     * @return true if the property owner can set a property ""does not exist"".
     *         A good example is a Map. You can always assign a value to any
     *         key even if it has never been ""declared"".","public boolean isDynamicPropertyDeclarationSupported() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    final int r = pointer1.getName().toString().compareTo(pointer2.getName().toString());
    return r == 0 ? pointer1.getIndex() - pointer2.getIndex() : r;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.<init>(NodePointer,Locale)","Constructor","* Create a new PropertyOwnerPointer.
     * @param parent parent pointer
     * @param locale Locale","protected PropertyOwnerPointer(final NodePointer parent, final Locale locale) {
    super(parent, locale);
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.<init>(NodePointer,Locale).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.<init>(NodePointer,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.<init>(NodePointer,Locale).locale","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.<init>(NodePointer,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.<init>(NodePointer)","Constructor","* Create a new PropertyOwnerPointer.
     * @param parent pointer","protected PropertyOwnerPointer(final NodePointer parent) {
    super(parent);
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.<init>(NodePointer).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.<init>(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory","Class","* Implements NodePointerFactory for stand-alone collections.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodePointerFactory"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.COLLECTION_POINTER_FACTORY_ORDER","Field","Factory order constant","public static final int COLLECTION_POINTER_FACTORY_ORDER = 10;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.getOrder()","Method","No Comment","@Override
public int getOrder() {
    return COLLECTION_POINTER_FACTORY_ORDER;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(QName,Object,Locale)","Method","No Comment","@Override
public NodePointer createNodePointer(final QName name, final Object bean, final Locale locale) {
    return ValueUtils.isCollection(bean) ? new CollectionPointer(bean, locale) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(QName,Object,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(NodePointer,QName,Object)","Method","No Comment","@Override
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object bean) {
    return ValueUtils.isCollection(bean) ? new CollectionPointer(parent, bean) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(NodePointer,QName,Object).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer","Abstract Class","* A pointer allocated by a PropertyOwnerPointer to represent the value of
 * a property of the parent object.","Abstract Class do not obtain Source Code","No return type","public , abstract ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.UNSPECIFIED_PROPERTY","Field","No Comment","public static final int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.propertyIndex","Field","Property index","protected int propertyIndex = UNSPECIFIED_PROPERTY;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.bean","Field","Owning object","protected Object bean;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.UNINITIALIZED","Field","No Comment","private static final Object UNINITIALIZED = new Object();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.value","Field","No Comment","private Object value = UNINITIALIZED;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.getPropertyIndex()","Method","* Gets the property index.
     * @return int index","public int getPropertyIndex() {
    return propertyIndex;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.setPropertyIndex(int)","Method","* Sets the property index.
     * @param index property index","public void setPropertyIndex(final int index) {
    if (propertyIndex != index) {
        propertyIndex = index;
        setIndex(WHOLE_COLLECTION);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.setPropertyIndex(int).index","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.setPropertyIndex(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.getBean()","Method","* Gets the parent bean.
     * @return Object","public Object getBean() {
    if (bean == null) {
        bean = getImmediateParentPointer().getNode();
    }
    return bean;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.getName()","Method","No Comment","@Override
public QName getName() {
    return new QName(null, getPropertyName());
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.getPropertyName()","Abstract Method","* Gets the property name.
     * @return String property name.","public abstract String getPropertyName();","String","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.setPropertyName(String)","Abstract Method","* Sets the property name.
     * @param propertyName property name to set.","public abstract void setPropertyName(String propertyName);","void","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.setPropertyName(String).propertyName","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.setPropertyName(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.getPropertyCount()","Abstract Method","* Count the number of properties represented.
     * @return int","public abstract int getPropertyCount();","int","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.getPropertyNames()","Abstract Method","* Gets the names of the included properties.
     * @return String[]","public abstract String[] getPropertyNames();","String[]","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.isActualProperty()","Abstract Method","* Learn whether this pointer references an actual property.
     * @return true if actual","protected abstract boolean isActualProperty();","boolean","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.isActual()","Method","No Comment","@Override
public boolean isActual() {
    if (!isActualProperty()) {
        return false;
    }
    return super.isActual();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    if (value == UNINITIALIZED) {
        value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue()) : ValueUtils.getValue(getBaseValue(), index);
    }
    return value;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    final Object value = getBaseValue();
    return value != null && ValueUtils.isCollection(value);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    final Object value = getNode();
    return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.getLength()","Method","* If the property contains a collection, then the length of that
     * collection, otherwise - 1.
     * @return int length","@Override
public int getLength() {
    final Object baseValue = getBaseValue();
    return baseValue == null ? 1 : ValueUtils.getLength(baseValue);
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.getImmediateValuePointer()","Method","* Returns a NodePointer that can be used to access the currently
     * selected property value.
     * @return NodePointer","@Override
public NodePointer getImmediateValuePointer() {
    return newChildNodePointer((NodePointer) clone(), getName(), getImmediateNode());
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createPath(JXPathContext)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context) {
    if (getImmediateNode() == null) {
        final AbstractFactory factory = getAbstractFactory(context);
        final int inx = index == WHOLE_COLLECTION ? 0 : index;
        final boolean success = factory.createObject(context, this, getBean(), getPropertyName(), inx);
        if (!success) {
            throw new JXPathAbstractFactoryException(""Factory "" + factory + "" could not create an object for path: "" + asPath());
        }
    }
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createPath(JXPathContext,Object)","Method","No Comment","@Override
public NodePointer createPath(final JXPathContext context, final Object value) {
    // If neccessary, expand collection
    if (index != WHOLE_COLLECTION && index >= getLength()) {
        createPath(context);
    }
    setValue(value);
    return this;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createPath(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createPath(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createPath(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int,Object)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index, final Object value) {
    final PropertyPointer prop = (PropertyPointer) clone();
    if (name != null) {
        prop.setPropertyName(name.toString());
    }
    prop.setIndex(index);
    return prop.createPath(context, value);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int,Object).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int,Object).value","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index) {
    final PropertyPointer prop = (PropertyPointer) clone();
    if (name != null) {
        prop.setPropertyName(name.toString());
    }
    prop.setIndex(index);
    return prop.createPath(context);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return getImmediateParentPointer().hashCode() + propertyIndex + index;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof PropertyPointer)) {
        return false;
    }
    final PropertyPointer other = (PropertyPointer) object;
    if (parent != other.parent && (parent == null || !parent.equals(other.parent))) {
        return false;
    }
    if (getPropertyIndex() != other.getPropertyIndex() || !getPropertyName().equals(other.getPropertyName())) {
        return false;
    }
    final int iThis = index == WHOLE_COLLECTION ? 0 : index;
    final int iOther = other.index == WHOLE_COLLECTION ? 0 : other.index;
    return iThis == iOther;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    return getValuePointer().compareChildNodePointers(pointer1, pointer2);
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.<init>(NodePointer)","Constructor","* Takes a javabean, a descriptor of a property of that object and
     * an offset within that property (starting with 0).
     * @param parent parent pointer","public PropertyPointer(final NodePointer parent) {
    super(parent);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.PropertyPointer.<init>(NodePointer).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.PropertyPointer.<init>(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory","Class","* Implements NodePointerFactory for JavaBeans.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodePointerFactory"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.BEAN_POINTER_FACTORY_ORDER","Field","Factory order constant","public static final int BEAN_POINTER_FACTORY_ORDER = 900;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.getOrder()","Method","No Comment","@Override
public int getOrder() {
    return BEAN_POINTER_FACTORY_ORDER;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(QName,Object,Locale)","Method","No Comment","@Override
public NodePointer createNodePointer(final QName name, final Object bean, final Locale locale) {
    final JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());
    return new BeanPointer(name, bean, bi, locale);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(QName,Object,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Method","No Comment","@Override
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object bean) {
    if (bean == null) {
        return new NullPointer(parent, name);
    }
    final JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());
    return new BeanPointer(parent, name, bean, bi);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(NodePointer,QName,Object).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer","Class","* Represents a namespace node.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.prefix","Field","No Comment","private final String prefix;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.namespaceURI","Field","No Comment","private String namespaceURI;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -7622456151550131709L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.getName()","Method","No Comment","@Override
public QName getName() {
    return new QName(prefix);
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return null;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return getNamespaceURI();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.getNamespaceURI()","Method","No Comment","@Override
public String getNamespaceURI() {
    if (namespaceURI == null) {
        namespaceURI = parent.getNamespaceURI(prefix);
    }
    return namespaceURI;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.setValue(Object)","Method","* Throws UnsupportedOperationException.
     * @param value Object","@Override
public void setValue(final Object value) {
    throw new UnsupportedOperationException(""Cannot modify DOM trees"");
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.testNode(NodeTest)","Method","No Comment","@Override
public boolean testNode(final NodeTest nodeTest) {
    return nodeTest == null || nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.testNode(NodeTest).nodeTest","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.testNode(NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    final StringBuilder buffer = new StringBuilder();
    if (parent != null) {
        buffer.append(parent.asPath());
        if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') {
            buffer.append('/');
        }
    }
    buffer.append(""namespace::"");
    buffer.append(prefix);
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return prefix.hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof NamespacePointer)) {
        return false;
    }
    final NamespacePointer other = (NamespacePointer) object;
    return prefix.equals(other.prefix);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    // Won't happen - namespaces don't have children
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String)","Constructor","* Create a new NamespacePointer.
     * @param parent parent pointer
     * @param prefix associated ns prefix.","public NamespacePointer(final NodePointer parent, final String prefix) {
    super(parent);
    this.prefix = prefix;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String).prefix","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String,String)","Constructor","* Create a new NamespacePointer.
     * @param parent parent pointer
     * @param prefix associated ns prefix.
     * @param namespaceURI associated ns URI.","public NamespacePointer(final NodePointer parent, final String prefix, final String namespaceURI) {
    super(parent);
    this.prefix = prefix;
    this.namespaceURI = namespaceURI;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String,String).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String,String).prefix","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String,String).namespaceURI","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dom.NamespacePointer.<init>(NodePointer,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer","Class","* A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,
 * a DOMNodePointer instance may likewise not be properly Serializable.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -8751046933894857319L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.node","Field","No Comment","private final Node node;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.namespaces","Field","No Comment","private Map namespaces;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.defaultNamespace","Field","No Comment","private String defaultNamespace;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.id","Field","No Comment","private String id;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.localNamespaceResolver","Field","No Comment","private NamespaceResolver localNamespaceResolver;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.XML_NAMESPACE_URI","Field","XML namespace URI","public static final String XML_NAMESPACE_URI = ""http://www.w3.org/XML/1998/namespace"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.XMLNS_NAMESPACE_URI","Field","XMLNS namespace URI","public static final String XMLNS_NAMESPACE_URI = ""http://www.w3.org/2000/xmlns/"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.testNode(NodeTest)","Method","No Comment","@Override
public boolean testNode(final NodeTest test) {
    return testNode(node, test);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.testNode(NodeTest).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.testNode(NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.testNode(Node,NodeTest)","Method","* Test a Node.
     * @param node to test
     * @param test to execute
     * @return true if node passes test","public static boolean testNode(final Node node, final NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (node.getNodeType() != Node.ELEMENT_NODE) {
            return false;
        }
        final NodeNameTest nodeNameTest = (NodeNameTest) test;
        final QName testName = nodeNameTest.getNodeName();
        final String namespaceURI = nodeNameTest.getNamespaceURI();
        final boolean wildcard = nodeNameTest.isWildcard();
        final String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(getLocalName(node))) {
            final String nodeNS = getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        final int nodeType = node.getNodeType();
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return true;
            case Compiler.NODE_TYPE_TEXT:
                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;
            case Compiler.NODE_TYPE_COMMENT:
                return nodeType == Node.COMMENT_NODE;
            case Compiler.NODE_TYPE_PI:
                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
            default:
                return false;
        }
    }
    if (test instanceof ProcessingInstructionTest && node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
        final String testPI = ((ProcessingInstructionTest) test).getTarget();
        final String nodePI = ((ProcessingInstruction) node).getTarget();
        return testPI.equals(nodePI);
    }
    return false;
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.testNode(Node,NodeTest).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.testNode(Node,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.testNode(Node,NodeTest).test","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.testNode(Node,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.equalStrings(String,String)","Method","* Test string equality.
     * @param s1 String 1
     * @param s2 String 2
     * @return true if == or .equals()","private static boolean equalStrings(String s1, String s2) {
    if (s1 == s2) {
        return true;
    }
    s1 = s1 == null ? """" : s1.trim();
    s2 = s2 == null ? """" : s2.trim();
    return s1.equals(s2);
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.equalStrings(String,String).s1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.equalStrings(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.equalStrings(String,String).s2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.equalStrings(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getName()","Method","No Comment","@Override
public QName getName() {
    String ln = null;
    String ns = null;
    final int type = node.getNodeType();
    if (type == Node.ELEMENT_NODE) {
        ns = getPrefix(node);
        ln = getLocalName(node);
    } else if (type == Node.PROCESSING_INSTRUCTION_NODE) {
        ln = ((ProcessingInstruction) node).getTarget();
    }
    return new QName(ns, ln);
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getNamespaceURI()","Method","No Comment","@Override
public String getNamespaceURI() {
    return getNamespaceURI(node);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.childIterator(NodeTest,boolean,NodePointer)","Method","No Comment","@Override
public NodeIterator childIterator(final NodeTest test, final boolean reverse, final NodePointer startWith) {
    return new DOMNodeIterator(this, test, reverse, startWith);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.childIterator(NodeTest,boolean,NodePointer).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.childIterator(NodeTest,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.childIterator(NodeTest,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.attributeIterator(QName)","Method","No Comment","@Override
public NodeIterator attributeIterator(final QName name) {
    return new DOMAttributeIterator(this, name);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.attributeIterator(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.attributeIterator(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.namespacePointer(String)","Method","No Comment","@Override
public NodePointer namespacePointer(final String prefix) {
    return new NamespacePointer(this, prefix);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.namespacePointer(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.namespacePointer(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.namespaceIterator()","Method","No Comment","@Override
public NodeIterator namespaceIterator() {
    return new DOMNamespaceIterator(this);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getNamespaceResolver()","Method","No Comment","@Override
public synchronized NamespaceResolver getNamespaceResolver() {
    if (localNamespaceResolver == null) {
        localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());
        localNamespaceResolver.setNamespaceContextPointer(this);
    }
    return localNamespaceResolver;
}","NamespaceResolver","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getNamespaceURI(String)","Method","No Comment","@Override
public String getNamespaceURI(final String prefix) {
    if (prefix == null || prefix.isEmpty()) {
        return getDefaultNamespaceURI();
    }
    if (prefix.equals(""xml"")) {
        return XML_NAMESPACE_URI;
    }
    if (prefix.equals(""xmlns"")) {
        return XMLNS_NAMESPACE_URI;
    }
    String namespace = null;
    if (namespaces == null) {
        namespaces = new HashMap();
    } else {
        namespace = (String) namespaces.get(prefix);
    }
    if (namespace == null) {
        final String qname = ""xmlns:"" + prefix;
        Node aNode = node;
        if (aNode instanceof Document) {
            aNode = ((Document) aNode).getDocumentElement();
        }
        while (aNode != null) {
            if (aNode.getNodeType() == Node.ELEMENT_NODE) {
                final Attr attr = ((Element) aNode).getAttributeNode(qname);
                if (attr != null) {
                    namespace = attr.getValue();
                    break;
                }
            }
            aNode = aNode.getParentNode();
        }
        if (namespace == null || namespace.isEmpty()) {
            namespace = UNKNOWN_NAMESPACE;
        }
    }
    namespaces.put(prefix, namespace);
    if (namespace == UNKNOWN_NAMESPACE) {
        return null;
    }
    // TBD: We are supposed to resolve relative URIs to absolute ones.
    return namespace;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getNamespaceURI(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getNamespaceURI(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getDefaultNamespaceURI()","Method","No Comment","@Override
public String getDefaultNamespaceURI() {
    if (defaultNamespace == null) {
        Node aNode = node;
        if (aNode instanceof Document) {
            aNode = ((Document) aNode).getDocumentElement();
        }
        while (aNode != null) {
            if (aNode.getNodeType() == Node.ELEMENT_NODE) {
                final Attr attr = ((Element) aNode).getAttributeNode(""xmlns"");
                if (attr != null) {
                    defaultNamespace = attr.getValue();
                    break;
                }
            }
            aNode = aNode.getParentNode();
        }
    }
    if (defaultNamespace == null) {
        defaultNamespace = """";
    }
    // TBD: We are supposed to resolve relative URIs to absolute ones.
    return defaultNamespace.isEmpty() ? null : defaultNamespace;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return node;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return node;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.isActual()","Method","No Comment","@Override
public boolean isActual() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return !node.hasChildNodes();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.isLanguage(String)","Method","* Returns true if the xml:lang attribute for the current node
     * or its parent has the specified prefix <em>lang</em>.
     * If no node has this prefix, calls {@code super.isLanguage(lang)}.
     * @param lang ns to test
     * @return boolean","@Override
public boolean isLanguage(final String lang) {
    final String current = getLanguage();
    return current == null ? super.isLanguage(lang) : current.toUpperCase(Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.isLanguage(String).lang","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.isLanguage(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.findEnclosingAttribute(Node,String)","Method","* Find the nearest occurrence of the specified attribute
     * on the specified and enclosing elements.
     * @param n current node
     * @param attrName attribute name
     * @return attribute value","protected static String findEnclosingAttribute(Node n, final String attrName) {
    while (n != null) {
        if (n.getNodeType() == Node.ELEMENT_NODE) {
            final Element e = (Element) n;
            final String attr = e.getAttribute(attrName);
            if (attr != null && !attr.isEmpty()) {
                return attr;
            }
        }
        n = n.getParentNode();
    }
    return null;
}","String","protected , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.findEnclosingAttribute(Node,String).n","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.findEnclosingAttribute(Node,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.findEnclosingAttribute(Node,String).attrName","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.findEnclosingAttribute(Node,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getLanguage()","Method","* Gets the language attribute for this node.
     * @return String language name","protected String getLanguage() {
    return findEnclosingAttribute(node, ""xml:lang"");
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.setValue(Object)","Method","* Sets contents of the node to the specified value. If the value is
     * a String, the contents of the node are replaced with this text.
     * If the value is an Element or Document, the children of the
     * node are replaced with the children of the passed node.
     * @param value to set","@Override
public void setValue(final Object value) {
    if (node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.CDATA_SECTION_NODE) {
        final String string = (String) TypeUtils.convert(value, String.class);
        if (string != null && !string.isEmpty()) {
            node.setNodeValue(string);
        } else {
            node.getParentNode().removeChild(node);
        }
    } else {
        NodeList children = node.getChildNodes();
        final int count = children.getLength();
        for (int i = count; --i >= 0; ) {
            final Node child = children.item(i);
            node.removeChild(child);
        }
        if (value instanceof Node) {
            final Node valueNode = (Node) value;
            if (valueNode instanceof Element || valueNode instanceof Document) {
                children = valueNode.getChildNodes();
                for (int i = 0; i < children.getLength(); i++) {
                    final Node child = children.item(i);
                    node.appendChild(child.cloneNode(true));
                }
            } else {
                node.appendChild(valueNode.cloneNode(true));
            }
        } else {
            final String string = (String) TypeUtils.convert(value, String.class);
            if (string != null && !string.isEmpty()) {
                final Node textNode = node.getOwnerDocument().createTextNode(string);
                node.appendChild(textNode);
            }
        }
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, int index) {
    if (index == WHOLE_COLLECTION) {
        index = 0;
    }
    final boolean success = getAbstractFactory(context).createObject(context, this, node, name.toString(), index);
    if (success) {
        NodeTest nodeTest;
        final String prefix = name.getPrefix();
        final String namespaceURI = prefix == null ? null : context.getNamespaceURI(prefix);
        nodeTest = new NodeNameTest(name, namespaceURI);
        final NodeIterator it = childIterator(nodeTest, false, null);
        if (it != null && it.setPosition(index + 1)) {
            return it.getNodePointer();
        }
    }
    throw new JXPathAbstractFactoryException(""Factory could not create a child node for path: "" + asPath() + ""/"" + name + ""["" + (index + 1) + ""]"");
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int,Object)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index, final Object value) {
    final NodePointer ptr = createChild(context, name, index);
    ptr.setValue(value);
    return ptr;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int,Object).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int,Object).value","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createAttribute(JXPathContext,QName)","Method","No Comment","@Override
public NodePointer createAttribute(final JXPathContext context, final QName name) {
    if (!(node instanceof Element)) {
        return super.createAttribute(context, name);
    }
    final Element element = (Element) node;
    final String prefix = name.getPrefix();
    if (prefix != null) {
        String ns = null;
        final NamespaceResolver nsr = getNamespaceResolver();
        if (nsr != null) {
            ns = nsr.getNamespaceURI(prefix);
        }
        if (ns == null) {
            throw new JXPathException(""Unknown namespace prefix: "" + prefix);
        }
        element.setAttributeNS(ns, name.toString(), """");
    } else if (!element.hasAttribute(name.getName())) {
        element.setAttribute(name.getName(), """");
    }
    final NodeIterator it = attributeIterator(name);
    it.setPosition(1);
    return it.getNodePointer();
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createAttribute(JXPathContext,QName).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createAttribute(JXPathContext,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createAttribute(JXPathContext,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.createAttribute(JXPathContext,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.remove()","Method","No Comment","@Override
public void remove() {
    final Node parent = node.getParentNode();
    if (parent == null) {
        throw new JXPathException(""Cannot remove root DOM node"");
    }
    parent.removeChild(node);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    if (id != null) {
        return ""id('"" + escape(id) + ""')"";
    }
    final StringBuilder buffer = new StringBuilder();
    if (parent != null) {
        buffer.append(parent.asPath());
    }
    switch(node.getNodeType()) {
        case Node.ELEMENT_NODE:
            // If the parent pointer is not a DOMNodePointer, it is
            // the parent's responsibility to produce the node test part
            // of the path
            if (parent instanceof DOMNodePointer) {
                if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') {
                    buffer.append('/');
                }
                final String ln = getLocalName(node);
                final String nsURI = getNamespaceURI();
                if (nsURI == null) {
                    buffer.append(ln);
                    buffer.append('[');
                    buffer.append(getRelativePositionByQName()).append(']');
                } else {
                    final String prefix = getNamespaceResolver().getPrefix(nsURI);
                    if (prefix != null) {
                        buffer.append(prefix);
                        buffer.append(':');
                        buffer.append(ln);
                        buffer.append('[');
                        buffer.append(getRelativePositionByQName());
                    } else {
                        buffer.append(""node()"");
                        buffer.append('[');
                        buffer.append(getRelativePositionOfElement());
                    }
                    buffer.append(']');
                }
            }
            break;
        case Node.TEXT_NODE:
        case Node.CDATA_SECTION_NODE:
            buffer.append(""/text()"");
            buffer.append('[');
            buffer.append(getRelativePositionOfTextNode()).append(']');
            break;
        case Node.PROCESSING_INSTRUCTION_NODE:
            buffer.append(""/processing-instruction(\'"");
            buffer.append(((ProcessingInstruction) node).getTarget()).append(""')"");
            buffer.append('[');
            buffer.append(getRelativePositionOfPI()).append(']');
            break;
        case Node.DOCUMENT_NODE:
            // That'll be empty
            break;
        default:
            break;
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getRelativePositionByQName()","Method","* Gets relative position of this among like-named siblings.
     * @return 1..n","private int getRelativePositionByQName() {
    int count = 1;
    Node n = node.getPreviousSibling();
    while (n != null) {
        if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) {
            count++;
        }
        n = n.getPreviousSibling();
    }
    return count;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.matchesQName(Node)","Method","No Comment","private boolean matchesQName(final Node n) {
    if (getNamespaceURI() != null) {
        return equalStrings(getNamespaceURI(n), getNamespaceURI()) && equalStrings(node.getLocalName(), n.getLocalName());
    }
    return equalStrings(node.getNodeName(), n.getNodeName());
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.matchesQName(Node).n","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.matchesQName(Node)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getRelativePositionOfElement()","Method","* Gets relative position of this among all siblings.
     * @return 1..n","private int getRelativePositionOfElement() {
    int count = 1;
    Node n = node.getPreviousSibling();
    while (n != null) {
        if (n.getNodeType() == Node.ELEMENT_NODE) {
            count++;
        }
        n = n.getPreviousSibling();
    }
    return count;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getRelativePositionOfTextNode()","Method","* Gets the relative position of this among sibling text nodes.
     * @return 1..n","private int getRelativePositionOfTextNode() {
    int count = 1;
    Node n = node.getPreviousSibling();
    while (n != null) {
        if (n.getNodeType() == Node.TEXT_NODE || n.getNodeType() == Node.CDATA_SECTION_NODE) {
            count++;
        }
        n = n.getPreviousSibling();
    }
    return count;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getRelativePositionOfPI()","Method","* Gets the relative position of this among same-target processing instruction siblings.
     * @return 1..n","private int getRelativePositionOfPI() {
    int count = 1;
    final String target = ((ProcessingInstruction) node).getTarget();
    Node n = node.getPreviousSibling();
    while (n != null) {
        if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE && ((ProcessingInstruction) n).getTarget().equals(target)) {
            count++;
        }
        n = n.getPreviousSibling();
    }
    return count;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return node.hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getPrefix(Node)","Method","* Gets any prefix from the specified node.
     * @param node the node to check
     * @return String xml prefix","public static String getPrefix(final Node node) {
    final String prefix = node.getPrefix();
    if (prefix != null) {
        return prefix;
    }
    final String name = node.getNodeName();
    final int index = name.lastIndexOf(':');
    return index < 0 ? null : name.substring(0, index);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getPrefix(Node).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getPrefix(Node)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getLocalName(Node)","Method","* Gets the local name of the specified node.
     * @param node node to check
     * @return String local name","public static String getLocalName(final Node node) {
    final String localName = node.getLocalName();
    if (localName != null) {
        return localName;
    }
    final String name = node.getNodeName();
    final int index = name.lastIndexOf(':');
    return index < 0 ? name : name.substring(index + 1);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getLocalName(Node).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getLocalName(Node)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getNamespaceURI(Node)","Method","* Gets the ns uri of the specified node.
     * @param node Node to check
     * @return String ns uri","public static String getNamespaceURI(Node node) {
    if (node instanceof Document) {
        node = ((Document) node).getDocumentElement();
    }
    final Element element = (Element) node;
    String uri = element.getNamespaceURI();
    if (uri == null) {
        final String prefix = getPrefix(node);
        final String qname = prefix == null ? ""xmlns"" : ""xmlns:"" + prefix;
        Node aNode = node;
        while (aNode != null) {
            if (aNode.getNodeType() == Node.ELEMENT_NODE) {
                final Attr attr = ((Element) aNode).getAttributeNode(qname);
                if (attr != null) {
                    uri = attr.getValue();
                    break;
                }
            }
            aNode = aNode.getParentNode();
        }
    }
    return """".equals(uri) ? null : uri;
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getNamespaceURI(Node).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getNamespaceURI(Node)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getValue()","Method","No Comment","@Override
public Object getValue() {
    if (node.getNodeType() == Node.COMMENT_NODE) {
        final String text = ((Comment) node).getData();
        return text == null ? """" : text.trim();
    }
    return stringValue(node);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.stringValue(Node)","Method","* Gets the string value of the specified node.
     * @param node Node to check
     * @return String","private String stringValue(final Node node) {
    final int nodeType = node.getNodeType();
    if (nodeType == Node.COMMENT_NODE) {
        return """";
    }
    final boolean trim = !""preserve"".equals(findEnclosingAttribute(node, ""xml:space""));
    if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {
        final String text = node.getNodeValue();
        return text == null ? """" : trim ? text.trim() : text;
    }
    if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {
        final String text = ((ProcessingInstruction) node).getData();
        return text == null ? """" : trim ? text.trim() : text;
    }
    final NodeList list = node.getChildNodes();
    final StringBuilder buf = new StringBuilder();
    for (int i = 0; i < list.getLength(); i++) {
        final Node child = list.item(i);
        buf.append(stringValue(child));
    }
    return buf.toString();
}","String","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.stringValue(Node).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.stringValue(Node)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getPointerByID(JXPathContext,String)","Method","* Locates a node by ID.
     * @param context starting context
     * @param id to find
     * @return Pointer","@Override
public Pointer getPointerByID(final JXPathContext context, final String id) {
    final Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node : node.getOwnerDocument();
    final Element element = document.getElementById(id);
    return element == null ? (Pointer) new NullPointer(getLocale(), id) : new DOMNodePointer(element, getLocale(), id);
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getPointerByID(JXPathContext,String).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getPointerByID(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getPointerByID(JXPathContext,String).id","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.getPointerByID(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    final Node node1 = (Node) pointer1.getBaseValue();
    final Node node2 = (Node) pointer2.getBaseValue();
    if (node1 == node2) {
        return 0;
    }
    final int t1 = node1.getNodeType();
    final int t2 = node2.getNodeType();
    if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {
        return -1;
    }
    if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {
        return 1;
    }
    if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {
        final NamedNodeMap map = ((Node) getNode()).getAttributes();
        final int length = map.getLength();
        for (int i = 0; i < length; i++) {
            final Node n = map.item(i);
            if (n == node1) {
                return -1;
            }
            if (n == node2) {
                return 1;
            }
        }
        // Should not happen
        return 0;
    }
    Node current = node.getFirstChild();
    while (current != null) {
        if (current == node1) {
            return -1;
        }
        if (current == node2) {
            return 1;
        }
        current = current.getNextSibling();
    }
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale)","Constructor","* Create a new DOMNodePointer.
     * @param node pointed at
     * @param locale Locale","public DOMNodePointer(final Node node, final Locale locale) {
    super(null, locale);
    this.node = node;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale).locale","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale,String)","Constructor","* Create a new DOMNodePointer.
     * @param node pointed at
     * @param locale Locale
     * @param id string id","public DOMNodePointer(final Node node, final Locale locale, final String id) {
    super(null, locale);
    this.node = node;
    this.id = id;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale,String).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale,String).locale","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale,String).id","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(Node,Locale,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(NodePointer,Node)","Constructor","* Create a new DOMNodePointer.
     * @param parent pointer
     * @param node pointed","public DOMNodePointer(final NodePointer parent, final Node node) {
    super(parent);
    this.node = node;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(NodePointer,Node).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(NodePointer,Node)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(NodePointer,Node).node","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.<init>(NodePointer,Node)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer","Class","* A Pointer that points to a DOM node. Because the underlying DOM Attr is not Serializable,
 * neither is this pointer class truly so.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1115085175427555951L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.attr","Field","No Comment","private final Attr attr;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.getName()","Method","No Comment","@Override
public QName getName() {
    return new QName(DOMNodePointer.getPrefix(attr), DOMNodePointer.getLocalName(attr));
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.getNamespaceURI()","Method","No Comment","@Override
public String getNamespaceURI() {
    final String prefix = DOMNodePointer.getPrefix(attr);
    return prefix == null ? null : parent.getNamespaceURI(prefix);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.getValue()","Method","No Comment","@Override
public Object getValue() {
    final String value = attr.getValue();
    if (value == null || value.isEmpty() && !attr.getSpecified()) {
        return null;
    }
    return value;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return attr;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return attr;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.isActual()","Method","No Comment","@Override
public boolean isActual() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.testNode(NodeTest)","Method","No Comment","@Override
public boolean testNode(final NodeTest nodeTest) {
    return nodeTest == null || nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.testNode(NodeTest).nodeTest","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.testNode(NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.setValue(Object)","Method","* Sets the value of this attribute.
     * @param value to set","@Override
public void setValue(final Object value) {
    attr.setValue((String) TypeUtils.convert(value, String.class));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.remove()","Method","No Comment","@Override
public void remove() {
    attr.getOwnerElement().removeAttributeNode(attr);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    final StringBuilder buffer = new StringBuilder();
    if (parent != null) {
        buffer.append(parent.asPath());
        if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') {
            buffer.append('/');
        }
    }
    buffer.append('@');
    buffer.append(getName());
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return System.identityHashCode(attr);
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    return object == this || object instanceof DOMAttributePointer && attr == ((DOMAttributePointer) object).attr;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    // Won't happen - attributes don't have children
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.<init>(NodePointer,Attr)","Constructor","* Create a new DOMAttributePointer.
     * @param parent pointer
     * @param attr pointed","public DOMAttributePointer(final NodePointer parent, final Attr attr) {
    super(parent);
    this.attr = attr;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.<init>(NodePointer,Attr).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.<init>(NodePointer,Attr)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.<init>(NodePointer,Attr).attr","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer.<init>(NodePointer,Attr)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator","Class","* An iterator of children of a DOM Node.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodeIterator"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.parent","Field","No Comment","private final NodePointer parent;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.node","Field","No Comment","private final Node node;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.child","Field","No Comment","private Node child = null;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.reverse","Field","No Comment","private final boolean reverse;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.position","Field","No Comment","private int position = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.getNodePointer()","Method","No Comment","@Override
public NodePointer getNodePointer() {
    if (position == 0) {
        setPosition(1);
    }
    return child == null ? null : new DOMNodePointer(parent, child);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    while (this.position < position) {
        if (!next()) {
            return false;
        }
    }
    while (this.position > position) {
        if (!previous()) {
            return false;
        }
    }
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.previous()","Method","* Sets the previous position.
     * @return whether valid","private boolean previous() {
    position--;
    if (!reverse) {
        if (position == 0) {
            child = null;
        } else if (child == null) {
            child = node.getLastChild();
        } else {
            child = child.getPreviousSibling();
        }
        while (child != null && !testChild()) {
            child = child.getPreviousSibling();
        }
    } else {
        child = child.getNextSibling();
        while (child != null && !testChild()) {
            child = child.getNextSibling();
        }
    }
    return child != null;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.next()","Method","* Sets the next position.
     * @return whether valid","private boolean next() {
    position++;
    if (!reverse) {
        if (position == 1 && child == null) {
            child = node.getFirstChild();
        } else {
            child = child.getNextSibling();
        }
        while (child != null && !testChild()) {
            child = child.getNextSibling();
        }
    } else {
        if (position == 1 && child == null) {
            child = node.getLastChild();
        } else {
            child = child.getPreviousSibling();
        }
        while (child != null && !testChild()) {
            child = child.getPreviousSibling();
        }
    }
    return child != null;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.testChild()","Method","* Test child.
     * @return result of the test","private boolean testChild() {
    return DOMNodePointer.testNode(child, nodeTest);
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Constructor","* Create a new DOMNodeIterator.
     * @param parent parent pointer
     * @param nodeTest test
     * @param reverse whether to iterate in reverse
     * @param startWith starting pointer","public DOMNodeIterator(final NodePointer parent, final NodeTest nodeTest, final boolean reverse, final NodePointer startWith) {
    this.parent = parent;
    this.node = (Node) parent.getNode();
    if (startWith != null) {
        this.child = (Node) startWith.getNode();
    }
    this.nodeTest = nodeTest;
    this.reverse = reverse;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer).reverse","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer).startWith","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator","Class","* An iterator of attributes of a DOM Node.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodeIterator"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.parent","Field","No Comment","private final NodePointer parent;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.name","Field","No Comment","private final QName name;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.attributes","Field","No Comment","private final List attributes;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.position","Field","No Comment","private int position = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.testAttr(Attr)","Method","* Test an attribute.
     * @param attr to test
     * @return whether test succeeded","private boolean testAttr(final Attr attr) {
    final String nodePrefix = DOMNodePointer.getPrefix(attr);
    final String nodeLocalName = DOMNodePointer.getLocalName(attr);
    if (nodePrefix != null && nodePrefix.equals(""xmlns"")) {
        return false;
    }
    if (nodePrefix == null && nodeLocalName.equals(""xmlns"")) {
        return false;
    }
    final String testLocalName = name.getName();
    if (testLocalName.equals(""*"") || testLocalName.equals(nodeLocalName)) {
        final String testPrefix = name.getPrefix();
        if (testPrefix == null || Objects.equals(testPrefix, nodePrefix)) {
            return true;
        }
        if (nodePrefix == null) {
            return false;
        }
        return Objects.equals(parent.getNamespaceURI(testPrefix), parent.getNamespaceURI(nodePrefix));
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.testAttr(Attr).attr","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.testAttr(Attr)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.getAttribute(Element,QName)","Method","* Gets the named attribute.
     * @param element to search
     * @param name to match
     * @return Attr found","private Attr getAttribute(final Element element, final QName name) {
    final String testPrefix = name.getPrefix();
    String testNS = null;
    if (testPrefix != null) {
        testNS = parent.getNamespaceResolver().getNamespaceURI(testPrefix);
    }
    if (testNS != null) {
        Attr attr = element.getAttributeNodeNS(testNS, name.getName());
        if (attr != null) {
            return attr;
        }
        // This may mean that the parser does not support NS for
        // attributes, example - the version of Crimson bundled
        // with JDK 1.4.0
        final NamedNodeMap nnm = element.getAttributes();
        for (int i = 0; i < nnm.getLength(); i++) {
            attr = (Attr) nnm.item(i);
            if (testAttr(attr)) {
                return attr;
            }
        }
        return null;
    }
    return element.getAttributeNode(name.getName());
}","Attr","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.getAttribute(Element,QName).element","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.getAttribute(Element,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.getAttribute(Element,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.getAttribute(Element,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.getNodePointer()","Method","No Comment","@Override
public NodePointer getNodePointer() {
    if (position == 0) {
        if (!setPosition(1)) {
            return null;
        }
        position = 0;
    }
    int index = position - 1;
    if (index < 0) {
        index = 0;
    }
    return new DOMAttributePointer(parent, (Attr) attributes.get(index));
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    this.position = position;
    return position >= 1 && position <= attributes.size();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.<init>(NodePointer,QName)","Constructor","* Create a new DOMAttributeIterator.
     * @param parent pointer
     * @param name to test","public DOMAttributeIterator(final NodePointer parent, final QName name) {
    this.parent = parent;
    this.name = name;
    attributes = new ArrayList();
    final Node node = (Node) parent.getNode();
    if (node.getNodeType() == Node.ELEMENT_NODE) {
        final String lname = name.getName();
        if (!lname.equals(""*"")) {
            final Attr attr = getAttribute((Element) node, name);
            if (attr != null) {
                attributes.add(attr);
            }
        } else {
            final NamedNodeMap map = node.getAttributes();
            final int count = map.getLength();
            for (int i = 0; i < count; i++) {
                final Attr attr = (Attr) map.item(i);
                if (testAttr(attr)) {
                    attributes.add(attr);
                }
            }
        }
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.<init>(NodePointer,QName).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.<init>(NodePointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.<init>(NodePointer,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator.<init>(NodePointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory","Class","* Implements NodePointerFactory for DOM elements.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodePointerFactory"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.DOM_POINTER_FACTORY_ORDER","Field","Factory order","public static final int DOM_POINTER_FACTORY_ORDER = 100;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.getOrder()","Method","No Comment","@Override
public int getOrder() {
    return DOM_POINTER_FACTORY_ORDER;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(QName,Object,Locale)","Method","No Comment","@Override
public NodePointer createNodePointer(final QName name, final Object bean, final Locale locale) {
    return bean instanceof Node ? new DOMNodePointer((Node) bean, locale) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(QName,Object,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(NodePointer,QName,Object)","Method","No Comment","@Override
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object bean) {
    return bean instanceof Node ? new DOMNodePointer(parent, (Node) bean) : null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(NodePointer,QName,Object).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator","Class","* An iterator of namespaces of a DOM Node.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodeIterator"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.parent","Field","No Comment","private final NodePointer parent;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.attributes","Field","No Comment","private final List attributes;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.position","Field","No Comment","private int position = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.collectNamespaces(List,Node)","Method","* Collect namespaces from attribute nodes.
     * @param attributes attribute list
     * @param node target node","private void collectNamespaces(final List attributes, Node node) {
    final Node parent = node.getParentNode();
    if (parent != null) {
        collectNamespaces(attributes, parent);
    }
    if (node.getNodeType() == Node.DOCUMENT_NODE) {
        node = ((Document) node).getDocumentElement();
    }
    if (node.getNodeType() == Node.ELEMENT_NODE) {
        final NamedNodeMap map = node.getAttributes();
        final int count = map.getLength();
        for (int i = 0; i < count; i++) {
            final Attr attr = (Attr) map.item(i);
            final String prefix = DOMNodePointer.getPrefix(attr);
            final String name = DOMNodePointer.getLocalName(attr);
            if (prefix != null && prefix.equals(""xmlns"") || prefix == null && name.equals(""xmlns"")) {
                attributes.add(attr);
            }
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.collectNamespaces(List,Node).attributes","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.collectNamespaces(List,Node)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.collectNamespaces(List,Node).node","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.collectNamespaces(List,Node)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.getNodePointer()","Method","No Comment","@Override
public NodePointer getNodePointer() {
    if (position == 0) {
        if (!setPosition(1)) {
            return null;
        }
        position = 0;
    }
    int index = position - 1;
    if (index < 0) {
        index = 0;
    }
    String prefix = """";
    final Attr attr = (Attr) attributes.get(index);
    final String name = attr.getPrefix();
    if (name != null && name.equals(""xmlns"")) {
        prefix = DOMNodePointer.getLocalName(attr);
    }
    return new NamespacePointer(parent, prefix, attr.getValue());
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    this.position = position;
    return position >= 1 && position <= attributes.size();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.<init>(NodePointer)","Constructor","* Create a new DOMNamespaceIterator.
     * @param parent parent pointer","public DOMNamespaceIterator(final NodePointer parent) {
    this.parent = parent;
    attributes = new ArrayList();
    collectNamespaces(attributes, (Node) parent.getNode());
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.<init>(NodePointer).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator.<init>(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory","Class","* NodePointerFactory to create {@link VariablePointer VariablePointers}.
 * @since JXPath 1.3","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodePointerFactory"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.VARIABLE_POINTER_FACTORY_ORDER","Field","Factory order constant","public static final int VARIABLE_POINTER_FACTORY_ORDER = 890;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.contextWrapper(JXPathContext)","Method","* VariableContextWrapper factory method.
     * @param context the JXPathContext to wrap.
     * @return VariableContextWrapper.","public static VariableContextWrapper contextWrapper(final JXPathContext context) {
    return new VariableContextWrapper(context);
}","VariableContextWrapper","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.contextWrapper(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointerFactory.contextWrapper(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(QName,Object,Locale)","Method","No Comment","@Override
public NodePointer createNodePointer(final QName name, final Object object, final Locale locale) {
    if (object instanceof VariableContextWrapper) {
        JXPathContext varCtx = ((VariableContextWrapper) object).getContext();
        while (varCtx != null) {
            final Variables vars = varCtx.getVariables();
            if (vars.isDeclaredVariable(name.toString())) {
                return new VariablePointer(vars, name);
            }
            varCtx = varCtx.getParentContext();
        }
        // The variable is not declared, but we will create
        // a pointer anyway in case the user wants to set, rather
        // than get, the value of the variable.
        return new VariablePointer(name);
    }
    return null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(QName,Object,Locale).object","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(NodePointer,QName,Object)","Method","No Comment","@Override
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object object) {
    return createNodePointer(name, object, null);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(NodePointer,QName,Object).object","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.VariablePointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.getOrder()","Method","No Comment","@Override
public int getOrder() {
    return VARIABLE_POINTER_FACTORY_ORDER;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory$VariableContextWrapper","Class","* Node value wrapper to trigger a VariablePointerFactory.","Class do not obtain Source Code","No return type","public , static , final ","",""
"org.apache.commons.jxpath.ri.model.VariablePointerFactory$VariableContextWrapper.context","Field","No Comment","private final JXPathContext context;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory$VariableContextWrapper.getContext()","Method","* Gets the original (unwrapped) context.
         *
         * @return JXPathContext.","public JXPathContext getContext() {
    return context;
}","JXPathContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory$VariableContextWrapper.<init>(JXPathContext)","Constructor","* Create a new VariableContextWrapper.
         * @param context to wrap","private VariableContextWrapper(final JXPathContext context) {
    this.context = context;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory$VariableContextWrapper.<init>(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointerFactory$VariableContextWrapper.<init>(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.VariableContextWrapper","Class","* Node value wrapper to trigger a VariablePointerFactory.","Class do not obtain Source Code","No return type","public , static , final ","",""
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.VariableContextWrapper.context","Field","No Comment","private final JXPathContext context;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.VariableContextWrapper.getContext()","Method","* Gets the original (unwrapped) context.
         *
         * @return JXPathContext.","public JXPathContext getContext() {
    return context;
}","JXPathContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.VariableContextWrapper.<init>(JXPathContext)","Constructor","* Create a new VariableContextWrapper.
         * @param context to wrap","private VariableContextWrapper(final JXPathContext context) {
    this.context = context;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.VariablePointerFactory.VariableContextWrapper.<init>(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.VariablePointerFactory.VariableContextWrapper.<init>(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer","Class","* A Pointer that points to a DOM node.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.attr","Field","No Comment","private final Attribute attr;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 8896050354479644028L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.getName()","Method","No Comment","@Override
public QName getName() {
    return new QName(JDOMNodePointer.getPrefix(attr), JDOMNodePointer.getLocalName(attr));
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.getNamespaceURI()","Method","No Comment","@Override
public String getNamespaceURI() {
    String uri = attr.getNamespaceURI();
    if (uri != null && uri.isEmpty()) {
        uri = null;
    }
    return uri;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.getValue()","Method","No Comment","@Override
public Object getValue() {
    return attr.getValue();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return attr;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return attr;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.isActual()","Method","No Comment","@Override
public boolean isActual() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.setValue(Object)","Method","No Comment","@Override
public void setValue(final Object value) {
    attr.setValue((String) TypeUtils.convert(value, String.class));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.remove()","Method","No Comment","@Override
public void remove() {
    attr.getParent().removeAttribute(attr);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    final StringBuilder buffer = new StringBuilder();
    if (parent != null) {
        buffer.append(parent.asPath());
        if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') {
            buffer.append('/');
        }
    }
    buffer.append('@');
    buffer.append(getName());
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return System.identityHashCode(attr);
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    return object == this || object instanceof JDOMAttributePointer && ((JDOMAttributePointer) object).attr == attr;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    // Won't happen - attributes don't have children
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.<init>(NodePointer,Attribute)","Constructor","* Create a JDOMAttributePointer.
     * @param parent NodePointer parent
     * @param attr JDOM Attribute","public JDOMAttributePointer(final NodePointer parent, final Attribute attr) {
    super(parent);
    this.attr = attr;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.<init>(NodePointer,Attribute).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.<init>(NodePointer,Attribute)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.<init>(NodePointer,Attribute).attr","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer.<init>(NodePointer,Attribute)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer","Class","* A Pointer that points to a DOM node.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -6346532297491082651L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.node","Field","No Comment","private final Object node;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.id","Field","No Comment","private String id;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.localNamespaceResolver","Field","No Comment","private NamespaceResolver localNamespaceResolver;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.XML_NAMESPACE_URI","Field","XML ns uri","public static final String XML_NAMESPACE_URI = ""http://www.w3.org/XML/1998/namespace"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.XMLNS_NAMESPACE_URI","Field","XMLNS ns uri","public static final String XMLNS_NAMESPACE_URI = ""http://www.w3.org/2000/xmlns/"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.childIterator(NodeTest,boolean,NodePointer)","Method","No Comment","@Override
public NodeIterator childIterator(final NodeTest test, final boolean reverse, final NodePointer startWith) {
    return new JDOMNodeIterator(this, test, reverse, startWith);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.childIterator(NodeTest,boolean,NodePointer).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.childIterator(NodeTest,boolean,NodePointer).reverse","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.childIterator(NodeTest,boolean,NodePointer).startWith","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.childIterator(NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.attributeIterator(QName)","Method","No Comment","@Override
public NodeIterator attributeIterator(final QName name) {
    return new JDOMAttributeIterator(this, name);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.attributeIterator(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.attributeIterator(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.namespaceIterator()","Method","No Comment","@Override
public NodeIterator namespaceIterator() {
    return new JDOMNamespaceIterator(this);
}","NodeIterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.namespacePointer(String)","Method","No Comment","@Override
public NodePointer namespacePointer(final String prefix) {
    return new JDOMNamespacePointer(this, prefix);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.namespacePointer(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.namespacePointer(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getNamespaceURI()","Method","No Comment","@Override
public String getNamespaceURI() {
    return getNamespaceURI(node);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getNamespaceURI(Object)","Method","* Gets the ns uri of the specified node.
     * @param node Node to check
     * @return String","private static String getNamespaceURI(final Object node) {
    if (node instanceof Element) {
        final Element element = (Element) node;
        String ns = element.getNamespaceURI();
        if ("""".equals(ns)) {
            ns = null;
        }
        return ns;
    }
    return null;
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getNamespaceURI(Object).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getNamespaceURI(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getNamespaceResolver()","Method","No Comment","@Override
public synchronized NamespaceResolver getNamespaceResolver() {
    if (localNamespaceResolver == null) {
        localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());
        localNamespaceResolver.setNamespaceContextPointer(this);
    }
    return localNamespaceResolver;
}","NamespaceResolver","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getNamespaceURI(String)","Method","No Comment","@Override
public String getNamespaceURI(final String prefix) {
    if (prefix.equals(""xml"")) {
        return Namespace.XML_NAMESPACE.getURI();
    }
    Element element = null;
    if (node instanceof Document) {
        element = ((Document) node).getRootElement();
    }
    if (node instanceof Element) {
        element = (Element) node;
    }
    if (element == null) {
        return null;
    }
    final Namespace ns = element.getNamespace(prefix);
    return ns == null ? null : ns.getURI();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getNamespaceURI(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getNamespaceURI(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    final Object node1 = pointer1.getBaseValue();
    final Object node2 = pointer2.getBaseValue();
    if (node1 == node2) {
        return 0;
    }
    if (node1 instanceof Attribute && !(node2 instanceof Attribute)) {
        return -1;
    }
    if (!(node1 instanceof Attribute) && node2 instanceof Attribute) {
        return 1;
    }
    if (node1 instanceof Attribute && node2 instanceof Attribute) {
        final List list = ((Element) getNode()).getAttributes();
        final int length = list.size();
        for (int i = 0; i < length; i++) {
            final Object n = list.get(i);
            if (n == node1) {
                return -1;
            } else if (n == node2) {
                return 1;
            }
        }
        // Should not happen
        return 0;
    }
    if (!(node instanceof Element)) {
        throw new IllegalStateException(""JXPath internal error: "" + ""compareChildNodes called for "" + node);
    }
    final List children = ((Element) node).getContent();
    final int length = children.size();
    for (int i = 0; i < length; i++) {
        final Object n = children.get(i);
        if (n == node1) {
            return -1;
        }
        if (n == node2) {
            return 1;
        }
    }
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return node;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    if (node instanceof Element) {
        return ((Element) node).getContent().isEmpty();
    }
    if (node instanceof Document) {
        return ((Document) node).getContent().isEmpty();
    }
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getName()","Method","No Comment","@Override
public QName getName() {
    String ns = null;
    String ln = null;
    if (node instanceof Element) {
        ns = ((Element) node).getNamespacePrefix();
        if (ns != null && ns.isEmpty()) {
            ns = null;
        }
        ln = ((Element) node).getName();
    } else if (node instanceof ProcessingInstruction) {
        ln = ((ProcessingInstruction) node).getTarget();
    }
    return new QName(ns, ln);
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return node;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getValue()","Method","No Comment","@Override
public Object getValue() {
    if (node instanceof Element) {
        final StringBuilder buf = new StringBuilder();
        for (final NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1); ) {
            final NodePointer ptr = children.getNodePointer();
            if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) {
                buf.append(ptr.getValue());
            }
        }
        return buf.toString();
    }
    if (node instanceof Comment) {
        String text = ((Comment) node).getText();
        if (text != null) {
            text = text.trim();
        }
        return text;
    }
    String result = null;
    if (node instanceof Text) {
        result = ((Text) node).getText();
    }
    if (node instanceof ProcessingInstruction) {
        result = ((ProcessingInstruction) node).getData();
    }
    final boolean trim = !""preserve"".equals(findEnclosingAttribute(node, ""space"", Namespace.XML_NAMESPACE));
    return result != null && trim ? result.trim() : result;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.setValue(Object)","Method","No Comment","@Override
public void setValue(final Object value) {
    if (node instanceof Text) {
        final String string = (String) TypeUtils.convert(value, String.class);
        if (string != null && !string.isEmpty()) {
            ((Text) node).setText(string);
        } else {
            nodeParent(node).removeContent((Text) node);
        }
    } else {
        final Element element = (Element) node;
        element.getContent().clear();
        if (value instanceof Element) {
            final Element valueElement = (Element) value;
            addContent(valueElement.getContent());
        } else if (value instanceof Document) {
            final Document valueDocument = (Document) value;
            addContent(valueDocument.getContent());
        } else if (value instanceof Text || value instanceof CDATA) {
            final String string = ((Text) value).getText();
            element.addContent(new Text(string));
        } else if (value instanceof ProcessingInstruction) {
            final ProcessingInstruction pi = (ProcessingInstruction) ((ProcessingInstruction) value).clone();
            element.addContent(pi);
        } else if (value instanceof Comment) {
            final Comment comment = (Comment) ((Comment) value).clone();
            element.addContent(comment);
        } else {
            final String string = (String) TypeUtils.convert(value, String.class);
            if (string != null && !string.isEmpty()) {
                element.addContent(new Text(string));
            }
        }
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.addContent(List)","Method","* Add the specified content to this element.
     * @param content List","private void addContent(final List content) {
    final Element element = (Element) node;
    final int count = content.size();
    for (int i = 0; i < count; i++) {
        Object child = content.get(i);
        if (child instanceof Element) {
            child = ((Element) child).clone();
            element.addContent((Element) child);
        } else if (child instanceof Text) {
            child = ((Text) child).clone();
            element.addContent((Text) child);
        } else if (node instanceof CDATA) {
            child = ((CDATA) child).clone();
            element.addContent((CDATA) child);
        } else if (node instanceof ProcessingInstruction) {
            child = ((ProcessingInstruction) child).clone();
            element.addContent((ProcessingInstruction) child);
        } else if (node instanceof Comment) {
            child = ((Comment) child).clone();
            element.addContent((Comment) child);
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.addContent(List).content","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.addContent(List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodeTest)","Method","No Comment","@Override
public boolean testNode(final NodeTest test) {
    return testNode(this, node, test);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodeTest).test","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodePointer,Object,NodeTest)","Method","* Execute test against node on behalf of pointer.
     * @param pointer Pointer
     * @param node to test
     * @param test to execute
     * @return true if node passes test","public static boolean testNode(final NodePointer pointer, final Object node, final NodeTest test) {
    if (test == null) {
        return true;
    }
    if (test instanceof NodeNameTest) {
        if (!(node instanceof Element)) {
            return false;
        }
        final NodeNameTest nodeNameTest = (NodeNameTest) test;
        final QName testName = nodeNameTest.getNodeName();
        final String namespaceURI = nodeNameTest.getNamespaceURI();
        final boolean wildcard = nodeNameTest.isWildcard();
        final String testPrefix = testName.getPrefix();
        if (wildcard && testPrefix == null) {
            return true;
        }
        if (wildcard || testName.getName().equals(getLocalName(node))) {
            final String nodeNS = getNamespaceURI(node);
            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));
        }
        return false;
    }
    if (test instanceof NodeTypeTest) {
        switch(((NodeTypeTest) test).getNodeType()) {
            case Compiler.NODE_TYPE_NODE:
                return true;
            case Compiler.NODE_TYPE_TEXT:
                return node instanceof Text || node instanceof CDATA;
            case Compiler.NODE_TYPE_COMMENT:
                return node instanceof Comment;
            case Compiler.NODE_TYPE_PI:
                return node instanceof ProcessingInstruction;
            default:
                return false;
        }
    }
    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {
        final String testPI = ((ProcessingInstructionTest) test).getTarget();
        final String nodePI = ((ProcessingInstruction) node).getTarget();
        return testPI.equals(nodePI);
    }
    return false;
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodePointer,Object,NodeTest).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodePointer,Object,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodePointer,Object,NodeTest).node","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodePointer,Object,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodePointer,Object,NodeTest).test","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.testNode(NodePointer,Object,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.equalStrings(String,String)","Method","* Learn whether two strings are == or .equals()
     * @param s1 string 1
     * @param s2 string 2
     * @return true if equal","private static boolean equalStrings(String s1, String s2) {
    if (s1 == s2) {
        return true;
    }
    s1 = s1 == null ? """" : s1.trim();
    s2 = s2 == null ? """" : s2.trim();
    return s1.equals(s2);
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.equalStrings(String,String).s1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.equalStrings(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.equalStrings(String,String).s2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.equalStrings(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getPrefix(Object)","Method","* Gets the prefix from a given node.
     * @param node to check
     * @return String","public static String getPrefix(final Object node) {
    if (node instanceof Element) {
        final String prefix = ((Element) node).getNamespacePrefix();
        return prefix == null || prefix.isEmpty() ? null : prefix;
    }
    if (node instanceof Attribute) {
        final String prefix = ((Attribute) node).getNamespacePrefix();
        return prefix == null || prefix.isEmpty() ? null : prefix;
    }
    return null;
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getPrefix(Object).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getPrefix(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getLocalName(Object)","Method","* Gets the local name of the specified node.
     * @param node to check
     * @return String local name","public static String getLocalName(final Object node) {
    if (node instanceof Element) {
        return ((Element) node).getName();
    }
    if (node instanceof Attribute) {
        return ((Attribute) node).getName();
    }
    return null;
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getLocalName(Object).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getLocalName(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.isLanguage(String)","Method","* Returns true if the xml:lang attribute for the current node
     * or its parent has the specified prefix <em>lang</em>.
     * If no node has this prefix, calls {@code super.isLanguage(lang)}.
     * @param lang to compare
     * @return true if this element uses the specified language.","@Override
public boolean isLanguage(final String lang) {
    final String current = getLanguage();
    return current == null ? super.isLanguage(lang) : current.toUpperCase(Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.isLanguage(String).lang","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.isLanguage(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getLanguage()","Method","* Gets the language of this element.
     * @return String language","protected String getLanguage() {
    return findEnclosingAttribute(node, ""lang"", Namespace.XML_NAMESPACE);
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.findEnclosingAttribute(Object,String,Namespace)","Method","* Find the nearest occurrence of the specified attribute
     * on the specified and enclosing elements.
     * @param n current node
     * @param attrName attribute name
     * @param ns Namespace
     * @return attribute value","protected static String findEnclosingAttribute(Object n, final String attrName, final Namespace ns) {
    while (n != null) {
        if (n instanceof Element) {
            final Element e = (Element) n;
            final String attr = e.getAttributeValue(attrName, ns);
            if (attr != null && !attr.isEmpty()) {
                return attr;
            }
        }
        n = nodeParent(n);
    }
    return null;
}","String","protected , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.findEnclosingAttribute(Object,String,Namespace).n","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.findEnclosingAttribute(Object,String,Namespace)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.findEnclosingAttribute(Object,String,Namespace).attrName","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.findEnclosingAttribute(Object,String,Namespace)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.findEnclosingAttribute(Object,String,Namespace).ns","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.findEnclosingAttribute(Object,String,Namespace)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.nodeParent(Object)","Method","* Gets the parent of the specified node.
     * @param node to check
     * @return parent Element","private static Element nodeParent(final Object node) {
    if (node instanceof Element) {
        final Object parent = ((Element) node).getParent();
        return parent instanceof Element ? (Element) parent : null;
    }
    if (node instanceof Text) {
        return (Element) ((Text) node).getParent();
    }
    if (node instanceof CDATA) {
        return (Element) ((CDATA) node).getParent();
    }
    if (node instanceof ProcessingInstruction) {
        return (Element) ((ProcessingInstruction) node).getParent();
    }
    if (node instanceof Comment) {
        return (Element) ((Comment) node).getParent();
    }
    return null;
}","Element","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.nodeParent(Object).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.nodeParent(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, int index) {
    if (index == WHOLE_COLLECTION) {
        index = 0;
    }
    final boolean success = getAbstractFactory(context).createObject(context, this, node, name.toString(), index);
    if (success) {
        NodeTest nodeTest;
        final String prefix = name.getPrefix();
        final String namespaceURI = prefix == null ? null : context.getNamespaceURI(prefix);
        nodeTest = new NodeNameTest(name, namespaceURI);
        final NodeIterator it = childIterator(nodeTest, false, null);
        if (it != null && it.setPosition(index + 1)) {
            return it.getNodePointer();
        }
    }
    throw new JXPathAbstractFactoryException(""Factory could not create "" + ""a child node for path: "" + asPath() + ""/"" + name + ""["" + (index + 1) + ""]"");
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int,Object)","Method","No Comment","@Override
public NodePointer createChild(final JXPathContext context, final QName name, final int index, final Object value) {
    final NodePointer ptr = createChild(context, name, index);
    ptr.setValue(value);
    return ptr;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int,Object).index","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int,Object).value","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createChild(JXPathContext,QName,int,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createAttribute(JXPathContext,QName)","Method","No Comment","@Override
public NodePointer createAttribute(final JXPathContext context, final QName name) {
    if (!(node instanceof Element)) {
        return super.createAttribute(context, name);
    }
    final Element element = (Element) node;
    final String prefix = name.getPrefix();
    if (prefix != null) {
        final String namespaceUri = getNamespaceResolver().getNamespaceURI(prefix);
        if (namespaceUri == null) {
            throw new JXPathException(""Unknown namespace prefix: "" + prefix);
        }
        final Namespace ns = Namespace.getNamespace(prefix, namespaceUri);
        final Attribute attr = element.getAttribute(name.getName(), ns);
        if (attr == null) {
            element.setAttribute(name.getName(), """", ns);
        }
    } else {
        final Attribute attr = element.getAttribute(name.getName());
        if (attr == null) {
            element.setAttribute(name.getName(), """");
        }
    }
    final NodeIterator it = attributeIterator(name);
    it.setPosition(1);
    return it.getNodePointer();
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createAttribute(JXPathContext,QName).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createAttribute(JXPathContext,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createAttribute(JXPathContext,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.createAttribute(JXPathContext,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.remove()","Method","No Comment","@Override
public void remove() {
    final Element parent = nodeParent(node);
    if (parent == null) {
        throw new JXPathException(""Cannot remove root JDOM node"");
    }
    parent.getContent().remove(node);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    if (id != null) {
        return ""id('"" + escape(id) + ""')"";
    }
    final StringBuilder buffer = new StringBuilder();
    if (parent != null) {
        buffer.append(parent.asPath());
    }
    if (node instanceof Element) {
        // If the parent pointer is not a JDOMNodePointer, it is
        // the parent's responsibility to produce the node test part
        // of the path
        if (parent instanceof JDOMNodePointer) {
            if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') {
                buffer.append('/');
            }
            final String nsURI = getNamespaceURI();
            final String ln = getLocalName(node);
            if (nsURI == null) {
                buffer.append(ln);
                buffer.append('[');
                buffer.append(getRelativePositionByQName()).append(']');
            } else {
                final String prefix = getNamespaceResolver().getPrefix(nsURI);
                if (prefix != null) {
                    buffer.append(prefix);
                    buffer.append(':');
                    buffer.append(ln);
                    buffer.append('[');
                    buffer.append(getRelativePositionByQName());
                } else {
                    buffer.append(""node()"");
                    buffer.append('[');
                    buffer.append(getRelativePositionOfElement());
                }
                buffer.append(']');
            }
        }
    } else if (node instanceof Text || node instanceof CDATA) {
        buffer.append(""/text()"");
        buffer.append('[').append(getRelativePositionOfTextNode()).append(']');
    } else if (node instanceof ProcessingInstruction) {
        buffer.append(""/processing-instruction(\'"").append(((ProcessingInstruction) node).getTarget()).append(""')"");
        buffer.append('[').append(getRelativePositionOfPI()).append(']');
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getRelativePositionByQName()","Method","* Gets relative position of this among like-named siblings.
     * @return 1..n","private int getRelativePositionByQName() {
    if (node instanceof Element) {
        final Object parent = ((Element) node).getParent();
        if (!(parent instanceof Element)) {
            return 1;
        }
        final List children = ((Element) parent).getContent();
        int count = 0;
        for (final Object child : children) {
            if (child instanceof Element && matchesQName((Element) child)) {
                count++;
            }
            if (child == node) {
                break;
            }
        }
        return count;
    }
    return 1;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.matchesQName(Element)","Method","No Comment","private boolean matchesQName(final Element element) {
    if (getNamespaceURI() != null) {
        final String ns = getNamespaceURI(element);
        if (ns == null || !ns.equals(getNamespaceURI())) {
            return false;
        }
    }
    return element.getName().equals(((Element) node).getName());
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.matchesQName(Element).element","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.matchesQName(Element)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getRelativePositionOfElement()","Method","* Gets relative position of this among all siblings.
     * @return 1..n","private int getRelativePositionOfElement() {
    final Object parent = ((Element) node).getParent();
    if (parent == null) {
        return 1;
    }
    List children;
    if (parent instanceof Element) {
        children = ((Element) parent).getContent();
    } else {
        children = ((Document) parent).getContent();
    }
    int count = 0;
    for (final Object child : children) {
        if (child instanceof Element) {
            count++;
        }
        if (child == node) {
            break;
        }
    }
    return count;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getRelativePositionOfTextNode()","Method","* Gets the relative position of this among sibling text nodes.
     * @return 1..n","private int getRelativePositionOfTextNode() {
    Element parent;
    if (node instanceof Text) {
        parent = (Element) ((Text) node).getParent();
    } else {
        parent = (Element) ((CDATA) node).getParent();
    }
    if (parent == null) {
        return 1;
    }
    final List children = parent.getContent();
    int count = 0;
    for (final Object child : children) {
        if (child instanceof Text || child instanceof CDATA) {
            count++;
        }
        if (child == node) {
            break;
        }
    }
    return count;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.getRelativePositionOfPI()","Method","* Gets the relative position of this among same-target processing instruction siblings.
     * @return 1..n","private int getRelativePositionOfPI() {
    final String target = ((ProcessingInstruction) node).getTarget();
    final Element parent = (Element) ((ProcessingInstruction) node).getParent();
    if (parent == null) {
        return 1;
    }
    final List children = parent.getContent();
    int count = 0;
    for (final Object child : children) {
        if (child instanceof ProcessingInstruction && (target == null || target.equals(((ProcessingInstruction) child).getTarget()))) {
            count++;
        }
        if (child == node) {
            break;
        }
    }
    return count;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return node.hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (object == this) {
        return true;
    }
    if (!(object instanceof JDOMNodePointer)) {
        return false;
    }
    final JDOMNodePointer other = (JDOMNodePointer) object;
    return node == other.node;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale)","Constructor","* Create a new JDOMNodePointer.
     * @param node pointed
     * @param locale Locale","public JDOMNodePointer(final Object node, final Locale locale) {
    super(null, locale);
    this.node = node;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale).locale","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale,String)","Constructor","* Create a new JDOMNodePointer.
     * @param node pointed
     * @param locale Locale
     * @param id String id","public JDOMNodePointer(final Object node, final Locale locale, final String id) {
    super(null, locale);
    this.node = node;
    this.id = id;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale,String).node","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale,String).locale","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale,String).id","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(Object,Locale,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(NodePointer,Object)","Constructor","* Create a new JDOMNodePointer.
     * @param parent NodePointer
     * @param node pointed","public JDOMNodePointer(final NodePointer parent, final Object node) {
    super(parent);
    this.node = node;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(NodePointer,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(NodePointer,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(NodePointer,Object).node","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer.<init>(NodePointer,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator","Class","* An iterator of attributes of a DOM Node.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodeIterator"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.parent","Field","No Comment","private NodePointer parent;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.attributes","Field","No Comment","private List attributes;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.position","Field","No Comment","private int position = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.getNodePointer()","Method","No Comment","@Override
public NodePointer getNodePointer() {
    if (position == 0) {
        if (!setPosition(1)) {
            return null;
        }
        position = 0;
    }
    int index = position - 1;
    if (index < 0) {
        index = 0;
    }
    return new JDOMAttributePointer(parent, (Attribute) attributes.get(index));
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (attributes == null) {
        return false;
    }
    this.position = position;
    return position >= 1 && position <= attributes.size();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.<init>(NodePointer,QName)","Constructor","* Create a new JDOMAttributeIterator.
     * @param parent pointer
     * @param name test","public JDOMAttributeIterator(final NodePointer parent, final QName name) {
    this.parent = parent;
    if (parent.getNode() instanceof Element) {
        final Element element = (Element) parent.getNode();
        final String prefix = name.getPrefix();
        Namespace ns = null;
        if (prefix != null) {
            if (prefix.equals(""xml"")) {
                ns = Namespace.XML_NAMESPACE;
            } else {
                final String uri = parent.getNamespaceResolver().getNamespaceURI(prefix);
                if (uri != null) {
                    ns = Namespace.getNamespace(prefix, uri);
                }
                if (ns == null) {
                    // TBD: no attributes
                    attributes = Collections.EMPTY_LIST;
                    return;
                }
            }
        } else {
            ns = Namespace.NO_NAMESPACE;
        }
        final String lname = name.getName();
        if (!lname.equals(""*"")) {
            attributes = new ArrayList();
            final Attribute attr = element.getAttribute(lname, ns);
            if (attr != null) {
                attributes.add(attr);
            }
        } else {
            attributes = new ArrayList();
            final List allAttributes = element.getAttributes();
            for (int i = 0; i < allAttributes.size(); i++) {
                final Attribute attr = (Attribute) allAttributes.get(i);
                if (ns == Namespace.NO_NAMESPACE || attr.getNamespace().equals(ns)) {
                    attributes.add(attr);
                }
            }
        }
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.<init>(NodePointer,QName).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.<init>(NodePointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.<init>(NodePointer,QName).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator.<init>(NodePointer,QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer","Class","* Represents a namespace node.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.model.NodePointer",""
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.prefix","Field","No Comment","private final String prefix;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.namespaceURI","Field","No Comment","private String namespaceURI;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 7935311686545862379L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.getName()","Method","No Comment","@Override
public QName getName() {
    return new QName(prefix);
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.getBaseValue()","Method","No Comment","@Override
public Object getBaseValue() {
    return null;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.isCollection()","Method","No Comment","@Override
public boolean isCollection() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.getLength()","Method","No Comment","@Override
public int getLength() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.getImmediateNode()","Method","No Comment","@Override
public Object getImmediateNode() {
    return getNamespaceURI();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.getNamespaceURI()","Method","No Comment","@Override
public String getNamespaceURI() {
    if (namespaceURI == null) {
        namespaceURI = parent.getNamespaceURI(prefix);
    }
    return namespaceURI;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.isLeaf()","Method","No Comment","@Override
public boolean isLeaf() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.setValue(Object)","Method","* Throws UnsupportedOperationException.
     * @param value Object value to set","@Override
public void setValue(final Object value) {
    throw new UnsupportedOperationException(""Cannot modify a namespace"");
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.asPath()","Method","No Comment","@Override
public String asPath() {
    final StringBuilder buffer = new StringBuilder();
    if (parent != null) {
        buffer.append(parent.asPath());
        if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') {
            buffer.append('/');
        }
    }
    buffer.append(""namespace::"");
    buffer.append(prefix);
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return prefix.hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    return object == this || object instanceof JDOMNamespacePointer && prefix.equals(((JDOMNamespacePointer) object).prefix);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.compareChildNodePointers(NodePointer,NodePointer)","Method","No Comment","@Override
public int compareChildNodePointers(final NodePointer pointer1, final NodePointer pointer2) {
    // Won't happen - namespaces don't have children
    return 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.compareChildNodePointers(NodePointer,NodePointer).pointer1","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.compareChildNodePointers(NodePointer,NodePointer).pointer2","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.compareChildNodePointers(NodePointer,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String)","Constructor","* Create a new JDOMNamespacePointer.
     * @param parent parent pointer
     * @param prefix ns prefix","public JDOMNamespacePointer(final NodePointer parent, final String prefix) {
    super(parent);
    this.prefix = prefix;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String).prefix","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String,String)","Constructor","* Create a new JDOMNamespacePointer.
     * @param parent parent pointer
     * @param prefix ns prefix
     * @param namespaceURI ns URI","public JDOMNamespacePointer(final NodePointer parent, final String prefix, final String namespaceURI) {
    super(parent);
    this.prefix = prefix;
    this.namespaceURI = namespaceURI;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String,String).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String,String).prefix","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String,String).namespaceURI","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer.<init>(NodePointer,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator","Class","* An iterator of namespaces of a DOM Node.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodeIterator"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.parent","Field","No Comment","private final NodePointer parent;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.namespaces","Field","No Comment","private List namespaces;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.prefixes","Field","No Comment","private Set prefixes;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.position","Field","No Comment","private int position = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.collectNamespaces(Element)","Method","* Collect the namespaces from a JDOM Element.
     * @param element the source Element","private void collectNamespaces(final Element element) {
    Namespace ns = element.getNamespace();
    if (ns != null && !prefixes.contains(ns.getPrefix())) {
        namespaces.add(ns);
        prefixes.add(ns.getPrefix());
    }
    final List others = element.getAdditionalNamespaces();
    for (int i = 0; i < others.size(); i++) {
        ns = (Namespace) others.get(i);
        if (ns != null && !prefixes.contains(ns.getPrefix())) {
            namespaces.add(ns);
            prefixes.add(ns.getPrefix());
        }
    }
    final Object elementParent = element.getParent();
    if (elementParent instanceof Element) {
        collectNamespaces((Element) elementParent);
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.collectNamespaces(Element).element","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.collectNamespaces(Element)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.getNodePointer()","Method","No Comment","@Override
public NodePointer getNodePointer() {
    if (position == 0) {
        if (!setPosition(1)) {
            return null;
        }
        position = 0;
    }
    int index = position - 1;
    if (index < 0) {
        index = 0;
    }
    final Namespace ns = (Namespace) namespaces.get(index);
    return new JDOMNamespacePointer(parent, ns.getPrefix(), ns.getURI());
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    if (namespaces == null) {
        return false;
    }
    this.position = position;
    return position >= 1 && position <= namespaces.size();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.<init>(NodePointer)","Constructor","* Create a new JDOMNamespaceIterator.
     * @param parent the parent NodePointer.","public JDOMNamespaceIterator(final NodePointer parent) {
    this.parent = parent;
    Object node = parent.getNode();
    if (node instanceof Document) {
        node = ((Document) node).getRootElement();
    }
    if (node instanceof Element) {
        namespaces = new ArrayList();
        prefixes = new HashSet();
        collectNamespaces((Element) node);
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.<init>(NodePointer).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator.<init>(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory","Class","* Implements NodePointerFactory for DOM elements.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodePointerFactory"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.JDOM_POINTER_FACTORY_ORDER","Field","Factory order constant","public static final int JDOM_POINTER_FACTORY_ORDER = 110;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.getOrder()","Method","No Comment","@Override
public int getOrder() {
    return JDOM_POINTER_FACTORY_ORDER;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(QName,Object,Locale)","Method","No Comment","@Override
public NodePointer createNodePointer(final QName name, final Object bean, final Locale locale) {
    if (bean instanceof Document) {
        return new JDOMNodePointer(bean, locale);
    }
    if (bean instanceof Element) {
        return new JDOMNodePointer(bean, locale);
    }
    return null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(QName,Object,Locale).bean","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(NodePointer,QName,Object)","Method","No Comment","@Override
public NodePointer createNodePointer(final NodePointer parent, final QName name, final Object bean) {
    if (bean instanceof Document) {
        return new JDOMNodePointer(parent, bean);
    }
    if (bean instanceof Element) {
        return new JDOMNodePointer(parent, bean);
    }
    return null;
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(NodePointer,QName,Object).bean","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator","Class","* An iterator of children of a JDOM Node.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.model.NodeIterator"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.parent","Field","No Comment","private final NodePointer parent;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.reverse","Field","No Comment","private final boolean reverse;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.position","Field","No Comment","private int position = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.index","Field","No Comment","private int index = 0;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.children","Field","No Comment","private List children;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.child","Field","No Comment","private Object child;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.getNodePointer()","Method","No Comment","@Override
public NodePointer getNodePointer() {
    if (child == null) {
        if (!setPosition(1)) {
            return null;
        }
        position = 0;
    }
    return new JDOMNodePointer(parent, child);
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.setPosition(int)","Method","No Comment","@Override
public boolean setPosition(final int position) {
    while (this.position < position) {
        if (!next()) {
            return false;
        }
    }
    while (this.position > position) {
        if (!previous()) {
            return false;
        }
    }
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.previous()","Method","* This is actually never invoked during the normal evaluation
     * of xpaths - an iterator is always going forward, never backwards.
     * So, this is implemented only for completeness and perhaps for
     * those who use these iterators outside of XPath evaluation.
     * @return boolean","private boolean previous() {
    position--;
    if (!reverse) {
        while (--index >= 0) {
            child = children.get(index);
            if (testChild()) {
                return true;
            }
        }
    } else {
        for (; index < children.size(); index++) {
            child = children.get(index);
            if (testChild()) {
                return true;
            }
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.next()","Method","* Iterate to next pointer.
     * @return whether valid","private boolean next() {
    position++;
    if (!reverse) {
        if (position == 1) {
            index = 0;
            if (child != null) {
                index = children.indexOf(child) + 1;
            }
        } else {
            index++;
        }
        for (; index < children.size(); index++) {
            child = children.get(index);
            if (testChild()) {
                return true;
            }
        }
        return false;
    }
    if (position == 1) {
        index = children.size() - 1;
        if (child != null) {
            index = children.indexOf(child) - 1;
        }
    } else {
        index--;
    }
    for (; index >= 0; index--) {
        child = children.get(index);
        if (testChild()) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.testChild()","Method","* Test a child node.
     * @return whether test passes.","private boolean testChild() {
    return JDOMNodePointer.testNode(parent, child, nodeTest);
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Constructor","* Create a new JDOMNodeIterator.
     * @param parent pointer
     * @param nodeTest test
     * @param reverse whether to iterate in reverse
     * @param startWith starting pointer","public JDOMNodeIterator(final NodePointer parent, final NodeTest nodeTest, final boolean reverse, final NodePointer startWith) {
    this.parent = parent;
    if (startWith != null) {
        this.child = startWith.getNode();
    }
    // TBD: optimize me for different node tests
    final Object node = parent.getNode();
    if (node instanceof Document) {
        this.children = ((Document) node).getContent();
    } else if (node instanceof Element) {
        this.children = ((Element) node).getContent();
    } else {
        this.children = Collections.EMPTY_LIST;
    }
    this.nodeTest = nodeTest;
    this.reverse = reverse;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer).reverse","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer).startWith","Parameter_4","Belong to org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator.<init>(NodePointer,NodeTest,boolean,NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointerFactory","Interface","* Creates NodePointers for objects of a certain type.
 * NodePointerFactories are ordered according to the values returned
 * by the ""getOrder"" method and always queried in that order.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.model.NodePointerFactory.getOrder()","Abstract Method","* The factory order number determines its position between other factories.
     * @return int order","int getOrder();","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(QName,Object,Locale)","Abstract Method","* Create a NodePointer for the supplied object.  The node will represent
     * the ""root"" object for a path.
     *
     * @param name String node name
     * @param object child object
     * @param locale Locale
     * @return  null if this factory does not recognize objects of the supplied
     * type.","NodePointer createNodePointer(QName name, Object object, Locale locale);","NodePointer","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(QName,Object,Locale).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(QName,Object,Locale).object","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(QName,Object,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(QName,Object,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(NodePointer,QName,Object)","Abstract Method","* Create a NodePointer for the supplied child object.
     *
     * @param parent parent node
     * @param name String node name
     * @param object child object
     * @return null if this factory does not recognize objects of the supplied
     * type.","NodePointer createNodePointer(NodePointer parent, QName name, Object object);","NodePointer","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(NodePointer,QName,Object).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(NodePointer,QName,Object).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(NodePointer,QName,Object).object","Parameter_3","Belong to org.apache.commons.jxpath.ri.model.NodePointerFactory.createNodePointer(NodePointer,QName,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName","Class","* A qualified name: a combination of an optional namespace prefix
 * and an local name.","Class do not obtain Source Code","No return type","public ","","java.io.Serializable"
"org.apache.commons.jxpath.ri.QName.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 7616199282015091496L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.prefix","Field","No Comment","private final String prefix;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.name","Field","No Comment","private final String name;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.qualifiedName","Field","No Comment","private final String qualifiedName;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.getPrefix()","Method","* Gets the prefix of this QName.
     * @return String","public String getPrefix() {
    return prefix;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.getName()","Method","* Gets the local name.
     * @return String","public String getName() {
    return name;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.toString()","Method","No Comment","@Override
public String toString() {
    return qualifiedName;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return name.hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object object) {
    if (this == object) {
        return true;
    }
    if (!(object instanceof QName)) {
        return false;
    }
    return qualifiedName.equals(((QName) object).qualifiedName);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.equals(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.QName.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.<init>(String)","Constructor","* Create a new QName.
     * @param qualifiedName value","public QName(final String qualifiedName) {
    this.qualifiedName = qualifiedName;
    final int index = qualifiedName.indexOf(':');
    prefix = index < 0 ? null : qualifiedName.substring(0, index);
    name = index < 0 ? qualifiedName : qualifiedName.substring(index + 1);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.<init>(String).qualifiedName","Parameter_1","Belong to org.apache.commons.jxpath.ri.QName.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.<init>(String,String)","Constructor","* Create a new QName.
     * @param prefix ns
     * @param localName String","public QName(final String prefix, final String localName) {
    this.prefix = prefix;
    this.name = localName;
    this.qualifiedName = prefix == null ? localName : prefix + ':' + localName;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.<init>(String,String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.QName.<init>(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.QName.<init>(String,String).localName","Parameter_2","Belong to org.apache.commons.jxpath.ri.QName.<init>(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil","Class","* Type conversions, XPath style.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.InfoSetUtil.ZERO","Field","No Comment","private static final Double ZERO = Double.valueOf(0);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.ONE","Field","No Comment","private static final Double ONE = Double.valueOf(1);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.NOT_A_NUMBER","Field","No Comment","private static final Double NOT_A_NUMBER = Double.valueOf(Double.NaN);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.stringValue(Object)","Method","* Converts the supplied object to String.
     * @param object to convert
     * @return String value","public static String stringValue(final Object object) {
    if (object instanceof String) {
        return (String) object;
    }
    if (object instanceof Number) {
        final double d = ((Number) object).doubleValue();
        final long l = ((Number) object).longValue();
        return d == l ? String.valueOf(l) : String.valueOf(d);
    }
    if (object instanceof Boolean) {
        return ((Boolean) object).booleanValue() ? ""true"" : ""false"";
    }
    if (object == null) {
        return """";
    }
    if (object instanceof NodePointer) {
        return stringValue(((NodePointer) object).getValue());
    }
    if (object instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) object;
        final Pointer ptr = ctx.getSingleNodePointer();
        return ptr == null ? """" : stringValue(ptr);
    }
    return String.valueOf(object);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.stringValue(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.InfoSetUtil.stringValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.number(Object)","Method","* Converts the supplied object to Number.
     * @param object to convert
     * @return Number result","public static Number number(final Object object) {
    if (object instanceof Number) {
        return (Number) object;
    }
    if (object instanceof Boolean) {
        return ((Boolean) object).booleanValue() ? ONE : ZERO;
    }
    if (object instanceof String) {
        try {
            return Double.valueOf((String) object);
        } catch (final NumberFormatException ex) {
            return NOT_A_NUMBER;
        }
    }
    if (object instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) object;
        final Pointer ptr = ctx.getSingleNodePointer();
        return ptr == null ? NOT_A_NUMBER : number(ptr);
    }
    if (object instanceof NodePointer) {
        return number(((NodePointer) object).getValue());
    }
    return number(stringValue(object));
}","Number","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.number(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.InfoSetUtil.number(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(Object)","Method","* Converts the supplied object to double.
     * @param object to convert
     * @return double","public static double doubleValue(final Object object) {
    if (object instanceof Number) {
        return ((Number) object).doubleValue();
    }
    if (object instanceof Boolean) {
        return ((Boolean) object).booleanValue() ? 0.0 : 1.0;
    }
    if (object instanceof String) {
        if (object.equals("""")) {
            return 0.0;
        }
        try {
            return Double.parseDouble((String) object);
        } catch (final NumberFormatException ex) {
            return Double.NaN;
        }
    }
    if (object instanceof NodePointer) {
        return doubleValue(((NodePointer) object).getValue());
    }
    if (object instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) object;
        final Pointer ptr = ctx.getSingleNodePointer();
        return ptr == null ? Double.NaN : doubleValue(ptr);
    }
    return doubleValue(stringValue(object));
}","double","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.booleanValue(Object)","Method","* Converts the supplied object to boolean.
     * @param object to convert
     * @return boolean","public static boolean booleanValue(final Object object) {
    if (object instanceof Number) {
        final double value = ((Number) object).doubleValue();
        final int negZero = -0;
        return value != 0 && value != negZero && !Double.isNaN(value);
    }
    if (object instanceof Boolean) {
        return ((Boolean) object).booleanValue();
    }
    if (object instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) object;
        final Pointer ptr = ctx.getSingleNodePointer();
        return ptr != null && booleanValue(ptr);
    }
    if (object instanceof String) {
        return ((String) object).length() != 0;
    }
    if (object instanceof NodePointer) {
        NodePointer pointer = (NodePointer) object;
        if (pointer instanceof VariablePointer) {
            return booleanValue(pointer.getNode());
        }
        pointer = pointer.getValuePointer();
        return pointer.isActual();
    }
    return object != null;
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.InfoSetUtil.booleanValue(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.InfoSetUtil.booleanValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver","Class","* Namespace resolver for {@link JXPathContextReferenceImpl}.","Class do not obtain Source Code","No return type","public ","","java.lang.Cloneable;java.io.Serializable"
"org.apache.commons.jxpath.ri.NamespaceResolver.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1085590057838651311L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.parent","Field","Parent NamespaceResolver","protected final NamespaceResolver parent;","No return type","protected , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.namespaceMap","Field","Namespace map","protected HashMap namespaceMap = new HashMap();","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.reverseMap","Field","Reverse lookup map","protected HashMap reverseMap = new HashMap();","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.pointer","Field","Pointer","protected NodePointer pointer;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.sealed","Field","No Comment","private boolean sealed;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(NodePointer,String)","Method","* Find the namespace prefix for the specified namespace URI and NodePointer.
     * @param pointer location
     * @param namespaceURI to check
     * @return prefix if found
     * @since JXPath 1.3","protected static String getPrefix(final NodePointer pointer, final String namespaceURI) {
    NodePointer currentPointer = pointer;
    while (currentPointer != null) {
        final NodeIterator ni = currentPointer.namespaceIterator();
        for (int position = 1; ni != null && ni.setPosition(position); position++) {
            final NodePointer nsPointer = ni.getNodePointer();
            final String uri = nsPointer.getNamespaceURI();
            if (uri.equals(namespaceURI)) {
                final String prefix = nsPointer.getName().getName();
                if (!"""".equals(prefix)) {
                    return prefix;
                }
            }
        }
        currentPointer = currentPointer.getParent();
    }
    return null;
}","String","protected , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(NodePointer,String).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(NodePointer,String).namespaceURI","Parameter_2","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(NodePointer,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.registerNamespace(String,String)","Method","* Registers a namespace prefix.
     *
     * @param prefix A namespace prefix
     * @param namespaceURI A URI for that prefix","public synchronized void registerNamespace(final String prefix, final String namespaceURI) {
    if (isSealed()) {
        throw new IllegalStateException(""Cannot register namespaces on a sealed NamespaceResolver"");
    }
    namespaceMap.put(prefix, namespaceURI);
    reverseMap.put(namespaceURI, prefix);
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.registerNamespace(String,String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.registerNamespace(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.registerNamespace(String,String).namespaceURI","Parameter_2","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.registerNamespace(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.setNamespaceContextPointer(NodePointer)","Method","* Register a namespace for the expression context.
     * @param pointer the Pointer to set.","public void setNamespaceContextPointer(final NodePointer pointer) {
    this.pointer = pointer;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.setNamespaceContextPointer(NodePointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.setNamespaceContextPointer(NodePointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getNamespaceContextPointer()","Method","* Gets the namespace context pointer.
     * @return Pointer","public Pointer getNamespaceContextPointer() {
    if (pointer == null && parent != null) {
        return parent.getNamespaceContextPointer();
    }
    return pointer;
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getNamespaceURI(String)","Method","* Given a prefix, returns a registered namespace URI. If the requested
     * prefix was not defined explicitly using the registerNamespace method,
     * JXPathContext will then check the context node to see if the prefix is
     * defined there. See
     * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.
     *
     * @param prefix The namespace prefix to look up
     * @return namespace URI or null if the prefix is undefined.","public synchronized String getNamespaceURI(final String prefix) {
    final String uri = getExternallyRegisteredNamespaceURI(prefix);
    return uri == null && pointer != null ? pointer.getNamespaceURI(prefix) : uri;
}","String","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getNamespaceURI(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.getNamespaceURI(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getExternallyRegisteredNamespaceURI(String)","Method","* Given a prefix, returns an externally registered namespace URI.
     *
     * @param prefix The namespace prefix to look up
     * @return namespace URI or null if the prefix is undefined.
     * @since JXPath 1.3","protected synchronized String getExternallyRegisteredNamespaceURI(final String prefix) {
    final String uri = (String) namespaceMap.get(prefix);
    return uri == null && parent != null ? parent.getExternallyRegisteredNamespaceURI(prefix) : uri;
}","String","protected , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getExternallyRegisteredNamespaceURI(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.getExternallyRegisteredNamespaceURI(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(String)","Method","* Gets the prefix associated with the specifed namespace URI.
     * @param namespaceURI the ns URI to check.
     * @return String prefix","public synchronized String getPrefix(final String namespaceURI) {
    final String prefix = getExternallyRegisteredPrefix(namespaceURI);
    return prefix == null && pointer != null ? getPrefix(pointer, namespaceURI) : prefix;
}","String","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(String).namespaceURI","Parameter_1","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getExternallyRegisteredPrefix(String)","Method","* Gets the nearest prefix found that matches an externally-registered namespace.
     * @param namespaceURI the ns URI to check.
     * @return String prefix if found.
     * @since JXPath 1.3","protected synchronized String getExternallyRegisteredPrefix(final String namespaceURI) {
    final String prefix = (String) reverseMap.get(namespaceURI);
    return prefix == null && parent != null ? parent.getExternallyRegisteredPrefix(namespaceURI) : prefix;
}","String","protected , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.getExternallyRegisteredPrefix(String).namespaceURI","Parameter_1","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.getExternallyRegisteredPrefix(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.isSealed()","Method","* Learn whether this NamespaceResolver has been sealed.
     * @return boolean","public boolean isSealed() {
    return sealed;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.seal()","Method","* Seal this {@link NamespaceResolver}.","public void seal() {
    sealed = true;
    if (parent != null) {
        parent.seal();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.clone()","Method","No Comment","@Override
public Object clone() {
    try {
        final NamespaceResolver result = (NamespaceResolver) super.clone();
        result.sealed = false;
        return result;
    } catch (final CloneNotSupportedException e) {
        // Of course, it's supported.
        e.printStackTrace();
        return null;
    }
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.<init>()","Constructor","* Create a new NamespaceResolver.","public NamespaceResolver() {
    this(null);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.<init>(NamespaceResolver)","Constructor","* Create a new NamespaceResolver.
     * @param parent NamespaceResolver","public NamespaceResolver(final NamespaceResolver parent) {
    this.parent = parent;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.NamespaceResolver.<init>(NamespaceResolver).parent","Parameter_1","Belong to org.apache.commons.jxpath.ri.NamespaceResolver.<init>(NamespaceResolver)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual","Class","* Implementation of {@link Expression} for the operation ""!="".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperationCompare",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""!="";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationNotEqual.
     * @param arg1 left operand
     * @param arg2 right operand","public CoreOperationNotEqual(final Expression arg1, final Expression arg2) {
    super(arg1, arg2, true);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract","Class","* Implementation of {@link Expression} for the operation ""-"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    final double l = InfoSetUtil.doubleValue(args[0].computeValue(context));
    final double r = InfoSetUtil.doubleValue(args[1].computeValue(context));
    return Double.valueOf(l - r);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return ADD_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return false;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""-"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationSubtract.
     * @param arg1 minuend
     * @param arg2 subtrahend","public CoreOperationSubtract(final Expression arg1, final Expression arg2) {
    super(new Expression[] { arg1, arg2 });
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationOr","Class","* Implementation of {@link Expression} for the operation ""or"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationOr.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    for (final Expression arg : args) {
        if (InfoSetUtil.booleanValue(arg.computeValue(context))) {
            return Boolean.TRUE;
        }
    }
    return Boolean.FALSE;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationOr.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationOr.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationOr.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return OR_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationOr.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return true;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationOr.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""or"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationOr.<init>(Expression[])","Constructor","* Create a new CoreOperationOr.
     * @param args or'd Expression components","public CoreOperationOr(final Expression[] args) {
    super(args);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationOr.<init>(Expression[]).args","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationOr.<init>(Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath","Class","* An  element of the parse tree that represents an expression path, which is a
 * path that starts with an expression like a function call: {@code getFoo(.)
 * /bar}.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.Path",""
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.expression","Field","No Comment","private final Expression expression;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.predicates","Field","No Comment","private final Expression[] predicates;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.basicKnown","Field","No Comment","private boolean basicKnown = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.basic","Field","No Comment","private boolean basic;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.getExpression()","Method","* Gets the expression.
     * @return Expression","public Expression getExpression() {
    return expression;
}","Expression","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.getPredicates()","Method","* Predicates are the expressions in brackets that may follow
     * the root expression of the path.
     * @return Expression[]","public Expression[] getPredicates() {
    return predicates;
}","Expression[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.computeContextDependent()","Method","* Returns true if the root expression or any of the
     * predicates or the path steps are context dependent.
     * @return boolean","@Override
public boolean computeContextDependent() {
    if (expression.isContextDependent()) {
        return true;
    }
    if (predicates != null) {
        for (final Expression predicate : predicates) {
            if (predicate.isContextDependent()) {
                return true;
            }
        }
    }
    return super.computeContextDependent();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.isSimpleExpressionPath()","Method","* Recognized paths formatted as {@code $x[3]/foo[2]}.  The
     * evaluation of such ""simple"" paths is optimized and streamlined.
     * @return boolean","public synchronized boolean isSimpleExpressionPath() {
    if (!basicKnown) {
        basicKnown = true;
        basic = isSimplePath() && areBasicPredicates(getPredicates());
    }
    return basic;
}","boolean","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.toString()","Method","No Comment","@Override
public String toString() {
    final StringBuilder buffer = new StringBuilder();
    if (expression instanceof CoreOperation || expression instanceof ExpressionPath || expression instanceof LocationPath) {
        buffer.append('(');
        buffer.append(expression);
        buffer.append(')');
    } else {
        buffer.append(expression);
    }
    if (predicates != null) {
        for (final Expression predicate : predicates) {
            buffer.append('[');
            buffer.append(predicate);
            buffer.append(']');
        }
    }
    final Step[] steps = getSteps();
    if (steps != null) {
        for (final Step step : steps) {
            buffer.append(""/"");
            buffer.append(step);
        }
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.compute(EvalContext)","Method","No Comment","@Override
public Object compute(final EvalContext context) {
    return expressionPath(context, false);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.compute(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.ExpressionPath.compute(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    return expressionPath(context, true);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.ExpressionPath.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.expressionPath(EvalContext,boolean)","Method","* Walks an expression path (a path that starts with an expression)
     * @param evalContext base context
     * @param firstMatch whether to return the first match found
     * @return Object found","protected Object expressionPath(final EvalContext evalContext, final boolean firstMatch) {
    final Object value = expression.compute(evalContext);
    EvalContext context;
    if (value instanceof InitialContext) {
        // This is an optimization. We can avoid iterating through a
        // collection if the context bean is in fact one.
        context = (InitialContext) value;
    } else if (value instanceof EvalContext) {
        // UnionContext will collect all values from the ""value"" context
        // and treat the whole thing as a big collection.
        context = new UnionContext(evalContext, new EvalContext[] { (EvalContext) value });
    } else {
        context = evalContext.getRootContext().getConstantContext(value);
    }
    if (firstMatch && isSimpleExpressionPath() && !(context instanceof NodeSetContext)) {
        final EvalContext ctx = context;
        final NodePointer ptr = (NodePointer) ctx.getSingleNodePointer();
        if (ptr != null && (ptr.getIndex() == NodePointer.WHOLE_COLLECTION || predicates == null || predicates.length == 0)) {
            return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps());
        }
    }
    if (predicates != null) {
        for (int j = 0; j < predicates.length; j++) {
            if (j != 0) {
                context = new UnionContext(context, new EvalContext[] { context });
            }
            context = new PredicateContext(context, predicates[j]);
        }
    }
    return firstMatch ? (Object) getSingleNodePointerForSteps(context) : evalSteps(context);
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.expressionPath(EvalContext,boolean).evalContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.ExpressionPath.expressionPath(EvalContext,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.expressionPath(EvalContext,boolean).firstMatch","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.ExpressionPath.expressionPath(EvalContext,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.<init>(Expression,Expression[],Step[])","Constructor","* Create a new ExpressionPath.
     * @param expression Expression
     * @param predicates to execute
     * @param steps navigation","public ExpressionPath(final Expression expression, final Expression[] predicates, final Step[] steps) {
    super(steps);
    this.expression = expression;
    this.predicates = predicates;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.<init>(Expression,Expression[],Step[]).expression","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.ExpressionPath.<init>(Expression,Expression[],Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.<init>(Expression,Expression[],Step[]).predicates","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.ExpressionPath.<init>(Expression,Expression[],Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExpressionPath.<init>(Expression,Expression[],Step[]).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.ExpressionPath.<init>(Expression,Expression[],Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath","Class","","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.Path",""
"org.apache.commons.jxpath.ri.compiler.LocationPath.absolute","Field","No Comment","private final boolean absolute;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.isAbsolute()","Method","* Learn whether this LocationPath is absolute.
     * @return boolean","public boolean isAbsolute() {
    return absolute;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.computeContextDependent()","Method","No Comment","@Override
public boolean computeContextDependent() {
    return !absolute || super.computeContextDependent();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.toString()","Method","No Comment","@Override
public String toString() {
    final StringBuilder buffer = new StringBuilder();
    final Step[] steps = getSteps();
    if (steps != null) {
        for (int i = 0; i < steps.length; i++) {
            if (i > 0 || absolute) {
                buffer.append('/');
            }
            buffer.append(steps[i]);
        }
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.compute(EvalContext)","Method","No Comment","@Override
public Object compute(final EvalContext context) {
    // Create a chain of contexts
    EvalContext rootContext;
    if (isAbsolute()) {
        rootContext = context.getRootContext().getAbsoluteRootContext();
    } else {
        rootContext = new InitialContext(context);
    }
    return evalSteps(rootContext);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.compute(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.LocationPath.compute(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    // Create a chain of contexts
    EvalContext rootContext;
    if (isAbsolute()) {
        rootContext = context.getRootContext().getAbsoluteRootContext();
    } else {
        rootContext = new InitialContext(context);
    }
    return getSingleNodePointerForSteps(rootContext);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.LocationPath.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.<init>(boolean,Step[])","Constructor","* Create a new LocationPath.
     * @param absolute whether this is an absolute path
     * @param steps to evaluate","public LocationPath(final boolean absolute, final Step[] steps) {
    super(steps);
    this.absolute = absolute;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.<init>(boolean,Step[]).absolute","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.LocationPath.<init>(boolean,Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.LocationPath.<init>(boolean,Step[]).steps","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.LocationPath.<init>(boolean,Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan","Class","* Implementation of {@link Expression} for the operation ""&gt;"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan.evaluateCompare(int)","Method","No Comment","@Override
protected boolean evaluateCompare(final int compare) {
    return compare > 0;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan.evaluateCompare(int).compare","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan.evaluateCompare(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return "">"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationGreaterThan.
     * @param arg1 left operand
     * @param arg2 right operand","public CoreOperationGreaterThan(final Expression arg1, final Expression arg2) {
    super(new Expression[] { arg1, arg2 });
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAnd","Class","* Implementation of {@link Expression} for the operation ""and"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationAnd.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    for (final Expression arg : args) {
        if (!InfoSetUtil.booleanValue(arg.computeValue(context))) {
            return Boolean.FALSE;
        }
    }
    return Boolean.TRUE;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAnd.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationAnd.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAnd.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return AND_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAnd.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return true;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAnd.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""and"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAnd.<init>(Expression[])","Constructor","* Create a new CoreOperationAnd.
     * @param args to combine","public CoreOperationAnd(final Expression[] args) {
    super(args);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAnd.<init>(Expression[]).args","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationAnd.<init>(Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationEqual","Class","* Implementation of {@link Expression} for the operation ""="".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperationCompare",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationEqual.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""="";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationEqual.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationEqual
     * @param arg1 first comparison Expression
     * @param arg2 second comparison Expression","public CoreOperationEqual(final Expression arg1, final Expression arg2) {
    super(arg1, arg2);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationEqual.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationEqual.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationEqual.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationEqual.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NameAttributeTest","Class","* Captures the {@code foo[@name=<em>expr</em>]} expression. These
 * expressions are handled in a special way when applied to beans
 * or maps.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperationEqual",""
"org.apache.commons.jxpath.ri.compiler.NameAttributeTest.getNameTestExpression()","Method","* Gets the name test expression.
     * @return Expression","public Expression getNameTestExpression() {
    return args[1];
}","Expression","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NameAttributeTest.computeContextDependent()","Method","No Comment","@Override
public boolean computeContextDependent() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NameAttributeTest.<init>(Expression,Expression)","Constructor","* Create a new NameAttributeTest.
     * @param namePath Expression
     * @param nameValue Expression","public NameAttributeTest(final Expression namePath, final Expression nameValue) {
    super(namePath, nameValue);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NameAttributeTest.<init>(Expression,Expression).namePath","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.NameAttributeTest.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NameAttributeTest.<init>(Expression,Expression).nameValue","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.NameAttributeTest.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Operation","Abstract Class","","Abstract Class do not obtain Source Code","No return type","public , abstract ","org.apache.commons.jxpath.ri.compiler.Expression",""
"org.apache.commons.jxpath.ri.compiler.Operation.args","Field","Expression[] of arguments","protected Expression[] args;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Operation.getArguments()","Method","* Gets the arguments.
     * @return Expression[]","public Expression[] getArguments() {
    return args;
}","Expression[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Operation.computeContextDependent()","Method","No Comment","@Override
public boolean computeContextDependent() {
    if (args != null) {
        for (final Expression arg : args) {
            if (arg.isContextDependent()) {
                return true;
            }
        }
    }
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Operation.<init>(Expression[])","Constructor","* Create a new Operation.
     * @param args Expression[]","public Operation(final Expression[] args) {
    this.args = args;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Operation.<init>(Expression[]).args","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Operation.<init>(Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual","Class","* Implementation of {@link Expression} for the operation ""&gt;="".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual.evaluateCompare(int)","Method","No Comment","@Override
protected boolean evaluateCompare(final int compare) {
    return compare >= 0;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual.evaluateCompare(int).compare","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual.evaluateCompare(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return "">="";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationGreaterThanOrEqual.
     * @param arg1 operand 1
     * @param arg2 operand 2","public CoreOperationGreaterThanOrEqual(final Expression arg1, final Expression arg2) {
    super(new Expression[] { arg1, arg2 });
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeTest","Abstract Class","","Abstract Class do not obtain Source Code","No return type","public , abstract ","",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationMod","Class","* Implementation of {@link Expression} for the operation ""mod"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationMod.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    final long l = (long) InfoSetUtil.doubleValue(args[0].computeValue(context));
    final long r = (long) InfoSetUtil.doubleValue(args[1].computeValue(context));
    return Double.valueOf(l % r);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMod.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationMod.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMod.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return MULTIPLY_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMod.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return false;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMod.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""mod"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMod.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationMod.
     * @param arg1 dividend
     * @param arg2 divisor","public CoreOperationMod(final Expression arg1, final Expression arg2) {
    super(new Expression[] { arg1, arg2 });
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMod.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationMod.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMod.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationMod.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant","Class","* A compile tree element containing a constant number or string.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.Expression",""
"org.apache.commons.jxpath.ri.compiler.Constant.value","Field","No Comment","private final Object value;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.compute(EvalContext)","Method","No Comment","@Override
public Object compute(final EvalContext context) {
    return value;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.compute(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Constant.compute(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    return value;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Constant.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.isContextDependent()","Method","* Returns false
     * @return false","@Override
public boolean isContextDependent() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.computeContextDependent()","Method","* Returns false
     * @return false","@Override
public boolean computeContextDependent() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.toString()","Method","No Comment","@Override
public String toString() {
    if (value instanceof Number) {
        return InfoSetUtil.stringValue(value);
    }
    return ""'"" + value + ""'"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.<init>(Number)","Constructor","* Create a new Constant.
     * @param number constant","public Constant(final Number number) {
    this.value = number;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.<init>(Number).number","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Constant.<init>(Number)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.<init>(String)","Constructor","* Create a new Constant.
     * @param string constant","public Constant(final String string) {
    this.value = string;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Constant.<init>(String).string","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Constant.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression","Abstract Class","* Common superclass for several types of nodes in the parse tree. Provides
 * APIs for optimization of evaluation of expressions.  Specifically, an
 * expression only needs to executed once during the evaluation of an xpath
 * if that expression is context-independent.  Expression.isContextDependent()
 * provides that hint.","Abstract Class do not obtain Source Code","No return type","public , abstract ","",""
"org.apache.commons.jxpath.ri.compiler.Expression.ZERO","Field","Zero","protected static final Double ZERO = Double.valueOf(0);","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.ONE","Field","One","protected static final Double ONE = Double.valueOf(1);","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.NOT_A_NUMBER","Field","NaN","protected static final Double NOT_A_NUMBER = Double.valueOf(Double.NaN);","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.contextDependencyKnown","Field","No Comment","private boolean contextDependencyKnown = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.contextDependent","Field","No Comment","private boolean contextDependent;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.isContextDependent()","Method","* Returns true if this expression should be re-evaluated
     * each time the current position in the context changes.
     * @return boolean","public synchronized boolean isContextDependent() {
    if (!contextDependencyKnown) {
        contextDependent = computeContextDependent();
        contextDependencyKnown = true;
    }
    return contextDependent;
}","boolean","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.computeContextDependent()","Abstract Method","* Implemented by subclasses and result is cached by isContextDependent()
     * @return calculated context-dependentness as boolean","public abstract boolean computeContextDependent();","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.computeValue(EvalContext)","Abstract Method","* Evaluates the expression. If the result is a node set, returns
     * the first element of the node set.
     * @param context evaluation context
     * @return Object","public abstract Object computeValue(EvalContext context);","Object","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Expression.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.compute(EvalContext)","Abstract Method","* Evaluates the expression. If the result is a node set, returns
     * the first element of the node set.
     * @param context evaluation context
     * @return Object","public abstract Object compute(EvalContext context);","Object","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.compute(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Expression.compute(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.iterate(EvalContext)","Method","* Iterate over the values from the specified context.
     * @param context evaluation context
     * @return value Iterator","public Iterator iterate(final EvalContext context) {
    final Object result = compute(context);
    if (result instanceof EvalContext) {
        return new ValueIterator((EvalContext) result);
    }
    if (result instanceof NodeSet) {
        return new ValueIterator(((NodeSet) result).getPointers().iterator());
    }
    return ValueUtils.iterate(result);
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.iterate(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Expression.iterate(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.iteratePointers(EvalContext)","Method","* Iterate over the pointers from the specified context.
     * @param context evaluation context
     * @return pointer Iterator","public Iterator iteratePointers(final EvalContext context) {
    final Object result = compute(context);
    if (result == null) {
        return Collections.EMPTY_LIST.iterator();
    }
    if (result instanceof EvalContext) {
        return (EvalContext) result;
    }
    if (result instanceof NodeSet) {
        return new PointerIterator(((NodeSet) result).getPointers().iterator(), new QName(null, ""value""), context.getRootContext().getCurrentNodePointer().getLocale());
    }
    return new PointerIterator(ValueUtils.iterate(result), new QName(null, ""value""), context.getRootContext().getCurrentNodePointer().getLocale());
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.iteratePointers(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Expression.iteratePointers(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator","Class","* Pointer iterator","Class do not obtain Source Code","No return type","public , static ","","java.util.Iterator"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.iterator","Field","No Comment","private final Iterator iterator;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.qname","Field","No Comment","private final QName qname;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.locale","Field","No Comment","private final Locale locale;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.hasNext()","Method","No Comment","@Override
public boolean hasNext() {
    return iterator.hasNext();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.next()","Method","No Comment","@Override
public Object next() {
    final Object o = iterator.next();
    return o instanceof Pointer ? o : NodePointer.newNodePointer(qname, o, locale);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.remove()","Method","* Unsupported.","@Override
public void remove() {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.<init>(Iterator,QName,Locale)","Constructor","* Create a new PointerIterator
         * @param it underlying Iterator
         * @param qname name
         * @param locale Locale
         * @deprecated Use the method that takes a NamespaceManager","@Deprecated
public PointerIterator(final Iterator it, final QName qname, final Locale locale) {
    this.iterator = it;
    this.qname = qname;
    this.locale = locale;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.<init>(Iterator,QName,Locale).it","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.<init>(Iterator,QName,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.<init>(Iterator,QName,Locale).qname","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.<init>(Iterator,QName,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.<init>(Iterator,QName,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator.<init>(Iterator,QName,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator","Class","* Value Iterator","Class do not obtain Source Code","No return type","public , static ","","java.util.Iterator"
"org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator.iterator","Field","No Comment","private final Iterator iterator;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator.hasNext()","Method","No Comment","@Override
public boolean hasNext() {
    return iterator.hasNext();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator.next()","Method","No Comment","@Override
public Object next() {
    final Object o = iterator.next();
    return o instanceof Pointer ? ((Pointer) o).getValue() : o;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator.remove()","Method","* Unsupported.","@Override
public void remove() {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator.<init>(Iterator)","Constructor","* Create a new ValueIterator.
         * @param it underlying Iterator, may contain pointers","public ValueIterator(final Iterator it) {
    this.iterator = it;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator.<init>(Iterator).it","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator.<init>(Iterator)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator","Class","* Pointer iterator","Class do not obtain Source Code","No return type","public , static ","","java.util.Iterator"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.iterator","Field","No Comment","private final Iterator iterator;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.qname","Field","No Comment","private final QName qname;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.locale","Field","No Comment","private final Locale locale;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.hasNext()","Method","No Comment","@Override
public boolean hasNext() {
    return iterator.hasNext();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.next()","Method","No Comment","@Override
public Object next() {
    final Object o = iterator.next();
    return o instanceof Pointer ? o : NodePointer.newNodePointer(qname, o, locale);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.remove()","Method","* Unsupported.","@Override
public void remove() {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.<init>(Iterator,QName,Locale)","Constructor","* Create a new PointerIterator
         * @param it underlying Iterator
         * @param qname name
         * @param locale Locale
         * @deprecated Use the method that takes a NamespaceManager","@Deprecated
public PointerIterator(final Iterator it, final QName qname, final Locale locale) {
    this.iterator = it;
    this.qname = qname;
    this.locale = locale;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.<init>(Iterator,QName,Locale).it","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.<init>(Iterator,QName,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.<init>(Iterator,QName,Locale).qname","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.<init>(Iterator,QName,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.<init>(Iterator,QName,Locale).locale","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.Expression.PointerIterator.<init>(Iterator,QName,Locale)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.ValueIterator","Class","* Value Iterator","Class do not obtain Source Code","No return type","public , static ","","java.util.Iterator"
"org.apache.commons.jxpath.ri.compiler.Expression.ValueIterator.iterator","Field","No Comment","private final Iterator iterator;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.ValueIterator.hasNext()","Method","No Comment","@Override
public boolean hasNext() {
    return iterator.hasNext();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.ValueIterator.next()","Method","No Comment","@Override
public Object next() {
    final Object o = iterator.next();
    return o instanceof Pointer ? ((Pointer) o).getValue() : o;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.ValueIterator.remove()","Method","* Unsupported.","@Override
public void remove() {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.ValueIterator.<init>(Iterator)","Constructor","* Create a new ValueIterator.
         * @param it underlying Iterator, may contain pointers","public ValueIterator(final Iterator it) {
    this.iterator = it;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Expression.ValueIterator.<init>(Iterator).it","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Expression.ValueIterator.<init>(Iterator)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual","Class","* Implementation of {@link Expression} for the operation ""&lt;="".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual.evaluateCompare(int)","Method","No Comment","@Override
protected boolean evaluateCompare(final int compare) {
    return compare <= 0;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual.evaluateCompare(int).compare","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual.evaluateCompare(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""<="";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationLessThanOrEqual.
     * @param arg1 left Expression
     * @param arg2 right Expression","public CoreOperationLessThanOrEqual(final Expression arg1, final Expression arg2) {
    super(new Expression[] { arg1, arg2 });
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply","Class","* Implementation of {@link Expression} for the operation ""*"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    final double l = InfoSetUtil.doubleValue(args[0].computeValue(context));
    final double r = InfoSetUtil.doubleValue(args[1].computeValue(context));
    return Double.valueOf(l * r);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return MULTIPLY_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return true;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""*"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationMultiply.
     * @param arg1 factor 1
     * @param arg2 factor 2","public CoreOperationMultiply(final Expression arg1, final Expression arg2) {
    super(new Expression[] { arg1, arg2 });
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan","Class","* Implementation of {@link Expression} for the operation ""&lt;"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan.evaluateCompare(int)","Method","No Comment","@Override
protected boolean evaluateCompare(final int compare) {
    return compare < 0;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan.evaluateCompare(int).compare","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan.evaluateCompare(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""<"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationLessThan.
     * @param arg1 left Expression
     * @param arg2 right Expression","public CoreOperationLessThan(final Expression arg1, final Expression arg2) {
    super(new Expression[] { arg1, arg2 });
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler","Class","","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.ri.Compiler"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.QNAME_NAME","Field","No Comment","private static final QName QNAME_NAME = new QName(null, ""name"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.number(String)","Method","No Comment","@Override
public Object number(final String value) {
    return new Constant(Double.valueOf(value));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.number(String).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.number(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.literal(String)","Method","No Comment","@Override
public Object literal(final String value) {
    return new Constant(value);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.literal(String).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.literal(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.qname(String,String)","Method","No Comment","@Override
public Object qname(final String prefix, final String name) {
    return new QName(prefix, name);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.qname(String,String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.qname(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.qname(String,String).name","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.qname(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.sum(Object[])","Method","No Comment","@Override
public Object sum(final Object[] arguments) {
    return new CoreOperationAdd(toExpressionArray(arguments));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.sum(Object[]).arguments","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.sum(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.minus(Object,Object)","Method","No Comment","@Override
public Object minus(final Object left, final Object right) {
    return new CoreOperationSubtract((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.minus(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.minus(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.minus(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.minus(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.multiply(Object,Object)","Method","No Comment","@Override
public Object multiply(final Object left, final Object right) {
    return new CoreOperationMultiply((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.multiply(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.multiply(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.multiply(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.multiply(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.divide(Object,Object)","Method","No Comment","@Override
public Object divide(final Object left, final Object right) {
    return new CoreOperationDivide((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.divide(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.divide(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.divide(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.divide(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.mod(Object,Object)","Method","No Comment","@Override
public Object mod(final Object left, final Object right) {
    return new CoreOperationMod((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.mod(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.mod(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.mod(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.mod(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThan(Object,Object)","Method","No Comment","@Override
public Object lessThan(final Object left, final Object right) {
    return new CoreOperationLessThan((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThan(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThan(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThan(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThan(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThanOrEqual(Object,Object)","Method","No Comment","@Override
public Object lessThanOrEqual(final Object left, final Object right) {
    return new CoreOperationLessThanOrEqual((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThanOrEqual(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThanOrEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThanOrEqual(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.lessThanOrEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThan(Object,Object)","Method","No Comment","@Override
public Object greaterThan(final Object left, final Object right) {
    return new CoreOperationGreaterThan((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThan(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThan(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThan(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThan(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThanOrEqual(Object,Object)","Method","No Comment","@Override
public Object greaterThanOrEqual(final Object left, final Object right) {
    return new CoreOperationGreaterThanOrEqual((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThanOrEqual(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThanOrEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThanOrEqual(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.greaterThanOrEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.equal(Object,Object)","Method","No Comment","@Override
public Object equal(final Object left, final Object right) {
    return isNameAttributeTest((Expression) left) ? new NameAttributeTest((Expression) left, (Expression) right) : new CoreOperationEqual((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.equal(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.equal(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.equal(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.equal(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.notEqual(Object,Object)","Method","No Comment","@Override
public Object notEqual(final Object left, final Object right) {
    return new CoreOperationNotEqual((Expression) left, (Expression) right);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.notEqual(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.notEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.notEqual(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.notEqual(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.minus(Object)","Method","No Comment","@Override
public Object minus(final Object argument) {
    return new CoreOperationNegate((Expression) argument);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.minus(Object).argument","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.minus(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.variableReference(Object)","Method","No Comment","@Override
public Object variableReference(final Object qName) {
    return new VariableReference((QName) qName);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.variableReference(Object).qName","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.variableReference(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(int,Object[])","Method","No Comment","@Override
public Object function(final int code, final Object[] args) {
    return new CoreFunction(code, toExpressionArray(args));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(int,Object[]).code","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(int,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(int,Object[]).args","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(int,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(Object,Object[])","Method","No Comment","@Override
public Object function(final Object name, final Object[] args) {
    return new ExtensionFunction((QName) name, toExpressionArray(args));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(Object,Object[]).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(Object,Object[]).args","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.function(Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.and(Object[])","Method","No Comment","@Override
public Object and(final Object[] arguments) {
    return new CoreOperationAnd(toExpressionArray(arguments));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.and(Object[]).arguments","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.and(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.or(Object[])","Method","No Comment","@Override
public Object or(final Object[] arguments) {
    return new CoreOperationOr(toExpressionArray(arguments));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.or(Object[]).arguments","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.or(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.union(Object[])","Method","No Comment","@Override
public Object union(final Object[] arguments) {
    return new CoreOperationUnion(toExpressionArray(arguments));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.union(Object[]).arguments","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.union(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.locationPath(boolean,Object[])","Method","No Comment","@Override
public Object locationPath(final boolean absolute, final Object[] steps) {
    return new LocationPath(absolute, toStepArray(steps));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.locationPath(boolean,Object[]).absolute","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.locationPath(boolean,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.locationPath(boolean,Object[]).steps","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.locationPath(boolean,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.expressionPath(Object,Object[],Object[])","Method","No Comment","@Override
public Object expressionPath(final Object expression, final Object[] predicates, final Object[] steps) {
    return new ExpressionPath((Expression) expression, toExpressionArray(predicates), toStepArray(steps));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.expressionPath(Object,Object[],Object[]).expression","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.expressionPath(Object,Object[],Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.expressionPath(Object,Object[],Object[]).predicates","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.expressionPath(Object,Object[],Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.expressionPath(Object,Object[],Object[]).steps","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.expressionPath(Object,Object[],Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.nodeNameTest(Object)","Method","No Comment","@Override
public Object nodeNameTest(final Object qname) {
    return new NodeNameTest((QName) qname);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.nodeNameTest(Object).qname","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.nodeNameTest(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.nodeTypeTest(int)","Method","No Comment","@Override
public Object nodeTypeTest(final int nodeType) {
    return new NodeTypeTest(nodeType);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.nodeTypeTest(int).nodeType","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.nodeTypeTest(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.processingInstructionTest(String)","Method","No Comment","@Override
public Object processingInstructionTest(final String instruction) {
    return new ProcessingInstructionTest(instruction);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.processingInstructionTest(String).instruction","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.processingInstructionTest(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.step(int,Object,Object[])","Method","No Comment","@Override
public Object step(final int axis, final Object nodeTest, final Object[] predicates) {
    return new Step(axis, (NodeTest) nodeTest, toExpressionArray(predicates));
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.step(int,Object,Object[]).axis","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.step(int,Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.step(int,Object,Object[]).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.step(int,Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.step(int,Object,Object[]).predicates","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.step(int,Object,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.toExpressionArray(Object[])","Method","* Gets an Object[] as an Expression[].
     * @param array Object[]
     * @return Expression[]","private Expression[] toExpressionArray(final Object[] array) {
    Expression[] expArray = null;
    if (array != null) {
        expArray = new Expression[array.length];
        for (int i = 0; i < expArray.length; i++) {
            expArray[i] = (Expression) array[i];
        }
    }
    return expArray;
}","Expression[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.toExpressionArray(Object[]).array","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.toExpressionArray(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.toStepArray(Object[])","Method","* Gets an Object[] as a Step[].
     * @param array Object[]
     * @return Step[]","private Step[] toStepArray(final Object[] array) {
    Step[] stepArray = null;
    if (array != null) {
        stepArray = new Step[array.length];
        for (int i = 0; i < stepArray.length; i++) {
            stepArray[i] = (Step) array[i];
        }
    }
    return stepArray;
}","Step[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.toStepArray(Object[]).array","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.toStepArray(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.isNameAttributeTest(Expression)","Method","* Learn whether arg is a name attribute test.
     * @param arg Expression to test
     * @return boolean","private boolean isNameAttributeTest(final Expression arg) {
    if (!(arg instanceof LocationPath)) {
        return false;
    }
    final Step[] steps = ((LocationPath) arg).getSteps();
    if (steps.length != 1) {
        return false;
    }
    if (steps[0].getAxis() != AXIS_ATTRIBUTE) {
        return false;
    }
    final NodeTest test = steps[0].getNodeTest();
    if (!(test instanceof NodeNameTest)) {
        return false;
    }
    if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) {
        return false;
    }
    return true;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.TreeCompiler.isNameAttributeTest(Expression).arg","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.TreeCompiler.isNameAttributeTest(Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step","Class","","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.ri.compiler.Step.axis","Field","No Comment","private final int axis;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.nodeTest","Field","No Comment","private final NodeTest nodeTest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.predicates","Field","No Comment","private final Expression[] predicates;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.getAxis()","Method","* Gets the axis code.
     * @return int","public int getAxis() {
    return axis;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.getNodeTest()","Method","* Gets the step test.
     * @return NodeTest","public NodeTest getNodeTest() {
    return nodeTest;
}","NodeTest","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.getPredicates()","Method","* Gets the predicates.
     * @return Expression[]","public Expression[] getPredicates() {
    return predicates;
}","Expression[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.isContextDependent()","Method","* Learn whether this step contains any predicate that is context dependent.
     * @return boolean","public boolean isContextDependent() {
    if (predicates != null) {
        for (final Expression predicate : predicates) {
            if (predicate.isContextDependent()) {
                return true;
            }
        }
    }
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.toString()","Method","No Comment","@Override
public String toString() {
    final StringBuilder buffer = new StringBuilder();
    final int axis = getAxis();
    if (axis == Compiler.AXIS_CHILD) {
        buffer.append(nodeTest);
    } else if (axis == Compiler.AXIS_ATTRIBUTE) {
        buffer.append('@');
        buffer.append(nodeTest);
    } else if (axis == Compiler.AXIS_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) {
        buffer.append(""."");
    } else if (axis == Compiler.AXIS_PARENT && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) {
        buffer.append("".."");
    } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF && nodeTest instanceof NodeTypeTest && ((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE && (predicates == null || predicates.length == 0)) {
        buffer.append("""");
    } else {
        buffer.append(axisToString(axis));
        buffer.append(""::"");
        buffer.append(nodeTest);
    }
    final Expression[] predicates = getPredicates();
    if (predicates != null) {
        for (final Expression predicate : predicates) {
            buffer.append('[');
            buffer.append(predicate);
            buffer.append(']');
        }
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.axisToString(int)","Method","* Decode an axis code to its name.
     * @param axis int code
     * @return String name.
     * @see Compiler
     * @see ""http://www.w3.org/TR/xpath#axes""","public static String axisToString(final int axis) {
    switch(axis) {
        case Compiler.AXIS_SELF:
            return ""self"";
        case Compiler.AXIS_CHILD:
            return ""child"";
        case Compiler.AXIS_PARENT:
            return ""parent"";
        case Compiler.AXIS_ANCESTOR:
            return ""ancestor"";
        case Compiler.AXIS_ATTRIBUTE:
            return ""attribute"";
        case Compiler.AXIS_NAMESPACE:
            return ""namespace"";
        case Compiler.AXIS_PRECEDING:
            return ""preceding"";
        case Compiler.AXIS_FOLLOWING:
            return ""following"";
        case Compiler.AXIS_DESCENDANT:
            return ""descendant"";
        case Compiler.AXIS_ANCESTOR_OR_SELF:
            return ""ancestor-or-self"";
        case Compiler.AXIS_FOLLOWING_SIBLING:
            return ""following-sibling"";
        case Compiler.AXIS_PRECEDING_SIBLING:
            return ""preceding-sibling"";
        case Compiler.AXIS_DESCENDANT_OR_SELF:
            return ""descendant-or-self"";
        default:
            return ""UNKNOWN"";
    }
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.axisToString(int).axis","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Step.axisToString(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.<init>(int,NodeTest,Expression[])","Constructor","* Create a new Step.
     * @param axis axis code
     * @param nodeTest step test
     * @param predicates predicate expressions","protected Step(final int axis, final NodeTest nodeTest, final Expression[] predicates) {
    this.axis = axis;
    this.nodeTest = nodeTest;
    this.predicates = predicates;
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.<init>(int,NodeTest,Expression[]).axis","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Step.<init>(int,NodeTest,Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.<init>(int,NodeTest,Expression[]).nodeTest","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.Step.<init>(int,NodeTest,Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Step.<init>(int,NodeTest,Expression[]).predicates","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.Step.<init>(int,NodeTest,Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationUnion","Class","* Implementation of {@link Expression} for the operation ""|"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationUnion.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    final EvalContext[] argCtxs = new EvalContext[args.length];
    for (int i = 0; i < args.length; i++) {
        final Object value = args[i].compute(context);
        if (value instanceof EvalContext) {
            argCtxs[i] = (EvalContext) value;
        } else {
            argCtxs[i] = context.getRootContext().getConstantContext(value);
        }
    }
    return new UnionContext(context.getRootContext(), argCtxs);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationUnion.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationUnion.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationUnion.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return UNION_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationUnion.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return true;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationUnion.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""|"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationUnion.<init>(Expression[])","Constructor","* Create a new CoreOperationUnion.
     * @param args Expression[]","public CoreOperationUnion(final Expression[] args) {
    super(args);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationUnion.<init>(Expression[]).args","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationUnion.<init>(Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare","Abstract Class","* Common superclass for the implementations of Expression for the operations
 * ""="" and ""!="".","Abstract Class do not obtain Source Code","No return type","public , abstract ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.invert","Field","No Comment","private final boolean invert;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return COMPARE_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return true;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(EvalContext,Expression,Expression)","Method","* Compares two values.
     * @param context evaluation context
     * @param left operand
     * @param right operand
     * @return whether left = right in XPath terms","protected boolean equal(final EvalContext context, final Expression left, final Expression right) {
    Object l = left.compute(context);
    Object r = right.compute(context);
    if (l instanceof InitialContext) {
        ((EvalContext) l).reset();
    }
    if (l instanceof SelfContext) {
        l = ((EvalContext) l).getSingleNodePointer();
    }
    if (r instanceof InitialContext) {
        ((EvalContext) r).reset();
    }
    if (r instanceof SelfContext) {
        r = ((EvalContext) r).getSingleNodePointer();
    }
    if (l instanceof Collection) {
        l = ((Collection) l).iterator();
    }
    if (r instanceof Collection) {
        r = ((Collection) r).iterator();
    }
    if (l instanceof Iterator && r instanceof Iterator) {
        return findMatch((Iterator) l, (Iterator) r);
    }
    if (l instanceof Iterator) {
        return contains((Iterator) l, r);
    }
    if (r instanceof Iterator) {
        return contains((Iterator) r, l);
    }
    return equal(l, r);
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(EvalContext,Expression,Expression).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(EvalContext,Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(EvalContext,Expression,Expression).left","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(EvalContext,Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(EvalContext,Expression,Expression).right","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(EvalContext,Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.contains(Iterator,Object)","Method","* Learn whether it contains value.
     * @param it Iterator to check
     * @param value for which to look
     * @return whether value was found","protected boolean contains(final Iterator it, final Object value) {
    while (it.hasNext()) {
        final Object element = it.next();
        if (equal(element, value)) {
            return true;
        }
    }
    return false;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.contains(Iterator,Object).it","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.contains(Iterator,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.contains(Iterator,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.contains(Iterator,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.findMatch(Iterator,Iterator)","Method","* Learn whether lit intersects rit.
     * @param lit left Iterator
     * @param rit right Iterator
     * @return boolean","protected boolean findMatch(final Iterator lit, final Iterator rit) {
    final HashSet left = new HashSet();
    while (lit.hasNext()) {
        left.add(lit.next());
    }
    while (rit.hasNext()) {
        if (contains(left.iterator(), rit.next())) {
            return true;
        }
    }
    return false;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.findMatch(Iterator,Iterator).lit","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.findMatch(Iterator,Iterator)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.findMatch(Iterator,Iterator).rit","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.findMatch(Iterator,Iterator)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(Object,Object)","Method","* Learn whether l equals r in XPath terms.
     * @param l left operand
     * @param r right operand
     * @return whether l = r","protected boolean equal(Object l, Object r) {
    if (l instanceof Pointer) {
        l = ((Pointer) l).getValue();
    }
    if (r instanceof Pointer) {
        r = ((Pointer) r).getValue();
    }
    boolean result;
    if (l instanceof Boolean || r instanceof Boolean) {
        result = l == r || InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r);
    } else if (l instanceof Number || r instanceof Number) {
        //if either side is NaN, no comparison returns true:
        final double ld = InfoSetUtil.doubleValue(l);
        if (Double.isNaN(ld)) {
            return false;
        }
        final double rd = InfoSetUtil.doubleValue(r);
        if (Double.isNaN(rd)) {
            return false;
        }
        result = ld == rd;
    } else {
        if (l instanceof String || r instanceof String) {
            l = InfoSetUtil.stringValue(l);
            r = InfoSetUtil.stringValue(r);
        }
        result = l == r || l != null && l.equals(r);
    }
    return result ^ invert;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(Object,Object).l","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(Object,Object).r","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationCompare.
     * @param arg1 left operand
     * @param arg2 right operand","public CoreOperationCompare(final Expression arg1, final Expression arg2) {
    this(arg1, arg2, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression,boolean)","Constructor","* Create a new CoreOperationCompare.
     * @param arg1 left operand
     * @param arg2 right operand
     * @param invert whether to invert (not) the comparison","protected CoreOperationCompare(final Expression arg1, final Expression arg2, final boolean invert) {
    super(new Expression[] { arg1, arg2 });
    this.invert = invert;
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression,boolean).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression,boolean).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression,boolean).invert","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.<init>(Expression,Expression,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationDivide","Class","* Implementation of {@link Expression} for the operation ""div"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    final double l = InfoSetUtil.doubleValue(args[0].computeValue(context));
    final double r = InfoSetUtil.doubleValue(args[1].computeValue(context));
    return Double.valueOf(l / r);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return MULTIPLY_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return false;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""div"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.<init>(Expression,Expression)","Constructor","* Create a new CoreOperationDivide.
     * @param arg1 dividend
     * @param arg2 divisor","public CoreOperationDivide(final Expression arg1, final Expression arg2) {
    super(new Expression[] { arg1, arg2 });
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.<init>(Expression,Expression).arg1","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.<init>(Expression,Expression).arg2","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationDivide.<init>(Expression,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression","Abstract Class","* Base implementation of Expression for the operations ""&gt;"", ""&gt;="", ""&lt;"", ""&lt;="".
 * @since JXPath 1.3","Abstract Class do not obtain Source Code","No return type","public , abstract ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.computeValue(EvalContext)","Method","No Comment","@Override
public final Object computeValue(final EvalContext context) {
    return compute(args[0].compute(context), args[1].compute(context)) ? Boolean.TRUE : Boolean.FALSE;
}","Object","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.getPrecedence()","Method","No Comment","@Override
protected final int getPrecedence() {
    return RELATIONAL_EXPR_PRECEDENCE;
}","int","protected , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.isSymmetric()","Method","No Comment","@Override
protected final boolean isSymmetric() {
    return false;
}","boolean","protected , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.evaluateCompare(int)","Abstract Method","* Template method for subclasses to evaluate the result of a comparison.
     * @param compare result of comparison to evaluate
     * @return ultimate operation success/failure","protected abstract boolean evaluateCompare(int compare);","boolean","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.evaluateCompare(int).compare","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.evaluateCompare(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.compute(Object,Object)","Method","* Compare left to right.
     * @param left left operand
     * @param right right operand
     * @return operation success/failure","private boolean compute(Object left, Object right) {
    left = reduce(left);
    right = reduce(right);
    if (left instanceof InitialContext) {
        ((InitialContext) left).reset();
    }
    if (right instanceof InitialContext) {
        ((InitialContext) right).reset();
    }
    if (left instanceof Iterator && right instanceof Iterator) {
        return findMatch((Iterator) left, (Iterator) right);
    }
    if (left instanceof Iterator) {
        return containsMatch((Iterator) left, right);
    }
    if (right instanceof Iterator) {
        return containsMatch(left, (Iterator) right);
    }
    final double ld = InfoSetUtil.doubleValue(left);
    if (Double.isNaN(ld)) {
        return false;
    }
    final double rd = InfoSetUtil.doubleValue(right);
    if (Double.isNaN(rd)) {
        return false;
    }
    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.compute(Object,Object).left","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.compute(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.compute(Object,Object).right","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.compute(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.reduce(Object)","Method","* Reduce an operand for comparison.
     * @param o Object to reduce
     * @return reduced operand","private Object reduce(Object o) {
    if (o instanceof SelfContext) {
        o = ((EvalContext) o).getSingleNodePointer();
    }
    if (o instanceof Collection) {
        o = ((Collection) o).iterator();
    }
    return o;
}","Object","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.reduce(Object).o","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.reduce(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Iterator,Object)","Method","* Learn whether any element returned from an Iterator matches a given value.
     * @param it Iterator
     * @param value to look for
     * @return whether a match was found","private boolean containsMatch(final Iterator it, final Object value) {
    while (it.hasNext()) {
        final Object element = it.next();
        if (compute(element, value)) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Iterator,Object).it","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Iterator,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Iterator,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Iterator,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Object,Iterator)","Method","* Learn whether any element returned from an Iterator matches a given value.
     * @param it Iterator
     * @param value to look for
     * @return whether a match was found","private boolean containsMatch(final Object value, final Iterator it) {
    while (it.hasNext()) {
        final Object element = it.next();
        if (compute(value, element)) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Object,Iterator).value","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Object,Iterator)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Object,Iterator).it","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.containsMatch(Object,Iterator)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.findMatch(Iterator,Iterator)","Method","* Learn whether there is an intersection between two Iterators.
     * @param lit left Iterator
     * @param rit right Iterator
     * @return whether a match was found","private boolean findMatch(final Iterator lit, final Iterator rit) {
    final HashSet left = new HashSet();
    while (lit.hasNext()) {
        left.add(lit.next());
    }
    while (rit.hasNext()) {
        if (containsMatch(left.iterator(), rit.next())) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.findMatch(Iterator,Iterator).lit","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.findMatch(Iterator,Iterator)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.findMatch(Iterator,Iterator).rit","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.findMatch(Iterator,Iterator)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.<init>(Expression[])","Constructor","* Create a new CoreOperationRelationalExpression.
     * @param args arguments","protected CoreOperationRelationalExpression(final Expression[] args) {
    super(args);
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.<init>(Expression[]).args","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression.<init>(Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest","Class","","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.NodeTest",""
"org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest.target","Field","No Comment","private final String target;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest.getTarget()","Method","* Gets the target.
     * @return String","public String getTarget() {
    return target;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest.toString()","Method","No Comment","@Override
public String toString() {
    return ""processing-instruction('"" + target + ""')"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest.<init>(String)","Constructor","* Create a new ProcessingInstructionTest.
     * @param target string","public ProcessingInstructionTest(final String target) {
    this.target = target;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest.<init>(String).target","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction","Class","* Represents an element of the parse tree representing an extension function
 * call.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.Operation",""
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.functionName","Field","No Comment","private final QName functionName;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.getFunctionName()","Method","* Gets the function name
     * @return QName","public QName getFunctionName() {
    return functionName;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.computeContextDependent()","Method","* An extension function gets the current context, therefore it MAY be
     * context dependent.
     * @return true","@Override
public boolean computeContextDependent() {
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.toString()","Method","No Comment","@Override
public String toString() {
    final StringBuilder buffer = new StringBuilder();
    buffer.append(functionName);
    buffer.append('(');
    final Expression[] args = getArguments();
    if (args != null) {
        for (int i = 0; i < args.length; i++) {
            if (i > 0) {
                buffer.append("", "");
            }
            buffer.append(args[i]);
        }
    }
    buffer.append(')');
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.compute(EvalContext)","Method","No Comment","@Override
public Object compute(final EvalContext context) {
    return computeValue(context);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.compute(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.ExtensionFunction.compute(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    Object[] parameters = null;
    if (args != null) {
        parameters = new Object[args.length];
        for (int i = 0; i < args.length; i++) {
            parameters[i] = convert(args[i].compute(context));
        }
    }
    final Function function = context.getRootContext().getFunction(functionName, parameters);
    if (function == null) {
        throw new JXPathFunctionNotFoundException(""No such function: "" + functionName + Arrays.asList(parameters));
    }
    final Object result = function.invoke(context, parameters);
    return result instanceof NodeSet ? new NodeSetContext(context, (NodeSet) result) : result;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.ExtensionFunction.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.convert(Object)","Method","* Convert any incoming context to a value.
     * @param object Object to convert
     * @return context value or {@code object} unscathed.","private Object convert(final Object object) {
    return object instanceof EvalContext ? ((EvalContext) object).getValue() : object;
}","Object","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.convert(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.ExtensionFunction.convert(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.<init>(QName,Expression[])","Constructor","* Create a new ExtensionFunction.
     * @param functionName name of the function
     * @param args Expression[] of function args","public ExtensionFunction(final QName functionName, final Expression[] args) {
    super(args);
    this.functionName = functionName;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.<init>(QName,Expression[]).functionName","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.ExtensionFunction.<init>(QName,Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.ExtensionFunction.<init>(QName,Expression[]).args","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.ExtensionFunction.<init>(QName,Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeTypeTest","Class","","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.NodeTest",""
"org.apache.commons.jxpath.ri.compiler.NodeTypeTest.nodeType","Field","No Comment","private final int nodeType;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeTypeTest.getNodeType()","Method","* Gets the nodeType.
     * @return int","public int getNodeType() {
    return nodeType;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeTypeTest.toString()","Method","No Comment","@Override
public String toString() {
    return nodeTypeToString(nodeType) + ""()"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeTypeTest.nodeTypeToString(int)","Method","* Render the given node type as a String.
     * @param code int
     * @return String","public static String nodeTypeToString(final int code) {
    switch(code) {
        case Compiler.NODE_TYPE_NODE:
            return ""node"";
        case Compiler.NODE_TYPE_TEXT:
            return ""text"";
        case Compiler.NODE_TYPE_COMMENT:
            return ""comment"";
        case Compiler.NODE_TYPE_PI:
            return ""processing-instruction"";
        default:
            return ""UNKNOWN"";
    }
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeTypeTest.nodeTypeToString(int).code","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.NodeTypeTest.nodeTypeToString(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeTypeTest.<init>(int)","Constructor","* Create a new NodeTypeTest.
     * @param nodeType to match","public NodeTypeTest(final int nodeType) {
    this.nodeType = nodeType;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeTypeTest.<init>(int).nodeType","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.NodeTypeTest.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation","Abstract Class","* The common subclass for tree elements representing core operations like ""+"",
 * ""- "", ""*"" etc.","Abstract Class do not obtain Source Code","No return type","public , abstract ","org.apache.commons.jxpath.ri.compiler.Operation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperation.OR_PRECEDENCE","Field","Or precedence","protected static final int OR_PRECEDENCE = 0;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.AND_PRECEDENCE","Field","And precedence","protected static final int AND_PRECEDENCE = 1;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.COMPARE_PRECEDENCE","Field","Compare precedence","protected static final int COMPARE_PRECEDENCE = 2;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.RELATIONAL_EXPR_PRECEDENCE","Field","Relational expression precedence","protected static final int RELATIONAL_EXPR_PRECEDENCE = 3;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.ADD_PRECEDENCE","Field","Add/subtract precedence","protected static final int ADD_PRECEDENCE = 4;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.MULTIPLY_PRECEDENCE","Field","Multiply/divide/mod precedence","protected static final int MULTIPLY_PRECEDENCE = 5;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.NEGATE_PRECEDENCE","Field","Negate precedence","protected static final int NEGATE_PRECEDENCE = 6;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.UNION_PRECEDENCE","Field","Union precedence","protected static final int UNION_PRECEDENCE = 7;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.compute(EvalContext)","Method","No Comment","@Override
public Object compute(final EvalContext context) {
    return computeValue(context);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.compute(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperation.compute(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.computeValue(EvalContext)","Abstract Method","No Comment","@Override
public abstract Object computeValue(EvalContext context);","Object","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperation.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.getSymbol()","Abstract Method","* Returns the XPath symbol for this operation, e.g. ""+"", ""div"", etc.
     * @return String symbol","public abstract String getSymbol();","String","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.isSymmetric()","Abstract Method","* Returns true if the operation is not sensitive to the order of arguments,
     * e.g. ""="", ""and"" etc, and false if it is, e.g. ""&lt;="", ""div"".
     * @return boolean","protected abstract boolean isSymmetric();","boolean","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.getPrecedence()","Abstract Method","* Computes the precedence of the operation.
     * @return int precedence","protected abstract int getPrecedence();","int","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.toString()","Method","No Comment","@Override
public String toString() {
    if (args.length == 1) {
        return getSymbol() + parenthesize(args[0], false);
    }
    final StringBuilder buffer = new StringBuilder();
    for (int i = 0; i < args.length; i++) {
        if (i > 0) {
            buffer.append(' ');
            buffer.append(getSymbol());
            buffer.append(' ');
        }
        buffer.append(parenthesize(args[i], i == 0));
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.parenthesize(Expression,boolean)","Method","* Wrap an expression in parens if necessary.
     * @param expression other Expression
     * @param left whether {@code expression} is left of this one.
     * @return String","private String parenthesize(final Expression expression, final boolean left) {
    final String s = expression.toString();
    if (!(expression instanceof CoreOperation)) {
        return s;
    }
    final int compared = getPrecedence() - ((CoreOperation) expression).getPrecedence();
    if (compared < 0) {
        return s;
    }
    if (compared == 0 && (isSymmetric() || left)) {
        return s;
    }
    return '(' + s + ')';
}","String","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.parenthesize(Expression,boolean).expression","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperation.parenthesize(Expression,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.parenthesize(Expression,boolean).left","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperation.parenthesize(Expression,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.<init>(Expression[])","Constructor","* Create a new CoreOperation.
     * @param args Expression[]","public CoreOperation(final Expression[] args) {
    super(args);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperation.<init>(Expression[]).args","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperation.<init>(Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAdd","Class","* Implementation of {@link Expression} for the operation ""+"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationAdd.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    double s = 0.0;
    for (final Expression arg : args) {
        s += InfoSetUtil.doubleValue(arg.computeValue(context));
    }
    return Double.valueOf(s);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAdd.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationAdd.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAdd.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return ADD_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAdd.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return true;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAdd.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""+"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAdd.<init>(Expression[])","Constructor","* Create a new CoreOperationAdd.
     * @param args Expression arguments to add together.","public CoreOperationAdd(final Expression[] args) {
    super(args);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationAdd.<init>(Expression[]).args","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationAdd.<init>(Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNegate","Class","* Implementation of {@link Expression} for the operation unary ""-"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.CoreOperation",""
"org.apache.commons.jxpath.ri.compiler.CoreOperationNegate.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    final double a = InfoSetUtil.doubleValue(args[0].computeValue(context));
    return Double.valueOf(-a);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNegate.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationNegate.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNegate.getPrecedence()","Method","No Comment","@Override
protected int getPrecedence() {
    return NEGATE_PRECEDENCE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNegate.isSymmetric()","Method","No Comment","@Override
protected boolean isSymmetric() {
    return false;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNegate.getSymbol()","Method","No Comment","@Override
public String getSymbol() {
    return ""-"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNegate.<init>(Expression)","Constructor","* Create a new CoreOperationNegate.
     * @param arg the Expression to negate","public CoreOperationNegate(final Expression arg) {
    super(new Expression[] { arg });
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreOperationNegate.<init>(Expression).arg","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreOperationNegate.<init>(Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference","Class","* An element of the compile tree holding a variable reference.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.Expression",""
"org.apache.commons.jxpath.ri.compiler.VariableReference.varName","Field","No Comment","private final QName varName;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.getVariableName()","Method","* Gets the variable name.
     * @return QName","public QName getVariableName() {
    return varName;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.toString()","Method","No Comment","@Override
public String toString() {
    return ""$"" + varName;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.isContextDependent()","Method","No Comment","@Override
public boolean isContextDependent() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.computeContextDependent()","Method","No Comment","@Override
public boolean computeContextDependent() {
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.compute(EvalContext)","Method","No Comment","@Override
public Object compute(final EvalContext context) {
    return computeValue(context);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.compute(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.VariableReference.compute(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.computeValue(EvalContext)","Method","* Returns the value of the variable.
     * @param context EvalContext against which to compute the variable's value.
     * @return Object","@Override
public Object computeValue(final EvalContext context) {
    return context.getRootContext().getVariableContext(varName);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.VariableReference.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.<init>(QName)","Constructor","* Create a new VariableReference.
     * @param varName variable name","public VariableReference(final QName varName) {
    this.varName = varName;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.VariableReference.<init>(QName).varName","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.VariableReference.<init>(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path","Abstract Class","","Abstract Class do not obtain Source Code","No return type","public , abstract ","org.apache.commons.jxpath.ri.compiler.Expression",""
"org.apache.commons.jxpath.ri.compiler.Path.steps","Field","No Comment","private final Step[] steps;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.basicKnown","Field","No Comment","private boolean basicKnown = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.basic","Field","No Comment","private boolean basic;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.getSteps()","Method","* Gets the steps.
     * @return Step[]","public Step[] getSteps() {
    return steps;
}","Step[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.computeContextDependent()","Method","No Comment","@Override
public boolean computeContextDependent() {
    if (steps != null) {
        for (final Step step : steps) {
            if (step.isContextDependent()) {
                return true;
            }
        }
    }
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.isSimplePath()","Method","* Recognizes paths formatted as {@code foo/bar[3]/baz[@name = 'biz']}.
     * The evaluation of such ""simple"" paths is optimized and
     * streamlined.
     * @return {@code true} if this path is simple","public synchronized boolean isSimplePath() {
    if (!basicKnown) {
        basicKnown = true;
        basic = true;
        final Step[] steps = getSteps();
        for (final Step step : steps) {
            if (!isSimpleStep(step)) {
                basic = false;
                break;
            }
        }
    }
    return basic;
}","boolean","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.isSimpleStep(Step)","Method","* A Step is ""simple"" if it takes one of these forms: ""."", ""/foo"",
     * ""@bar"", ""/foo[3]"". If there are predicates, they should be
     * context independent for the step to still be considered simple.
     * @param step the step to check
     * @return boolean","protected boolean isSimpleStep(final Step step) {
    if (step.getAxis() == Compiler.AXIS_SELF) {
        final NodeTest nodeTest = step.getNodeTest();
        if (!(nodeTest instanceof NodeTypeTest)) {
            return false;
        }
        final int nodeType = ((NodeTypeTest) nodeTest).getNodeType();
        if (nodeType != Compiler.NODE_TYPE_NODE) {
            return false;
        }
        return areBasicPredicates(step.getPredicates());
    }
    if (step.getAxis() == Compiler.AXIS_CHILD || step.getAxis() == Compiler.AXIS_ATTRIBUTE) {
        final NodeTest nodeTest = step.getNodeTest();
        if (!(nodeTest instanceof NodeNameTest)) {
            return false;
        }
        if (((NodeNameTest) nodeTest).isWildcard()) {
            return false;
        }
        return areBasicPredicates(step.getPredicates());
    }
    return false;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.isSimpleStep(Step).step","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Path.isSimpleStep(Step)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.areBasicPredicates(Expression[])","Method","* Learn whether the elements of the specified array are ""basic"" predicates.
     * @param predicates the Expression[] to check
     * @return boolean","protected boolean areBasicPredicates(final Expression[] predicates) {
    if (predicates != null && predicates.length != 0) {
        boolean firstIndex = true;
        for (final Expression predicate : predicates) {
            if (predicate instanceof NameAttributeTest) {
                if (((NameAttributeTest) predicate).getNameTestExpression().isContextDependent()) {
                    return false;
                }
            } else if (predicate.isContextDependent()) {
                return false;
            } else {
                if (!firstIndex) {
                    return false;
                }
                firstIndex = false;
            }
        }
    }
    return true;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.areBasicPredicates(Expression[]).predicates","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Path.areBasicPredicates(Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.getSingleNodePointerForSteps(EvalContext)","Method","* Given a root context, walks a path therefrom and finds the
     * pointer to the first element matching the path.
     * @param context evaluation context
     * @return Pointer","protected Pointer getSingleNodePointerForSteps(final EvalContext context) {
    if (steps.length == 0) {
        return context.getSingleNodePointer();
    }
    if (isSimplePath()) {
        final NodePointer ptr = (NodePointer) context.getSingleNodePointer();
        return SimplePathInterpreter.interpretSimpleLocationPath(context, ptr, steps);
    }
    return searchForPath(context);
}","Pointer","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.getSingleNodePointerForSteps(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Path.getSingleNodePointerForSteps(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.searchForPath(EvalContext)","Method","* The idea here is to return a NullPointer rather than null if that's at
     * all possible. Take for example this path: ""//map/key"". Let's say, ""map""
     * is an existing node, but ""key"" is not there. We will create a
     * NullPointer that can be used to set/create the ""key"" property.
     * <p>
     * However, a path like ""//key"" would still produce null, because we have
     * no way of knowing where ""key"" would be if it existed.
     * </p>
     * <p>
     * To accomplish this, we first try the path itself. If it does not find
     * anything, we chop off last step of the path, as long as it is a simple
     * one like child:: or attribute:: and try to evaluate the truncated path.
     * If it finds exactly one node - create a NullPointer and return. If it
     * fails, chop off another step and repeat. If it finds more than one
     * location - return null.
     * </p>
     * @param context evaluation context
     * @return Pointer","protected Pointer searchForPath(final EvalContext context) {
    EvalContext ctx = buildContextChain(context, steps.length, true);
    final Pointer pointer = ctx.getSingleNodePointer();
    if (pointer != null) {
        return pointer;
    }
    for (int i = steps.length; --i > 0; ) {
        if (!isSimpleStep(steps[i])) {
            return null;
        }
        ctx = buildContextChain(context, i, true);
        if (ctx.hasNext()) {
            final Pointer partial = (Pointer) ctx.next();
            if (ctx.hasNext()) {
                // If we find another location - the search is
                // ambiguous, so we report failure
                return null;
            }
            if (partial instanceof NodePointer) {
                return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i);
            }
        }
    }
    return null;
}","Pointer","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.searchForPath(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Path.searchForPath(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.evalSteps(EvalContext)","Method","* Given a root context, walks a path therefrom and builds a context
     * that contains all nodes matching the path.
     * @param context evaluation context
     * @return EvaluationContext","protected EvalContext evalSteps(final EvalContext context) {
    return buildContextChain(context, steps.length, false);
}","EvalContext","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.evalSteps(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Path.evalSteps(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.buildContextChain(EvalContext,int,boolean)","Method","* Build a context from a chain of contexts.
     * @param context evaluation context
     * @param stepCount number of steps to descend
     * @param createInitialContext whether to create the initial context
     * @return created context","protected EvalContext buildContextChain(EvalContext context, final int stepCount, final boolean createInitialContext) {
    if (createInitialContext) {
        context = new InitialContext(context);
    }
    if (steps.length == 0) {
        return context;
    }
    for (int i = 0; i < stepCount; i++) {
        context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());
        final Expression[] predicates = steps[i].getPredicates();
        if (predicates != null) {
            for (int j = 0; j < predicates.length; j++) {
                if (j != 0) {
                    context = new UnionContext(context, new EvalContext[] { context });
                }
                context = new PredicateContext(context, predicates[j]);
            }
        }
    }
    return context;
}","EvalContext","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.buildContextChain(EvalContext,int,boolean).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Path.buildContextChain(EvalContext,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.buildContextChain(EvalContext,int,boolean).stepCount","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.Path.buildContextChain(EvalContext,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.buildContextChain(EvalContext,int,boolean).createInitialContext","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.Path.buildContextChain(EvalContext,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.createContextForStep(EvalContext,int,NodeTest)","Method","* Different axes are serviced by different contexts. This method
     * allocates the right context for the supplied step.
     * @param context evaluation context
     * @param axis code
     * @param nodeTest node test
     * @return EvalContext","protected EvalContext createContextForStep(final EvalContext context, final int axis, NodeTest nodeTest) {
    if (nodeTest instanceof NodeNameTest) {
        final QName qname = ((NodeNameTest) nodeTest).getNodeName();
        final String prefix = qname.getPrefix();
        if (prefix != null) {
            final String namespaceURI = context.getJXPathContext().getNamespaceURI(prefix);
            nodeTest = new NodeNameTest(qname, namespaceURI);
        }
    }
    switch(axis) {
        case Compiler.AXIS_ANCESTOR:
            return new AncestorContext(context, false, nodeTest);
        case Compiler.AXIS_ANCESTOR_OR_SELF:
            return new AncestorContext(context, true, nodeTest);
        case Compiler.AXIS_ATTRIBUTE:
            return new AttributeContext(context, nodeTest);
        case Compiler.AXIS_CHILD:
            return new ChildContext(context, nodeTest, false, false);
        case Compiler.AXIS_DESCENDANT:
            return new DescendantContext(context, false, nodeTest);
        case Compiler.AXIS_DESCENDANT_OR_SELF:
            return new DescendantContext(context, true, nodeTest);
        case Compiler.AXIS_FOLLOWING:
            return new PrecedingOrFollowingContext(context, nodeTest, false);
        case Compiler.AXIS_FOLLOWING_SIBLING:
            return new ChildContext(context, nodeTest, true, false);
        case Compiler.AXIS_NAMESPACE:
            return new NamespaceContext(context, nodeTest);
        case Compiler.AXIS_PARENT:
            return new ParentContext(context, nodeTest);
        case Compiler.AXIS_PRECEDING:
            return new PrecedingOrFollowingContext(context, nodeTest, true);
        case Compiler.AXIS_PRECEDING_SIBLING:
            return new ChildContext(context, nodeTest, true, true);
        case Compiler.AXIS_SELF:
            return new SelfContext(context, nodeTest);
        default:
            // Never happens
            return null;
    }
}","EvalContext","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.createContextForStep(EvalContext,int,NodeTest).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Path.createContextForStep(EvalContext,int,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.createContextForStep(EvalContext,int,NodeTest).axis","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.Path.createContextForStep(EvalContext,int,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.createContextForStep(EvalContext,int,NodeTest).nodeTest","Parameter_3","Belong to org.apache.commons.jxpath.ri.compiler.Path.createContextForStep(EvalContext,int,NodeTest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.<init>(Step[])","Constructor","* Create a new Path.
     * @param steps that compose the Path","public Path(final Step[] steps) {
    this.steps = steps;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.Path.<init>(Step[]).steps","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.Path.<init>(Step[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest","Class","","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.NodeTest",""
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.qname","Field","No Comment","private final QName qname;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.namespaceURI","Field","No Comment","private String namespaceURI;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.getNodeName()","Method","* Gets the node name.
     * @return QName","public QName getNodeName() {
    return qname;
}","QName","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.getNamespaceURI()","Method","* Gets the ns URI.
     * @return String","public String getNamespaceURI() {
    return namespaceURI;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.isWildcard()","Method","* Learn whether this is a wildcard test.
     * @return {@code true} if the node name is ""*"".","public boolean isWildcard() {
    return qname.getName().equals(""*"");
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.toString()","Method","No Comment","@Override
public String toString() {
    return qname.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.<init>(QName)","Constructor","* Create a new NodeNameTest.
     * @param qname name to match","public NodeNameTest(final QName qname) {
    this.qname = qname;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.<init>(QName).qname","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.NodeNameTest.<init>(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.<init>(QName,String)","Constructor","* Create a new NodeNameTest.
     * @param qname name to match
     * @param namespaceURI uri to match","public NodeNameTest(final QName qname, final String namespaceURI) {
    this.qname = qname;
    this.namespaceURI = namespaceURI;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.<init>(QName,String).qname","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.NodeNameTest.<init>(QName,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.NodeNameTest.<init>(QName,String).namespaceURI","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.NodeNameTest.<init>(QName,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction","Class","* An element of the compile tree representing one of built-in functions
 * like ""position()"" or ""number()"".","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.ri.compiler.Operation",""
"org.apache.commons.jxpath.ri.compiler.CoreFunction.ZERO","Field","No Comment","private static final Double ZERO = Double.valueOf(0);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionCode","Field","No Comment","private final int functionCode;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.getFunctionCode()","Method","* Gets the function code.
     * @return int function code","public int getFunctionCode() {
    return functionCode;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.getFunctionName()","Method","* Gets the name of this function.
     * @return String function name","protected String getFunctionName() {
    switch(functionCode) {
        case Compiler.FUNCTION_LAST:
            return ""last"";
        case Compiler.FUNCTION_POSITION:
            return ""position"";
        case Compiler.FUNCTION_COUNT:
            return ""count"";
        case Compiler.FUNCTION_ID:
            return ""id"";
        case Compiler.FUNCTION_LOCAL_NAME:
            return ""local-name"";
        case Compiler.FUNCTION_NAMESPACE_URI:
            return ""namespace-uri"";
        case Compiler.FUNCTION_NAME:
            return ""name"";
        case Compiler.FUNCTION_STRING:
            return ""string"";
        case Compiler.FUNCTION_CONCAT:
            return ""concat"";
        case Compiler.FUNCTION_STARTS_WITH:
            return ""starts-with"";
        case Compiler.FUNCTION_ENDS_WITH:
            return ""ends-with"";
        case Compiler.FUNCTION_CONTAINS:
            return ""contains"";
        case Compiler.FUNCTION_SUBSTRING_BEFORE:
            return ""substring-before"";
        case Compiler.FUNCTION_SUBSTRING_AFTER:
            return ""substring-after"";
        case Compiler.FUNCTION_SUBSTRING:
            return ""substring"";
        case Compiler.FUNCTION_STRING_LENGTH:
            return ""string-length"";
        case Compiler.FUNCTION_NORMALIZE_SPACE:
            return ""normalize-space"";
        case Compiler.FUNCTION_TRANSLATE:
            return ""translate"";
        case Compiler.FUNCTION_BOOLEAN:
            return ""boolean"";
        case Compiler.FUNCTION_NOT:
            return ""not"";
        case Compiler.FUNCTION_TRUE:
            return ""true"";
        case Compiler.FUNCTION_FALSE:
            return ""false"";
        case Compiler.FUNCTION_LANG:
            return ""lang"";
        case Compiler.FUNCTION_NUMBER:
            return ""number"";
        case Compiler.FUNCTION_SUM:
            return ""sum"";
        case Compiler.FUNCTION_FLOOR:
            return ""floor"";
        case Compiler.FUNCTION_CEILING:
            return ""ceiling"";
        case Compiler.FUNCTION_ROUND:
            return ""round"";
        case Compiler.FUNCTION_KEY:
            return ""key"";
        case Compiler.FUNCTION_FORMAT_NUMBER:
            return ""format-number"";
        default:
            return ""unknownFunction"" + functionCode + ""()"";
    }
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.getArg1()","Method","* Convenience method to return the first argument.
     * @return Expression","public Expression getArg1() {
    return args[0];
}","Expression","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.getArg2()","Method","* Convenience method to return the second argument.
     * @return Expression","public Expression getArg2() {
    return args[1];
}","Expression","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.getArg3()","Method","* Convenience method to return the third argument.
     * @return Expression","public Expression getArg3() {
    return args[2];
}","Expression","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.getArgumentCount()","Method","* Gets the number of argument Expressions.
     * @return int count","public int getArgumentCount() {
    if (args == null) {
        return 0;
    }
    return args.length;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.computeContextDependent()","Method","* Returns true if any argument is context dependent or if
     * the function is last(), position(), boolean(), local-name(),
     * name(), string(), lang(), number().
     * @return boolean","@Override
public boolean computeContextDependent() {
    if (super.computeContextDependent()) {
        return true;
    }
    switch(functionCode) {
        case Compiler.FUNCTION_LAST:
        case Compiler.FUNCTION_POSITION:
            return true;
        case Compiler.FUNCTION_BOOLEAN:
        case Compiler.FUNCTION_LOCAL_NAME:
        case Compiler.FUNCTION_NAME:
        case Compiler.FUNCTION_NAMESPACE_URI:
        case Compiler.FUNCTION_STRING:
        case Compiler.FUNCTION_LANG:
        case Compiler.FUNCTION_NUMBER:
            return args == null || args.length == 0;
        case Compiler.FUNCTION_FORMAT_NUMBER:
            return args != null && args.length == 2;
        case Compiler.FUNCTION_COUNT:
        case Compiler.FUNCTION_ID:
        case Compiler.FUNCTION_CONCAT:
        case Compiler.FUNCTION_STARTS_WITH:
        case Compiler.FUNCTION_ENDS_WITH:
        case Compiler.FUNCTION_CONTAINS:
        case Compiler.FUNCTION_SUBSTRING_BEFORE:
        case Compiler.FUNCTION_SUBSTRING_AFTER:
        case Compiler.FUNCTION_SUBSTRING:
        case Compiler.FUNCTION_STRING_LENGTH:
        case Compiler.FUNCTION_NORMALIZE_SPACE:
        case Compiler.FUNCTION_TRANSLATE:
        case Compiler.FUNCTION_NOT:
        case Compiler.FUNCTION_TRUE:
        case Compiler.FUNCTION_FALSE:
        case Compiler.FUNCTION_SUM:
        case Compiler.FUNCTION_FLOOR:
        case Compiler.FUNCTION_CEILING:
        case Compiler.FUNCTION_ROUND:
        default:
            return false;
    }
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.toString()","Method","No Comment","@Override
public String toString() {
    final StringBuilder buffer = new StringBuilder();
    buffer.append(getFunctionName());
    buffer.append('(');
    final Expression[] args = getArguments();
    if (args != null) {
        for (int i = 0; i < args.length; i++) {
            if (i > 0) {
                buffer.append("", "");
            }
            buffer.append(args[i]);
        }
    }
    buffer.append(')');
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.compute(EvalContext)","Method","No Comment","@Override
public Object compute(final EvalContext context) {
    return computeValue(context);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.compute(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.compute(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.computeValue(EvalContext)","Method","No Comment","@Override
public Object computeValue(final EvalContext context) {
    switch(functionCode) {
        case Compiler.FUNCTION_LAST:
            return functionLast(context);
        case Compiler.FUNCTION_POSITION:
            return functionPosition(context);
        case Compiler.FUNCTION_COUNT:
            return functionCount(context);
        case Compiler.FUNCTION_LANG:
            return functionLang(context);
        case Compiler.FUNCTION_ID:
            return functionID(context);
        case Compiler.FUNCTION_LOCAL_NAME:
            return functionLocalName(context);
        case Compiler.FUNCTION_NAMESPACE_URI:
            return functionNamespaceURI(context);
        case Compiler.FUNCTION_NAME:
            return functionName(context);
        case Compiler.FUNCTION_STRING:
            return functionString(context);
        case Compiler.FUNCTION_CONCAT:
            return functionConcat(context);
        case Compiler.FUNCTION_STARTS_WITH:
            return functionStartsWith(context);
        case Compiler.FUNCTION_ENDS_WITH:
            return functionEndsWith(context);
        case Compiler.FUNCTION_CONTAINS:
            return functionContains(context);
        case Compiler.FUNCTION_SUBSTRING_BEFORE:
            return functionSubstringBefore(context);
        case Compiler.FUNCTION_SUBSTRING_AFTER:
            return functionSubstringAfter(context);
        case Compiler.FUNCTION_SUBSTRING:
            return functionSubstring(context);
        case Compiler.FUNCTION_STRING_LENGTH:
            return functionStringLength(context);
        case Compiler.FUNCTION_NORMALIZE_SPACE:
            return functionNormalizeSpace(context);
        case Compiler.FUNCTION_TRANSLATE:
            return functionTranslate(context);
        case Compiler.FUNCTION_BOOLEAN:
            return functionBoolean(context);
        case Compiler.FUNCTION_NOT:
            return functionNot(context);
        case Compiler.FUNCTION_TRUE:
            return functionTrue(context);
        case Compiler.FUNCTION_FALSE:
            return functionFalse(context);
        case Compiler.FUNCTION_NULL:
            return functionNull(context);
        case Compiler.FUNCTION_NUMBER:
            return functionNumber(context);
        case Compiler.FUNCTION_SUM:
            return functionSum(context);
        case Compiler.FUNCTION_FLOOR:
            return functionFloor(context);
        case Compiler.FUNCTION_CEILING:
            return functionCeiling(context);
        case Compiler.FUNCTION_ROUND:
            return functionRound(context);
        case Compiler.FUNCTION_KEY:
            return functionKey(context);
        case Compiler.FUNCTION_FORMAT_NUMBER:
            return functionFormatNumber(context);
        default:
            return null;
    }
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.computeValue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.computeValue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionLast(EvalContext)","Method","* last() implementation.
     * @param context evaluation context
     * @return Number","protected Object functionLast(final EvalContext context) {
    assertArgCount(0);
    // Move the position to the beginning and iterate through
    // the context to count nodes.
    final int old = context.getCurrentPosition();
    context.reset();
    int count = 0;
    while (context.nextNode()) {
        count++;
    }
    // Restore the current position.
    if (old != 0) {
        context.setPosition(old);
    }
    return Double.valueOf(count);
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionLast(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionLast(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionPosition(EvalContext)","Method","* position() implementation.
     * @param context evaluation context
     * @return Number","protected Object functionPosition(final EvalContext context) {
    assertArgCount(0);
    return Integer.valueOf(context.getCurrentPosition());
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionPosition(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionPosition(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionCount(EvalContext)","Method","* count() implementation.
     * @param context evaluation context
     * @return Number","protected Object functionCount(final EvalContext context) {
    assertArgCount(1);
    final Expression arg1 = getArg1();
    int count = 0;
    Object value = arg1.compute(context);
    if (value instanceof NodePointer) {
        value = ((NodePointer) value).getValue();
    }
    if (value instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) value;
        while (ctx.hasNext()) {
            ctx.next();
            count++;
        }
    } else if (value instanceof Collection) {
        count = ((Collection) value).size();
    } else if (value == null) {
        count = 0;
    } else {
        count = 1;
    }
    return Double.valueOf(count);
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionCount(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionCount(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionLang(EvalContext)","Method","* lang() implementation.
     * @param context evaluation context
     * @return Boolean","protected Object functionLang(final EvalContext context) {
    assertArgCount(1);
    final String lang = InfoSetUtil.stringValue(getArg1().computeValue(context));
    final NodePointer pointer = (NodePointer) context.getSingleNodePointer();
    if (pointer == null) {
        return Boolean.FALSE;
    }
    return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionLang(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionLang(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionID(EvalContext)","Method","* id() implementation.
     * @param context evaluation context
     * @return Pointer","protected Object functionID(final EvalContext context) {
    assertArgCount(1);
    final String id = InfoSetUtil.stringValue(getArg1().computeValue(context));
    final JXPathContext jxpathContext = context.getJXPathContext();
    final NodePointer pointer = (NodePointer) jxpathContext.getContextPointer();
    return pointer.getPointerByID(jxpathContext, id);
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionID(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionID(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionKey(EvalContext)","Method","* key() implementation.
     * @param context evaluation context
     * @return various Object","protected Object functionKey(final EvalContext context) {
    assertArgCount(2);
    final String key = InfoSetUtil.stringValue(getArg1().computeValue(context));
    Object value = getArg2().compute(context);
    EvalContext ec = null;
    if (value instanceof EvalContext) {
        ec = (EvalContext) value;
        if (ec.hasNext()) {
            value = ((NodePointer) ec.next()).getValue();
        } else {
            // empty context -> empty results
            return new NodeSetContext(context, new BasicNodeSet());
        }
    }
    final JXPathContext jxpathContext = context.getJXPathContext();
    NodeSet nodeSet = jxpathContext.getNodeSetByKey(key, value);
    if (ec != null && ec.hasNext()) {
        final BasicNodeSet accum = new BasicNodeSet();
        accum.add(nodeSet);
        while (ec.hasNext()) {
            value = ((NodePointer) ec.next()).getValue();
            accum.add(jxpathContext.getNodeSetByKey(key, value));
        }
        nodeSet = accum;
    }
    return new NodeSetContext(context, nodeSet);
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionKey(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionKey(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNamespaceURI(EvalContext)","Method","* namespace-uri() implementation.
     * @param context evaluation context
     * @return String","protected Object functionNamespaceURI(final EvalContext context) {
    if (getArgumentCount() == 0) {
        final NodePointer ptr = context.getCurrentNodePointer();
        final String str = ptr.getNamespaceURI();
        return str == null ? """" : str;
    }
    assertArgCount(1);
    final Object set = getArg1().compute(context);
    if (set instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) set;
        if (ctx.hasNext()) {
            final NodePointer ptr = (NodePointer) ctx.next();
            final String str = ptr.getNamespaceURI();
            return str == null ? """" : str;
        }
    }
    return """";
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNamespaceURI(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNamespaceURI(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionLocalName(EvalContext)","Method","* local-name() implementation.
     * @param context evaluation context
     * @return String","protected Object functionLocalName(final EvalContext context) {
    if (getArgumentCount() == 0) {
        final NodePointer ptr = context.getCurrentNodePointer();
        return ptr.getName().getName();
    }
    assertArgCount(1);
    final Object set = getArg1().compute(context);
    if (set instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) set;
        if (ctx.hasNext()) {
            final NodePointer ptr = (NodePointer) ctx.next();
            return ptr.getName().getName();
        }
    }
    return """";
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionLocalName(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionLocalName(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionName(EvalContext)","Method","* name() implementation.
     * @param context evaluation context
     * @return String","protected Object functionName(final EvalContext context) {
    if (getArgumentCount() == 0) {
        final NodePointer ptr = context.getCurrentNodePointer();
        return ptr.getName().toString();
    }
    assertArgCount(1);
    final Object set = getArg1().compute(context);
    if (set instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) set;
        if (ctx.hasNext()) {
            final NodePointer ptr = (NodePointer) ctx.next();
            return ptr.getName().toString();
        }
    }
    return """";
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionName(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionName(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionString(EvalContext)","Method","* string() implementation.
     * @param context evaluation context
     * @return String","protected Object functionString(final EvalContext context) {
    if (getArgumentCount() == 0) {
        return InfoSetUtil.stringValue(context.getCurrentNodePointer());
    }
    assertArgCount(1);
    return InfoSetUtil.stringValue(getArg1().computeValue(context));
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionString(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionString(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionConcat(EvalContext)","Method","* concat() implementation.
     * @param context evaluation context
     * @return String","protected Object functionConcat(final EvalContext context) {
    if (getArgumentCount() < 2) {
        assertArgCount(2);
    }
    final StringBuilder buffer = new StringBuilder();
    final Expression[] args = getArguments();
    for (final Expression arg : args) {
        buffer.append(InfoSetUtil.stringValue(arg.compute(context)));
    }
    return buffer.toString();
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionConcat(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionConcat(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionStartsWith(EvalContext)","Method","* starts-with() implementation.
     * @param context evaluation context
     * @return Boolean","protected Object functionStartsWith(final EvalContext context) {
    assertArgCount(2);
    final String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));
    final String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));
    return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionStartsWith(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionStartsWith(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionEndsWith(EvalContext)","Method","* ends-with() implementation.
     * @param context evaluation context
     * @return Boolean
     * @since 1.4","protected Object functionEndsWith(final EvalContext context) {
    assertArgCount(2);
    final String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));
    final String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));
    return s1.endsWith(s2) ? Boolean.TRUE : Boolean.FALSE;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionEndsWith(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionEndsWith(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionContains(EvalContext)","Method","* contains() implementation.
     * @param context evaluation context
     * @return Boolean","protected Object functionContains(final EvalContext context) {
    assertArgCount(2);
    final String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));
    final String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));
    return Boolean.valueOf(s1.contains(s2));
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionContains(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionContains(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSubstringBefore(EvalContext)","Method","* substring-before() implementation.
     * @param context evaluation context
     * @return String","protected Object functionSubstringBefore(final EvalContext context) {
    assertArgCount(2);
    final String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));
    final String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));
    final int index = s1.indexOf(s2);
    if (index == -1) {
        return """";
    }
    return s1.substring(0, index);
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSubstringBefore(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSubstringBefore(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSubstringAfter(EvalContext)","Method","* substring-after() implementation.
     * @param context evaluation context
     * @return String","protected Object functionSubstringAfter(final EvalContext context) {
    assertArgCount(2);
    final String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));
    final String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));
    final int index = s1.indexOf(s2);
    if (index == -1) {
        return """";
    }
    return s1.substring(index + s2.length());
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSubstringAfter(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSubstringAfter(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSubstring(EvalContext)","Method","* substring() implementation.
     * @param context evaluation context
     * @return String","protected Object functionSubstring(final EvalContext context) {
    final int minArgs = 2;
    final int maxArgs = 3;
    assertArgRange(minArgs, maxArgs);
    final int ac = getArgumentCount();
    final String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));
    double from = InfoSetUtil.doubleValue(getArg2().computeValue(context));
    if (Double.isNaN(from)) {
        return """";
    }
    from = Math.round(from);
    if (from > s1.length() + 1) {
        return """";
    }
    if (ac == 2) {
        if (from < 1) {
            from = 1;
        }
        return s1.substring((int) from - 1);
    }
    double length = InfoSetUtil.doubleValue(getArg3().computeValue(context));
    length = Math.round(length);
    if (length < 0) {
        return """";
    }
    final double to = from + length;
    if (to < 1) {
        return """";
    }
    if (to > s1.length() + 1) {
        if (from < 1) {
            from = 1;
        }
        return s1.substring((int) from - 1);
    }
    if (from < 1) {
        from = 1;
    }
    return s1.substring((int) from - 1, (int) (to - 1));
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSubstring(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSubstring(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionStringLength(EvalContext)","Method","* string-length() implementation.
     * @param context evaluation context
     * @return Number","protected Object functionStringLength(final EvalContext context) {
    String s;
    if (getArgumentCount() == 0) {
        s = InfoSetUtil.stringValue(context.getCurrentNodePointer());
    } else {
        assertArgCount(1);
        s = InfoSetUtil.stringValue(getArg1().computeValue(context));
    }
    return Double.valueOf(s.length());
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionStringLength(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionStringLength(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNormalizeSpace(EvalContext)","Method","* normalize-space() implementation.
     * @param context evaluation context
     * @return String","protected Object functionNormalizeSpace(final EvalContext context) {
    assertArgCount(1);
    final String s = InfoSetUtil.stringValue(getArg1().computeValue(context));
    final char[] chars = s.toCharArray();
    int out = 0;
    int phase = 0;
    for (int in = 0; in < chars.length; in++) {
        switch(chars[in]) {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                if (phase == 1) {
                    // non-space
                    phase = 2;
                    chars[out++] = ' ';
                }
                break;
            default:
                chars[out++] = chars[in];
                phase = 1;
        }
    }
    if (phase == 2) {
        // trailing-space
        out--;
    }
    return new String(chars, 0, out);
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNormalizeSpace(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNormalizeSpace(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionTranslate(EvalContext)","Method","* translate() implementation.
     * @param context evaluation context
     * @return String","protected Object functionTranslate(final EvalContext context) {
    final int argCount = 3;
    assertArgCount(argCount);
    final String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));
    final String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));
    final String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context));
    final char[] chars = s1.toCharArray();
    int out = 0;
    for (int in = 0; in < chars.length; in++) {
        final char c = chars[in];
        final int inx = s2.indexOf(c);
        if (inx != -1) {
            if (inx < s3.length()) {
                chars[out++] = s3.charAt(inx);
            }
        } else {
            chars[out++] = c;
        }
    }
    return new String(chars, 0, out);
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionTranslate(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionTranslate(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionBoolean(EvalContext)","Method","* boolean() implementation.
     * @param context evaluation context
     * @return Boolean","protected Object functionBoolean(final EvalContext context) {
    assertArgCount(1);
    return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionBoolean(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionBoolean(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNot(EvalContext)","Method","* not() implementation.
     * @param context evaluation context
     * @return Boolean","protected Object functionNot(final EvalContext context) {
    assertArgCount(1);
    return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.FALSE : Boolean.TRUE;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNot(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNot(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionTrue(EvalContext)","Method","* true() implementation.
     * @param context evaluation context
     * @return Boolean.TRUE","protected Object functionTrue(final EvalContext context) {
    assertArgCount(0);
    return Boolean.TRUE;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionTrue(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionTrue(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionFalse(EvalContext)","Method","* false() implementation.
     * @param context evaluation context
     * @return Boolean.FALSE","protected Object functionFalse(final EvalContext context) {
    assertArgCount(0);
    return Boolean.FALSE;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionFalse(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionFalse(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNull(EvalContext)","Method","* null() implementation.
     * @param context evaluation context
     * @return null","protected Object functionNull(final EvalContext context) {
    assertArgCount(0);
    return null;
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNull(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNull(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNumber(EvalContext)","Method","* number() implementation.
     * @param context evaluation context
     * @return Number","protected Object functionNumber(final EvalContext context) {
    if (getArgumentCount() == 0) {
        return InfoSetUtil.number(context.getCurrentNodePointer());
    }
    assertArgCount(1);
    return InfoSetUtil.number(getArg1().computeValue(context));
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNumber(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionNumber(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSum(EvalContext)","Method","* sum() implementation.
     * @param context evaluation context
     * @return Number","protected Object functionSum(final EvalContext context) {
    assertArgCount(1);
    final Object v = getArg1().compute(context);
    if (v == null) {
        return ZERO;
    }
    if (v instanceof EvalContext) {
        double sum = 0.0;
        final EvalContext ctx = (EvalContext) v;
        while (ctx.hasNext()) {
            final NodePointer ptr = (NodePointer) ctx.next();
            sum += InfoSetUtil.doubleValue(ptr);
        }
        return Double.valueOf(sum);
    }
    throw new JXPathException(""Invalid argument type for 'sum': "" + v.getClass().getName());
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSum(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionSum(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionFloor(EvalContext)","Method","* floor() implementation.
     * @param context evaluation context
     * @return Number","protected Object functionFloor(final EvalContext context) {
    assertArgCount(1);
    final double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
    if (Double.isNaN(v) || Double.isInfinite(v)) {
        return Double.valueOf(v);
    }
    return Double.valueOf(Math.floor(v));
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionFloor(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionFloor(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionCeiling(EvalContext)","Method","* ceiling() implementation.
     * @param context evaluation context
     * @return Number","protected Object functionCeiling(final EvalContext context) {
    assertArgCount(1);
    final double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
    if (Double.isNaN(v) || Double.isInfinite(v)) {
        return Double.valueOf(v);
    }
    return Double.valueOf(Math.ceil(v));
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionCeiling(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionCeiling(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionRound(EvalContext)","Method","* round() implementation.
     * @param context evaluation context
     * @return Number","protected Object functionRound(final EvalContext context) {
    assertArgCount(1);
    final double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
    if (Double.isNaN(v) || Double.isInfinite(v)) {
        return Double.valueOf(v);
    }
    return Double.valueOf(Math.round(v));
}","Object","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionRound(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionRound(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionFormatNumber(EvalContext)","Method","* format-number() implementation.
     * @param context evaluation context
     * @return String","private Object functionFormatNumber(final EvalContext context) {
    final int minArgs = 2;
    final int maxArgs = 3;
    assertArgRange(minArgs, maxArgs);
    final double number = InfoSetUtil.doubleValue(getArg1().computeValue(context));
    final String pattern = InfoSetUtil.stringValue(getArg2().computeValue(context));
    DecimalFormatSymbols symbols;
    if (getArgumentCount() == maxArgs) {
        final String symbolsName = InfoSetUtil.stringValue(getArg3().computeValue(context));
        symbols = context.getJXPathContext().getDecimalFormatSymbols(symbolsName);
    } else {
        final NodePointer pointer = context.getCurrentNodePointer();
        Locale locale;
        if (pointer != null) {
            locale = pointer.getLocale();
        } else {
            locale = context.getJXPathContext().getLocale();
        }
        symbols = new DecimalFormatSymbols(locale);
    }
    final DecimalFormat format = (DecimalFormat) NumberFormat.getInstance();
    format.setDecimalFormatSymbols(symbols);
    format.applyLocalizedPattern(pattern);
    return format.format(number);
}","Object","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.functionFormatNumber(EvalContext).context","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.functionFormatNumber(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.assertArgCount(int)","Method","* Assert {@code count} args.
     * @param count int","private void assertArgCount(final int count) {
    assertArgRange(count, count);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.assertArgCount(int).count","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.assertArgCount(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.assertArgRange(int,int)","Method","* Assert at least {@code min}/at most {@code max} args.
     * @param min int
     * @param max int","private void assertArgRange(final int min, final int max) {
    final int ct = getArgumentCount();
    if (ct < min || ct > max) {
        throw new JXPathInvalidSyntaxException(""Incorrect number of arguments: "" + this);
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.assertArgRange(int,int).min","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.assertArgRange(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.assertArgRange(int,int).max","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.assertArgRange(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.<init>(int,Expression[])","Constructor","* Create a new CoreFunction.
     * @param functionCode int function code
     * @param args argument Expressions","public CoreFunction(final int functionCode, final Expression[] args) {
    super(args);
    this.functionCode = functionCode;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.<init>(int,Expression[]).functionCode","Parameter_1","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.<init>(int,Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.compiler.CoreFunction.<init>(int,Expression[]).args","Parameter_2","Belong to org.apache.commons.jxpath.ri.compiler.CoreFunction.<init>(int,Expression[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl","Class","* The reference implementation of JXPathContext.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.JXPathContext",""
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.USE_SOFT_CACHE","Field","* Change this to {@code false} to disable soft caching of
     * CompiledExpressions.","public static final boolean USE_SOFT_CACHE = true;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.COMPILER","Field","No Comment","private static final Compiler COMPILER = new TreeCompiler();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.compiled","Field","No Comment","private static Map compiled = new HashMap();","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.cleanupCount","Field","No Comment","private static int cleanupCount = 0;","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.nodeFactoryArray","Field","No Comment","private static NodePointerFactory[] nodeFactoryArray = null;","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.CLEANUP_THRESHOLD","Field","The frequency of the cache cleanup","private static final int CLEANUP_THRESHOLD = 500;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.nodeFactories","Field","No Comment","private static final Vector nodeFactories = new Vector();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.namespaceResolver","Field","Namespace resolver","protected NamespaceResolver namespaceResolver;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.rootPointer","Field","No Comment","private Pointer rootPointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.contextPointer","Field","No Comment","private Pointer contextPointer;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createNodeFactoryArray()","Method","* Create the default node factory array.","private static synchronized void createNodeFactoryArray() {
    if (nodeFactoryArray == null) {
        nodeFactoryArray = (NodePointerFactory[]) nodeFactories.toArray(new NodePointerFactory[nodeFactories.size()]);
        Arrays.sort(nodeFactoryArray, (a, b) -> {
            final int orderA = ((NodePointerFactory) a).getOrder();
            final int orderB = ((NodePointerFactory) b).getOrder();
            return orderA - orderB;
        });
    }
}","void","private , static , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.addNodePointerFactory(NodePointerFactory)","Method","* Call this with a custom NodePointerFactory to add support for
     * additional types of objects.  Make sure the factory returns
     * a name that puts it in the right position on the list of factories.
     * @param factory NodePointerFactory to add","public static void addNodePointerFactory(final NodePointerFactory factory) {
    synchronized (nodeFactories) {
        nodeFactories.add(factory);
        nodeFactoryArray = null;
    }
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.addNodePointerFactory(NodePointerFactory).factory","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.addNodePointerFactory(NodePointerFactory)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeNodePointerFactory(NodePointerFactory)","Method","* Removes support for additional types of objects.
     *
     * @param factory NodePointerFactory to remove
     * @return true if this implementation contained the specified element
     * @since 1.4.0","public static boolean removeNodePointerFactory(final NodePointerFactory factory) {
    synchronized (nodeFactories) {
        final boolean remove = nodeFactories.remove(factory);
        nodeFactoryArray = null;
        return remove;
    }
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeNodePointerFactory(NodePointerFactory).factory","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeNodePointerFactory(NodePointerFactory)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getNodePointerFactories()","Method","* Gets the registered NodePointerFactories.
     * @return NodePointerFactory[]","public static NodePointerFactory[] getNodePointerFactories() {
    return nodeFactoryArray;
}","NodePointerFactory[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getCompiler()","Method","* Returns a static instance of TreeCompiler.
     *
     * Override this to return an alternate compiler.
     * @return Compiler","protected Compiler getCompiler() {
    return COMPILER;
}","Compiler","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.compilePath(String)","Method","No Comment","@Override
protected CompiledExpression compilePath(final String xpath) {
    return new JXPathCompiledExpression(xpath, compileExpression(xpath));
}","CompiledExpression","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.compilePath(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.compilePath(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.compileExpression(String)","Method","* Compile the given expression.
     * @param xpath to compile
     * @return Expression","private Expression compileExpression(final String xpath) {
    Expression expr;
    synchronized (compiled) {
        if (USE_SOFT_CACHE) {
            expr = null;
            final SoftReference ref = (SoftReference) compiled.get(xpath);
            if (ref != null) {
                expr = (Expression) ref.get();
            }
        } else {
            expr = (Expression) compiled.get(xpath);
        }
    }
    if (expr != null) {
        return expr;
    }
    expr = (Expression) Parser.parseExpression(xpath, getCompiler());
    synchronized (compiled) {
        if (USE_SOFT_CACHE) {
            if (cleanupCount++ >= CLEANUP_THRESHOLD) {
                final Iterator it = compiled.entrySet().iterator();
                while (it.hasNext()) {
                    final Entry me = (Entry) it.next();
                    if (((SoftReference) me.getValue()).get() == null) {
                        it.remove();
                    }
                }
                cleanupCount = 0;
            }
            compiled.put(xpath, new SoftReference(expr));
        } else {
            compiled.put(xpath, expr);
        }
    }
    return expr;
}","Expression","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.compileExpression(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.compileExpression(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String)","Method","* Traverses the xpath and returns the resulting object. Primitive
     * types are wrapped into objects.
     * @param xpath expression
     * @return Object found","@Override
public Object getValue(final String xpath) {
    final Expression expression = compileExpression(xpath);
    // TODO: (work in progress) - trying to integrate with Xalan
    //        Object ctxNode = getNativeContextNode(expression);
    //        if (ctxNode != null) {
    //            System.err.println(""WILL USE XALAN: "" + xpath);
    //            CachedXPathAPI api = new CachedXPathAPI();
    //            try {
    //                if (expression instanceof Path) {
    //                    Node node = api.selectSingleNode((Node)ctxNode, xpath);
    //                    System.err.println(""NODE: "" + node);
    //                    if (node == null) {
    //                        return null;
    //                    }
    //                    return new DOMNodePointer(node, null).getValue();
    //                }
    //                else {
    //                    XObject object = api.eval((Node)ctxNode, xpath);
    //                    switch (object.getType()) {
    //                    case XObject.CLASS_STRING: return object.str();
    //                    case XObject.CLASS_NUMBER: return new Double(object.num());
    //                    case XObject.CLASS_BOOLEAN: return new Boolean(object.bool());
    //                    default:
    //                        System.err.println(""OTHER TYPE: "" + object.getTypeString());
    //                    }
    //                }
    //            }
    //            catch (TransformerException e) {
    //                // TODO Auto-generated catch block
    //                e.printStackTrace();
    //            }
    //            return
    //        }
    return getValue(xpath, expression);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression)","Method","* Gets the value indicated.
     * @param xpath String
     * @param expr Expression
     * @return Object","public Object getValue(final String xpath, final Expression expr) {
    Object result = expr.computeValue(getEvalContext());
    if (result == null) {
        if (expr instanceof Path && !isLenient()) {
            throw new JXPathNotFoundException(""No value for xpath: "" + xpath);
        }
        return null;
    }
    if (result instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) result;
        result = ctx.getSingleNodePointer();
        if (!isLenient() && result == null) {
            throw new JXPathNotFoundException(""No value for xpath: "" + xpath);
        }
    }
    if (result instanceof NodePointer) {
        result = ((NodePointer) result).getValuePointer();
        if (!isLenient()) {
            NodePointer.verify((NodePointer) result);
        }
        result = ((NodePointer) result).getValue();
    }
    return result;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Class)","Method","* Calls getValue(xpath), converts the result to the required type
     * and returns the result of the conversion.
     * @param xpath expression
     * @param requiredType Class
     * @return Object","@Override
public Object getValue(final String xpath, final Class requiredType) {
    final Expression expr = compileExpression(xpath);
    return getValue(xpath, expr, requiredType);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Class).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Class).requiredType","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression,Class)","Method","* Gets the value indicated.
     * @param xpath expression
     * @param expr compiled Expression
     * @param requiredType Class
     * @return Object","public Object getValue(final String xpath, final Expression expr, final Class requiredType) {
    Object value = getValue(xpath, expr);
    if (value != null && requiredType != null) {
        if (!TypeUtils.canConvert(value, requiredType)) {
            throw new JXPathTypeConversionException(""Invalid expression type. '"" + xpath + ""' returns "" + value.getClass().getName() + "". It cannot be converted to "" + requiredType.getName());
        }
        value = TypeUtils.convert(value, requiredType);
    }
    return value;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression,Class).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression,Class).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression,Class).requiredType","Parameter_3","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(String,Expression,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iterate(String)","Method","* Traverses the xpath and returns a Iterator of all results found
     * for the path. If the xpath matches no properties
     * in the graph, the Iterator will not be null.
     * @param xpath expression
     * @return Iterator","@Override
public Iterator iterate(final String xpath) {
    return iterate(xpath, compileExpression(xpath));
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iterate(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iterate(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iterate(String,Expression)","Method","* Traverses the xpath and returns a Iterator of all results found
     * for the path. If the xpath matches no properties
     * in the graph, the Iterator will not be null.
     * @param xpath expression
     * @param expr compiled Expression
     * @return Iterator","public Iterator iterate(final String xpath, final Expression expr) {
    return expr.iterate(getEvalContext());
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iterate(String,Expression).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iterate(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iterate(String,Expression).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iterate(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPointer(String)","Method","No Comment","@Override
public Pointer getPointer(final String xpath) {
    return getPointer(xpath, compileExpression(xpath));
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPointer(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPointer(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPointer(String,Expression)","Method","* Gets a pointer to the specified path/expression.
     * @param xpath String
     * @param expr compiled Expression
     * @return Pointer","public Pointer getPointer(final String xpath, final Expression expr) {
    Object result = expr.computeValue(getEvalContext());
    if (result instanceof EvalContext) {
        result = ((EvalContext) result).getSingleNodePointer();
    }
    if (result instanceof Pointer) {
        if (!isLenient() && !((NodePointer) result).isActual()) {
            throw new JXPathNotFoundException(""No pointer for xpath: "" + xpath);
        }
        return (Pointer) result;
    }
    return NodePointer.newNodePointer(null, result, getLocale());
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPointer(String,Expression).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPointer(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPointer(String,Expression).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPointer(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Object)","Method","No Comment","@Override
public void setValue(final String xpath, final Object value) {
    setValue(xpath, compileExpression(xpath), value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Object).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object)","Method","* Sets the value of xpath to value.
     * @param xpath path
     * @param expr compiled Expression
     * @param value Object","public void setValue(final String xpath, final Expression expr, final Object value) {
    try {
        setValue(xpath, expr, value, false);
    } catch (final Throwable ex) {
        throw new JXPathException(""Exception trying to set value with xpath "" + xpath, ex);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(String)","Method","No Comment","@Override
public Pointer createPath(final String xpath) {
    return createPath(xpath, compileExpression(xpath));
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(String,Expression)","Method","* Create the given path.
     * @param xpath String
     * @param expr compiled Expression
     * @return resulting Pointer","public Pointer createPath(final String xpath, final Expression expr) {
    try {
        final Object result = expr.computeValue(getEvalContext());
        Pointer pointer;
        if (result instanceof Pointer) {
            pointer = (Pointer) result;
        } else if (result instanceof EvalContext) {
            final EvalContext ctx = (EvalContext) result;
            pointer = ctx.getSingleNodePointer();
        } else {
            checkSimplePath(expr);
            // This should never happen
            throw new JXPathException(""Cannot create path:"" + xpath);
        }
        return ((NodePointer) pointer).createPath(this);
    } catch (final Throwable ex) {
        throw new JXPathException(""Exception trying to create xpath "" + xpath, ex);
    }
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(String,Expression).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(String,Expression).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Object)","Method","No Comment","@Override
public Pointer createPathAndSetValue(final String xpath, final Object value) {
    return createPathAndSetValue(xpath, compileExpression(xpath), value);
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Object).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Expression,Object)","Method","* Create the given path setting its value to value.
     * @param xpath String
     * @param expr compiled Expression
     * @param value Object
     * @return resulting Pointer","public Pointer createPathAndSetValue(final String xpath, final Expression expr, final Object value) {
    try {
        return setValue(xpath, expr, value, true);
    } catch (final Throwable ex) {
        throw new JXPathException(""Exception trying to create xpath "" + xpath, ex);
    }
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Expression,Object).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Expression,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Expression,Object).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Expression,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Expression,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(String,Expression,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object,boolean)","Method","* Sets the specified value.
     * @param xpath path
     * @param expr compiled Expression
     * @param value destination value
     * @param create whether to create missing node(s)
     * @return Pointer created","private Pointer setValue(final String xpath, final Expression expr, final Object value, final boolean create) {
    final Object result = expr.computeValue(getEvalContext());
    Pointer pointer;
    if (result instanceof Pointer) {
        pointer = (Pointer) result;
    } else if (result instanceof EvalContext) {
        final EvalContext ctx = (EvalContext) result;
        pointer = ctx.getSingleNodePointer();
    } else {
        if (create) {
            checkSimplePath(expr);
        }
        // This should never happen
        throw new JXPathException(""Cannot set value for xpath: "" + xpath);
    }
    if (create) {
        pointer = ((NodePointer) pointer).createPath(this, value);
    } else {
        pointer.setValue(value);
    }
    return pointer;
}","Pointer","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object,boolean).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object,boolean).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object,boolean).value","Parameter_3","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object,boolean).create","Parameter_4","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setValue(String,Expression,Object,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.checkSimplePath(Expression)","Method","* Checks if the path follows the JXPath restrictions on the type
     * of path that can be passed to create... methods.
     * @param expr Expression to check","private void checkSimplePath(final Expression expr) {
    if (!(expr instanceof LocationPath) || !((LocationPath) expr).isSimplePath()) {
        throw new JXPathInvalidSyntaxException(""JXPath can only create a path if it uses exclusively "" + ""the child:: and attribute:: axes and has "" + ""no context-dependent predicates"");
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.checkSimplePath(Expression).expr","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.checkSimplePath(Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iteratePointers(String)","Method","* Traverses the xpath and returns an Iterator of Pointers.
     * A Pointer provides easy access to a property.
     * If the xpath matches no properties
     * in the graph, the Iterator be empty, but not null.
     * @param xpath expression
     * @return Iterator","@Override
public Iterator iteratePointers(final String xpath) {
    return iteratePointers(xpath, compileExpression(xpath));
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iteratePointers(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iteratePointers(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iteratePointers(String,Expression)","Method","* Traverses the xpath and returns an Iterator of Pointers.
     * A Pointer provides easy access to a property.
     * If the xpath matches no properties
     * in the graph, the Iterator be empty, but not null.
     * @param xpath expression
     * @param expr compiled Expression
     * @return Iterator","public Iterator iteratePointers(final String xpath, final Expression expr) {
    return expr.iteratePointers(getEvalContext());
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iteratePointers(String,Expression).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iteratePointers(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iteratePointers(String,Expression).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iteratePointers(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removePath(String)","Method","No Comment","@Override
public void removePath(final String xpath) {
    removePath(xpath, compileExpression(xpath));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removePath(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removePath(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removePath(String,Expression)","Method","* Remove the specified path.
     * @param xpath expression
     * @param expr compiled Expression","public void removePath(final String xpath, final Expression expr) {
    try {
        final NodePointer pointer = (NodePointer) getPointer(xpath, expr);
        if (pointer != null) {
            pointer.remove();
        }
    } catch (final Throwable ex) {
        throw new JXPathException(""Exception trying to remove xpath "" + xpath, ex);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removePath(String,Expression).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removePath(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removePath(String,Expression).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removePath(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeAll(String)","Method","No Comment","@Override
public void removeAll(final String xpath) {
    removeAll(xpath, compileExpression(xpath));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeAll(String).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeAll(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeAll(String,Expression)","Method","* Remove all matching nodes.
     * @param xpath expression
     * @param expr compiled Expression","public void removeAll(final String xpath, final Expression expr) {
    try {
        final ArrayList list = new ArrayList();
        Iterator it = expr.iteratePointers(getEvalContext());
        while (it.hasNext()) {
            list.add(it.next());
        }
        Collections.sort(list, ReverseComparator.INSTANCE);
        it = list.iterator();
        if (it.hasNext()) {
            final NodePointer pointer = (NodePointer) it.next();
            pointer.remove();
            while (it.hasNext()) {
                removePath(((NodePointer) it.next()).asPath());
            }
        }
    } catch (final Throwable ex) {
        throw new JXPathException(""Exception trying to remove all for xpath "" + xpath, ex);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeAll(String,Expression).xpath","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeAll(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeAll(String,Expression).expr","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.removeAll(String,Expression)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getRelativeContext(Pointer)","Method","No Comment","@Override
public JXPathContext getRelativeContext(final Pointer pointer) {
    final Object contextBean = pointer.getNode();
    if (contextBean == null) {
        throw new JXPathException(""Cannot create a relative context for a non-existent node: "" + pointer);
    }
    return new JXPathContextReferenceImpl(this, contextBean, pointer);
}","JXPathContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getRelativeContext(Pointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getRelativeContext(Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getContextPointer()","Method","No Comment","@Override
public Pointer getContextPointer() {
    return contextPointer;
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getAbsoluteRootPointer()","Method","* Gets absolute root pointer.
     * @return NodePointer","private NodePointer getAbsoluteRootPointer() {
    return (NodePointer) rootPointer;
}","NodePointer","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getEvalContext()","Method","* Gets the evaluation context.
     * @return EvalContext","private EvalContext getEvalContext() {
    return new InitialContext(new RootContext(this, (NodePointer) getContextPointer()));
}","EvalContext","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getAbsoluteRootContext()","Method","* Gets the absolute root context.
     * @return EvalContext","public EvalContext getAbsoluteRootContext() {
    return new InitialContext(new RootContext(this, getAbsoluteRootPointer()));
}","EvalContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getVariablePointer(QName)","Method","* Gets a VariablePointer for the given variable name.
     * @param name variable name
     * @return NodePointer","public NodePointer getVariablePointer(final QName name) {
    return NodePointer.newNodePointer(name, VariablePointerFactory.contextWrapper(this), getLocale());
}","NodePointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getVariablePointer(QName).name","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getVariablePointer(QName)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getFunction(QName,Object[])","Method","* Gets the named Function.
     * @param functionName name
     * @param parameters function args
     * @return Function","public Function getFunction(final QName functionName, final Object[] parameters) {
    final String namespace = functionName.getPrefix();
    final String name = functionName.getName();
    JXPathContext funcCtx = this;
    Function func;
    Functions funcs;
    while (funcCtx != null) {
        funcs = funcCtx.getFunctions();
        if (funcs != null) {
            func = funcs.getFunction(namespace, name, parameters);
            if (func != null) {
                return func;
            }
        }
        funcCtx = funcCtx.getParentContext();
    }
    throw new JXPathFunctionNotFoundException(""Undefined function: "" + functionName.toString());
}","Function","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getFunction(QName,Object[]).functionName","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getFunction(QName,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getFunction(QName,Object[]).parameters","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getFunction(QName,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.registerNamespace(String,String)","Method","No Comment","@Override
public void registerNamespace(final String prefix, final String namespaceURI) {
    if (namespaceResolver.isSealed()) {
        namespaceResolver = (NamespaceResolver) namespaceResolver.clone();
    }
    namespaceResolver.registerNamespace(prefix, namespaceURI);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.registerNamespace(String,String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.registerNamespace(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.registerNamespace(String,String).namespaceURI","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.registerNamespace(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getNamespaceURI(String)","Method","No Comment","@Override
public String getNamespaceURI(final String prefix) {
    return namespaceResolver.getNamespaceURI(prefix);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getNamespaceURI(String).prefix","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getNamespaceURI(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPrefix(String)","Method","* {@inheritDoc}
     * @see org.apache.commons.jxpath.JXPathContext#getPrefix(java.lang.String)","@Override
public String getPrefix(final String namespaceURI) {
    return namespaceResolver.getPrefix(namespaceURI);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPrefix(String).namespaceURI","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPrefix(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setNamespaceContextPointer(Pointer)","Method","No Comment","@Override
public void setNamespaceContextPointer(final Pointer pointer) {
    if (namespaceResolver.isSealed()) {
        namespaceResolver = (NamespaceResolver) namespaceResolver.clone();
    }
    namespaceResolver.setNamespaceContextPointer((NodePointer) pointer);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setNamespaceContextPointer(Pointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setNamespaceContextPointer(Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getNamespaceContextPointer()","Method","No Comment","@Override
public Pointer getNamespaceContextPointer() {
    return namespaceResolver.getNamespaceContextPointer();
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getNamespaceResolver()","Method","* Gets the namespace resolver.
     * @return NamespaceResolver","public NamespaceResolver getNamespaceResolver() {
    namespaceResolver.seal();
    return namespaceResolver;
}","NamespaceResolver","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setExceptionHandler(ExceptionHandler)","Method","* {@inheritDoc}","@Override
public void setExceptionHandler(final ExceptionHandler exceptionHandler) {
    if (rootPointer instanceof NodePointer) {
        ((NodePointer) rootPointer).setExceptionHandler(exceptionHandler);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setExceptionHandler(ExceptionHandler).exceptionHandler","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.setExceptionHandler(ExceptionHandler)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.allocateConditionally(String,String)","Method","* Checks if existenceCheckClass exists on the class path. If so, allocates
     * an instance of the specified class, otherwise returns null.
     * @param className to instantiate
     * @param existenceCheckClassName guard class
     * @return className instance","public static Object allocateConditionally(final String className, final String existenceCheckClassName) {
    try {
        try {
            ClassLoaderUtil.getClass(existenceCheckClassName, true);
        } catch (final ClassNotFoundException ex) {
            return null;
        }
        final Class cls = ClassLoaderUtil.getClass(className, true);
        return cls.getConstructor().newInstance();
    } catch (final Exception ex) {
        throw new JXPathException(""Cannot allocate "" + className, ex);
    }
}","Object","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.allocateConditionally(String,String).className","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.allocateConditionally(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.allocateConditionally(String,String).existenceCheckClassName","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.allocateConditionally(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object)","Constructor","* Create a new JXPathContextReferenceImpl.
     * @param parentContext parent context
     * @param contextBean Object","protected JXPathContextReferenceImpl(final JXPathContext parentContext, final Object contextBean) {
    this(parentContext, contextBean, null);
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object).contextBean","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object,Pointer)","Constructor","* Create a new JXPathContextReferenceImpl.
     * @param parentContext parent context
     * @param contextBean Object
     * @param contextPointer context pointer","public JXPathContextReferenceImpl(final JXPathContext parentContext, final Object contextBean, final Pointer contextPointer) {
    super(parentContext, contextBean);
    synchronized (nodeFactories) {
        createNodeFactoryArray();
    }
    if (contextPointer != null) {
        this.contextPointer = contextPointer;
        this.rootPointer = NodePointer.newNodePointer(new QName(null, ""root""), contextPointer.getRootNode(), getLocale());
    } else {
        this.contextPointer = NodePointer.newNodePointer(new QName(null, ""root""), contextBean, getLocale());
        this.rootPointer = this.contextPointer;
    }
    NamespaceResolver parentNR = null;
    if (parentContext instanceof JXPathContextReferenceImpl) {
        parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver();
    }
    namespaceResolver = new NamespaceResolver(parentNR);
    namespaceResolver.setNamespaceContextPointer((NodePointer) this.contextPointer);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object,Pointer).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object,Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object,Pointer).contextBean","Parameter_2","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object,Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object,Pointer).contextPointer","Parameter_3","Belong to org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContext,Object,Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext","Abstract Class","* An XPath evaluation context.
 *
 * When  evaluating a path, a chain of EvalContexts is created, each context in
 * the chain representing a step of the path. Subclasses of EvalContext
 * implement behavior of various XPath axes: ""child::"", ""parent::"" etc.","Abstract Class do not obtain Source Code","No return type","public , abstract ","","org.apache.commons.jxpath.ExpressionContext;java.util.Iterator"
"org.apache.commons.jxpath.ri.EvalContext.parentContext","Field","Parent context","protected EvalContext parentContext;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.rootContext","Field","Root context","protected RootContext rootContext;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.position","Field","Position","protected int position = 0;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.startedSetIteration","Field","No Comment","private boolean startedSetIteration = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.done","Field","No Comment","private boolean done = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.hasPerformedIteratorStep","Field","No Comment","private boolean hasPerformedIteratorStep = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.pointerIterator","Field","No Comment","private Iterator<Pointer> pointerIterator;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getContextNodePointer()","Method","No Comment","@Override
public Pointer getContextNodePointer() {
    return getCurrentNodePointer();
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getJXPathContext()","Method","No Comment","@Override
public JXPathContext getJXPathContext() {
    return getRootContext().getJXPathContext();
}","JXPathContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getPosition()","Method","No Comment","@Override
public int getPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getDocumentOrder()","Method","* Determines the document order for this context.
     *
     * @return 1 ascending order, -1 descending order,
     *  0 - does not require ordering","public int getDocumentOrder() {
    return parentContext != null && parentContext.isChildOrderingRequired() ? 1 : 0;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.isChildOrderingRequired()","Method","* Even if this context has the natural ordering and therefore does
     * not require collecting and sorting all nodes prior to returning them,
     * such operation may be required for any child context.
     * @return boolean","public boolean isChildOrderingRequired() {
    // Default behavior: if this context needs to be ordered,
    // the children need to be ordered too
    return getDocumentOrder() != 0;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.hasNext()","Method","* Returns true if there are mode nodes matching the context's constraints.
     * @return boolean","@Override
public boolean hasNext() {
    if (pointerIterator != null) {
        return pointerIterator.hasNext();
    }
    if (getDocumentOrder() != 0) {
        return constructIterator();
    }
    if (!done && !hasPerformedIteratorStep) {
        performIteratorStep();
    }
    return !done;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.next()","Method","* Returns the next node pointer in the context
     * @return Object","@Override
public Object next() {
    if (pointerIterator != null) {
        return pointerIterator.next();
    }
    if (getDocumentOrder() != 0) {
        if (!constructIterator()) {
            throw new NoSuchElementException();
        }
        return pointerIterator.next();
    }
    if (!done && !hasPerformedIteratorStep) {
        performIteratorStep();
    }
    if (done) {
        throw new NoSuchElementException();
    }
    hasPerformedIteratorStep = false;
    return getCurrentNodePointer();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.performIteratorStep()","Method","* Moves the iterator forward by one position","private void performIteratorStep() {
    done = true;
    if (position != 0 && nextNode()) {
        done = false;
    } else {
        while (nextSet()) {
            if (nextNode()) {
                done = false;
                break;
            }
        }
    }
    hasPerformedIteratorStep = true;
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.remove()","Method","* Operation is not supported
     * @throws UnsupportedOperationException Always thrown.","@Override
public void remove() {
    throw new UnsupportedOperationException(""JXPath iterators cannot remove nodes"");
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.constructIterator()","Method","* Constructs an iterator.
     * @return whether the Iterator was constructed","private boolean constructIterator() {
    final HashSet<Pointer> set = new HashSet<>();
    final ArrayList<Pointer> list = new ArrayList<>();
    while (nextSet()) {
        while (nextNode()) {
            final NodePointer pointer = getCurrentNodePointer();
            if (!set.contains(pointer)) {
                set.add(pointer);
                list.add(pointer);
            }
        }
    }
    if (list.isEmpty()) {
        return false;
    }
    sortPointers(list);
    pointerIterator = list.iterator();
    return true;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.sortPointers(List)","Method","* Sort a list of pointers based on document order.
     * @param l the list to sort.","protected void sortPointers(final List l) {
    switch(getDocumentOrder()) {
        case 1:
            Collections.sort(l);
            break;
        case -1:
            Collections.sort(l, ReverseComparator.INSTANCE);
            break;
        default:
            break;
    }
}","void","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.sortPointers(List).l","Parameter_1","Belong to org.apache.commons.jxpath.ri.EvalContext.sortPointers(List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getContextNodeList()","Method","* Returns the list of all Pointers in this context for the current
     * position of the parent context.
     * @return List","@Override
public List getContextNodeList() {
    final int pos = position;
    if (pos != 0) {
        reset();
    }
    final List<Pointer> list = new ArrayList<>();
    while (nextNode()) {
        list.add(getCurrentNodePointer());
    }
    if (pos != 0) {
        setPosition(pos);
    } else {
        reset();
    }
    return list;
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getNodeSet()","Method","* Returns the list of all Pointers in this context for all positions
     * of the parent contexts.  If there was an ongoing iteration over
     * this context, the method should not be called.
     * @return NodeSet","public NodeSet getNodeSet() {
    if (position != 0) {
        throw new JXPathException(""Simultaneous operations: "" + ""should not request pointer list while "" + ""iterating over an EvalContext"");
    }
    final BasicNodeSet set = new BasicNodeSet();
    while (nextSet()) {
        while (nextNode()) {
            set.add((Pointer) getCurrentNodePointer().clone());
        }
    }
    return set;
}","NodeSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getValue()","Method","* Typically returns the NodeSet by calling getNodeSet(),
     * but will be overridden for contexts that more naturally produce
     * individual values, e.g. VariableContext
     * @return Object","public Object getValue() {
    return getNodeSet();
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.toString()","Method","No Comment","@Override
public String toString() {
    final Pointer ptr = getContextNodePointer();
    return ptr == null ? ""Empty expression context"" : ""Expression context ["" + getPosition() + ""] "" + ptr.asPath();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getRootContext()","Method","* Returns the root context of the path, which provides easy
     * access to variables and functions.
     * @return RootContext","public RootContext getRootContext() {
    if (rootContext == null) {
        rootContext = parentContext.getRootContext();
    }
    return rootContext;
}","RootContext","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.reset()","Method","* Sets current position = 0, which is the pre-iteration state.","public void reset() {
    position = 0;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getCurrentPosition()","Method","* Gets the current position.
     * @return int position.","public int getCurrentPosition() {
    return position;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getSingleNodePointer()","Method","* Returns the first encountered Pointer that matches the current
     * context's criteria.
     * @return Pointer","public Pointer getSingleNodePointer() {
    reset();
    while (nextSet()) {
        if (nextNode()) {
            return getCurrentNodePointer();
        }
    }
    return null;
}","Pointer","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.getCurrentNodePointer()","Abstract Method","* Returns the current context node. Undefined before the beginning
     * of the iteration.
     * @return NodePoiner","public abstract NodePointer getCurrentNodePointer();","NodePointer","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.nextSet()","Method","* Returns true if there is another sets of objects to interate over.
     * Resets the current position and node.
     * @return boolean","public boolean nextSet() {
    // Restart iteration within the set
    reset();
    // Most of the time you have one set per parent node
    // First time this method is called, we should look for
    // the first parent set that contains at least one node.
    if (!startedSetIteration) {
        startedSetIteration = true;
        while (parentContext.nextSet()) {
            if (parentContext.nextNode()) {
                return true;
            }
        }
        return false;
    }
    // In subsequent calls, we see if the parent context
    // has any nodes left in the current set
    if (parentContext.nextNode()) {
        return true;
    }
    // If not, we look for the next set that contains
    // at least one node
    while (parentContext.nextSet()) {
        if (parentContext.nextNode()) {
            return true;
        }
    }
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.nextNode()","Abstract Method","* Returns true if there is another object in the current set.
     * Switches the current position and node to the next object.
     * @return boolean","public abstract boolean nextNode();","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.setPosition(int)","Method","* Moves the current position to the specified index. Used with integer
     * predicates to quickly get to the n'th element of the node set.
     * Returns false if the position is out of the node set range.
     * You can call it with 0 as the position argument to restart the iteration.
     * @param position to set
     * @return boolean","public boolean setPosition(final int position) {
    this.position = position;
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.setPosition(int).position","Parameter_1","Belong to org.apache.commons.jxpath.ri.EvalContext.setPosition(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.<init>(EvalContext)","Constructor","* Create a new EvalContext.
     * @param parentContext parent context","public EvalContext(final EvalContext parentContext) {
    this.parentContext = parentContext;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ri.EvalContext.<init>(EvalContext).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.ri.EvalContext.<init>(EvalContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Container","Interface","* A Container is an object implementing an indirection
 * mechanism transparent to JXPath.  For example, if property
 * ""foo"" of the context node has a Container as its value,
 * the XPath ""foo"" will produce the contents of that Container,
 * rather than the container itself.","Interface do not obtain Source Code","No return type","public ","java.io.Serializable",""
"org.apache.commons.jxpath.Container.getValue()","Abstract Method","* Returns the contained value.
     * @return Object value","Object getValue();","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Container.setValue(Object)","Abstract Method","* Modifies the value contained by this container.  May throw
     * UnsupportedOperationException.
     * @param value Object value to set.","void setValue(Object value);","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Container.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.Container.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DOMParser","Class","* An implementation of the XMLParser interface that produces a DOM Document.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.xml.XMLParser2",""
"org.apache.commons.jxpath.xml.DOMParser.parseXML(InputStream)","Method","No Comment","@Override
public Object parseXML(final InputStream stream) {
    try {
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(isValidating());
        factory.setNamespaceAware(isNamespaceAware());
        factory.setIgnoringElementContentWhitespace(isIgnoringElementContentWhitespace());
        factory.setExpandEntityReferences(isExpandEntityReferences());
        factory.setIgnoringComments(isIgnoringComments());
        factory.setCoalescing(isCoalescing());
        return factory.newDocumentBuilder().parse(stream);
    } catch (final Exception ex) {
        throw new JXPathException(""DOM parser error"", ex);
    }
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DOMParser.parseXML(InputStream).stream","Parameter_1","Belong to org.apache.commons.jxpath.xml.DOMParser.parseXML(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2","Abstract Class","* The abstract superclass of XML parsers that produce DOM Documents.
 * The features have the same defaults as {@link javax.xml.parsers.DocumentBuilderFactory}.","Abstract Class do not obtain Source Code","No return type","public , abstract ","","org.apache.commons.jxpath.xml.XMLParser"
"org.apache.commons.jxpath.xml.XMLParser2.validating","Field","No Comment","private boolean validating = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.namespaceAware","Field","No Comment","private boolean namespaceAware = true;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.whitespace","Field","No Comment","private boolean whitespace = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.expandEntityRef","Field","No Comment","private boolean expandEntityRef = true;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.ignoreComments","Field","No Comment","private boolean ignoreComments = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.coalescing","Field","No Comment","private boolean coalescing = false;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setValidating(boolean)","Method","* Sets whether the underlying parser should be validating.
     * @param validating flag
     * @see javax.xml.parsers.DocumentBuilderFactory#setValidating(boolean)","public void setValidating(final boolean validating) {
    this.validating = validating;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setValidating(boolean).validating","Parameter_1","Belong to org.apache.commons.jxpath.xml.XMLParser2.setValidating(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.isValidating()","Method","* Learn whether the underlying parser is validating.
     * @return boolean
     * @see javax.xml.parsers.DocumentBuilderFactory#isValidating()","public boolean isValidating() {
    return validating;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.isNamespaceAware()","Method","* Learn whether the underlying parser is ns-aware.
     * @return boolean
     * @see javax.xml.parsers.DocumentBuilderFactory#isNamespaceAware()","public boolean isNamespaceAware() {
    return namespaceAware;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setNamespaceAware(boolean)","Method","* Sets whether the underlying parser is ns-aware.
     * @param namespaceAware flag
     * @see javax.xml.parsers.DocumentBuilderFactory#setNamespaceAware(boolean)","public void setNamespaceAware(final boolean namespaceAware) {
    this.namespaceAware = namespaceAware;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setNamespaceAware(boolean).namespaceAware","Parameter_1","Belong to org.apache.commons.jxpath.xml.XMLParser2.setNamespaceAware(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setIgnoringElementContentWhitespace(boolean)","Method","* Sets whether the underlying parser is ignoring whitespace.
     * @param whitespace flag
     * @see javax.xml.parsers.DocumentBuilderFactory#setIgnoringElementContentWhitespace(boolean)","public void setIgnoringElementContentWhitespace(final boolean whitespace) {
    this.whitespace = whitespace;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setIgnoringElementContentWhitespace(boolean).whitespace","Parameter_1","Belong to org.apache.commons.jxpath.xml.XMLParser2.setIgnoringElementContentWhitespace(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.isIgnoringElementContentWhitespace()","Method","* Learn whether the underlying parser is ignoring whitespace.
     * @return boolean
     * @see javax.xml.parsers.DocumentBuilderFactory#isIgnoringElementContentWhitespace()","public boolean isIgnoringElementContentWhitespace() {
    return whitespace;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.isExpandEntityReferences()","Method","* Learn whether the underlying parser expands entity references.
     * @return boolean
     * @see javax.xml.parsers.DocumentBuilderFactory#isExpandEntityReferences()","public boolean isExpandEntityReferences() {
    return expandEntityRef;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setExpandEntityReferences(boolean)","Method","* Sets whether the underlying parser expands entity references.
     * @param expandEntityRef flag
     * @see javax.xml.parsers.DocumentBuilderFactory#setExpandEntityReferences(boolean)","public void setExpandEntityReferences(final boolean expandEntityRef) {
    this.expandEntityRef = expandEntityRef;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setExpandEntityReferences(boolean).expandEntityRef","Parameter_1","Belong to org.apache.commons.jxpath.xml.XMLParser2.setExpandEntityReferences(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.isIgnoringComments()","Method","* Learn whether the underlying parser ignores comments.
     * @return boolean
     * @see javax.xml.parsers.DocumentBuilderFactory#isIgnoringComments()","public boolean isIgnoringComments() {
    return ignoreComments;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setIgnoringComments(boolean)","Method","* Sets whether the underlying parser ignores comments.
     * @param ignoreComments flag
     * @see javax.xml.parsers.DocumentBuilderFactory#setIgnoringComments(boolean)","public void setIgnoringComments(final boolean ignoreComments) {
    this.ignoreComments = ignoreComments;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setIgnoringComments(boolean).ignoreComments","Parameter_1","Belong to org.apache.commons.jxpath.xml.XMLParser2.setIgnoringComments(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.isCoalescing()","Method","* Learn whether the underlying parser is coalescing.
     * @return boolean
     * @see javax.xml.parsers.DocumentBuilderFactory#isCoalescing()","public boolean isCoalescing() {
    return coalescing;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setCoalescing(boolean)","Method","* Sets whether the underlying parser is coalescing.
     * @param coalescing flag
     * @see javax.xml.parsers.DocumentBuilderFactory#setCoalescing(boolean)","public void setCoalescing(final boolean coalescing) {
    this.coalescing = coalescing;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.setCoalescing(boolean).coalescing","Parameter_1","Belong to org.apache.commons.jxpath.xml.XMLParser2.setCoalescing(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.parseXML(InputStream)","Abstract Method","No Comment","@Override
public abstract Object parseXML(InputStream stream);","Object","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser2.parseXML(InputStream).stream","Parameter_1","Belong to org.apache.commons.jxpath.xml.XMLParser2.parseXML(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.JDOMParser","Class","* An implementation of the XMLParser interface that produces a JDOM Document.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.xml.XMLParser2",""
"org.apache.commons.jxpath.xml.JDOMParser.parseXML(InputStream)","Method","No Comment","@Override
public Object parseXML(final InputStream stream) {
    if (!isNamespaceAware()) {
        throw new JXPathException(""JDOM parser configuration error. JDOM "" + ""does not support the namespaceAware=false setting."");
    }
    try {
        final SAXBuilder builder = new SAXBuilder();
        builder.setExpandEntities(isExpandEntityReferences());
        builder.setIgnoringElementContentWhitespace(isIgnoringElementContentWhitespace());
        builder.setValidation(isValidating());
        return builder.build(stream);
    } catch (final Exception ex) {
        throw new JXPathException(""JDOM parser error"", ex);
    }
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.JDOMParser.parseXML(InputStream).stream","Parameter_1","Belong to org.apache.commons.jxpath.xml.JDOMParser.parseXML(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer","Class","* An XML document container reads and parses XML only when it is
 * accessed.  JXPath traverses Containers transparently -
 * you use the same paths to access objects in containers as you
 * do to access those objects directly.  You can create
 * XMLDocumentContainers for various XML documents that may or
 * may not be accessed by XPaths.  If they are, they will be automatically
 * read, parsed and traversed. If they are not - they won't be
 * read at all.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.xml.XMLParser2","org.apache.commons.jxpath.Container"
"org.apache.commons.jxpath.xml.DocumentContainer.MODEL_DOM","Field","DOM constant","public static final String MODEL_DOM = ""DOM"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.MODEL_JDOM","Field","JDOM constant","public static final String MODEL_JDOM = ""JDOM"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -8713290334113427066L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.parserClasses","Field","No Comment","private static HashMap parserClasses = new HashMap();","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.parsers","Field","No Comment","private static HashMap parsers = new HashMap();","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.document","Field","No Comment","private Object document;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.xmlURL","Field","No Comment","private final URL xmlURL;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.model","Field","No Comment","private final String model;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,XMLParser)","Method","* Add an XML parser.  Parsers for the models ""DOM"" and ""JDOM"" are
     * pre-registered.
     * @param model model name
     * @param parser parser","public static void registerXMLParser(final String model, final XMLParser parser) {
    parsers.put(model, parser);
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,XMLParser).model","Parameter_1","Belong to org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,XMLParser)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,XMLParser).parser","Parameter_2","Belong to org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,XMLParser)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,String)","Method","* Add a class of a custom XML parser.
     * Parsers for the models ""DOM"" and ""JDOM"" are pre-registered.
     * @param model model name
     * @param parserClassName parser class name","public static void registerXMLParser(final String model, final String parserClassName) {
    parserClasses.put(model, parserClassName);
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,String).model","Parameter_1","Belong to org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,String).parserClassName","Parameter_2","Belong to org.apache.commons.jxpath.xml.DocumentContainer.registerXMLParser(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.getValue()","Method","* Reads XML, caches it internally and returns the Document.
     * @return Object","@Override
public Object getValue() {
    if (document == null) {
        try {
            InputStream stream = null;
            try {
                if (xmlURL != null) {
                    stream = xmlURL.openStream();
                }
                document = parseXML(stream);
            } finally {
                if (stream != null) {
                    stream.close();
                }
            }
        } catch (final IOException ex) {
            throw new JXPathException(""Cannot read XML from: "" + xmlURL.toString(), ex);
        }
    }
    return document;
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.parseXML(InputStream)","Method","* Parses XML using the parser for the specified model.
     * @param stream InputStream
     * @return Object","@Override
public Object parseXML(final InputStream stream) {
    final XMLParser parser = getParser(model);
    if (parser instanceof XMLParser2) {
        final XMLParser2 parser2 = (XMLParser2) parser;
        parser2.setValidating(isValidating());
        parser2.setNamespaceAware(isNamespaceAware());
        parser2.setIgnoringElementContentWhitespace(isIgnoringElementContentWhitespace());
        parser2.setExpandEntityReferences(isExpandEntityReferences());
        parser2.setIgnoringComments(isIgnoringComments());
        parser2.setCoalescing(isCoalescing());
    }
    return parser.parseXML(stream);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.parseXML(InputStream).stream","Parameter_1","Belong to org.apache.commons.jxpath.xml.DocumentContainer.parseXML(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.setValue(Object)","Method","* Throws an UnsupportedOperationException.
     * @param value value (not) to set","@Override
public void setValue(final Object value) {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.setValue(Object).value","Parameter_1","Belong to org.apache.commons.jxpath.xml.DocumentContainer.setValue(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.getParser(String)","Method","* Maps a model type to a parser.
     * @param model input model type
     * @return XMLParser","private static XMLParser getParser(final String model) {
    return (XMLParser) parsers.computeIfAbsent(model, k -> {
        final String className = (String) parserClasses.get(model);
        if (className == null) {
            throw new JXPathException(""Unsupported XML model: "" + model);
        }
        try {
            final Class clazz = ClassLoaderUtil.getClass(className, true);
            return (XMLParser) clazz.getConstructor().newInstance();
        } catch (final Exception ex) {
            throw new JXPathException(""Cannot allocate XMLParser: "" + className, ex);
        }
    });
}","XMLParser","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.getParser(String).model","Parameter_1","Belong to org.apache.commons.jxpath.xml.DocumentContainer.getParser(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.<init>(URL)","Constructor","* Use this constructor if the desired model is DOM.
     *
     * @param xmlURL is a URL for an XML file.
     * Use getClass().getResource(resourceName) to load XML from a
     * resource file.","public DocumentContainer(final URL xmlURL) {
    this(xmlURL, MODEL_DOM);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.<init>(URL).xmlURL","Parameter_1","Belong to org.apache.commons.jxpath.xml.DocumentContainer.<init>(URL)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.<init>(URL,String)","Constructor","* Constructs a new DocumentContainer.
     * @param xmlURL is a URL for an XML file. Use getClass().getResource
     *               (resourceName) to load XML from a resource file.
     *
     * @param model is one of the MODEL_* constants defined in this class. It
     *              determines which parser should be used to load the XML.","public DocumentContainer(final URL xmlURL, final String model) {
    this.xmlURL = xmlURL;
    if (xmlURL == null) {
        throw new JXPathException(""XML URL is null"");
    }
    this.model = model;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.<init>(URL,String).xmlURL","Parameter_1","Belong to org.apache.commons.jxpath.xml.DocumentContainer.<init>(URL,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.DocumentContainer.<init>(URL,String).model","Parameter_2","Belong to org.apache.commons.jxpath.xml.DocumentContainer.<init>(URL,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser","Interface","* Common interface for XML parsers.  We are not using JAXP because
 * some of the parsers we want to support may not be JAXP compliant.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.xml.XMLParser.parseXML(InputStream)","Abstract Method","* Reads the supplied XML file and returns the resulting model,
     * which is not necessarily DOM.
     * @param stream InputStream
     * @return Object","Object parseXML(InputStream stream);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.xml.XMLParser.parseXML(InputStream).stream","Parameter_1","Belong to org.apache.commons.jxpath.xml.XMLParser.parseXML(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.NodeSet","Interface","* NodeSet interface can be used as the type of an argument of an extension
 * function.  Alternatively, the function can declare the argument as
 * a Collection (or List or Set), in which case it will be given a collection
 * of <em>values</em> matching the path.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.NodeSet.getNodes()","Abstract Method","* Returns a list of nodes.
     * @return List","List getNodes();","List","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.NodeSet.getPointers()","Abstract Method","* Returns a list of pointers for all nodes in the set.
     * @return List","List getPointers();","List","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.NodeSet.getValues()","Abstract Method","* Returns a list of values of all contained pointers.
     * @return List","List getValues();","List","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathFunctionNotFoundException","Class","No Comment","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.JXPathException",""
"org.apache.commons.jxpath.JXPathFunctionNotFoundException.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -8875537628056117241L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathFunctionNotFoundException.<init>(String)","Constructor","* Create a new JXPathFunctionNotFoundException.
     * @param message exception message","public JXPathFunctionNotFoundException(final String message) {
    super(message);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathFunctionNotFoundException.<init>(String).message","Parameter_1","Belong to org.apache.commons.jxpath.JXPathFunctionNotFoundException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary","Class","* An object that aggregates {@link Functions} objects into a group Functions
 * object. Since {@link JXPathContext} can only register a single Functions
 * object, FunctionLibrary should always be used to group all Functions objects
 * that need to be registered.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.Functions"
"org.apache.commons.jxpath.FunctionLibrary.allFunctions","Field","No Comment","private final List allFunctions = new ArrayList();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.byNamespace","Field","No Comment","private Map byNamespace;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.addFunctions(Functions)","Method","* Add functions to the library
     * @param functions to add","public void addFunctions(final Functions functions) {
    allFunctions.add(functions);
    synchronized (this) {
        byNamespace = null;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.addFunctions(Functions).functions","Parameter_1","Belong to org.apache.commons.jxpath.FunctionLibrary.addFunctions(Functions)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.removeFunctions(Functions)","Method","* Remove functions from the library.
     * @param functions to remove","public void removeFunctions(final Functions functions) {
    allFunctions.remove(functions);
    synchronized (this) {
        byNamespace = null;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.removeFunctions(Functions).functions","Parameter_1","Belong to org.apache.commons.jxpath.FunctionLibrary.removeFunctions(Functions)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.getUsedNamespaces()","Method","* Returns a set containing all namespaces used by the aggregated
     * Functions.
     * @return Set","@Override
public Set getUsedNamespaces() {
    return functionCache().keySet();
}","Set","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.getFunction(String,String,Object[])","Method","* Returns a Function, if any, for the specified namespace,
     * name and parameter types.
     * @param namespace function namespace
     * @param name function name
     * @param parameters parameters
     * @return Function found","@Override
public Function getFunction(final String namespace, final String name, final Object[] parameters) {
    final Object candidates = functionCache().get(namespace);
    if (candidates instanceof Functions) {
        return ((Functions) candidates).getFunction(namespace, name, parameters);
    }
    if (candidates instanceof List) {
        final List list = (List) candidates;
        final int count = list.size();
        for (int i = 0; i < count; i++) {
            final Function function = ((Functions) list.get(i)).getFunction(namespace, name, parameters);
            if (function != null) {
                return function;
            }
        }
    }
    return null;
}","Function","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.getFunction(String,String,Object[]).namespace","Parameter_1","Belong to org.apache.commons.jxpath.FunctionLibrary.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.getFunction(String,String,Object[]).name","Parameter_2","Belong to org.apache.commons.jxpath.FunctionLibrary.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.getFunction(String,String,Object[]).parameters","Parameter_3","Belong to org.apache.commons.jxpath.FunctionLibrary.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.FunctionLibrary.functionCache()","Method","* Prepare the cache.
     * @return cache map keyed by namespace","private synchronized Map functionCache() {
    if (byNamespace == null) {
        byNamespace = new HashMap();
        final int count = allFunctions.size();
        for (int i = 0; i < count; i++) {
            final Functions funcs = (Functions) allFunctions.get(i);
            final Set namespaces = funcs.getUsedNamespaces();
            for (final Iterator it = namespaces.iterator(); it.hasNext(); ) {
                final String ns = (String) it.next();
                final Object candidates = byNamespace.get(ns);
                if (candidates == null) {
                    byNamespace.put(ns, funcs);
                } else if (candidates instanceof Functions) {
                    final List lst = new ArrayList();
                    lst.add(candidates);
                    lst.add(funcs);
                    byNamespace.put(ns, lst);
                } else {
                    ((List) candidates).add(funcs);
                }
            }
        }
    }
    return byNamespace;
}","Map","private , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExtendedKeyManager","Interface","* More complete implementation for the XPath {@code ""key()""} function.
 * Returns NodeSet results and allows Object values for better compatibility
 * with non-XML graphs.
 * @since JXPath 1.3","Interface do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.KeyManager",""
"org.apache.commons.jxpath.ExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Abstract Method","* Find a NodeSet by key/value.
     * @param context base
     * @param key String
     * @param value Object
     * @return NodeSet found","NodeSet getNodeSetByKey(JXPathContext context, String key, Object value);","NodeSet","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.ExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object).key","Parameter_2","Belong to org.apache.commons.jxpath.ExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.ExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.ExtendedKeyManager.getNodeSetByKey(JXPathContext,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.KeyManager","Interface","* A delegate of {@link JXPathContext} that implements the XPath {@code ""key()""}
 * function.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.KeyManager.getPointerByKey(JXPathContext,String,String)","Abstract Method","* Find a node by key/value.
     *
     * @param context to search
     * @param keyName String
     * @param keyValue String
     * @return Pointer","Pointer getPointerByKey(JXPathContext context, String keyName, String keyValue);","Pointer","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.KeyManager.getPointerByKey(JXPathContext,String,String).context","Parameter_1","Belong to org.apache.commons.jxpath.KeyManager.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.KeyManager.getPointerByKey(JXPathContext,String,String).keyName","Parameter_2","Belong to org.apache.commons.jxpath.KeyManager.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.KeyManager.getPointerByKey(JXPathContext,String,String).keyValue","Parameter_3","Belong to org.apache.commons.jxpath.KeyManager.getPointerByKey(JXPathContext,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBeanInfo","Interface","* JXPathBeanInfo  is similar to {@link java.beans.BeanInfo} in that it describes
 * properties of a JavaBean class.  By default, JXPathBeanInfo classes are
 * automatically generated by {@link JXPathIntrospector JXPathIntrospector}
 * based on the java.beans.BeanInfo. As with JavaBeans, the user can supply an
 * alternative implementation of JXPathBeanInfo for a custom class.  The
 * alternative implementation is located by class name, which is the same as the
 * name of the class it represents with the suffix ""XBeanInfo"".  So, for
 * example, if you need to provide an alternative JXPathBeanInfo class for class
 * ""com.foo.Bar"", write a class ""com.foo.BarXBeanInfo"" and make it implement the
 * JXPathBeanInfo interface.","Interface do not obtain Source Code","No return type","public ","java.io.Serializable",""
"org.apache.commons.jxpath.JXPathBeanInfo.isAtomic()","Abstract Method","* Returns true if objects of this class are treated as atomic
     * objects which have no properties of their own.
     * For example, {@link String} and {@link Number} are atomic.
     * @return boolean","boolean isAtomic();","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBeanInfo.isDynamic()","Abstract Method","* Returns true if the objects of this class have dynamic properties
     * (e.g. java.util.Map). If this method returns true, {@link #getPropertyDescriptors}
     * should return null and {@link #getDynamicPropertyHandlerClass} should return
     * a valid class name.  An object cannot have both static and dynamic
     * properties at the same time.
     * @return boolean","boolean isDynamic();","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBeanInfo.getPropertyDescriptors()","Abstract Method","* Returns a list of property descriptors for the beans described by this
     * bean info object.  Returns null for atomic beans.
     * @return PropertyDescriptor[]","PropertyDescriptor[] getPropertyDescriptors();","PropertyDescriptor[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBeanInfo.getPropertyDescriptor(String)","Abstract Method","* Returns a PropertyDescriptor for the specified name or null if there
     * is no such property.
     * @param propertyName property name
     * @return PropertyDescriptor","PropertyDescriptor getPropertyDescriptor(String propertyName);","PropertyDescriptor","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBeanInfo.getPropertyDescriptor(String).propertyName","Parameter_1","Belong to org.apache.commons.jxpath.JXPathBeanInfo.getPropertyDescriptor(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathBeanInfo.getDynamicPropertyHandlerClass()","Abstract Method","* For dynamic objects, returns the class implementing
     * the {@link DynamicPropertyHandler} interface. That class can
     * be used to access dynamic properties.
     * @return Class","Class getDynamicPropertyHandlerClass();","Class","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError","Class","* Thrown when a problem with configuration with the {@link JXPathContextFactory JXPathContextFactories}
 * exists. This error will typically be thrown when the class of a
 * factory specified in the system properties cannot be found
 * or instantiated.","Class do not obtain Source Code","No return type","public ","java.lang.Error",""
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.exception","Field","@serial","private final Exception exception;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.getMessage()","Method","* Gets the message (if any) for this error . If there is no
     * message for the exception and there is an encapsulated
     * exception then the message of that exception will be returned.
     *
     * @return The error message.","@Override
public String getMessage() {
    final String message = super.getMessage();
    if (message == null && exception != null) {
        return exception.getMessage();
    }
    return message;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.getException()","Method","* Gets the actual exception (if any) that caused this exception to
     * be raised.
     *
     * @return The encapsulated exception, or null if there is none.","public Exception getException() {
    return exception;
}","Exception","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>()","Constructor","* Create a new {@code JXPathContextFactoryConfigurationError} with no
     * detail mesage.","public JXPathContextFactoryConfigurationError() {
    this.exception = null;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(String)","Constructor","* Create a new {@code JXPathContextFactoryConfigurationError} with
     * the {@code String } specified as an error message.
     *
     * @param msg The error message for the exception.","public JXPathContextFactoryConfigurationError(final String msg) {
    super(msg);
    this.exception = null;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(String).msg","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(Exception)","Constructor","* Create a new {@code JXPathContextFactoryConfigurationError} with a
     * given {@code Exception} base cause of the error.
     *
     * @param e The exception to be encapsulated in a
     * JXPathContextFactoryConfigurationError.","public JXPathContextFactoryConfigurationError(final Exception e) {
    super(e.toString());
    this.exception = e;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(Exception).e","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(Exception)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(Exception,String)","Constructor","* Create a new {@code JXPathContextFactoryConfigurationError} with the
     * given {@code Exception} base cause and detail message.
     *
     * @param e The exception to be encapsulated in a
     * JXPathContextFactoryConfigurationError
     * @param msg The detail message.","public JXPathContextFactoryConfigurationError(final Exception e, final String msg) {
    super(msg);
    this.exception = e;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(Exception,String).e","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(Exception,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(Exception,String).msg","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContextFactoryConfigurationError.<init>(Exception,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathAbstractFactoryException","Class","No Comment","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.JXPathException",""
"org.apache.commons.jxpath.JXPathAbstractFactoryException.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -4403564377958943239L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathAbstractFactoryException.<init>(String)","Constructor","* Create a new JXPathAbstractFactoryException.
     * @param message exception message","public JXPathAbstractFactoryException(final String message) {
    super(message);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathAbstractFactoryException.<init>(String).message","Parameter_1","Belong to org.apache.commons.jxpath.JXPathAbstractFactoryException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.MethodFunction","Class","* An XPath extension function implemented as an individual Java method.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.Function"
"org.apache.commons.jxpath.functions.MethodFunction.method","Field","No Comment","private final Method method;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.MethodFunction.EMPTY_ARRAY","Field","No Comment","private static final Object[] EMPTY_ARRAY = {};","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.MethodFunction.invoke(ExpressionContext,Object[])","Method","No Comment","@Override
public Object invoke(final ExpressionContext context, Object[] parameters) {
    try {
        Object target;
        Object[] args;
        if (Modifier.isStatic(method.getModifiers())) {
            target = null;
            if (parameters == null) {
                parameters = EMPTY_ARRAY;
            }
            int pi = 0;
            final Class[] types = method.getParameterTypes();
            if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) {
                pi = 1;
            }
            args = new Object[parameters.length + pi];
            if (pi == 1) {
                args[0] = context;
            }
            for (int i = 0; i < parameters.length; i++) {
                args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]);
            }
        } else {
            int pi = 0;
            final Class[] types = method.getParameterTypes();
            if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) {
                pi = 1;
            }
            target = TypeUtils.convert(parameters[0], method.getDeclaringClass());
            args = new Object[parameters.length - 1 + pi];
            if (pi == 1) {
                args[0] = context;
            }
            for (int i = 1; i < parameters.length; i++) {
                args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i + pi - 1]);
            }
        }
        return method.invoke(target, args);
    } catch (Throwable ex) {
        if (ex instanceof InvocationTargetException) {
            ex = ((InvocationTargetException) ex).getTargetException();
        }
        throw new JXPathInvalidAccessException(""Cannot invoke "" + method, ex);
    }
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.MethodFunction.invoke(ExpressionContext,Object[]).context","Parameter_1","Belong to org.apache.commons.jxpath.functions.MethodFunction.invoke(ExpressionContext,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.MethodFunction.invoke(ExpressionContext,Object[]).parameters","Parameter_2","Belong to org.apache.commons.jxpath.functions.MethodFunction.invoke(ExpressionContext,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.MethodFunction.toString()","Method","No Comment","@Override
public String toString() {
    return method.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.MethodFunction.<init>(Method)","Constructor","* Create a new MethodFunction.
     * @param method implementing Method","public MethodFunction(final Method method) {
    this.method = ValueUtils.getAccessibleMethod(method);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.MethodFunction.<init>(Method).method","Parameter_1","Belong to org.apache.commons.jxpath.functions.MethodFunction.<init>(Method)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.ConstructorFunction","Class","* An extension function that creates an instance using a constructor.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.Function"
"org.apache.commons.jxpath.functions.ConstructorFunction.EMPTY_ARRAY","Field","No Comment","private static final Object[] EMPTY_ARRAY = {};","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.ConstructorFunction.constructor","Field","No Comment","private final Constructor constructor;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.ConstructorFunction.invoke(ExpressionContext,Object[])","Method","* Converts parameters to suitable types and invokes the constructor.
     * @param context evaluation context
     * @param parameters constructor args
     * @return new instance","@Override
public Object invoke(final ExpressionContext context, Object[] parameters) {
    try {
        Object[] args;
        if (parameters == null) {
            parameters = EMPTY_ARRAY;
        }
        int pi = 0;
        final Class[] types = constructor.getParameterTypes();
        if (types.length > 0 && ExpressionContext.class.isAssignableFrom(types[0])) {
            pi = 1;
        }
        args = new Object[parameters.length + pi];
        if (pi == 1) {
            args[0] = context;
        }
        for (int i = 0; i < parameters.length; i++) {
            args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]);
        }
        return constructor.newInstance(args);
    } catch (Throwable ex) {
        if (ex instanceof InvocationTargetException) {
            ex = ((InvocationTargetException) ex).getTargetException();
        }
        throw new JXPathInvalidAccessException(""Cannot invoke constructor "" + constructor, ex);
    }
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.ConstructorFunction.invoke(ExpressionContext,Object[]).context","Parameter_1","Belong to org.apache.commons.jxpath.functions.ConstructorFunction.invoke(ExpressionContext,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.ConstructorFunction.invoke(ExpressionContext,Object[]).parameters","Parameter_2","Belong to org.apache.commons.jxpath.functions.ConstructorFunction.invoke(ExpressionContext,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.ConstructorFunction.<init>(Constructor)","Constructor","* Create a new ConstructorFunction.
     * @param constructor the constructor to call.","public ConstructorFunction(final Constructor constructor) {
    this.constructor = constructor;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.functions.ConstructorFunction.<init>(Constructor).constructor","Parameter_1","Belong to org.apache.commons.jxpath.functions.ConstructorFunction.<init>(Constructor)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.MapDynamicPropertyHandler","Class","* Implements the DynamicPropertyHandler interface for {@link java.util.Map}.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.DynamicPropertyHandler"
"org.apache.commons.jxpath.MapDynamicPropertyHandler.getPropertyNames(Object)","Method","No Comment","@Override
public String[] getPropertyNames(final Object object) {
    final Map map = (Map) object;
    final Set set = map.keySet();
    final String[] names = new String[set.size()];
    final Iterator it = set.iterator();
    for (int i = 0; i < names.length; i++) {
        names[i] = String.valueOf(it.next());
    }
    return names;
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.MapDynamicPropertyHandler.getPropertyNames(Object).object","Parameter_1","Belong to org.apache.commons.jxpath.MapDynamicPropertyHandler.getPropertyNames(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.MapDynamicPropertyHandler.getProperty(Object,String)","Method","No Comment","@Override
public Object getProperty(final Object object, final String propertyName) {
    return ((Map) object).get(propertyName);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.MapDynamicPropertyHandler.getProperty(Object,String).object","Parameter_1","Belong to org.apache.commons.jxpath.MapDynamicPropertyHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.MapDynamicPropertyHandler.getProperty(Object,String).propertyName","Parameter_2","Belong to org.apache.commons.jxpath.MapDynamicPropertyHandler.getProperty(Object,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.MapDynamicPropertyHandler.setProperty(Object,String,Object)","Method","No Comment","@Override
public void setProperty(final Object object, final String propertyName, final Object value) {
    ((Map) object).put(propertyName, value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.MapDynamicPropertyHandler.setProperty(Object,String,Object).object","Parameter_1","Belong to org.apache.commons.jxpath.MapDynamicPropertyHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.MapDynamicPropertyHandler.setProperty(Object,String,Object).propertyName","Parameter_2","Belong to org.apache.commons.jxpath.MapDynamicPropertyHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.MapDynamicPropertyHandler.setProperty(Object,String,Object).value","Parameter_3","Belong to org.apache.commons.jxpath.MapDynamicPropertyHandler.setProperty(Object,String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions","Class","* Extension functions provided by Java classes.  The class prefix specified
 * in the constructor is used when a constructor or a static method is called.
 * Usually, a class prefix is a package name (hence the name of this class).
 *
 * Let's say, we declared a PackageFunction like this:
 * <blockquote><pre>
 *     new PackageFunctions(""java.util."", ""util"")
 * </pre></blockquote>
 *
 * We can now use XPaths like:
 * <dl>
 *  <dt>{@code ""util:Date.new()""}</dt>
 *  <dd>Equivalent to {@code new java.util.Date()}</dd>
 *  <dt>{@code ""util:Collections.singleton('foo')""}</dt>
 *  <dd>Equivalent to {@code java.util.Collections.singleton(""foo"")}</dd>
 *  <dt>{@code ""util:substring('foo', 1, 2)""}</dt>
 *  <dd>Equivalent to {@code ""foo"".substring(1, 2)}.  Note that in
 *  this case, the class prefix is not used. JXPath does not check that
 *  the first parameter of the function (the method target) is in fact
 *  a member of the package described by this PackageFunctions object.</dd>
 * </dl>
 *
 * <p>
 * If the first argument of a method or constructor is {@link ExpressionContext},
 * the expression context in which the function is evaluated is passed to
 * the method.
 * </p>
 * <p>
 * There is one PackageFunctions object registered by default with each
 * JXPathContext.  It does not have a namespace and uses no class prefix.
 * The existence of this object allows us to use XPaths like:
 * {@code ""java.util.Date.new()""} and {@code ""length('foo')""}
 * without the explicit registration of any extension functions.
 * </p>","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.Functions"
"org.apache.commons.jxpath.PackageFunctions.classPrefix","Field","No Comment","private final String classPrefix;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.namespace","Field","No Comment","private final String namespace;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.EMPTY_ARRAY","Field","No Comment","private static final Object[] EMPTY_ARRAY = {};","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.getUsedNamespaces()","Method","* Returns the namespace specified in the constructor
     * @return (singleton) namespace Set","@Override
public Set getUsedNamespaces() {
    return Collections.singleton(namespace);
}","Set","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.getFunction(String,String,Object[])","Method","* Returns a {@link Function}, if found, for the specified namespace,
     * name and parameter types.
     *
     * @param  namespace - if it is not the same as specified in the
     * construction, this method returns null
     * @param name - name of the method, which can one these forms:
     * <ul>
     * <li><strong>methodname</strong>, if invoking a method on an object passed as the
     * first parameter</li>
     * <li><strong>Classname.new</strong>, if looking for a constructor</li>
     * <li><strong>subpackage.subpackage.Classname.new</strong>, if looking for a
     * constructor in a subpackage</li>
     * <li><strong>Classname.methodname</strong>, if looking for a static method</li>
     * <li><strong>subpackage.subpackage.Classname.methodname</strong>, if looking for a
     * static method of a class in a subpackage</li>
     * </ul>
     * @param parameters Object[] of parameters
     * @return a MethodFunction, a ConstructorFunction or null if no function
     * is found","@Override
public Function getFunction(final String namespace, final String name, Object[] parameters) {
    if (!Objects.equals(this.namespace, namespace)) {
        return null;
    }
    if (parameters == null) {
        parameters = EMPTY_ARRAY;
    }
    if (parameters.length >= 1) {
        Object target = TypeUtils.convert(parameters[0], Object.class);
        if (target != null) {
            Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters);
            if (method != null) {
                return new MethodFunction(method);
            }
            if (target instanceof NodeSet) {
                target = ((NodeSet) target).getPointers();
            }
            method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters);
            if (method != null) {
                return new MethodFunction(method);
            }
            if (target instanceof Collection) {
                final Iterator iter = ((Collection) target).iterator();
                if (iter.hasNext()) {
                    target = iter.next();
                    if (target instanceof Pointer) {
                        target = ((Pointer) target).getValue();
                    }
                } else {
                    target = null;
                }
            }
        }
        if (target != null) {
            final Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters);
            if (method != null) {
                return new MethodFunction(method);
            }
        }
    }
    final String fullName = classPrefix + name;
    final int inx = fullName.lastIndexOf('.');
    if (inx == -1) {
        return null;
    }
    final String className = fullName.substring(0, inx);
    final String methodName = fullName.substring(inx + 1);
    Class functionClass;
    try {
        functionClass = ClassLoaderUtil.getClass(className, true);
    } catch (final ClassNotFoundException ex) {
        throw new JXPathException(""Cannot invoke extension function "" + (namespace != null ? namespace + "":"" + name : name), ex);
    }
    if (methodName.equals(""new"")) {
        final Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters);
        if (constructor != null) {
            return new ConstructorFunction(constructor);
        }
    } else {
        final Method method = MethodLookupUtils.lookupStaticMethod(functionClass, methodName, parameters);
        if (method != null) {
            return new MethodFunction(method);
        }
    }
    return null;
}","Function","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.getFunction(String,String,Object[]).namespace","Parameter_1","Belong to org.apache.commons.jxpath.PackageFunctions.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.getFunction(String,String,Object[]).name","Parameter_2","Belong to org.apache.commons.jxpath.PackageFunctions.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.getFunction(String,String,Object[]).parameters","Parameter_3","Belong to org.apache.commons.jxpath.PackageFunctions.getFunction(String,String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.<init>(String,String)","Constructor","* Create a new PackageFunctions.
     * @param classPrefix class prefix
     * @param namespace namespace String","public PackageFunctions(final String classPrefix, final String namespace) {
    this.classPrefix = classPrefix;
    this.namespace = namespace;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.<init>(String,String).classPrefix","Parameter_1","Belong to org.apache.commons.jxpath.PackageFunctions.<init>(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.PackageFunctions.<init>(String,String).namespace","Parameter_2","Belong to org.apache.commons.jxpath.PackageFunctions.<init>(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression","Interface","* Represents a compiled XPath. The interpretation of compiled XPaths
 * may be faster, because it bypasses the compilation step. The reference
 * implementation of {@link JXPathContext} also globally caches some of the
 * results of compilation, so the direct use of JXPathContext is not
 * always less efficient than the use of CompiledExpression.
 * <p>
 * Use CompiledExpression only when there is a need to evaluate the
 * same expression multiple times and the CompiledExpression can be
 * conveniently cached.
 * <p>
 * To acquire a CompiledExpression, call {@link JXPathContext#compile
 * JXPathContext.compile}","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.CompiledExpression.getValue(JXPathContext)","Abstract Method","* Evaluates the xpath and returns the resulting object. Primitive
     * types are wrapped into objects.
     * @param context to evaluate
     * @return Object","Object getValue(JXPathContext context);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.getValue(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.getValue(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.getValue(JXPathContext,Class)","Abstract Method","* Evaluates the xpath, converts the result to the specified class and
     * returns the resulting object.
     * @param context to evaluate
     * @param requiredType return type
     * @return Object","Object getValue(JXPathContext context, Class requiredType);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.getValue(JXPathContext,Class).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.getValue(JXPathContext,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.getValue(JXPathContext,Class).requiredType","Parameter_2","Belong to org.apache.commons.jxpath.CompiledExpression.getValue(JXPathContext,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.setValue(JXPathContext,Object)","Abstract Method","* Modifies the value of the property described by the supplied xpath.
     * Will throw an exception if one of the following conditions occurs:
     * <ul>
     * <li>The xpath does not in fact describe an existing property
     * <li>The property is not writable (no public, non-static set method)
     * </ul>
     * @param context base
     * @param value to set","void setValue(JXPathContext context, Object value);","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.setValue(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.setValue(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.setValue(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.CompiledExpression.setValue(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.createPath(JXPathContext)","Abstract Method","* Creates intermediate elements of
     * the path by invoking an {@link AbstractFactory}, which should first be
     * installed on the context by calling {@link JXPathContext#setFactory}.
     * @param context base
     * @return Pointer created","Pointer createPath(JXPathContext context);","Pointer","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.createPath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.createPath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.createPathAndSetValue(JXPathContext,Object)","Abstract Method","* The same as setValue, except it creates intermediate elements of
     * the path by invoking an {@link AbstractFactory}, which should first be
     * installed on the context by calling {@link JXPathContext#setFactory}.
     * <p>
     * Will throw an exception if one of the following conditions occurs:
     * <ul>
     * <li>Elements of the xpath aleady exist, by the path does not in
     *  fact describe an existing property
     * <li>The AbstractFactory fails to create an instance for an intermediate
     * element.
     * <li>The property is not writable (no public, non-static set method)
     * </ul>
     * @param context base
     * @param value to set
     * @return Pointer created","Pointer createPathAndSetValue(JXPathContext context, Object value);","Pointer","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.createPathAndSetValue(JXPathContext,Object).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.createPathAndSetValue(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.createPathAndSetValue(JXPathContext,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.CompiledExpression.createPathAndSetValue(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.iterate(JXPathContext)","Abstract Method","* Traverses the xpath and returns a Iterator of all results found
     * for the path. If the xpath matches no properties
     * in the graph, the Iterator will not be null.
     * @param context base
     * @return Iterator","Iterator iterate(JXPathContext context);","Iterator","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.iterate(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.iterate(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.getPointer(JXPathContext,String)","Abstract Method","* Traverses the xpath and returns a Pointer.
     * A Pointer provides easy access to a property.
     * If the xpath matches no properties
     * in the graph, the pointer will be null.
     * @param context base
     * @param xpath string
     * @return Pointer found","Pointer getPointer(JXPathContext context, String xpath);","Pointer","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.getPointer(JXPathContext,String).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.getPointer(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.getPointer(JXPathContext,String).xpath","Parameter_2","Belong to org.apache.commons.jxpath.CompiledExpression.getPointer(JXPathContext,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.iteratePointers(JXPathContext)","Abstract Method","* Traverses the xpath and returns an Iterator of Pointers.
     * A Pointer provides easy access to a property.
     * If the xpath matches no properties
     * in the graph, the Iterator be empty, but not null.
     * @param context to iterate
     * @return Iterator","Iterator iteratePointers(JXPathContext context);","Iterator","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.iteratePointers(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.iteratePointers(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.removePath(JXPathContext)","Abstract Method","* Remove the graph element described by this expression.
     * @param context base","void removePath(JXPathContext context);","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.removePath(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.removePath(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.removeAll(JXPathContext)","Abstract Method","* Remove all graph elements described by this expression.
     * @param context base","void removeAll(JXPathContext context);","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.CompiledExpression.removeAll(JXPathContext).context","Parameter_1","Belong to org.apache.commons.jxpath.CompiledExpression.removeAll(JXPathContext)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathNotFoundException","Class","* Thrown when JXPath cannot find a requested path.","Class do not obtain Source Code","No return type","public ","org.apache.commons.jxpath.JXPathException",""
"org.apache.commons.jxpath.JXPathNotFoundException.serialVersionUID","Field","No Comment","private static final long serialVersionUID = -8875537628056117241L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathNotFoundException.<init>(String)","Constructor","* Create a new JXPathNotFoundException.
     * @param message exception detail","public JXPathNotFoundException(final String message) {
    super(message);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathNotFoundException.<init>(String).message","Parameter_1","Belong to org.apache.commons.jxpath.JXPathNotFoundException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException","Class","No Comment","Class do not obtain Source Code","No return type","public ","java.lang.RuntimeException",""
"org.apache.commons.jxpath.JXPathException.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 4306409701468017766L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.exception","Field","@serial","private final Throwable exception;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.getMessage()","Method","* Gets the message (if any) for this error . If there is no
     * message for the exception and there is an encapsulated
     * exception then the message of that exception will be returned.
     *
     * @return The error message.","@Override
public String getMessage() {
    final String message = super.getMessage();
    if (exception == null) {
        return message;
    }
    final StringBuilder buf = new StringBuilder();
    if (message != null) {
        buf.append(message).append(""; "");
    }
    final String eMsg = exception.getMessage();
    buf.append(eMsg == null ? exception.getClass().getName() : eMsg);
    return buf.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.getException()","Method","* Gets the actual exception (if any) that caused this exception to
     * be raised.
     *
     * @return The encapsulated exception, or null if there is none.","public Throwable getException() {
    return exception;
}","Throwable","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.getCause()","Method","* Same as {@link #getException() getException()}
     * @return The encapsulated exception, or null if there is none.","@Override
public Throwable getCause() {
    return exception;
}","Throwable","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.<init>()","Constructor","No Comment","public JXPathException() {
    this.exception = null;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.<init>(String)","Constructor","* Create a new {@code JXPathException} with
     * the {@code String } specified as an error message.
     *
     * @param msg The error message for the exception.","public JXPathException(final String msg) {
    super(msg);
    this.exception = null;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.<init>(String).msg","Parameter_1","Belong to org.apache.commons.jxpath.JXPathException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.<init>(Throwable)","Constructor","* Create a new {@code JXPathException} with a
     * given {@code Throwable} base cause of the error.
     *
     * @param e The exception to be encapsulated in a
     * JXPathException.","public JXPathException(final Throwable e) {
    super(e.toString());
    this.exception = e;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.<init>(Throwable).e","Parameter_1","Belong to org.apache.commons.jxpath.JXPathException.<init>(Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.<init>(String,Throwable)","Constructor","* Create a new {@code JXPathException} with the
     * given {@code Exception} base cause and detail message.
     *
     * @param msg The detail message.
     * @param e The exception to be encapsulated in a JXPathException","public JXPathException(final String msg, final Throwable e) {
    super(msg);
    this.exception = e;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.<init>(String,Throwable).msg","Parameter_1","Belong to org.apache.commons.jxpath.JXPathException.<init>(String,Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathException.<init>(String,Throwable).e","Parameter_2","Belong to org.apache.commons.jxpath.JXPathException.<init>(String,Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory","Abstract Class","* Defines a factory API that enables applications to obtain a
 * {@link JXPathContext} instance.  To acquire a JXPathContext, first call the
 * static {@link #newInstance} method of JXPathContextFactory.
 * This method returns a concrete JXPathContextFactory.
 * Then call {@link #newContext} on that instance.  You will rarely
 * need to perform these steps explicitly: usually you can call one of the
 * {@code JXPathContex.newContext} methods, which will perform these steps
 * for you.
 *
 * @see JXPathContext#newContext(Object)
 * @see JXPathContext#newContext(JXPathContext,Object)","Abstract Class do not obtain Source Code","No return type","public , abstract ","",""
"org.apache.commons.jxpath.JXPathContextFactory.FACTORY_NAME_PROPERTY","Field","The default property","public static final String FACTORY_NAME_PROPERTY = ""org.apache.commons.jxpath.JXPathContextFactory"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.DEFAULT_FACTORY_CLASS","Field","The default factory class","private static final String DEFAULT_FACTORY_CLASS = ""org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.FACTORY_IMPL_NAME","Field","Avoid reading all the files when the findFactory
        method is called the second time ( cache the result of
        finding the default impl )","private static final String FACTORY_IMPL_NAME = findFactory(FACTORY_NAME_PROPERTY, DEFAULT_FACTORY_CLASS);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.debug","Field","Temp debug code - this will be removed after we test everything","private static boolean debug = false;","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.newInstance()","Method","* Obtain a new instance of a {@code JXPathContextFactory}.
     * This static method creates a new factory instance.
     * This method uses the following ordered lookup procedure to determine
     * the {@code JXPathContextFactory} implementation class to load:
     * <ul>
     * <li>
     * Use  the {@code org.apache.commons.jxpath.JXPathContextFactory}
     * system property.
     * </li>
     * <li>
     * Alternatively, use the JAVA_HOME (the parent directory where jdk is
     * installed)/lib/jxpath.properties for a property file that contains the
     * name of the implementation class keyed on
     * {@code org.apache.commons.jxpath.JXPathContextFactory}.
     * </li>
     * <li>
     * Use the Services API (as detailed in the JAR specification), if
     * available, to determine the class name. The Services API will look
     * for a class name in the file
     * {@code META- INF/services/<i>org.apache.commons.jxpath.
     * JXPathContextFactory</i>} in jars available to the runtime.
     * </li>
     * <li>
     * Platform default {@code JXPathContextFactory} instance.
     * </li>
     * </ul>
     *
     * Once an application has obtained a reference to a
     * {@code JXPathContextFactory} it can use the factory to
     * obtain JXPathContext instances.
     *
     * @return JXPathContextFactory
     * @throws JXPathContextFactoryConfigurationError if the implementation
     *            is not available or cannot be instantiated.","public static JXPathContextFactory newInstance() {
    JXPathContextFactory factoryImpl;
    try {
        final Class clazz = ClassLoaderUtil.getClass(FACTORY_IMPL_NAME, true);
        factoryImpl = (JXPathContextFactory) clazz.getConstructor().newInstance();
    } catch (final ReflectiveOperationException ie) {
        throw new JXPathContextFactoryConfigurationError(ie);
    }
    return factoryImpl;
}","JXPathContextFactory","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.newContext(JXPathContext,Object)","Abstract Method","No Comment","public abstract JXPathContext newContext(JXPathContext parentContext, Object contextBean);","JXPathContext","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.newContext(JXPathContext,Object).parentContext","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContextFactory.newContext(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.newContext(JXPathContext,Object).contextBean","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContextFactory.newContext(JXPathContext,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.findFactory(String,String)","Method","* Private implementation method - will find the implementation
     * class in the specified order.
     * @param property    Property name
     * @param defaultFactory Default implementation, if nothing else is found
     * @return class name of the JXPathContextFactory","private static String findFactory(final String property, final String defaultFactory) {
    // Use the factory ID system property first
    try {
        final String systemProp = System.getProperty(property);
        if (systemProp != null) {
            if (debug) {
                System.err.println(""JXPath: found system property"" + systemProp);
            }
            return systemProp;
        }
    } catch (final SecurityException ignore) {
        // NOPMD
        // Ignore
    }
    // try to read from $java.home/lib/xml.properties
    try {
        final String javah = System.getProperty(""java.home"");
        final String configFile = javah + File.separator + ""lib"" + File.separator + ""jxpath.properties"";
        final File f = new File(configFile);
        if (f.exists()) {
            final Properties props = new Properties();
            final FileInputStream fis = new FileInputStream(f);
            try {
                props.load(fis);
            } finally {
                if (fis != null) {
                    try {
                        fis.close();
                    } catch (final IOException ignore) {
                        // NOPMD
                        //swallow
                    }
                }
            }
            final String factory = props.getProperty(property);
            if (factory != null) {
                if (debug) {
                    System.err.println(""JXPath: found java.home property "" + factory);
                }
                return factory;
            }
        }
    } catch (final IOException ex) {
        if (debug) {
            ex.printStackTrace();
        }
    }
    final String serviceId = ""META-INF/services/"" + property;
    // try to find services in CLASSPATH
    try {
        final ClassLoader cl = JXPathContextFactory.class.getClassLoader();
        InputStream is;
        if (cl == null) {
            is = ClassLoader.getSystemResourceAsStream(serviceId);
        } else {
            is = cl.getResourceAsStream(serviceId);
        }
        if (is != null) {
            if (debug) {
                System.err.println(""JXPath: found  "" + serviceId);
            }
            final BufferedReader rd = new BufferedReader(new InputStreamReader(is, ""UTF-8""));
            String factory = null;
            try {
                factory = rd.readLine();
            } finally {
                try {
                    rd.close();
                } catch (final IOException ignore) {
                    // NOPMD
                    // Ignore
                }
            }
            if (factory != null && !"""".equals(factory)) {
                if (debug) {
                    System.err.println(""JXPath: loaded from services: "" + factory);
                }
                return factory;
            }
        }
    } catch (final Exception ex) {
        if (debug) {
            ex.printStackTrace();
        }
    }
    return defaultFactory;
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.findFactory(String,String).property","Parameter_1","Belong to org.apache.commons.jxpath.JXPathContextFactory.findFactory(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.findFactory(String,String).defaultFactory","Parameter_2","Belong to org.apache.commons.jxpath.JXPathContextFactory.findFactory(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathContextFactory.<init>()","Constructor","* Create a new JXPathContextFactory.","protected JXPathContextFactory() {
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet","Class","* A simple implementation of {@link NodeSet} that behaves as a collection
 * of pointers.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.NodeSet"
"org.apache.commons.jxpath.BasicNodeSet.pointers","Field","No Comment","private final List pointers = new ArrayList();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.readOnlyPointers","Field","No Comment","private List readOnlyPointers;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.nodes","Field","No Comment","private List nodes;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.values","Field","No Comment","private List values;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.add(Pointer)","Method","* Add a pointer to this NodeSet.
     * @param pointer to add","public void add(final Pointer pointer) {
    if (pointers.add(pointer)) {
        clearCacheLists();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.add(Pointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.BasicNodeSet.add(Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.add(NodeSet)","Method","* Add the specified NodeSet to this NodeSet.
     * @param nodeSet to add","public void add(final NodeSet nodeSet) {
    if (pointers.addAll(nodeSet.getPointers())) {
        clearCacheLists();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.add(NodeSet).nodeSet","Parameter_1","Belong to org.apache.commons.jxpath.BasicNodeSet.add(NodeSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.remove(Pointer)","Method","* Remove a pointer from this NodeSet.
     * @param pointer to remove","public void remove(final Pointer pointer) {
    if (pointers.remove(pointer)) {
        clearCacheLists();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.remove(Pointer).pointer","Parameter_1","Belong to org.apache.commons.jxpath.BasicNodeSet.remove(Pointer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.getPointers()","Method","No Comment","@Override
public synchronized List getPointers() {
    if (readOnlyPointers == null) {
        readOnlyPointers = Collections.unmodifiableList(pointers);
    }
    return readOnlyPointers;
}","List","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.getNodes()","Method","No Comment","@Override
public synchronized List getNodes() {
    if (nodes == null) {
        nodes = new ArrayList();
        for (int i = 0; i < pointers.size(); i++) {
            final Pointer pointer = (Pointer) pointers.get(i);
            nodes.add(pointer.getNode());
        }
        nodes = Collections.unmodifiableList(nodes);
    }
    return nodes;
}","List","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.getValues()","Method","No Comment","@Override
public synchronized List getValues() {
    if (values == null) {
        values = new ArrayList();
        for (int i = 0; i < pointers.size(); i++) {
            final Pointer pointer = (Pointer) pointers.get(i);
            values.add(pointer.getValue());
        }
        values = Collections.unmodifiableList(values);
    }
    return values;
}","List","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.toString()","Method","No Comment","@Override
public String toString() {
    return pointers.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicNodeSet.clearCacheLists()","Method","* Clear cache list members.","private synchronized void clearCacheLists() {
    readOnlyPointers = null;
    nodes = null;
    values = null;
}","void","private , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Function","Interface","* Extension function interface. Extension functions are grouped into
 * {@link Functions Functions} objects, which are installed on
 * JXPathContexts using the
 * {@link JXPathContext#setFunctions JXPathContext.setFunctions()}
 * call.
 * <p>
 * The Function interface can be implemented directly. However,
 * most of the time JXPath's built-in implementations should suffice.
 * See {@link ClassFunctions ClassFunctions} and
 * {@link PackageFunctions PackageFunctions}.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.Function.invoke(ExpressionContext,Object[])","Abstract Method","* Computes the value of the function. Each implementation of Function
     * is responsible for conversion of supplied parameters to the required
     * argument types.
     *
     * @param context can be used to acquire the context in which the
     *    function is being evaluted.
     * @param parameters function arguments
     * @return Object result","Object invoke(ExpressionContext context, Object[] parameters);","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Function.invoke(ExpressionContext,Object[]).context","Parameter_1","Belong to org.apache.commons.jxpath.Function.invoke(ExpressionContext,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.Function.invoke(ExpressionContext,Object[]).parameters","Parameter_2","Belong to org.apache.commons.jxpath.Function.invoke(ExpressionContext,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector","Class","* JXPathIntrospector  maintains a registry of {@link JXPathBeanInfo
 * JXPathBeanInfo} objects for Java classes.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.jxpath.JXPathIntrospector.byClass","Field","No Comment","private static Map byClass = Collections.synchronizedMap(new HashMap());","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.byInterface","Field","No Comment","private static Map byInterface = Collections.synchronizedMap(new HashMap());","No return type","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.registerAtomicClass(Class)","Method","* Automatically creates and registers a JXPathBeanInfo object
     * for the specified class. That object returns true to isAtomic().
     * @param beanClass to register","public static void registerAtomicClass(final Class beanClass) {
    synchronized (byClass) {
        byClass.put(beanClass, new JXPathBasicBeanInfo(beanClass, true));
    }
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.registerAtomicClass(Class).beanClass","Parameter_1","Belong to org.apache.commons.jxpath.JXPathIntrospector.registerAtomicClass(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.registerDynamicClass(Class,Class)","Method","* Automatically creates and registers a {@link JXPathBeanInfo} object
     * for the specified class. That object returns true to
     * {@link JXPathBeanInfo#isDynamic()}.
     *
     * @param beanClass to register
     * @param dynamicPropertyHandlerClass to handle beanClass","public static void registerDynamicClass(final Class beanClass, final Class dynamicPropertyHandlerClass) {
    final JXPathBasicBeanInfo bi = new JXPathBasicBeanInfo(beanClass, dynamicPropertyHandlerClass);
    if (beanClass.isInterface()) {
        synchronized (byInterface) {
            byInterface.put(beanClass, bi);
        }
    } else {
        synchronized (byClass) {
            byClass.put(beanClass, bi);
        }
    }
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.registerDynamicClass(Class,Class).beanClass","Parameter_1","Belong to org.apache.commons.jxpath.JXPathIntrospector.registerDynamicClass(Class,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.registerDynamicClass(Class,Class).dynamicPropertyHandlerClass","Parameter_2","Belong to org.apache.commons.jxpath.JXPathIntrospector.registerDynamicClass(Class,Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.getBeanInfo(Class)","Method","* Creates and registers a JXPathBeanInfo object for the supplied class. If
     * the class has already been registered, returns the registered
     * JXPathBeanInfo object.
     * <p>
     * The process of creation of JXPathBeanInfo is as follows:
     * <ul>
     * <li>If class named {@code <beanClass>XBeanInfo} exists,
     *     an instance of that class is allocated.
     * <li>Otherwise, an instance of {@link JXPathBasicBeanInfo
     *     JXPathBasicBeanInfo}  is allocated.
     * </ul>
     * @param beanClass whose info to get
     * @return JXPathBeanInfo","public static JXPathBeanInfo getBeanInfo(final Class beanClass) {
    JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass);
    if (beanInfo == null) {
        beanInfo = findDynamicBeanInfo(beanClass);
        if (beanInfo == null) {
            beanInfo = findInformant(beanClass);
            if (beanInfo == null) {
                beanInfo = new JXPathBasicBeanInfo(beanClass);
            }
        }
        synchronized (byClass) {
            byClass.put(beanClass, beanInfo);
        }
    }
    return beanInfo;
}","JXPathBeanInfo","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.getBeanInfo(Class).beanClass","Parameter_1","Belong to org.apache.commons.jxpath.JXPathIntrospector.getBeanInfo(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.findDynamicBeanInfo(Class)","Method","* Find a dynamic bean info if available for any superclasses or
     * interfaces.
     * @param beanClass to search for
     * @return JXPathBeanInfo","private static JXPathBeanInfo findDynamicBeanInfo(final Class beanClass) {
    JXPathBeanInfo beanInfo;
    if (beanClass.isInterface()) {
        beanInfo = (JXPathBeanInfo) byInterface.get(beanClass);
        if (beanInfo != null && beanInfo.isDynamic()) {
            return beanInfo;
        }
    }
    final Class[] interfaces = beanClass.getInterfaces();
    if (interfaces != null) {
        for (final Class element : interfaces) {
            beanInfo = findDynamicBeanInfo(element);
            if (beanInfo != null && beanInfo.isDynamic()) {
                return beanInfo;
            }
        }
    }
    final Class sup = beanClass.getSuperclass();
    if (sup != null) {
        beanInfo = (JXPathBeanInfo) byClass.get(sup);
        if (beanInfo != null && beanInfo.isDynamic()) {
            return beanInfo;
        }
        return findDynamicBeanInfo(sup);
    }
    return null;
}","JXPathBeanInfo","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.findDynamicBeanInfo(Class).beanClass","Parameter_1","Belong to org.apache.commons.jxpath.JXPathIntrospector.findDynamicBeanInfo(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.findInformant(Class)","Method","* find a JXPathBeanInfo instance for the specified class.
     * Similar to javax.beans property handler discovery; search for a
     * class with ""XBeanInfo"" appended to beanClass.name, then check
     * whether beanClass implements JXPathBeanInfo for itself.
     * Invokes the default constructor for any class it finds.
     * @param beanClass for which to look for an info provider
     * @return JXPathBeanInfo instance or null if none found","private static synchronized JXPathBeanInfo findInformant(final Class beanClass) {
    final String name = beanClass.getName() + ""XBeanInfo"";
    try {
        return (JXPathBeanInfo) instantiate(beanClass, name);
    } catch (final Exception ignore) {
        // NOPMD
        // Just drop through
    }
    // Now try checking if the bean is its own JXPathBeanInfo.
    try {
        if (JXPathBeanInfo.class.isAssignableFrom(beanClass)) {
            return (JXPathBeanInfo) beanClass.getConstructor().newInstance();
        }
    } catch (final Exception ignore) {
        // NOPMD
        // Just drop through
    }
    return null;
}","JXPathBeanInfo","private , static , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.findInformant(Class).beanClass","Parameter_1","Belong to org.apache.commons.jxpath.JXPathIntrospector.findInformant(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.instantiate(Class,String)","Method","* Try to create an instance of a named class.
     * First try the classloader of ""sibling"", then try the system
     * classloader.
     * @param sibling Class
     * @param className to instantiate
     * @return new Object
     * @throws Exception if instantiation fails","private static Object instantiate(final Class sibling, final String className) throws Exception {
    // First check with sibling's classloader (if any).
    final ClassLoader cl = sibling.getClassLoader();
    if (cl != null) {
        try {
            final Class cls = cl.loadClass(className);
            return cls.getConstructor().newInstance();
        } catch (final Exception ex) {
            //NOPMD
            // Just drop through and use the ClassLoaderUtil.
        }
    }
    // Now try the ClassLoaderUtil.
    final Class cls = ClassLoaderUtil.getClass(className);
    return cls.newInstance();
}","Object","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.instantiate(Class,String).sibling","Parameter_1","Belong to org.apache.commons.jxpath.JXPathIntrospector.instantiate(Class,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.JXPathIntrospector.instantiate(Class,String).className","Parameter_2","Belong to org.apache.commons.jxpath.JXPathIntrospector.instantiate(Class,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables","Class","* A basic implementation of the Variables interface that uses a HashMap.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.jxpath.Variables"
"org.apache.commons.jxpath.BasicVariables.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 2708263960832062725L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.vars","Field","* Contains the values of declared variables","private final HashMap vars = new HashMap();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.isDeclaredVariable(String)","Method","* Returns true if the variable has been defined, even if the
     * value of the variable is null.
     *
     * @param varName is a variable name without the ""$"" sign
     * @return true if the variable is declared","@Override
public boolean isDeclaredVariable(final String varName) {
    return vars.containsKey(varName);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.isDeclaredVariable(String).varName","Parameter_1","Belong to org.apache.commons.jxpath.BasicVariables.isDeclaredVariable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.getVariable(String)","Method","* Returns the value of the variable if it is defined,
     * otherwise, throws IllegalArgumentException
     *
     * @param varName is a variable name without the ""$"" sign
     * @return the value of the variable","@Override
public Object getVariable(final String varName) {
    // Note that a variable may be defined with a null value
    if (vars.containsKey(varName)) {
        return vars.get(varName);
    }
    throw new IllegalArgumentException(""No such variable: '"" + varName + ""'"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.getVariable(String).varName","Parameter_1","Belong to org.apache.commons.jxpath.BasicVariables.getVariable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.declareVariable(String,Object)","Method","* Defines a new variable with the specified value or modifies
     * the value of an existing variable.
     *
     * @param varName is a variable name without the ""$"" sign
     * @param value is the new value for the variable, which can be null","@Override
public void declareVariable(final String varName, final Object value) {
    vars.put(varName, value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.declareVariable(String,Object).varName","Parameter_1","Belong to org.apache.commons.jxpath.BasicVariables.declareVariable(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.declareVariable(String,Object).value","Parameter_2","Belong to org.apache.commons.jxpath.BasicVariables.declareVariable(String,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.undeclareVariable(String)","Method","* Removes an existing variable. May throw UnsupportedOperationException.
     *
     * @param varName is a variable name without the ""$"" sign","@Override
public void undeclareVariable(final String varName) {
    vars.remove(varName);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.undeclareVariable(String).varName","Parameter_1","Belong to org.apache.commons.jxpath.BasicVariables.undeclareVariable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.jxpath.BasicVariables.toString()","Method","No Comment","@Override
public String toString() {
    return vars.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
