FEN:ID,:LABEL,Comment,Modifiers,Extends,Implements
org.apache.commons.jxpath.JXPathContext,Abstract Class,"* JXPathContext  provides APIs for the traversal of graphs of JavaBeans using\n * the XPath syntax. Using JXPathContext, you can read and write properties of\n * JavaBeans, arrays, collections and maps. JXPathContext uses JavaBeans\n * introspection to enumerate and access JavaBeans properties.\n * <p>\n * JXPathContext  allows alternative implementations. This is why instead of\n * allocating JXPathContext directly, you should call a static\n * {@code newContext} method.  This method will utilize the\n * {@link JXPathContextFactory} API to locate a suitable implementation of\n * JXPath. Bundled with JXPath comes a default implementation called Reference\n * Implementation.\n * </p>\n *\n * <h2>JXPath Interprets XPath Syntax on Java Object Graphs</h2>\n *\n * JXPath uses an intuitive interpretation of the xpath syntax in the context\n * of Java object graphs. Here are some examples:\n *\n * <h3>Example 1: JavaBean Property Access</h3>\n *\n * JXPath can be used to access properties of a JavaBean.\n *\n * <pre>\n * public class Employee {\n *    public String getFirstName(){\n *       ...\n *    }\n * }\n *\n * Employee emp = new Employee();\n * ...\n *\n * JXPathContext context = JXPathContext.newContext(emp);\n * String fName = (String)context.getValue(""firstName"");\n * </pre>\n *\n * In  this example, we are using JXPath to access a property of the\n * {@code emp} bean. In this simple case the invocation of JXPath is\n * equivalent to invocation of getFirstName() on the bean.\n *\n * <h3>Example 2: Nested Bean Property Access</h3>\n * JXPath can traverse object graphs:\n *\n * <pre>\n * public class Employee {\n *    public Address getHomeAddress(){\n *       ...\n *    }\n * }\n * public class Address {\n *    public String getStreetNumber(){\n *       ...\n *    }\n * }\n *\n * Employee emp = new Employee();\n * ...\n *\n * JXPathContext context = JXPathContext.newContext(emp);\n * String sNumber = (String)context.getValue(""homeAddress/streetNumber"");\n * </pre>\n *\n * In this case XPath is used to access a property of a nested bean.\n * <p>\n * A property identified by the xpath does not have to be a ""leaf"" property.\n * For instance, we can extract the whole Address object in above example:\n * </p>\n * <pre>\n *    Address addr = (Address)context.getValue(""homeAddress"");\n * </pre>\n *\n * <h3>Example 3: Collection Subscripts</h3>\n * JXPath can extract elements from arrays and collections.\n *\n * <pre>\n * public class Integers {\n *    public int[] getNumbers(){\n *       ...\n *    }\n * }\n *\n * Integers ints = new Integers();\n * ...\n *\n * JXPathContext context = JXPathContext.newContext(ints);\n * Integer thirdInt = (Integer)context.getValue(""numbers[3]"");\n * </pre>\n * A  collection can be an arbitrary array or an instance of java.util.\n * Collection.\n * <p>\n * Note: in XPath the first element of a collection has index 1, not 0.<br>\n *\n * <h3>Example 4: Map Element Access</h3>\n *\n * JXPath supports maps. To get a value use its key.\n *\n * <pre>\n * public class Employee {\n *    public Map getAddresses(){\n *       return addressMap;\n *    }\n *\n *    public void addAddress(String key, Address address){\n *       addressMap.put(key, address);\n *    }\n *    ...\n * }\n *\n * Employee emp = new Employee();\n * emp.addAddress(""home"", new Address(...));\n * emp.addAddress(""office"", new Address(...));\n * ...\n *\n * JXPathContext context = JXPathContext.newContext(emp);\n * String homeZipCode = (String)context.getValue(""addresses/home/zipCode"");\n * </pre>\n *\n * Often you will need to use the alternative syntax for accessing Map\n * elements:\n *\n * <pre>\n * String homeZipCode =\n *     (String) context.getValue(""addresses[@name='home']/zipCode"");\n * </pre>\n *\n * In this case, the key can be an expression, e.g. a variable.<br>\n *\n * Note: At this point JXPath only supports Maps that use strings for keys.<br>\n * Note: JXPath supports the extended notion of Map: any object with\n *       dynamic properties can be handled by JXPath provided that its\n *       class is registered with the {@link JXPathIntrospector}.\n *\n * <h3>Example 5: Retrieving Multiple Results</h3>\n *\n * JXPath can retrieve multiple objects from a graph. Note that the method\n * called in this case is not {@code getValue}, but {@code iterate}.\n *\n * <pre>{@code\n * public class Author {\n *    public Book[] getBooks(){\n *       ...\n *    }\n * }\n *\n * Author auth = new Author();\n * ...\n *\n * JXPathContext context = JXPathContext.newContext(auth);\n * Iterator threeBooks = context.iterate(""books[position() < 4]"");\n * }</pre>\n *\n * This returns a list of at most three books from the array of all books\n * written by the author.\n *\n * <h3>Example 6: Setting Properties</h3>\n * JXPath can be used to modify property values.\n *\n * <pre>\n * public class Employee {\n *    public Address getAddress() {\n *       ...\n *    }\n *\n *    public void setAddress(Address address) {\n *       ...\n *    }\n * }\n *\n * Employee emp = new Employee();\n * Address addr = new Address();\n * ...\n *\n * JXPathContext context = JXPathContext.newContext(emp);\n * context.setValue(""address"", addr);\n * context.setValue(""address/zipCode"", ""90190"");\n *\n * </pre>\n *\n * <h3>Example 7: Creating objects</h3>\n * JXPath  can be used to create new objects. First, create a subclass of {@link\n * AbstractFactory AbstractFactory} and install it on the JXPathContext. Then\n * call {@link JXPathContext#createPath createPathAndSetValue()} instead of\n * ""setValue"". JXPathContext will invoke your AbstractFactory when it discovers\n * that an intermediate node of the path is <strong>null</strong>.  It will not override\n * existing nodes.\n *\n * <pre>\n * public class AddressFactory extends AbstractFactory {\n *    public boolean createObject(JXPathContext context,\n *               Pointer pointer, Object parent, String name, int index){\n *     if ((parent instanceof Employee) &amp;&amp; name.equals(""address""){\n *       ((Employee)parent).setAddress(new Address());\n *       return true;\n *     }\n *     return false;\n *   }\n * }\n *\n * JXPathContext context = JXPathContext.newContext(emp);\n * context.setFactory(new AddressFactory());\n * context.createPathAndSetValue(""address/zipCode"", ""90190"");\n * </pre>\n *\n * <h3>Example 8: Using Variables</h3>\n * JXPath supports the notion of variables. The XPath syntax for accessing\n * variables is <em>""$varName""</em>.\n *\n * <pre>\n * public class Author {\n *    public Book[] getBooks(){\n *       ...\n *    }\n * }\n *\n * Author auth = new Author();\n * ...\n *\n * JXPathContext context = JXPathContext.newContext(auth);\n * context.getVariables().declareVariable(""index"", Integer.valueOf(2));\n *\n * Book secondBook = (Book)context.getValue(""books[$index]"");\n * </pre>\n *\n * You can also set variables using JXPath:\n *\n * <pre>\n * context.setValue(""$index"", Integer.valueOf(3));\n * </pre>\n *\n * Note: you can only <em>change</em> the value of an existing variable this\n * way, you cannot <em>define</em> a new variable.\n *\n * <p>\n * When a variable contains a JavaBean or a collection, you can\n * traverse the bean or collection as well:\n * <pre>\n * ...\n * context.getVariables().declareVariable(""book"", myBook);\n * String title = (String)context.getValue(""$book/title);\n *\n * Book array[] = new Book[]{...};\n *\n * context.getVariables().declareVariable(""books"", array);\n *\n * String title = (String)context.getValue(""$books[2]/title);\n * </pre>\n *\n * <h3>Example 9: Using Nested Contexts</h3>\n * If  you need to use the same set of variable while interpreting XPaths with\n * different beans, it makes sense to put the variables in a separate context\n * and specify that context as a parent context every time you allocate a new\n * JXPathContext for a JavaBean.\n *\n * <pre>\n * JXPathContext varContext = JXPathContext.newContext(null);\n * varContext.getVariables().declareVariable(""title"", ""Java"");\n *\n * JXPathContext context = JXPathContext.newContext(varContext, auth);\n *\n * Iterator javaBooks = context.iterate(""books[title = $title]"");\n * </pre>\n *\n * <h3>Using Custom Variable Pools</h3>\n * By default, JXPathContext creates a HashMap of variables. However,\n * you can substitute a custom implementation of the Variables\n * interface to make JXPath work with an alternative source of variables.\n * For example, you can define implementations of Variables that\n * cover a servlet context, HTTP request or any similar structure.\n *\n * <h3>Example 10: Using Standard Extension Functions</h3>\n * Using the standard extension functions, you can call methods on objects,\n * static methods on classes and create objects using any constructor.\n * The class names should be fully qualified.\n * <p>\n * Here's how you can create new objects:\n * <pre>\n * Book book =\n *    (Book) context.getValue(\n *         ""org.apache.commons.jxpath.example.Book.new ('John Updike')"");\n * </pre>\n *\n * Here's how you can call static methods:\n * <pre>\n *   Book book =\n *    (Book) context.getValue(\n *       ""org. apache.commons.jxpath.example.Book.getBestBook('John Updike')"");\n * </pre>\n *\n * Here's how you can call regular methods:\n * <pre>\n * String firstName = (String)context.getValue(""getAuthorsFirstName($book)"");\n * </pre>\n * As you can see, the target of the method is specified as the first parameter\n * of the function.\n *\n * <h3>Example 11: Using Custom Extension Functions</h3>\n * Collections of custom extension functions can be implemented\n * as {@link Functions Functions} objects or as Java classes, whose methods\n * become extenstion functions.\n * <p>\n * Let's say the following class implements various formatting operations:\n * <pre>\n * public class Formats {\n *    public static String date(Date d, String pattern){\n *        return new SimpleDateFormat(pattern).format(d);\n *    }\n *    ...\n * }\n * </pre>\n *\n * We can register this class with a JXPathContext:\n *\n * <pre>\n * context.setFunctions(new ClassFunctions(Formats.class, ""format""));\n * ...\n *\n * context.getVariables().declareVariable(""today"", new Date());\n * String today = (String)context.getValue(""format:date($today, 'MM/dd/yyyy')"");\n *\n * </pre>\n * You can also register whole packages of Java classes using PackageFunctions.\n * <p>\n * Also, see {@link FunctionLibrary FunctionLibrary}, which is a class\n * that allows you to register multiple sets of extension functions with\n * the same JXPathContext.\n *\n * <h2>Configuring JXPath</h2>\n *\n * JXPath uses JavaBeans introspection to discover properties of JavaBeans.\n * You can provide alternative property lists by supplying\n * custom JXPathBeanInfo classes (see {@link JXPathBeanInfo JXPathBeanInfo}).\n *\n * <h2>Notes</h2>\n * <ul>\n * <li> JXPath does not support DOM attributes for non-DOM objects. Even though\n * XPaths like ""para[@type='warning']"" are legitimate, they will always produce\n * empty results. The only attribute supported for JavaBeans is ""name"".  The\n * XPath ""foo/bar"" is equivalent to ""foo[@name='bar']"".\n *\n * <li id='matches_no_property_in_the_graph'>The term <b>matches no property in\n * the graph</b> is used throughout the documentation. It describes a property or\n * path that can be determined as not belonging to the graph. Determining\n * whether a property or path belongs to the graph depends on the type of object\n * being used as {@code cotextBean} (see {@link #newContext(Object)}).\n * It is only possible strongly typed models where a specific Java model is used\n * as context. It is not possible with dynamic models such Maps or DOM\n * implementations.\n * <p>When a XPath does not match a property in the graph, the methods of this\n * class that retrieve a pointer will generally behave in the following way,\n * depending on the last value configured with {@link #setLenient(boolean)}:</p>\n *\n *  <ol style='list-style:upper-alpha'>\n *      <li>If {@code lenient} is {@code false} (default) - methods\n *          will throw {@link JXPathNotFoundException}.\n *      <li>If {@code lenient} is {@code true} - methods will throw\n *          no exception and return a value appropriate for that method to\n *          express the absence: might be a Java {@code null} or a\n *          {@link Pointer} whose {@link Pointer#getValue()} returns\n *          {@code null}, depends on the method.\n *  </ol>\n * </li>\n * </ul>\n *\n * See  <a href=""http://www.w3schools.com/xpath"">XPath Tutorial by\n * W3Schools</a><br>. Also see <a href=""http://www.w3.org/TR/xpath"">XML Path\n * Language (XPath) Version 1.0</a><br><br>\n *\n * You will also find more information and examples in\n * <a href=""https://commons.apache.org/jxpath/users-guide.html"">\n * JXPath User's Guide</a>","public , abstract ",,
org.apache.commons.jxpath.JXPathTypeConversionException,Class,No Comment,public ,org.apache.commons.jxpath.JXPathException,
org.apache.commons.jxpath.servlet.ServletRequestHandler,Class,* Implementation of the {@link org.apache.commons.jxpath.DynamicPropertyHandler}\n * interface that provides access to attributes and parameters\n * of a {@link ServletRequest}.,public ,org.apache.commons.jxpath.servlet.HttpSessionHandler,
org.apache.commons.jxpath.servlet.PageScopeContextHandler,Class,* Implementation of the {@link DynamicPropertyHandler} interface that provides\n * access to attributes of a {@link PageScopeContext}.,public ,,org.apache.commons.jxpath.DynamicPropertyHandler
org.apache.commons.jxpath.servlet.ServletContextHandler,Class,* Implementation of the {@link DynamicPropertyHandler} interface that provides\n * access to attributes of a {@link ServletContext}.,public ,,org.apache.commons.jxpath.DynamicPropertyHandler
org.apache.commons.jxpath.servlet.PageScopeContext,Class,"* A lightweight wrapper for {@link PageContext} that restricts access\n * to attributes of the ""page"" scope.  This object is needed so that\n * XPath ""foo"" would lookup the attribute ""foo"" in all scopes, while\n * ""$page/foo"" would only look in the ""page"" scope.",public ,,
org.apache.commons.jxpath.servlet.HttpSessionHandler,Class,* Implementation of the {@link org.apache.commons.jxpath.DynamicPropertyHandler}\n * interface that provides access to attributes of a @{link HttpSession}.,public ,org.apache.commons.jxpath.servlet.ServletContextHandler,
org.apache.commons.jxpath.servlet.KeywordVariables,Class,* Implementation of the Variables interface that provides access\n * to a single object using a reserved name (keyword).,public ,,org.apache.commons.jxpath.Variables
org.apache.commons.jxpath.servlet.PageContextHandler,Class,* Implementation of the {@link DynamicPropertyHandler} interface that provides\n * access to attributes of a {@link PageContext} in all scopes.,public ,,org.apache.commons.jxpath.DynamicPropertyHandler
org.apache.commons.jxpath.servlet.HttpSessionAndServletContext,Class,* Just a structure to hold a ServletRequest and ServletContext together.,public ,,
org.apache.commons.jxpath.servlet.JXPathServletContexts,Class,"* Static methods that allocate and cache JXPathContexts bound to\n * {@link PageContext}, {@link ServletRequest}, {@link HttpSession}\n * and {@link ServletContext}.\n * <p>\n * The {@link JXPathContext} returned by {@link #getPageContext getPageContext()}\n * provides access to all scopes via the PageContext.findAttribute()\n * method.  Thus, an expression like ""foo"" will first look for the attribute\n * named ""foo"" in the ""page"" context, then the ""request"" context, then\n * the ""session"" one and finally in the ""application"" context.\n * <p>\n * If you need to limit the attibute lookup to just one scope, you can use the\n * pre-definded variables ""page"", ""request"", ""session"" and ""application"".\n * For example, the expression ""$session/foo"" extracts the value of the\n * session attribute named ""foo"".\n * <p>\n * Following are some implementation details. There is a separate JXPathContext\n * for each of the four scopes. These contexts are chained according to the\n * nesting of the scopes.  So, the parent of the ""page"" JXPathContext is a\n * ""request"" JXPathContext, whose parent is a ""session"" JXPathContext (that is\n * if there is a session), whose parent is an ""application"" context.\n * <p>\n * The  XPath context node for each context is the corresponding object:\n * PageContext, ServletRequest, HttpSession or ServletContext.  This feature can\n * be used by servlets.  A servlet can use one of the methods declared by this\n * class and work with a specific JXPathContext for any scope.\n * <p>\n * Since JXPath chains lookups for variables and extension functions, variables\n * and extension function declared in the outer scopes are also available in\n * the inner scopes.\n * <p>\n * Each  of the four context declares exactly one variable, the value of which\n * is the corresponding object: PageContext, etc.\n * <p>\n * The  ""session"" variable will be undefined if there is no session for this\n * servlet. JXPath does not automatically create sessions.","public , final ",,
org.apache.commons.jxpath.servlet.ServletRequestAndContext,Class,* Just a structure to hold a {@link ServletRequest} and {@link ServletContext}\n * together.,public ,org.apache.commons.jxpath.servlet.HttpSessionAndServletContext,
org.apache.commons.jxpath.servlet.Constants,Class,* String constants for this package.,"public , final ",,
org.apache.commons.jxpath.Pointer,Interface,"* Pointers represent locations of objects and their properties\n * in Java object graphs. JXPathContext has methods\n * ({@link JXPathContext#getPointer(java.lang.String) getPointer()}\n * and  ({@link JXPathContext#iteratePointers(java.lang.String)\n * iteratePointers()}, which, given an XPath, produce Pointers for the objects\n * or properties described the path. For example, {@code ctx.getPointer\n * (""foo/bar"")} will produce a Pointer that can get and set the property\n * ""bar"" of the object which is the value of the property ""foo"" of the root\n * object. The value of {@code ctx.getPointer(""aMap/aKey[3]"")} will be a\n * pointer to the 3'rd element of the array, which is the value for the key\n * ""aKey"" of the map, which is the value of the property ""aMap"" of the root\n * object.",public ,java.lang.Cloneable;java.lang.Comparable;java.io.Serializable,
org.apache.commons.jxpath.Functions,Interface,* A group of Function objects sharing a common namespace or a set of\n * common namespaces. Use the classes\n * {@link ClassFunctions ClassFunctions} and\n * {@link PackageFunctions PackageFunctions}\n * to register extension functions implemented as Java methods.,public ,,
org.apache.commons.jxpath.ExpressionContext,Interface,"* If an extenstion function has an argument of type ExpressionContext,\n * it can gain access to the current node of an XPath expression context.\n * <p>\n * Example:\n * <blockquote><pre>\n * public class MyExtenstionFunctions {\n *    public static String objectType(ExpressionContext context){\n *       Object value = context.getContextNodePointer().getValue();\n *       if (value == null){\n *           return ""null"";\n *       }\n *       return value.getClass().getName();\n *    }\n * }\n * </pre></blockquote>\n *\n * You can then register this extension function using a {@link ClassFunctions\n * ClassFunctions} object and call it like this:\n * <blockquote><pre>\n *   ""/descendent-or-self::node()[ns:objectType() = 'java.util.Date']""\n * </pre></blockquote>\n * This expression will find all nodes of the graph that are dates.",public ,,
org.apache.commons.jxpath.ExceptionHandler,Interface,* Exception handler interface.  Actually handles Throwables.\n * @since 1.4,public ,,
org.apache.commons.jxpath.IdentityManager,Interface,"* A delegate of {@link JXPathContext} that implements the XPath {@code ""id()""}\n * function. This delegate is only used when there is no default implementation\n * of the {@code id()} function. For example, it is <em>not</em> used\n * when the root of the context is a DOM Node.",public ,,
org.apache.commons.jxpath.JXPathBasicBeanInfo,Class,* An implementation of JXPathBeanInfo based on JavaBeans' BeanInfo. Properties\n * advertised by JXPathBasicBeanInfo are the same as those advertised by\n * BeanInfo for the corresponding class.\n *\n * @see java.beans.BeanInfo\n * @see java.beans.Introspector,public ,,org.apache.commons.jxpath.JXPathBeanInfo
org.apache.commons.jxpath.Variables,Interface,"* Variables provide access to a global set of values accessible via XPath.\n * XPath can reference variables using the {@code ""$varname""} syntax.\n * To use a custom implementation of this interface, pass it to\n * {@link JXPathContext#setVariables JXPathContext.setVariables()}",public ,java.io.Serializable,
org.apache.commons.jxpath.util.BasicTypeConverter,Class,* The default implementation of TypeConverter.,public ,,org.apache.commons.jxpath.util.TypeConverter
org.apache.commons.jxpath.util.BasicTypeConverter$ValueNodeSet,Class,* NodeSet implementation,"static , final ",,org.apache.commons.jxpath.NodeSet
org.apache.commons.jxpath.util.BasicTypeConverter$ValuePointer,Class,* Value pointer,"static , final ",,org.apache.commons.jxpath.Pointer
org.apache.commons.jxpath.util.TypeUtils,Class,* Global type conversion utilities.,public ,,
org.apache.commons.jxpath.util.TypeConverter,Interface,* A type converter can be installed on {@link TypeUtils} to introduce\n * additional type conversions for JXPath. Most of\n * the time {@link BasicTypeConverter} should be used as the superclass.\n *\n * @see TypeUtils#setTypeConverter,public ,,
org.apache.commons.jxpath.util.ReverseComparator,Class,* Reverse comparator.,"public , final ",,java.util.Comparator;java.io.Serializable
org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter,Class,* TypeConverter implementation to circumvent automagic {@link NodeSet}\n * decoding. Suggested by JIRA issue JXPATH-10.\n *\n * @since JXPath 1.3,public ,org.apache.commons.jxpath.util.BasicTypeConverter,
org.apache.commons.jxpath.util.ClassLoaderUtil,Class,* Port of class loading methods from {@code org.apache.commons.lang3.ClassUtils} from\n * the Apache Commons Lang Component. Some adjustments made to remove dependency on\n * {@code org.apache.commons.lang3.StringUtils}. Also modified to fall back on the\n * current class loader when an attempt to load a class with the context class loader\n * results in a {@code java.lang.ClassNotFoundException}.\n *\n * See org.apache.commons.lang3.ClassUtils,public ,,
org.apache.commons.jxpath.util.ValueUtils,Class,* Collection and property access utilities.,public ,,
org.apache.commons.jxpath.util.MethodLookupUtils,Class,"* Method lookup utilities, which find static and non-static methods as well\n * as constructors based on a name and list of parameters.",public ,,
org.apache.commons.jxpath.util.KeyManagerUtils,Class,* Utility class.\n * @since JXPath 1.3,public ,,
org.apache.commons.jxpath.util.KeyManagerUtils$SingleNodeExtendedKeyManager,Class,* Adapt KeyManager to implement ExtendedKeyManager.,"private , static , final ",,org.apache.commons.jxpath.ExtendedKeyManager
org.apache.commons.jxpath.JXPathInvalidSyntaxException,Class,No Comment,public ,org.apache.commons.jxpath.JXPathException,
org.apache.commons.jxpath.AbstractFactory,Abstract Class,* The  {@link JXPathContext#createPath JXPathContext.createPath()} method of\n * JXPathContext can create missing objects as it traverses an XPath; it\n * utilizes an AbstractFactory for that purpose. Install a factory on\n * JXPathContext by calling {@link JXPathContext#setFactory JXPathContext.\n * setFactory()}.\n * <p>\n * All  methods of this class return false.  Override any of them to return true\n * to indicate that the factory has successfully created the described object.,"public , abstract ",,
org.apache.commons.jxpath.JXPathInvalidAccessException,Class,"* Similary to {@link java.lang.reflect.InvocationTargetException} in that\n * it is thrown when JXPath cannot access properties, collection etc on the\n * target object model.",public ,org.apache.commons.jxpath.JXPathException,
org.apache.commons.jxpath.ClassFunctions,Class,"* Extension functions provided by a Java class.\n *\n * Let's say we declared a ClassFunction like this:\n * <blockquote><pre>\n *     new ClassFunctions(Integer.class, ""int"")\n * </pre></blockquote>\n *\n * We can now use XPaths like:\n * <dl>\n *  <dt>{@code ""int:new(3)""}</dt>\n *  <dd>Equivalent to {@code Integer.valueOf(3)}</dd>\n *  <dt>{@code ""int:getInteger('foo')""}</dt>\n *  <dd>Equivalent to {@code Integer.getInteger(""foo"")}</dd>\n *  <dt>{@code ""int:floatValue(int:new(4))""}</dt>\n *  <dd>Equivalent to {@code Integer.valueOf(4).floatValue()}</dd>\n * </dl>\n *\n * <p>\n * If the first argument of a method is {@link ExpressionContext}, the\n * expression context in which the function is evaluated is passed to\n * the method.",public ,,org.apache.commons.jxpath.Functions
org.apache.commons.jxpath.XMLDocumentContainer,Class,"* An XML document container reads and parses XML only when it is\n * accessed.  JXPath traverses Containers transparently -\n * you use the same paths to access objects in containers as you\n * do to access those objects directly.  You can create\n * XMLDocumentContainers for various XML documents that may or\n * may not be accessed by XPaths.  If they are, they will be automatically\n * read, parsed and traversed. If they are not - they won't be\n * read at all.\n *\n * @deprecated 1.1 Please use {@link DocumentContainer}",public ,,org.apache.commons.jxpath.Container
org.apache.commons.jxpath.DynamicPropertyHandler,Interface,"* A generic mechanism for accessing collections of name/value pairs.\n * Examples of such collections are HashMap, Properties,\n * ServletContext.  In order to add support for a new such collection\n * type to JXPath, perform the following two steps:\n * <ol>\n * <li>Build an implementation of the DynamicPropertyHandler interface\n * for the desired collection type.</li>\n * <li>Invoke the static method {@link JXPathIntrospector#registerDynamicClass\n * JXPathIntrospector.registerDynamicClass(class, handlerClass)}</li>\n * </ol>\n * JXPath allows access to dynamic properties using these three formats:\n * <ul>\n * <li>{@code ""myMap/myKey""}</li>\n * <li>{@code ""myMap[@name = 'myKey']""}</li>\n * <li>{@code ""myMap[name(.) = 'myKey']""}</li>\n * </ul>",public ,,
org.apache.commons.jxpath.ri.Parser,Class,* XPath parser,public ,,
org.apache.commons.jxpath.ri.axes.AncestorContext,Class,"* EvalContext that walks the ""ancestor::"" and ""ancestor-or-self::"" axes.",public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.ParentContext,Class,"* EvalContext that walks the ""parent::"" axis.",public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext,Class,"* EvalContext that walks the ""preceding::"" and ""following::"" axes.",public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.NamespaceContext,Class,"* EvalContext that walks the ""namespace::"" axis.",public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.PredicateContext,Class,* EvalContext that checks predicates.,public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.NodeSetContext,Class,* A simple context that is based on a {@link NodeSet}.,public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.SimplePathInterpreter,Class,"* An evaluation mechanism for simple XPaths, which\n * is much faster than the usual process. It is only used for\n * xpaths which have no context-dependent parts, consist entirely of\n * {@code child::name} and {@code self::node()} steps with\n * predicates that either integer or have the form {@code [@name = ...]}.",public ,,
org.apache.commons.jxpath.ri.axes.InitialContext,Class,* A single-set EvalContext that provides access to the current node of\n * the parent context and nothing else.  It does not pass the iteration\n * on to the parent context.,public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.DescendantContext,Class,"* An EvalContext that walks the ""descendant::"" and ""descendant-or-self::""\n * axes.",public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.RootContext,Class,* EvalContext that is used to hold the root node for the path traversal.,public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.SelfContext,Class,* EvalContext that returns the current node from the parent context if the\n * test succeeds.,public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.AttributeContext,Class,"* EvalContext that walks the ""attribute::"" axis.",public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.axes.UnionContext,Class,* EvalContext that represents a union between other contexts - result\n * of a union operation like (a | b),public ,org.apache.commons.jxpath.ri.axes.NodeSetContext,
org.apache.commons.jxpath.ri.axes.ChildContext,Class,"* EvalContext that can walk the ""child::"", ""following-sibling::"" and\n * ""preceding-sibling::"" axes.",public ,org.apache.commons.jxpath.ri.EvalContext,
org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl,Class,* Default implementation of JXPathContextFactory.,public ,org.apache.commons.jxpath.JXPathContextFactory,
org.apache.commons.jxpath.ri.Compiler,Interface,"* The Compiler APIs are completely agnostic to the actual types of objects\n * produced and consumed by the APIs.  Arguments and return values are\n * declared as java.lang.Object.\n * <p>\n * Since objects returned by Compiler methods are passed as arguments to other\n * Compiler methods, the descriptions of these methods use virtual types.  There\n * are four virtual object types: EXPRESSION, QNAME, STEP and NODE_TEST.\n * <p>\n * The following example illustrates this notion.  This sequence compiles\n * the xpath ""foo[round(1 div 2)]/text()"":\n * <blockquote><pre>\n *      Object qname1 = compiler.qname(null, ""foo"")\n *      Object expr1 = compiler.number(""1"");\n *      Object expr2 = compiler.number(""2"");\n *      Object expr3 = compiler.div(expr1, expr2);\n *      Object expr4 = compiler.\n *              coreFunction(Compiler.FUNCTION_ROUND, new Object[]{expr3});\n *      Object test1 = compiler.nodeNameTest(qname1);\n *      Object step1 = compiler.\n *              step(Compiler.AXIS_CHILD, test1, new Object[]{expr4});\n *      Object test2 = compiler.nodeTypeTest(Compiler.NODE_TYPE_TEXT);\n *      Object step2 = compiler.nodeTypeTest(Compiler.AXIS_CHILD, test2, null);\n *      Object expr5 = compiler.locationPath(false, new Object[]{step1, step2});\n * </pre></blockquote>",public ,,
org.apache.commons.jxpath.ri.parser.TokenMgrError,Class,No Comment,public ,java.lang.Error,
org.apache.commons.jxpath.ri.parser.ParseException,Class,* This exception is thrown when parse errors are encountered.\n * You can explicitly create objects of this exception type by\n * calling the method generateParseException in the generated\n * parser.\n *\n * You can modify this class to customize your error reporting\n * mechanisms so long as you retain the public fields.,public ,java.lang.Exception,
org.apache.commons.jxpath.ri.parser.XPathParser,Class,No Comment,public ,,org.apache.commons.jxpath.ri.parser.XPathParserConstants
org.apache.commons.jxpath.ri.parser.XPathParser$LookaheadSuccess,Class,No Comment,"static , private , final ",java.lang.Error,
org.apache.commons.jxpath.ri.parser.XPathParser$JJCalls,Class,No Comment,"static , final ",,
org.apache.commons.jxpath.ri.parser.SimpleCharStream,Class,No Comment,public ,,
org.apache.commons.jxpath.ri.parser.Token,Class,* Describes the input token stream.,public ,,
org.apache.commons.jxpath.ri.parser.XPathParserTokenManager,Class,No Comment,public ,,org.apache.commons.jxpath.ri.parser.XPathParserConstants
org.apache.commons.jxpath.ri.parser.XPathParserConstants,Interface,No Comment,public ,,
org.apache.commons.jxpath.ri.JXPathCompiledExpression,Class,* RI of CompiledExpression.,public ,,org.apache.commons.jxpath.CompiledExpression
org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer,Class,* Pointer pointing to a property of an object with dynamic properties.,public ,org.apache.commons.jxpath.ri.model.beans.PropertyPointer,
org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory,Class,* Implements NodePointerFactory for Dynamic classes like Map.,public ,,org.apache.commons.jxpath.ri.model.NodePointerFactory
org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyIterator,Class,"* @deprecated - no longer needed, as it is identical to PropertyIterator.",public ,org.apache.commons.jxpath.ri.model.beans.PropertyIterator,
org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer,Class,* A Pointer that points to an object with Dynamic Properties. It is used for\n * the first element of a path; following elements will by of type\n * {@link PropertyPointer}.,public ,org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer,
org.apache.commons.jxpath.ri.model.dynamic.DynamicAttributeIterator,Class,* {@code DynamicAttributeIterator} is different from a regular\n * {@code BeanAttributeIterator} in that given a property name it\n * will always find that property (albeit with a null value).,public ,org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator,
org.apache.commons.jxpath.ri.model.NodeIterator,Interface,* Definition for an iterator for all kinds of Nodes.,public ,,
org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory,Class,* Implemented in response to [JXPATH-144]. Optionally pluggable\n * {@code NodePointerFactory} that returns a special type of\n * {@code NodePointer} for {@code LazyDynaBean}s. The\n * {@code PropertyPointer}s returned by these will respect\n * {@link LazyDynaClass#isDynaProperty(String)} when determining\n * {@link PropertyPointer#isActual()}.,public ,,org.apache.commons.jxpath.ri.model.NodePointerFactory
org.apache.commons.jxpath.ri.model.dynabeans.StrictLazyDynaBeanPointerFactory$StrictLazyDynaBeanPointer,Class,* Pointer implementation.,"private , static , final ",org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer,
org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory,Class,"* Implements NodePointerFactory for DynaBeans.\n * See <a href=""https://commons.apache.org/beanutils/"">\n * Apache Commons BeanUtils\n * </a>",public ,,org.apache.commons.jxpath.ri.model.NodePointerFactory
org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointer,Class,"* A Pointer that points to a {@link DynaBean}.  If the target DynaBean is Serializable,\n * so should this instance be.",public ,org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer,
org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer,Class,"* Pointer pointing to a property of a {@link DynaBean}. If the target DynaBean is\n * Serializable, so should this instance be.",public ,org.apache.commons.jxpath.ri.model.beans.PropertyPointer,
org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory,Class,* Implements NodePointerFactory for {@link Container} objects.,public ,,org.apache.commons.jxpath.ri.model.NodePointerFactory
org.apache.commons.jxpath.ri.model.container.ContainerPointer,Class,"* Transparent pointer to a Container. The {@link #getValue()} method\n * returns the contents of the container, rather than the container\n * itself.",public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.VariablePointer,Class,* Pointer to a context variable.,public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.NodePointer,Abstract Class,"* Common superclass for Pointers of all kinds.  A NodePointer maps to\n * a deterministic XPath that represents the location of a node in an\n * object graph. This XPath uses only simple axes: child, namespace and\n * attribute and only simple, context-independent predicates.","public , abstract ",,org.apache.commons.jxpath.Pointer
org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer,Class,* Pointer pointing to a property of a JavaBean.,public ,org.apache.commons.jxpath.ri.model.beans.PropertyPointer,
org.apache.commons.jxpath.ri.model.beans.LangAttributePointer,Class,"* A Pointer that points to the ""lang"" attribute of a JavaBean. The value\n * of the attribute is based on the locale supplied to it in the constructor.",public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator,Abstract Class,* Combines node iterators of all elements of a collection into one\n * aggregate node iterator.,"public , abstract ",,org.apache.commons.jxpath.ri.model.NodeIterator
org.apache.commons.jxpath.ri.model.beans.CollectionPointer,Class,* Transparent pointer to a collection (array or Collection).,public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.beans.CollectionChildNodeIterator,Class,* Combines child node iterators of all elements of a collection into one\n * aggregate child node iterator.,public ,org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator,
org.apache.commons.jxpath.ri.model.beans.BeanAttributeIterator,Class,"* An iterator of attributes of a JavaBean. Returns bean properties as\n * well as the ""xml:lang"" attribute.",public ,org.apache.commons.jxpath.ri.model.beans.PropertyIterator,
org.apache.commons.jxpath.ri.model.beans.CollectionAttributeNodeIterator,Class,* Combines attribute node iterators of all elements of a collection into one\n * aggregate attribute node iterator.,public ,org.apache.commons.jxpath.ri.model.beans.CollectionNodeIterator,
org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer,Class,,public ,org.apache.commons.jxpath.ri.model.beans.PropertyPointer,
org.apache.commons.jxpath.ri.model.beans.NullElementPointer,Class,"* Used when there is a need to construct a Pointer for a collection element\n * that does not exist.  For example, if the path is ""foo[3]"", but the\n * collection ""foo"" only has one element or is empty or is null, the\n * NullElementPointer can be used to capture this situation without putting a\n * regular NodePointer into an invalid state.  Just create a NullElementPointer\n * with index 2 (= 3 - 1) and a ""foo"" pointer as the parent.",public ,org.apache.commons.jxpath.ri.model.beans.CollectionPointer,
org.apache.commons.jxpath.ri.model.beans.NullPointer,Class,* Pointer whose value is {@code null}.,public ,org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer,
org.apache.commons.jxpath.ri.model.beans.BeanPointer,Class,* A Pointer that points to a JavaBean or a collection. It is either\n * the first element of a path or a pointer for a property value.\n * Typically there is a {@link BeanPropertyPointer} between two BeanPointers\n * in the chain.,public ,org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer,
org.apache.commons.jxpath.ri.model.beans.PropertyIterator,Class,* Iterates property values of an object pointed at with a {@link PropertyOwnerPointer}.\n * Examples of such objects are JavaBeans and objects with Dynamic Properties.,public ,,org.apache.commons.jxpath.ri.model.NodeIterator
org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer,Abstract Class,"* A pointer describing a node that has properties, each of which could be\n * a collection.","public , abstract ",org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory,Class,* Implements NodePointerFactory for stand-alone collections.,public ,,org.apache.commons.jxpath.ri.model.NodePointerFactory
org.apache.commons.jxpath.ri.model.beans.PropertyPointer,Abstract Class,* A pointer allocated by a PropertyOwnerPointer to represent the value of\n * a property of the parent object.,"public , abstract ",org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory,Class,* Implements NodePointerFactory for JavaBeans.,public ,,org.apache.commons.jxpath.ri.model.NodePointerFactory
org.apache.commons.jxpath.ri.model.dom.NamespacePointer,Class,* Represents a namespace node.,public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.dom.DOMNodePointer,Class,"* A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n * a DOMNodePointer instance may likewise not be properly Serializable.",public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.dom.DOMAttributePointer,Class,"* A Pointer that points to a DOM node. Because the underlying DOM Attr is not Serializable,\n * neither is this pointer class truly so.",public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.dom.DOMNodeIterator,Class,* An iterator of children of a DOM Node.,public ,,org.apache.commons.jxpath.ri.model.NodeIterator
org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator,Class,* An iterator of attributes of a DOM Node.,public ,,org.apache.commons.jxpath.ri.model.NodeIterator
org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory,Class,* Implements NodePointerFactory for DOM elements.,public ,,org.apache.commons.jxpath.ri.model.NodePointerFactory
org.apache.commons.jxpath.ri.model.dom.DOMNamespaceIterator,Class,* An iterator of namespaces of a DOM Node.,public ,,org.apache.commons.jxpath.ri.model.NodeIterator
org.apache.commons.jxpath.ri.model.VariablePointerFactory,Class,* NodePointerFactory to create {@link VariablePointer VariablePointers}.\n * @since JXPath 1.3,public ,,org.apache.commons.jxpath.ri.model.NodePointerFactory
org.apache.commons.jxpath.ri.model.VariablePointerFactory$VariableContextWrapper,Class,* Node value wrapper to trigger a VariablePointerFactory.,"public , static , final ",,
org.apache.commons.jxpath.ri.model.jdom.JDOMAttributePointer,Class,* A Pointer that points to a DOM node.,public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer,Class,* A Pointer that points to a DOM node.,public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.jdom.JDOMAttributeIterator,Class,* An iterator of attributes of a DOM Node.,public ,,org.apache.commons.jxpath.ri.model.NodeIterator
org.apache.commons.jxpath.ri.model.jdom.JDOMNamespacePointer,Class,* Represents a namespace node.,public ,org.apache.commons.jxpath.ri.model.NodePointer,
org.apache.commons.jxpath.ri.model.jdom.JDOMNamespaceIterator,Class,* An iterator of namespaces of a DOM Node.,public ,,org.apache.commons.jxpath.ri.model.NodeIterator
org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory,Class,* Implements NodePointerFactory for DOM elements.,public ,,org.apache.commons.jxpath.ri.model.NodePointerFactory
org.apache.commons.jxpath.ri.model.jdom.JDOMNodeIterator,Class,* An iterator of children of a JDOM Node.,public ,,org.apache.commons.jxpath.ri.model.NodeIterator
org.apache.commons.jxpath.ri.model.NodePointerFactory,Interface,"* Creates NodePointers for objects of a certain type.\n * NodePointerFactories are ordered according to the values returned\n * by the ""getOrder"" method and always queried in that order.",public ,,
org.apache.commons.jxpath.ri.QName,Class,* A qualified name: a combination of an optional namespace prefix\n * and an local name.,public ,,java.io.Serializable
org.apache.commons.jxpath.ri.InfoSetUtil,Class,"* Type conversions, XPath style.",public ,,
org.apache.commons.jxpath.ri.NamespaceResolver,Class,* Namespace resolver for {@link JXPathContextReferenceImpl}.,public ,,java.lang.Cloneable;java.io.Serializable
org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual,Class,"* Implementation of {@link Expression} for the operation ""!="".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperationCompare,
org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract,Class,"* Implementation of {@link Expression} for the operation ""-"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.CoreOperationOr,Class,"* Implementation of {@link Expression} for the operation ""or"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.ExpressionPath,Class,"* An  element of the parse tree that represents an expression path, which is a\n * path that starts with an expression like a function call: {@code getFoo(.)\n * /bar}.",public ,org.apache.commons.jxpath.ri.compiler.Path,
org.apache.commons.jxpath.ri.compiler.LocationPath,Class,,public ,org.apache.commons.jxpath.ri.compiler.Path,
org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan,Class,"* Implementation of {@link Expression} for the operation ""&gt;"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression,
org.apache.commons.jxpath.ri.compiler.CoreOperationAnd,Class,"* Implementation of {@link Expression} for the operation ""and"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.CoreOperationEqual,Class,"* Implementation of {@link Expression} for the operation ""="".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperationCompare,
org.apache.commons.jxpath.ri.compiler.NameAttributeTest,Class,* Captures the {@code foo[@name=<em>expr</em>]} expression. These\n * expressions are handled in a special way when applied to beans\n * or maps.,public ,org.apache.commons.jxpath.ri.compiler.CoreOperationEqual,
org.apache.commons.jxpath.ri.compiler.Operation,Abstract Class,,"public , abstract ",org.apache.commons.jxpath.ri.compiler.Expression,
org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual,Class,"* Implementation of {@link Expression} for the operation ""&gt;="".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression,
org.apache.commons.jxpath.ri.compiler.NodeTest,Abstract Class,,"public , abstract ",,
org.apache.commons.jxpath.ri.compiler.CoreOperationMod,Class,"* Implementation of {@link Expression} for the operation ""mod"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.Constant,Class,* A compile tree element containing a constant number or string.,public ,org.apache.commons.jxpath.ri.compiler.Expression,
org.apache.commons.jxpath.ri.compiler.Expression,Abstract Class,"* Common superclass for several types of nodes in the parse tree. Provides\n * APIs for optimization of evaluation of expressions.  Specifically, an\n * expression only needs to executed once during the evaluation of an xpath\n * if that expression is context-independent.  Expression.isContextDependent()\n * provides that hint.","public , abstract ",,
org.apache.commons.jxpath.ri.compiler.Expression$PointerIterator,Class,* Pointer iterator,"public , static ",,java.util.Iterator
org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator,Class,* Value Iterator,"public , static ",,java.util.Iterator
org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual,Class,"* Implementation of {@link Expression} for the operation ""&lt;="".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression,
org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply,Class,"* Implementation of {@link Expression} for the operation ""*"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan,Class,"* Implementation of {@link Expression} for the operation ""&lt;"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression,
org.apache.commons.jxpath.ri.compiler.TreeCompiler,Class,,public ,,org.apache.commons.jxpath.ri.Compiler
org.apache.commons.jxpath.ri.compiler.Step,Class,,public ,,
org.apache.commons.jxpath.ri.compiler.CoreOperationUnion,Class,"* Implementation of {@link Expression} for the operation ""|"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.CoreOperationCompare,Abstract Class,"* Common superclass for the implementations of Expression for the operations\n * ""="" and ""!="".","public , abstract ",org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.CoreOperationDivide,Class,"* Implementation of {@link Expression} for the operation ""div"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression,Abstract Class,"* Base implementation of Expression for the operations ""&gt;"", ""&gt;="", ""&lt;"", ""&lt;="".\n * @since JXPath 1.3","public , abstract ",org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest,Class,,public ,org.apache.commons.jxpath.ri.compiler.NodeTest,
org.apache.commons.jxpath.ri.compiler.ExtensionFunction,Class,* Represents an element of the parse tree representing an extension function\n * call.,public ,org.apache.commons.jxpath.ri.compiler.Operation,
org.apache.commons.jxpath.ri.compiler.NodeTypeTest,Class,,public ,org.apache.commons.jxpath.ri.compiler.NodeTest,
org.apache.commons.jxpath.ri.compiler.CoreOperation,Abstract Class,"* The common subclass for tree elements representing core operations like ""+"",\n * ""- "", ""*"" etc.","public , abstract ",org.apache.commons.jxpath.ri.compiler.Operation,
org.apache.commons.jxpath.ri.compiler.CoreOperationAdd,Class,"* Implementation of {@link Expression} for the operation ""+"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.CoreOperationNegate,Class,"* Implementation of {@link Expression} for the operation unary ""-"".",public ,org.apache.commons.jxpath.ri.compiler.CoreOperation,
org.apache.commons.jxpath.ri.compiler.VariableReference,Class,* An element of the compile tree holding a variable reference.,public ,org.apache.commons.jxpath.ri.compiler.Expression,
org.apache.commons.jxpath.ri.compiler.Path,Abstract Class,,"public , abstract ",org.apache.commons.jxpath.ri.compiler.Expression,
org.apache.commons.jxpath.ri.compiler.NodeNameTest,Class,,public ,org.apache.commons.jxpath.ri.compiler.NodeTest,
org.apache.commons.jxpath.ri.compiler.CoreFunction,Class,"* An element of the compile tree representing one of built-in functions\n * like ""position()"" or ""number()"".",public ,org.apache.commons.jxpath.ri.compiler.Operation,
org.apache.commons.jxpath.ri.JXPathContextReferenceImpl,Class,* The reference implementation of JXPathContext.,public ,org.apache.commons.jxpath.JXPathContext,
org.apache.commons.jxpath.ri.EvalContext,Abstract Class,"* An XPath evaluation context.\n *\n * When  evaluating a path, a chain of EvalContexts is created, each context in\n * the chain representing a step of the path. Subclasses of EvalContext\n * implement behavior of various XPath axes: ""child::"", ""parent::"" etc.","public , abstract ",,org.apache.commons.jxpath.ExpressionContext;java.util.Iterator
org.apache.commons.jxpath.Container,Interface,"* A Container is an object implementing an indirection\n * mechanism transparent to JXPath.  For example, if property\n * ""foo"" of the context node has a Container as its value,\n * the XPath ""foo"" will produce the contents of that Container,\n * rather than the container itself.",public ,java.io.Serializable,
org.apache.commons.jxpath.xml.DOMParser,Class,* An implementation of the XMLParser interface that produces a DOM Document.,public ,org.apache.commons.jxpath.xml.XMLParser2,
org.apache.commons.jxpath.xml.XMLParser2,Abstract Class,* The abstract superclass of XML parsers that produce DOM Documents.\n * The features have the same defaults as {@link javax.xml.parsers.DocumentBuilderFactory}.,"public , abstract ",,org.apache.commons.jxpath.xml.XMLParser
org.apache.commons.jxpath.xml.JDOMParser,Class,* An implementation of the XMLParser interface that produces a JDOM Document.,public ,org.apache.commons.jxpath.xml.XMLParser2,
org.apache.commons.jxpath.xml.DocumentContainer,Class,"* An XML document container reads and parses XML only when it is\n * accessed.  JXPath traverses Containers transparently -\n * you use the same paths to access objects in containers as you\n * do to access those objects directly.  You can create\n * XMLDocumentContainers for various XML documents that may or\n * may not be accessed by XPaths.  If they are, they will be automatically\n * read, parsed and traversed. If they are not - they won't be\n * read at all.",public ,org.apache.commons.jxpath.xml.XMLParser2,org.apache.commons.jxpath.Container
org.apache.commons.jxpath.xml.XMLParser,Interface,* Common interface for XML parsers.  We are not using JAXP because\n * some of the parsers we want to support may not be JAXP compliant.,public ,,
org.apache.commons.jxpath.NodeSet,Interface,"* NodeSet interface can be used as the type of an argument of an extension\n * function.  Alternatively, the function can declare the argument as\n * a Collection (or List or Set), in which case it will be given a collection\n * of <em>values</em> matching the path.",public ,,
org.apache.commons.jxpath.JXPathFunctionNotFoundException,Class,No Comment,public ,org.apache.commons.jxpath.JXPathException,
org.apache.commons.jxpath.FunctionLibrary,Class,"* An object that aggregates {@link Functions} objects into a group Functions\n * object. Since {@link JXPathContext} can only register a single Functions\n * object, FunctionLibrary should always be used to group all Functions objects\n * that need to be registered.",public ,,org.apache.commons.jxpath.Functions
org.apache.commons.jxpath.ExtendedKeyManager,Interface,"* More complete implementation for the XPath {@code ""key()""} function.\n * Returns NodeSet results and allows Object values for better compatibility\n * with non-XML graphs.\n * @since JXPath 1.3",public ,org.apache.commons.jxpath.KeyManager,
org.apache.commons.jxpath.KeyManager,Interface,"* A delegate of {@link JXPathContext} that implements the XPath {@code ""key()""}\n * function.",public ,,
org.apache.commons.jxpath.JXPathBeanInfo,Interface,"* JXPathBeanInfo  is similar to {@link java.beans.BeanInfo} in that it describes\n * properties of a JavaBean class.  By default, JXPathBeanInfo classes are\n * automatically generated by {@link JXPathIntrospector JXPathIntrospector}\n * based on the java.beans.BeanInfo. As with JavaBeans, the user can supply an\n * alternative implementation of JXPathBeanInfo for a custom class.  The\n * alternative implementation is located by class name, which is the same as the\n * name of the class it represents with the suffix ""XBeanInfo"".  So, for\n * example, if you need to provide an alternative JXPathBeanInfo class for class\n * ""com.foo.Bar"", write a class ""com.foo.BarXBeanInfo"" and make it implement the\n * JXPathBeanInfo interface.",public ,java.io.Serializable,
org.apache.commons.jxpath.JXPathContextFactoryConfigurationError,Class,* Thrown when a problem with configuration with the {@link JXPathContextFactory JXPathContextFactories}\n * exists. This error will typically be thrown when the class of a\n * factory specified in the system properties cannot be found\n * or instantiated.,public ,java.lang.Error,
org.apache.commons.jxpath.JXPathAbstractFactoryException,Class,No Comment,public ,org.apache.commons.jxpath.JXPathException,
org.apache.commons.jxpath.functions.MethodFunction,Class,* An XPath extension function implemented as an individual Java method.,public ,,org.apache.commons.jxpath.Function
org.apache.commons.jxpath.functions.ConstructorFunction,Class,* An extension function that creates an instance using a constructor.,public ,,org.apache.commons.jxpath.Function
org.apache.commons.jxpath.MapDynamicPropertyHandler,Class,* Implements the DynamicPropertyHandler interface for {@link java.util.Map}.,public ,,org.apache.commons.jxpath.DynamicPropertyHandler
org.apache.commons.jxpath.PackageFunctions,Class,"* Extension functions provided by Java classes.  The class prefix specified\n * in the constructor is used when a constructor or a static method is called.\n * Usually, a class prefix is a package name (hence the name of this class).\n *\n * Let's say, we declared a PackageFunction like this:\n * <blockquote><pre>\n *     new PackageFunctions(""java.util."", ""util"")\n * </pre></blockquote>\n *\n * We can now use XPaths like:\n * <dl>\n *  <dt>{@code ""util:Date.new()""}</dt>\n *  <dd>Equivalent to {@code new java.util.Date()}</dd>\n *  <dt>{@code ""util:Collections.singleton('foo')""}</dt>\n *  <dd>Equivalent to {@code java.util.Collections.singleton(""foo"")}</dd>\n *  <dt>{@code ""util:substring('foo', 1, 2)""}</dt>\n *  <dd>Equivalent to {@code ""foo"".substring(1, 2)}.  Note that in\n *  this case, the class prefix is not used. JXPath does not check that\n *  the first parameter of the function (the method target) is in fact\n *  a member of the package described by this PackageFunctions object.</dd>\n * </dl>\n *\n * <p>\n * If the first argument of a method or constructor is {@link ExpressionContext},\n * the expression context in which the function is evaluated is passed to\n * the method.\n * </p>\n * <p>\n * There is one PackageFunctions object registered by default with each\n * JXPathContext.  It does not have a namespace and uses no class prefix.\n * The existence of this object allows us to use XPaths like:\n * {@code ""java.util.Date.new()""} and {@code ""length('foo')""}\n * without the explicit registration of any extension functions.\n * </p>",public ,,org.apache.commons.jxpath.Functions
org.apache.commons.jxpath.CompiledExpression,Interface,"* Represents a compiled XPath. The interpretation of compiled XPaths\n * may be faster, because it bypasses the compilation step. The reference\n * implementation of {@link JXPathContext} also globally caches some of the\n * results of compilation, so the direct use of JXPathContext is not\n * always less efficient than the use of CompiledExpression.\n * <p>\n * Use CompiledExpression only when there is a need to evaluate the\n * same expression multiple times and the CompiledExpression can be\n * conveniently cached.\n * <p>\n * To acquire a CompiledExpression, call {@link JXPathContext#compile\n * JXPathContext.compile}",public ,,
org.apache.commons.jxpath.JXPathNotFoundException,Class,* Thrown when JXPath cannot find a requested path.,public ,org.apache.commons.jxpath.JXPathException,
org.apache.commons.jxpath.JXPathException,Class,No Comment,public ,java.lang.RuntimeException,
org.apache.commons.jxpath.JXPathContextFactory,Abstract Class,"* Defines a factory API that enables applications to obtain a\n * {@link JXPathContext} instance.  To acquire a JXPathContext, first call the\n * static {@link #newInstance} method of JXPathContextFactory.\n * This method returns a concrete JXPathContextFactory.\n * Then call {@link #newContext} on that instance.  You will rarely\n * need to perform these steps explicitly: usually you can call one of the\n * {@code JXPathContex.newContext} methods, which will perform these steps\n * for you.\n *\n * @see JXPathContext#newContext(Object)\n * @see JXPathContext#newContext(JXPathContext,Object)","public , abstract ",,
org.apache.commons.jxpath.BasicNodeSet,Class,* A simple implementation of {@link NodeSet} that behaves as a collection\n * of pointers.,public ,,org.apache.commons.jxpath.NodeSet
org.apache.commons.jxpath.Function,Interface,"* Extension function interface. Extension functions are grouped into\n * {@link Functions Functions} objects, which are installed on\n * JXPathContexts using the\n * {@link JXPathContext#setFunctions JXPathContext.setFunctions()}\n * call.\n * <p>\n * The Function interface can be implemented directly. However,\n * most of the time JXPath's built-in implementations should suffice.\n * See {@link ClassFunctions ClassFunctions} and\n * {@link PackageFunctions PackageFunctions}.",public ,,
org.apache.commons.jxpath.JXPathIntrospector,Class,* JXPathIntrospector  maintains a registry of {@link JXPathBeanInfo\n * JXPathBeanInfo} objects for Java classes.,public ,,
org.apache.commons.jxpath.BasicVariables,Class,* A basic implementation of the Variables interface that uses a HashMap.,public ,,org.apache.commons.jxpath.Variables
