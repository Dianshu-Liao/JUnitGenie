"FEN","Type","Comment","Source Code","Return Type","Modifier","class_extends","implements"
"org.apache.commons.csv.CSVParser","Class","* Parses CSV files according to the specified format.
 *
 * Because CSV appears in many different dialects, the parser supports many formats by allowing the
 * specification of a {@link CSVFormat}.
 *
 * The parser works record-wise. It is not possible to go back, once a record has been parsed from the input stream.
 *
 * <h2>Creating instances</h2>
 * <p>
 * There are several static factory methods that can be used to create instances for various types of resources:
 * </p>
 * <ul>
 *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>
 *     <li>{@link #parse(String, CSVFormat)}</li>
 *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>
 * </ul>
 * <p>
 * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.
 *
 * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:
 * </p>
 * <pre>
 * for (CSVRecord record : CSVFormat.EXCEL.parse(in)) {
 *     ...
 * }
 * </pre>
 *
 * <h2>Parsing record wise</h2>
 * <p>
 * To parse a CSV input from a file, you write:
 * </p>
 *
 * <pre>{@code
 * File csvData = new File(""/path/to/csv"");
 * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);
 * for (CSVRecord csvRecord : parser) {
 *     ...
 * }}
 * </pre>
 *
 * <p>
 * This will read the parse the contents of the file using the
 * <a href=""https://tools.ietf.org/html/rfc4180"" target=""_blank"">RFC 4180</a> format.
 * </p>
 *
 * <p>
 * To parse CSV input in a format like Excel, you write:
 * </p>
 *
 * <pre>
 * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);
 * for (CSVRecord csvRecord : parser) {
 *     ...
 * }
 * </pre>
 *
 * <p>
 * If the predefined formats don't match the format at hand, custom formats can be defined. More information about
 * customizing CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.
 * </p>
 *
 * <h2>Parsing into memory</h2>
 * <p>
 * If parsing record-wise is not desired, the contents of the input can be read completely into memory.
 * </p>
 *
 * <pre>{@code
 * Reader in = new StringReader(""a;b\nc;d"");
 * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);
 * List<CSVRecord> list = parser.getRecords();
 * }</pre>
 *
 * <p>
 * There are two constraints that have to be kept in mind:
 * </p>
 *
 * <ol>
 *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from
 *     the input, those records will not end up in the in-memory representation of your CSV data.</li>
 *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example, if you're
 *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>
 * </ol>
 *
 * <h2>Notes</h2>
 * <p>
 * The internal parser state is completely covered by the format and the reader state.
 * </p>
 *
 * @see <a href=""package-summary.html"">package documentation for more details</a>","Class do not obtain Source Code","No return type","public , final ","","java.lang.Iterable;java.io.Closeable"
"org.apache.commons.csv.CSVParser.headerComment","Field","No Comment","private String headerComment;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.trailerComment","Field","No Comment","private String trailerComment;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.format","Field","No Comment","private final CSVFormat format;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.headers","Field","No Comment","private final Headers headers;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.lexer","Field","No Comment","private final Lexer lexer;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.csvRecordIterator","Field","No Comment","private final CSVRecordIterator csvRecordIterator;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.recordList","Field","A record buffer for getRecord(). Grows as necessary and is reused.","private final List<String> recordList = new ArrayList<>();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.recordNumber","Field","* The next record number to assign.","private long recordNumber;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.characterOffset","Field","* Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination
     * with {@link #recordNumber}.","private final long characterOffset;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.reusableToken","Field","No Comment","private final Token reusableToken = new Token();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.builder()","Method","* Creates a new builder.
     *
     * @return a new builder.
     * @since 1.13.0","public static Builder builder() {
    return new Builder();
}","Builder","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(File,Charset,CSVFormat)","Method","* Creates a parser for the given {@link File}.
     *
     * @param file
     *            a CSV file. Must not be null.
     * @param charset
     *            The Charset to decode the given file.
     * @param format
     *            the CSVFormat used for CSV parsing. Must not be null.
     * @return a new parser
     * @throws IllegalArgumentException
     *             If the parameters of the format are inconsistent or if either file or format are null.
     * @throws IOException
     *             If an I/O error occurs
     * @throws CSVException Thrown on invalid input.","public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {
    Objects.requireNonNull(file, ""file"");
    return parse(file.toPath(), charset, format);
}","CSVParser","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(File,Charset,CSVFormat).file","Parameter_1","Belong to org.apache.commons.csv.CSVParser.parse(File,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(File,Charset,CSVFormat).charset","Parameter_2","Belong to org.apache.commons.csv.CSVParser.parse(File,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(File,Charset,CSVFormat).format","Parameter_3","Belong to org.apache.commons.csv.CSVParser.parse(File,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(InputStream,Charset,CSVFormat)","Method","* Creates a CSV parser using the given {@link CSVFormat}.
     *
     * <p>
     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,
     * unless you close the {@code reader}.
     * </p>
     *
     * @param inputStream
     *            an InputStream containing CSV-formatted input. Must not be null.
     * @param charset
     *            The Charset to decode the given file.
     * @param format
     *            the CSVFormat used for CSV parsing. Must not be null.
     * @return a new CSVParser configured with the given reader and format.
     * @throws IllegalArgumentException
     *             If the parameters of the format are inconsistent or if either reader or format are null.
     * @throws IOException
     *             If there is a problem reading the header or skipping the first record
     * @throws CSVException Thrown on invalid input.
     * @since 1.5","@SuppressWarnings(""resource"")
public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException {
    Objects.requireNonNull(inputStream, ""inputStream"");
    Objects.requireNonNull(format, ""format"");
    return parse(new InputStreamReader(inputStream, charset), format);
}","CSVParser","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(InputStream,Charset,CSVFormat).inputStream","Parameter_1","Belong to org.apache.commons.csv.CSVParser.parse(InputStream,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(InputStream,Charset,CSVFormat).charset","Parameter_2","Belong to org.apache.commons.csv.CSVParser.parse(InputStream,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(InputStream,Charset,CSVFormat).format","Parameter_3","Belong to org.apache.commons.csv.CSVParser.parse(InputStream,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(Path,Charset,CSVFormat)","Method","* Creates and returns a parser for the given {@link Path}, which the caller MUST close.
     *
     * @param path
     *            a CSV file. Must not be null.
     * @param charset
     *            The Charset to decode the given file.
     * @param format
     *            the CSVFormat used for CSV parsing. Must not be null.
     * @return a new parser
     * @throws IllegalArgumentException
     *             If the parameters of the format are inconsistent or if either file or format are null.
     * @throws IOException
     *             If an I/O error occurs
     * @throws CSVException Thrown on invalid input.
     * @since 1.5","@SuppressWarnings(""resource"")
public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {
    Objects.requireNonNull(path, ""path"");
    Objects.requireNonNull(format, ""format"");
    return parse(Files.newInputStream(path), charset, format);
}","CSVParser","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(Path,Charset,CSVFormat).path","Parameter_1","Belong to org.apache.commons.csv.CSVParser.parse(Path,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(Path,Charset,CSVFormat).charset","Parameter_2","Belong to org.apache.commons.csv.CSVParser.parse(Path,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(Path,Charset,CSVFormat).format","Parameter_3","Belong to org.apache.commons.csv.CSVParser.parse(Path,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(Reader,CSVFormat)","Method","* Creates a CSV parser using the given {@link CSVFormat}
     *
     * <p>
     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,
     * unless you close the {@code reader}.
     * </p>
     *
     * @param reader
     *            a Reader containing CSV-formatted input. Must not be null.
     * @param format
     *            the CSVFormat used for CSV parsing. Must not be null.
     * @return a new CSVParser configured with the given reader and format.
     * @throws IllegalArgumentException
     *             If the parameters of the format are inconsistent or if either reader or format are null.
     * @throws IOException
     *             If there is a problem reading the header or skipping the first record
     * @throws CSVException Thrown on invalid input.
     * @since 1.5","public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {
    return builder().setReader(reader).setFormat(format).get();
}","CSVParser","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(Reader,CSVFormat).reader","Parameter_1","Belong to org.apache.commons.csv.CSVParser.parse(Reader,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(Reader,CSVFormat).format","Parameter_2","Belong to org.apache.commons.csv.CSVParser.parse(Reader,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(String,CSVFormat)","Method","* Creates a parser for the given {@link String}.
     *
     * @param string
     *            a CSV string. Must not be null.
     * @param format
     *            the CSVFormat used for CSV parsing. Must not be null.
     * @return a new parser
     * @throws IllegalArgumentException
     *             If the parameters of the format are inconsistent or if either string or format are null.
     * @throws IOException
     *             If an I/O error occurs
     * @throws CSVException Thrown on invalid input.","public static CSVParser parse(final String string, final CSVFormat format) throws IOException {
    Objects.requireNonNull(string, ""string"");
    Objects.requireNonNull(format, ""format"");
    return parse(new StringReader(string), format);
}","CSVParser","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(String,CSVFormat).string","Parameter_1","Belong to org.apache.commons.csv.CSVParser.parse(String,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(String,CSVFormat).format","Parameter_2","Belong to org.apache.commons.csv.CSVParser.parse(String,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(URL,Charset,CSVFormat)","Method","* Creates and returns a parser for the given URL, which the caller MUST close.
     *
     * <p>
     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless
     * you close the {@code url}.
     * </p>
     *
     * @param url
     *            a URL. Must not be null.
     * @param charset
     *            the charset for the resource. Must not be null.
     * @param format
     *            the CSVFormat used for CSV parsing. Must not be null.
     * @return a new parser
     * @throws IllegalArgumentException
     *             If the parameters of the format are inconsistent or if either url, charset or format are null.
     * @throws IOException
     *             If an I/O error occurs
     * @throws CSVException Thrown on invalid input.","@SuppressWarnings(""resource"")
public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {
    Objects.requireNonNull(url, ""url"");
    return parse(url.openStream(), charset, format);
}","CSVParser","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(URL,Charset,CSVFormat).url","Parameter_1","Belong to org.apache.commons.csv.CSVParser.parse(URL,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(URL,Charset,CSVFormat).charset","Parameter_2","Belong to org.apache.commons.csv.CSVParser.parse(URL,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.parse(URL,Charset,CSVFormat).format","Parameter_3","Belong to org.apache.commons.csv.CSVParser.parse(URL,Charset,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.addRecordValue(boolean)","Method","No Comment","private void addRecordValue(final boolean lastRecord) {
    final String input = format.trim(reusableToken.content.toString());
    if (lastRecord && input.isEmpty() && format.getTrailingDelimiter()) {
        return;
    }
    recordList.add(handleNull(input));
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.addRecordValue(boolean).lastRecord","Parameter_1","Belong to org.apache.commons.csv.CSVParser.addRecordValue(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.close()","Method","* Closes resources.
     *
     * @throws IOException
     *             If an I/O error occurs","@Override
public void close() throws IOException {
    lexer.close();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.createEmptyHeaderMap()","Method","No Comment","private Map<String, Integer> createEmptyHeaderMap() {
    return format.getIgnoreHeaderCase() ? new TreeMap<>(String.CASE_INSENSITIVE_ORDER) : new LinkedHashMap<>();
}","Map","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.createHeaders()","Method","* Creates the name to index mapping if the format defines a header.
     *
     * @return null if the format has no header.
     * @throws IOException if there is a problem reading the header or skipping the first record
     * @throws CSVException on invalid input.","private Headers createHeaders() throws IOException {
    Map<String, Integer> hdrMap = null;
    List<String> headerNames = null;
    final String[] formatHeader = format.getHeader();
    if (formatHeader != null) {
        hdrMap = createEmptyHeaderMap();
        String[] headerRecord = null;
        if (formatHeader.length == 0) {
            // read the header from the first line of the file
            final CSVRecord nextRecord = nextRecord();
            if (nextRecord != null) {
                headerRecord = nextRecord.values();
                headerComment = nextRecord.getComment();
            }
        } else {
            if (format.getSkipHeaderRecord()) {
                final CSVRecord nextRecord = nextRecord();
                if (nextRecord != null) {
                    headerComment = nextRecord.getComment();
                }
            }
            headerRecord = formatHeader;
        }
        // build the name to index mappings
        if (headerRecord != null) {
            // Track an occurrence of a null, empty or blank header.
            boolean observedMissing = false;
            for (int i = 0; i < headerRecord.length; i++) {
                final String header = headerRecord[i];
                final boolean blankHeader = CSVFormat.isBlank(header);
                if (blankHeader && !format.getAllowMissingColumnNames()) {
                    throw new IllegalArgumentException(""A header name is missing in "" + Arrays.toString(headerRecord));
                }
                final boolean containsHeader = blankHeader ? observedMissing : hdrMap.containsKey(header);
                final DuplicateHeaderMode headerMode = format.getDuplicateHeaderMode();
                final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;
                final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;
                if (containsHeader && !duplicatesAllowed && !(blankHeader && emptyDuplicatesAllowed)) {
                    throw new IllegalArgumentException(String.format(""The header contains a duplicate name: \""%s\"" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode()."", header, Arrays.toString(headerRecord)));
                }
                observedMissing |= blankHeader;
                if (header != null) {
                    // N.B. Explicit (un)boxing is intentional
                    hdrMap.put(header, Integer.valueOf(i));
                    if (headerNames == null) {
                        headerNames = new ArrayList<>(headerRecord.length);
                    }
                    headerNames.add(header);
                }
            }
        }
    }
    // Make header names Collection immutable
    return new Headers(hdrMap, headerNames == null ? Collections.emptyList() : Collections.unmodifiableList(headerNames));
}","Headers","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.getCurrentLineNumber()","Method","* Gets the current line number in the input stream.
     *
     * <p>
     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
     * the record number.
     * </p>
     *
     * @return current line number","public long getCurrentLineNumber() {
    return lexer.getCurrentLineNumber();
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.getFirstEndOfLine()","Method","* Gets the first end-of-line string encountered.
     *
     * @return the first end-of-line string
     * @since 1.5","public String getFirstEndOfLine() {
    return lexer.getFirstEol();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.getHeaderComment()","Method","* Gets the header comment, if any.
     * The header comment appears before the header record.
     *
     * @return the header comment for this stream, or null if no comment is available.
     * @since 1.10.0","public String getHeaderComment() {
    return headerComment;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.getHeaderMap()","Method","* Gets a copy of the header map as defined in the CSVFormat's header.
     * <p>
     * The map keys are column names. The map values are 0-based indices.
     * </p>
     * <p>
     * Note: The map can only provide a one-to-one mapping when the format did not
     * contain null or duplicate column names.
     * </p>
     *
     * @return a copy of the header map.","public Map<String, Integer> getHeaderMap() {
    if (headers.headerMap == null) {
        return null;
    }
    final Map<String, Integer> map = createEmptyHeaderMap();
    map.putAll(headers.headerMap);
    return map;
}","Map","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.getHeaderMapRaw()","Method","* Gets the underlying header map.
     *
     * @return the underlying header map.","Map<String, Integer> getHeaderMapRaw() {
    return headers.headerMap;
}","Map","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.getHeaderNames()","Method","* Gets a read-only list of header names that iterates in column order as defined in the CSVFormat's header.
     * <p>
     * Note: The list provides strings that can be used as keys in the header map.
     * The list will not contain null column names if they were present in the input
     * format.
     * </p>
     *
     * @return read-only list of header names that iterates in column order.
     * @see #getHeaderMap()
     * @since 1.7","public List<String> getHeaderNames() {
    return Collections.unmodifiableList(headers.headerNames);
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.getRecordNumber()","Method","* Gets the current record number in the input stream.
     *
     * <p>
     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to
     * the line number.
     * </p>
     *
     * @return current record number","public long getRecordNumber() {
    return recordNumber;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.getRecords()","Method","* Parses the CSV input according to the given format and returns the content as a list of
     * {@link CSVRecord CSVRecords}.
     *
     * <p>
     * The returned content starts at the current parse-position in the stream.
     * </p>
     * <p>
     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows this method produces.
     * </p>
     *
     * @return list of {@link CSVRecord CSVRecords}, may be empty
     * @throws UncheckedIOException
     *             on parse error or input read-failure","public List<CSVRecord> getRecords() {
    return stream().collect(Collectors.toList());
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.getTrailerComment()","Method","* Gets the trailer comment, if any.
     * Trailer comments are located between the last record and EOF
     *
     * @return the trailer comment for this stream, or null if no comment is available.
     * @since 1.10.0","public String getTrailerComment() {
    return trailerComment;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.handleNull(String)","Method","* Handles whether the input is parsed as null
     *
     * @param input
     *           the cell data to further processed
     * @return null if input is parsed as null, or input itself if the input isn't parsed as null","private String handleNull(final String input) {
    final boolean isQuoted = reusableToken.isQuoted;
    final String nullString = format.getNullString();
    final boolean strictQuoteMode = isStrictQuoteMode();
    if (input.equals(nullString)) {
        // nullString = NULL(String), distinguish between ""NULL"" and NULL in ALL_NON_NULL or NON_NUMERIC quote mode
        return strictQuoteMode && isQuoted ? input : null;
    }
    // don't set nullString, distinguish between """" and ,, (absent values) in All_NON_NULL or NON_NUMERIC quote mode
    return strictQuoteMode && nullString == null && input.isEmpty() && !isQuoted ? null : input;
}","String","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.handleNull(String).input","Parameter_1","Belong to org.apache.commons.csv.CSVParser.handleNull(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.hasHeaderComment()","Method","* Checks whether there is a header comment.
     * The header comment appears before the header record.
     * Note that if the parser's format has been given an explicit header
     * (with {@link CSVFormat.Builder#setHeader(String... )} or another overload)
     * and the header record is not being skipped
     * ({@link CSVFormat.Builder#setSkipHeaderRecord} is false) then any initial comments
     * will be associated with the first record, not the header.
     *
     * @return true if this parser has seen a header comment, false otherwise
     * @since 1.10.0","public boolean hasHeaderComment() {
    return headerComment != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.hasTrailerComment()","Method","* Checks whether there is a trailer comment.
     * Trailer comments are located between the last record and EOF.
     * The trailer comments will only be available after the parser has
     * finished processing this stream.
     *
     * @return true if this parser has seen a trailer comment, false otherwise
     * @since 1.10.0","public boolean hasTrailerComment() {
    return trailerComment != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.isClosed()","Method","* Tests whether this parser is closed.
     *
     * @return whether this parser is closed.","public boolean isClosed() {
    return lexer.isClosed();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.isStrictQuoteMode()","Method","* Tests whether the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or {@link QuoteMode#NON_NUMERIC}.
     *
     * @return true if the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or
     *         {@link QuoteMode#NON_NUMERIC}.","private boolean isStrictQuoteMode() {
    return format.getQuoteMode() == QuoteMode.ALL_NON_NULL || format.getQuoteMode() == QuoteMode.NON_NUMERIC;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.iterator()","Method","* Returns the record iterator.
     *
     * <p>
     * An {@link IOException} caught during the iteration is re-thrown as an
     * {@link IllegalStateException}.
     * </p>
     * <p>
     * If the parser is closed, the iterator will not yield any more records.
     * A call to {@link Iterator#hasNext()} will return {@code false} and
     * a call to {@link Iterator#next()} will throw a
     * {@link NoSuchElementException}.
     * </p>
     * <p>
     * If it is necessary to construct an iterator which is usable after the
     * parser is closed, one option is to extract all records as a list with
     * {@link #getRecords()}, and return an iterator to that list.
     * </p>
     * <p>
     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows an Iterator produces.
     * </p>","@Override
public Iterator<CSVRecord> iterator() {
    return csvRecordIterator;
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.nextRecord()","Method","* Parses the next record from the current point in the stream.
     *
     * @return the record as an array of values, or {@code null} if the end of the stream has been reached.
     * @throws IOException  on parse error or input read-failure.
     * @throws CSVException on invalid input.","CSVRecord nextRecord() throws IOException {
    CSVRecord result = null;
    recordList.clear();
    StringBuilder sb = null;
    final long startCharPosition = lexer.getCharacterPosition() + characterOffset;
    final long startBytePosition = lexer.getBytesRead() + this.characterOffset;
    do {
        reusableToken.reset();
        lexer.nextToken(reusableToken);
        switch(reusableToken.type) {
            case TOKEN:
                addRecordValue(false);
                break;
            case EORECORD:
                addRecordValue(true);
                break;
            case EOF:
                if (reusableToken.isReady) {
                    addRecordValue(true);
                } else if (sb != null) {
                    trailerComment = sb.toString();
                }
                break;
            case INVALID:
                throw new CSVException(""(line %,d) invalid parse sequence"", getCurrentLineNumber());
            case // Ignored currently
            COMMENT:
                if (sb == null) {
                    // first comment for this record
                    sb = new StringBuilder();
                } else {
                    sb.append(Constants.LF);
                }
                sb.append(reusableToken.content);
                // Read another token
                reusableToken.type = TOKEN;
                break;
            default:
                throw new CSVException(""Unexpected Token type: %s"", reusableToken.type);
        }
    } while (reusableToken.type == TOKEN);
    if (!recordList.isEmpty()) {
        recordNumber++;
        final String comment = Objects.toString(sb, null);
        result = new CSVRecord(this, recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment, recordNumber, startCharPosition, startBytePosition);
    }
    return result;
}","CSVRecord","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.stream()","Method","* Returns a sequential {@code Stream} with this collection as its source.
     * <p>
     * If the parser is closed, the stream will not produce any more values.
     * See the comments in {@link #iterator()}.
     * </p>
     * <p>
     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a Stream produces.
     * </p>
     *
     * @return a sequential {@code Stream} with this collection as its source.
     * @since 1.9.0","public Stream<CSVRecord> stream() {
    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(), Spliterator.ORDERED), false);
}","Stream","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat)","Constructor","* Constructs a new instance using the given {@link CSVFormat}
     *
     * <p>
     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,
     * unless you close the {@code reader}.
     * </p>
     *
     * @param reader
     *            a Reader containing CSV-formatted input. Must not be null.
     * @param format
     *            the CSVFormat used for CSV parsing. Must not be null.
     * @throws IllegalArgumentException
     *             If the parameters of the format are inconsistent or if either reader or format are null.
     * @throws IOException
     *             If there is a problem reading the header or skipping the first record
     * @throws CSVException Thrown on invalid input.
     * @deprecated Will be removed in the next major version, use {@link Builder#get()}.","@Deprecated
public CSVParser(final Reader reader, final CSVFormat format) throws IOException {
    this(reader, format, 0, 1);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat).reader","Parameter_1","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat).format","Parameter_2","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long)","Constructor","* Constructs a new instance using the given {@link CSVFormat}
     *
     * <p>
     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,
     * unless you close the {@code reader}.
     * </p>
     *
     * @param reader
     *            a Reader containing CSV-formatted input. Must not be null.
     * @param format
     *            the CSVFormat used for CSV parsing. Must not be null.
     * @param characterOffset
     *            Lexer offset when the parser does not start parsing at the beginning of the source.
     * @param recordNumber
     *            The next record number to assign.
     * @throws IllegalArgumentException
     *             If the parameters of the format are inconsistent or if either the reader or format is null.
     * @throws IOException
     *             if there is a problem reading the header or skipping the first record
     * @throws CSVException on invalid input.
     * @since 1.1
     * @deprecated Will be private in the next major version, use {@link Builder#get()}.","@Deprecated
public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException {
    this(reader, format, characterOffset, recordNumber, null, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long).reader","Parameter_1","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long).format","Parameter_2","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long).characterOffset","Parameter_3","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long).recordNumber","Parameter_4","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean)","Constructor","* Constructs a new instance using the given {@link CSVFormat}
     *
     * <p>
     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,
     * unless you close the {@code reader}.
     * </p>
     *
     * @param reader
     *            a Reader containing CSV-formatted input. Must not be null.
     * @param format
     *            the CSVFormat used for CSV parsing. Must not be null.
     * @param characterOffset
     *            Lexer offset when the parser does not start parsing at the beginning of the source.
     * @param recordNumber
     *            The next record number to assign.
     * @param charset
     *            The character encoding to be used for the reader when enableByteTracking is true.
     * @param trackBytes
     *           {@code true} to enable byte tracking for the parser; {@code false} to disable it.
     * @throws IllegalArgumentException
     *             If the parameters of the format are inconsistent or if either the reader or format is null.
     * @throws IOException
     *             If there is a problem reading the header or skipping the first record.
     * @throws CSVException Thrown on invalid input.","private CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber, final Charset charset, final boolean trackBytes) throws IOException {
    Objects.requireNonNull(reader, ""reader"");
    Objects.requireNonNull(format, ""format"");
    this.format = format.copy();
    this.lexer = new Lexer(format, new ExtendedBufferedReader(reader, charset, trackBytes));
    this.csvRecordIterator = new CSVRecordIterator();
    this.headers = createHeaders();
    this.characterOffset = characterOffset;
    this.recordNumber = recordNumber - 1;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean).reader","Parameter_1","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean).format","Parameter_2","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean).characterOffset","Parameter_3","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean).recordNumber","Parameter_4","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean).charset","Parameter_5","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean).trackBytes","Parameter_6","Belong to org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder","Class","* Builds a new {@link CSVParser}.
     *
     * @since 1.13.0","Class do not obtain Source Code","No return type","public , static ","org.apache.commons.io.build.AbstractStreamBuilder",""
"org.apache.commons.csv.CSVParser$Builder.format","Field","No Comment","private CSVFormat format;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.characterOffset","Field","No Comment","private long characterOffset;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.recordNumber","Field","No Comment","private long recordNumber = 1;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.trackBytes","Field","No Comment","private boolean trackBytes;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.get()","Method","No Comment","@SuppressWarnings(""resource"")
@Override
public CSVParser get() throws IOException {
    return new CSVParser(getReader(), format != null ? format : CSVFormat.DEFAULT, characterOffset, recordNumber, getCharset(), trackBytes);
}","CSVParser","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.setCharacterOffset(long)","Method","* Sets the lexer offset when the parser does not start parsing at the beginning of the source.
         *
         * @param characterOffset the lexer offset.
         * @return this instance.","public Builder setCharacterOffset(final long characterOffset) {
    this.characterOffset = characterOffset;
    return asThis();
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.setCharacterOffset(long).characterOffset","Parameter_1","Belong to org.apache.commons.csv.CSVParser$Builder.setCharacterOffset(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.setFormat(CSVFormat)","Method","* Sets the CSV format. A copy of the given format is kept.
         *
         * @param format the CSV format, null is equivalent to {@link CSVFormat#DEFAULT}.
         * @return this instance.","public Builder setFormat(final CSVFormat format) {
    this.format = CSVFormat.copy(format);
    return asThis();
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.setFormat(CSVFormat).format","Parameter_1","Belong to org.apache.commons.csv.CSVParser$Builder.setFormat(CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.setRecordNumber(long)","Method","* Sets the next record number to assign, defaults to {@code 1}.
         *
         * @param recordNumber the next record number to assign.
         * @return this instance.","public Builder setRecordNumber(final long recordNumber) {
    this.recordNumber = recordNumber;
    return asThis();
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.setRecordNumber(long).recordNumber","Parameter_1","Belong to org.apache.commons.csv.CSVParser$Builder.setRecordNumber(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.setTrackBytes(boolean)","Method","* Sets whether to enable byte tracking for the parser.
         *
         * @param trackBytes {@code true} to enable byte tracking; {@code false} to disable it.
         * @return this instance.
         * @since 1.13.0","public Builder setTrackBytes(final boolean trackBytes) {
    this.trackBytes = trackBytes;
    return asThis();
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.setTrackBytes(boolean).trackBytes","Parameter_1","Belong to org.apache.commons.csv.CSVParser$Builder.setTrackBytes(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Builder.<init>()","Constructor","* Constructs a new instance.","protected Builder() {
    // empty
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$CSVRecordIterator","Class","No Comment","Class do not obtain Source Code","No return type","final ","","java.util.Iterator"
"org.apache.commons.csv.CSVParser$CSVRecordIterator.current","Field","No Comment","private CSVRecord current;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$CSVRecordIterator.getNextRecord()","Method","* Gets the next record or null at the end of stream or max rows read.
         *
         * @throws IOException  on parse error or input read-failure
         * @throws CSVException on invalid input.
         * @return the next record, or {@code null} if the end of the stream has been reached.","private CSVRecord getNextRecord() {
    CSVRecord record = null;
    if (format.useRow(recordNumber + 1)) {
        record = Uncheck.get(CSVParser.this::nextRecord);
    }
    return record;
}","CSVRecord","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$CSVRecordIterator.hasNext()","Method","No Comment","@Override
public boolean hasNext() {
    if (isClosed()) {
        return false;
    }
    if (current == null) {
        current = getNextRecord();
    }
    return current != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$CSVRecordIterator.next()","Method","No Comment","@Override
public CSVRecord next() {
    if (isClosed()) {
        throw new NoSuchElementException(""CSVParser has been closed"");
    }
    CSVRecord next = current;
    current = null;
    if (next == null) {
        // hasNext() wasn't called before
        next = getNextRecord();
        if (next == null) {
            throw new NoSuchElementException(""No more CSV records available"");
        }
    }
    return next;
}","CSVRecord","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$CSVRecordIterator.remove()","Method","No Comment","@Override
public void remove() {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Headers","Class","* Header information based on name and position.","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.csv.CSVParser$Headers.headerMap","Field","* Header column positions (0-based)","final Map<String, Integer> headerMap;","No return type","final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Headers.headerNames","Field","* Header names in column order","final List<String> headerNames;","No return type","final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Headers.<init>(Map,List)","Constructor","No Comment","Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {
    this.headerMap = headerMap;
    this.headerNames = headerNames;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Headers.<init>(Map,List).headerMap","Parameter_1","Belong to org.apache.commons.csv.CSVParser$Headers.<init>(Map,List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser$Headers.<init>(Map,List).headerNames","Parameter_2","Belong to org.apache.commons.csv.CSVParser$Headers.<init>(Map,List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder","Class","* Builds a new {@link CSVParser}.
     *
     * @since 1.13.0","Class do not obtain Source Code","No return type","public , static ","org.apache.commons.io.build.AbstractStreamBuilder",""
"org.apache.commons.csv.CSVParser.Builder.format","Field","No Comment","private CSVFormat format;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.characterOffset","Field","No Comment","private long characterOffset;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.recordNumber","Field","No Comment","private long recordNumber = 1;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.trackBytes","Field","No Comment","private boolean trackBytes;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.get()","Method","No Comment","@SuppressWarnings(""resource"")
@Override
public CSVParser get() throws IOException {
    return new CSVParser(getReader(), format != null ? format : CSVFormat.DEFAULT, characterOffset, recordNumber, getCharset(), trackBytes);
}","CSVParser","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.setCharacterOffset(long)","Method","* Sets the lexer offset when the parser does not start parsing at the beginning of the source.
         *
         * @param characterOffset the lexer offset.
         * @return this instance.","public Builder setCharacterOffset(final long characterOffset) {
    this.characterOffset = characterOffset;
    return asThis();
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.setCharacterOffset(long).characterOffset","Parameter_1","Belong to org.apache.commons.csv.CSVParser.Builder.setCharacterOffset(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.setFormat(CSVFormat)","Method","* Sets the CSV format. A copy of the given format is kept.
         *
         * @param format the CSV format, null is equivalent to {@link CSVFormat#DEFAULT}.
         * @return this instance.","public Builder setFormat(final CSVFormat format) {
    this.format = CSVFormat.copy(format);
    return asThis();
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.setFormat(CSVFormat).format","Parameter_1","Belong to org.apache.commons.csv.CSVParser.Builder.setFormat(CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.setRecordNumber(long)","Method","* Sets the next record number to assign, defaults to {@code 1}.
         *
         * @param recordNumber the next record number to assign.
         * @return this instance.","public Builder setRecordNumber(final long recordNumber) {
    this.recordNumber = recordNumber;
    return asThis();
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.setRecordNumber(long).recordNumber","Parameter_1","Belong to org.apache.commons.csv.CSVParser.Builder.setRecordNumber(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.setTrackBytes(boolean)","Method","* Sets whether to enable byte tracking for the parser.
         *
         * @param trackBytes {@code true} to enable byte tracking; {@code false} to disable it.
         * @return this instance.
         * @since 1.13.0","public Builder setTrackBytes(final boolean trackBytes) {
    this.trackBytes = trackBytes;
    return asThis();
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.setTrackBytes(boolean).trackBytes","Parameter_1","Belong to org.apache.commons.csv.CSVParser.Builder.setTrackBytes(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Builder.<init>()","Constructor","* Constructs a new instance.","protected Builder() {
    // empty
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.CSVRecordIterator","Class","No Comment","Class do not obtain Source Code","No return type","final ","","java.util.Iterator"
"org.apache.commons.csv.CSVParser.CSVRecordIterator.current","Field","No Comment","private CSVRecord current;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.CSVRecordIterator.getNextRecord()","Method","* Gets the next record or null at the end of stream or max rows read.
         *
         * @throws IOException  on parse error or input read-failure
         * @throws CSVException on invalid input.
         * @return the next record, or {@code null} if the end of the stream has been reached.","private CSVRecord getNextRecord() {
    CSVRecord record = null;
    if (format.useRow(recordNumber + 1)) {
        record = Uncheck.get(CSVParser.this::nextRecord);
    }
    return record;
}","CSVRecord","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.CSVRecordIterator.hasNext()","Method","No Comment","@Override
public boolean hasNext() {
    if (isClosed()) {
        return false;
    }
    if (current == null) {
        current = getNextRecord();
    }
    return current != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.CSVRecordIterator.next()","Method","No Comment","@Override
public CSVRecord next() {
    if (isClosed()) {
        throw new NoSuchElementException(""CSVParser has been closed"");
    }
    CSVRecord next = current;
    current = null;
    if (next == null) {
        // hasNext() wasn't called before
        next = getNextRecord();
        if (next == null) {
            throw new NoSuchElementException(""No more CSV records available"");
        }
    }
    return next;
}","CSVRecord","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.CSVRecordIterator.remove()","Method","No Comment","@Override
public void remove() {
    throw new UnsupportedOperationException();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Headers","Class","* Header information based on name and position.","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.csv.CSVParser.Headers.headerMap","Field","* Header column positions (0-based)","final Map<String, Integer> headerMap;","No return type","final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Headers.headerNames","Field","* Header names in column order","final List<String> headerNames;","No return type","final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Headers.<init>(Map,List)","Constructor","No Comment","Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {
    this.headerMap = headerMap;
    this.headerNames = headerNames;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Headers.<init>(Map,List).headerMap","Parameter_1","Belong to org.apache.commons.csv.CSVParser.Headers.<init>(Map,List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVParser.Headers.<init>(Map,List).headerNames","Parameter_2","Belong to org.apache.commons.csv.CSVParser.Headers.<init>(Map,List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter","Class","* Prints values in a {@link CSVFormat CSV format}.
 *
 * <p>Values can be appended to the output by calling the {@link #print(Object)} method.
 * Values are printed according to {@link String#valueOf(Object)}.
 * To complete a record the {@link #println()} method has to be called.
 * Comments can be appended by calling {@link #printComment(String)}.
 * However a comment will only be written to the output if the {@link CSVFormat} supports comments.
 * </p>
 *
 * <p>The printer also supports appending a complete record at once by calling {@link #printRecord(Object...)}
 * or {@link #printRecord(Iterable)}.
 * Furthermore {@link #printRecords(Object...)}, {@link #printRecords(Iterable)} and {@link #printRecords(ResultSet)}
 * methods can be used to print several records at once.
 * </p>
 *
 * <p>Example:</p>
 *
 * <pre>
 * try (CSVPrinter printer = new CSVPrinter(new FileWriter(""csv.txt""), CSVFormat.EXCEL)) {
 *     printer.printRecord(""id"", ""userName"", ""firstName"", ""lastName"", ""birthday"");
 *     printer.printRecord(1, ""john73"", ""John"", ""Doe"", LocalDate.of(1973, 9, 15));
 *     printer.println();
 *     printer.printRecord(2, ""mary"", ""Mary"", ""Meyer"", LocalDate.of(1985, 3, 29));
 * } catch (IOException ex) {
 *     ex.printStackTrace();
 * }
 * </pre>
 *
 * <p>This code will write the following to csv.txt:</p>
 * <pre>
 * id,userName,firstName,lastName,birthday
 * 1,john73,John,Doe,1973-09-15
 *
 * 2,mary,Mary,Meyer,1985-03-29
 * </pre>","Class do not obtain Source Code","No return type","public , final ","","java.io.Flushable;java.io.Closeable"
"org.apache.commons.csv.CSVPrinter.appendable","Field","The place that the values get written.","private final Appendable appendable;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.format","Field","No Comment","private final CSVFormat format;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.newRecord","Field","True if we just began a new record.","private boolean newRecord = true;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.recordCount","Field","No Comment","private long recordCount;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.close()","Method","No Comment","@Override
public void close() throws IOException {
    close(false);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.close(boolean)","Method","* Closes the underlying stream with an optional flush first.
     * @param flush whether to flush before the actual close.
     * @throws IOException
     *             If an I/O error occurs
     * @since 1.6","public void close(final boolean flush) throws IOException {
    if (flush || format.getAutoFlush()) {
        flush();
    }
    if (appendable instanceof Closeable) {
        ((Closeable) appendable).close();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.close(boolean).flush","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.close(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.endOfRecord()","Method","* Outputs the record separator and increments the record count.
     *
     * @throws IOException
     *             If an I/O error occurs","private synchronized void endOfRecord() throws IOException {
    println();
    recordCount++;
}","void","private , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.flush()","Method","* Flushes the underlying stream.
     *
     * @throws IOException
     *             If an I/O error occurs","@Override
public void flush() throws IOException {
    if (appendable instanceof Flushable) {
        ((Flushable) appendable).flush();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.getOut()","Method","* Gets the target Appendable.
     *
     * @return the target Appendable.","public Appendable getOut() {
    return this.appendable;
}","Appendable","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.getRecordCount()","Method","* Gets the record count printed, this does not include comments or headers.
     *
     * @return the record count, this does not include comments or headers.
     * @since 1.13.0","public long getRecordCount() {
    return recordCount;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.print(Object)","Method","* Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.
     *
     * @param value
     *            value to be output.
     * @throws IOException
     *             If an I/O error occurs","public synchronized void print(final Object value) throws IOException {
    format.print(value, appendable, newRecord);
    newRecord = false;
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.print(Object).value","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.print(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printComment(String)","Method","* Prints a comment on a new line among the delimiter-separated values.
     *
     * <p>
     * Comments will always begin on a new line and occupy at least one full line. The character specified to start
     * comments and a space will be inserted at the beginning of each new line in the comment.
     * </p>
     *
     * <p>
     * If comments are disabled in the current CSV format this method does nothing.
     * </p>
     *
     * <p>This method detects line breaks inside the comment string and inserts {@link CSVFormat#getRecordSeparator()}
     * to start a new line of the comment. Note that this might produce unexpected results for formats that do not use
     * line breaks as record separators.</p>
     *
     * @param comment
     *            the comment to output
     * @throws IOException
     *             If an I/O error occurs","public synchronized void printComment(final String comment) throws IOException {
    if (comment == null || !format.isCommentMarkerSet()) {
        return;
    }
    if (!newRecord) {
        println();
    }
    // N.B. Explicit (un)boxing is intentional
    appendable.append(format.getCommentMarker().charValue());
    appendable.append(SP);
    for (int i = 0; i < comment.length(); i++) {
        final char c = comment.charAt(i);
        switch(c) {
            case CR:
                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {
                    i++;
                }
            // falls-through: break intentionally excluded.
            case LF:
                println();
                // N.B. Explicit (un)boxing is intentional
                appendable.append(format.getCommentMarker().charValue());
                appendable.append(SP);
                break;
            default:
                appendable.append(c);
                break;
        }
    }
    println();
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printComment(String).comment","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printComment(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printHeaders(ResultSet)","Method","* Prints headers for a result set based on its metadata.
     *
     * @param resultSet The ResultSet to query for metadata.
     * @throws IOException If an I/O error occurs.
     * @throws SQLException If a database access error occurs or this method is called on a closed result set.
     * @since 1.9.0","public synchronized void printHeaders(final ResultSet resultSet) throws IOException, SQLException {
    try (IOStream<String> stream = IOStream.of(format.builder().setHeader(resultSet).get().getHeader())) {
        stream.forEachOrdered(this::print);
    }
    println();
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printHeaders(ResultSet).resultSet","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printHeaders(ResultSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.println()","Method","* Outputs the record separator.
     *
     * @throws IOException
     *             If an I/O error occurs","public synchronized void println() throws IOException {
    format.println(appendable);
    newRecord = true;
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecord(Iterable)","Method","* Prints the given values as a single record of delimiter-separated values followed by the record separator.
     *
     * <p>
     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record
     * separator to the output after printing the record, so there is no need to call {@link #println()}.
     * </p>
     *
     * @param values
     *            values to output.
     * @throws IOException
     *             If an I/O error occurs","@SuppressWarnings(""resource"")
public synchronized void printRecord(final Iterable<?> values) throws IOException {
    IOStream.of(values).forEachOrdered(this::print);
    endOfRecord();
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecord(Iterable).values","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecord(Iterable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecord(Object[])","Method","* Prints the given values as a single record of delimiter-separated values followed by the record separator.
     *
     * <p>
     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record
     * separator to the output after printing the record, so there is no need to call {@link #println()}.
     * </p>
     *
     * @param values
     *            values to output.
     * @throws IOException
     *             If an I/O error occurs","public void printRecord(final Object... values) throws IOException {
    printRecord(Arrays.asList(values));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecord(Object[]).values","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecord(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecord(Stream)","Method","* Prints the given values as a single record of delimiter-separated values followed by the record separator.
     *
     * <p>
     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record
     * separator to the output after printing the record, so there is no need to call {@link #println()}.
     * </p>
     *
     * @param values
     *            values to output.
     * @throws IOException
     *             If an I/O error occurs
     * @since 1.10.0","// caller closes.
@SuppressWarnings(""resource"")
public synchronized void printRecord(final Stream<?> values) throws IOException {
    IOStream.adapt(values).forEachOrdered(this::print);
    endOfRecord();
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecord(Stream).values","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecord(Stream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecordObject(Object)","Method","No Comment","private void printRecordObject(final Object value) throws IOException {
    if (value instanceof Object[]) {
        this.printRecord((Object[]) value);
    } else if (value instanceof Iterable) {
        this.printRecord((Iterable<?>) value);
    } else {
        this.printRecord(value);
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecordObject(Object).value","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecordObject(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(IOStream)","Method","No Comment","@SuppressWarnings(""resource"")
private void printRecords(final IOStream<?> stream) throws IOException {
    format.limit(stream).forEachOrdered(this::printRecordObject);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(IOStream).stream","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecords(IOStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(Iterable)","Method","* Prints all the objects in the given {@link Iterable} handling nested collections/arrays as records.
     *
     * <p>
     * If the given Iterable only contains simple objects, this method will print a single record like
     * {@link #printRecord(Iterable)}. If the given Iterable contains nested collections/arrays those nested elements
     * will each be printed as records using {@link #printRecord(Object...)}.
     * </p>
     *
     * <p>
     * Given the following data structure:
     * </p>
     *
     * <pre>{@code
     * List<String[]> data = new ArrayList<>();
     * data.add(new String[]{ ""A"", ""B"", ""C"" });
     * data.add(new String[]{ ""1"", ""2"", ""3"" });
     * data.add(new String[]{ ""A1"", ""B2"", ""C3"" });
     * }
     * </pre>
     *
     * <p>
     * Calling this method will print:
     * </p>
     *
     * <pre>
     * {@code
     * A, B, C
     * 1, 2, 3
     * A1, B2, C3
     * }
     * </pre>
     *
     * @param values
     *            the values to print.
     * @throws IOException
     *             If an I/O error occurs","@SuppressWarnings(""resource"")
public void printRecords(final Iterable<?> values) throws IOException {
    printRecords(IOStream.of(values));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(Iterable).values","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecords(Iterable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(Object[])","Method","* Prints all the objects in the given array handling nested collections/arrays as records.
     *
     * <p>
     * If the given array only contains simple objects, this method will print a single record like
     * {@link #printRecord(Object...)}. If the given collections contain nested collections or arrays, those nested
     * elements will each be printed as records using {@link #printRecord(Object...)}.
     * </p>
     *
     * <p>
     * Given the following data structure:
     * </p>
     *
     * <pre>{@code
     * String[][] data = new String[3][]
     * data[0] = String[]{ ""A"", ""B"", ""C"" };
     * data[1] = new String[]{ ""1"", ""2"", ""3"" };
     * data[2] = new String[]{ ""A1"", ""B2"", ""C3"" };
     * }
     * </pre>
     *
     * <p>
     * Calling this method will print:
     * </p>
     *
     * <pre>{@code
     * A, B, C
     * 1, 2, 3
     * A1, B2, C3
     * }
     * </pre>
     *
     * @param values
     *            the values to print.
     * @throws IOException
     *             If an I/O error occurs","public void printRecords(final Object... values) throws IOException {
    printRecords(Arrays.asList(values));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(Object[]).values","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecords(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(ResultSet)","Method","* Prints all the objects in the given JDBC result set.
     * <p>
     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a result set produces. This is most useful when you cannot limit rows
     * through {@link Statement#setLargeMaxRows(long)} or {@link Statement#setMaxRows(int)}.
     * </p>
     *
     * @param resultSet The values to print.
     * @throws IOException  If an I/O error occurs.
     * @throws SQLException Thrown when a database access error occurs.","public void printRecords(final ResultSet resultSet) throws SQLException, IOException {
    final int columnCount = resultSet.getMetaData().getColumnCount();
    while (resultSet.next() && format.useRow(resultSet.getRow())) {
        for (int i = 1; i <= columnCount; i++) {
            final Object object = resultSet.getObject(i);
            if (object instanceof Clob) {
                try (Reader reader = ((Clob) object).getCharacterStream()) {
                    print(reader);
                }
            } else if (object instanceof Blob) {
                try (InputStream inputStream = ((Blob) object).getBinaryStream()) {
                    print(inputStream);
                }
            } else {
                print(object);
            }
        }
        endOfRecord();
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(ResultSet).resultSet","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecords(ResultSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(ResultSet,boolean)","Method","* Prints all the objects with metadata in the given JDBC result set based on the header boolean.
     * <p>
     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a result set produces. This is most useful when you cannot limit rows
     * through {@link Statement#setLargeMaxRows(long)} or {@link Statement#setMaxRows(int)}.
     * </p>
     *
     * @param resultSet source of row data.
     * @param printHeader whether to print headers.
     * @throws IOException If an I/O error occurs
     * @throws SQLException if a database access error occurs
     * @since 1.9.0","public void printRecords(final ResultSet resultSet, final boolean printHeader) throws SQLException, IOException {
    if (printHeader) {
        printHeaders(resultSet);
    }
    printRecords(resultSet);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(ResultSet,boolean).resultSet","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecords(ResultSet,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(ResultSet,boolean).printHeader","Parameter_2","Belong to org.apache.commons.csv.CSVPrinter.printRecords(ResultSet,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(Stream)","Method","* Prints all the objects in the given {@link Stream} handling nested collections/arrays as records.
     *
     * <p>
     * If the given Stream only contains simple objects, this method will print a single record like
     * {@link #printRecord(Iterable)}. If the given Stream contains nested collections/arrays those nested elements
     * will each be printed as records using {@link #printRecord(Object...)}.
     * </p>
     *
     * <p>
     * Given the following data structure:
     * </p>
     *
     * <pre>{@code
     * List<String[]> data = new ArrayList<>();
     * data.add(new String[]{ ""A"", ""B"", ""C"" });
     * data.add(new String[]{ ""1"", ""2"", ""3"" });
     * data.add(new String[]{ ""A1"", ""B2"", ""C3"" });
     * Stream<String[]> stream = data.stream();
     * }
     * </pre>
     *
     * <p>
     * Calling this method will print:
     * </p>
     *
     * <pre>
     * {@code
     * A, B, C
     * 1, 2, 3
     * A1, B2, C3
     * }
     * </pre>
     *
     * @param values
     *            the values to print.
     * @throws IOException
     *             If an I/O error occurs
     * @since 1.10.0","// Caller closes.
@SuppressWarnings({ ""resource"" })
public void printRecords(final Stream<?> values) throws IOException {
    printRecords(IOStream.adapt(values));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.printRecords(Stream).values","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.printRecords(Stream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.<init>(Appendable,CSVFormat)","Constructor","* Creates a printer that will print values to the given stream following the CSVFormat.
     * <p>
     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation
     * and escaping with a different character) are not supported.
     * </p>
     *
     * @param appendable
     *            stream to which to print. Must not be null.
     * @param format
     *            the CSV format. Must not be null.
     * @throws IOException
     *             thrown if the optional header cannot be printed.
     * @throws IllegalArgumentException
     *             thrown if the parameters of the format are inconsistent or if either out or format are null.","public CSVPrinter(final Appendable appendable, final CSVFormat format) throws IOException {
    Objects.requireNonNull(appendable, ""appendable"");
    Objects.requireNonNull(format, ""format"");
    this.appendable = appendable;
    this.format = format.copy();
    // TODO: Is it a good idea to do this here instead of on the first call to a print method?
    // It seems a pain to have to track whether the header has already been printed or not.
    final String[] headerComments = format.getHeaderComments();
    if (headerComments != null) {
        for (final String line : headerComments) {
            printComment(line);
        }
    }
    if (format.getHeader() != null && !format.getSkipHeaderRecord()) {
        this.printRecord((Object[]) format.getHeader());
    }
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.<init>(Appendable,CSVFormat).appendable","Parameter_1","Belong to org.apache.commons.csv.CSVPrinter.<init>(Appendable,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVPrinter.<init>(Appendable,CSVFormat).format","Parameter_2","Belong to org.apache.commons.csv.CSVPrinter.<init>(Appendable,CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat","Class","* Specifies the format of a CSV file for parsing and writing.
 *
 * <h2>Using predefined formats</h2>
 *
 * <p>
 * You can use one of the predefined formats:
 * </p>
 *
 * <ul>
 * <li>{@link #DEFAULT}</li>
 * <li>{@link #EXCEL}</li>
 * <li>{@link #INFORMIX_UNLOAD}</li>
 * <li>{@link #INFORMIX_UNLOAD_CSV}</li>
 * <li>{@link #MONGODB_CSV}</li>
 * <li>{@link #MONGODB_TSV}</li>
 * <li>{@link #MYSQL}</li>
 * <li>{@link #ORACLE}</li>
 * <li>{@link #POSTGRESQL_CSV}</li>
 * <li>{@link #POSTGRESQL_TEXT}</li>
 * <li>{@link #RFC4180}</li>
 * <li>{@link #TDF}</li>
 * </ul>
 *
 * <p>
 * For example:
 * </p>
 *
 * <pre>
 * CSVParser parser = CSVFormat.EXCEL.parse(reader);
 * </pre>
 *
 * <p>
 * The {@link CSVParser} provides static methods to parse other input types, for example:
 * </p>
 *
 * <pre>
 * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);
 * </pre>
 *
 * <h2>Defining formats</h2>
 *
 * <p>
 * You can extend a format by calling the {@code set} methods. For example:
 * </p>
 *
 * <pre>{@code
 * CSVFormat.EXCEL.builder().setNullString(""N/A"").setIgnoreSurroundingSpaces(true).get();
 * }</pre>
 *
 * <h2>Defining column names</h2>
 *
 * <p>
 * To define the column names you want to use to access records, write:
 * </p>
 *
 * <pre>{@code
 * CSVFormat.EXCEL.builder().setHeader(""Col1"", ""Col2"", ""Col3"").get();
 * }</pre>
 *
 * <p>
 * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not
 * contain a first record that also defines column names.
 *
 * If it does, then you are overriding this metadata with your names and you should skip the first record by calling
 * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.
 * </p>
 *
 * <h2>Parsing</h2>
 *
 * <p>
 * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:
 * </p>
 *
 * <pre>{@code
 * Reader in = ...;
 * CSVFormat.EXCEL.builder().setHeader(""Col1"", ""Col2"", ""Col3"").get().parse(in);
 * }</pre>
 *
 * <p>
 * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.
 * </p>
 *
 * <h2>Referencing columns safely</h2>
 *
 * <p>
 * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no
 * arguments:
 * </p>
 *
 * <pre>
 * CSVFormat.EXCEL.builder().setHeader().get();
 * </pre>
 *
 * <p>
 * This causes the parser to read the first record and use its values as column names.
 *
 * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:
 * </p>
 *
 * <pre>{@code
 * String value = record.get(""Col1"");
 * }</pre>
 *
 * <p>
 * This makes your code impervious to changes in column order in the CSV file.
 * </p>
 *
 * <h2>Serialization</h2>
 * <p>
 * This class implements the {@link Serializable} interface with the following caveats:
 * </p>
 * <ul>
 * <li>This class will no longer implement Serializable in 2.0.</li>
 * <li>Serialization is not supported from one version to the next.</li>
 * </ul>
 * <p>
 * The {@code serialVersionUID} values are:
 * </p>
 * <ul>
 * <li>Version 1.10.0: {@code 2L}</li>
 * <li>Version 1.9.0 through 1.0: {@code 1L}</li>
 * </ul>
 *
 * <h2>Notes</h2>
 * <p>
 * This class is immutable.
 * </p>
 * <p>
 * Not all settings are used for both parsing and writing.
 * </p>","Class do not obtain Source Code","No return type","public , final ","","java.io.Serializable"
"org.apache.commons.csv.CSVFormat.DEFAULT","Field","* Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.
     *
     * <p>
     * The {@link Builder} settings are:
     * </p>
     * <ul>
     * <li>{@link Builder#setDelimiter(char) setDelimiter}{@code (',')}</li>
     * <li>{@link Builder#setQuote(char) setQuote}{@code ('""')}</li>
     * <li>{@link Builder#setRecordSeparator(String) setRecordSeparator}{@code (""\r\n"")}</li>
     * <li>{@link Builder#setIgnoreEmptyLines(boolean) setIgnoreEmptyLines}{@code (true)}</li>
     * <li>{@link Builder#setDuplicateHeaderMode(DuplicateHeaderMode) setDuplicateHeaderMode}{@code (DuplicateHeaderMode.ALLOW_ALL)}</li>
     * </ul>
     *
     * @see Predefined#Default
     * @see DuplicateHeaderMode#ALLOW_ALL","public static final CSVFormat DEFAULT = new CSVFormat(Builder.create());","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.EXCEL","Field","@formatter:off","public static final CSVFormat EXCEL = DEFAULT.builder().setIgnoreEmptyLines(false).setAllowMissingColumnNames(true).setTrailingData(true).setLenientEof(true).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.INFORMIX_UNLOAD","Field","@formatter:off","public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder().setDelimiter(Constants.PIPE).setEscape(Constants.BACKSLASH).setQuote(Constants.DOUBLE_QUOTE_CHAR).setRecordSeparator(Constants.LF).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.INFORMIX_UNLOAD_CSV","Field","@formatter:off","public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder().setDelimiter(Constants.COMMA).setQuote(Constants.DOUBLE_QUOTE_CHAR).setRecordSeparator(Constants.LF).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.MONGODB_CSV","Field","@formatter:off","public static final CSVFormat MONGODB_CSV = DEFAULT.builder().setDelimiter(Constants.COMMA).setEscape(Constants.DOUBLE_QUOTE_CHAR).setQuote(Constants.DOUBLE_QUOTE_CHAR).setQuoteMode(QuoteMode.MINIMAL).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.MONGODB_TSV","Field","@formatter:off","public static final CSVFormat MONGODB_TSV = DEFAULT.builder().setDelimiter(Constants.TAB).setEscape(Constants.DOUBLE_QUOTE_CHAR).setQuote(Constants.DOUBLE_QUOTE_CHAR).setQuoteMode(QuoteMode.MINIMAL).setSkipHeaderRecord(false).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.MYSQL","Field","@formatter:off","public static final CSVFormat MYSQL = DEFAULT.builder().setDelimiter(Constants.TAB).setEscape(Constants.BACKSLASH).setIgnoreEmptyLines(false).setQuote(null).setRecordSeparator(Constants.LF).setNullString(Constants.SQL_NULL_STRING).setQuoteMode(QuoteMode.ALL_NON_NULL).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.ORACLE","Field","@formatter:off","public static final CSVFormat ORACLE = DEFAULT.builder().setDelimiter(Constants.COMMA).setEscape(Constants.BACKSLASH).setIgnoreEmptyLines(false).setQuote(Constants.DOUBLE_QUOTE_CHAR).setNullString(Constants.SQL_NULL_STRING).setTrim(true).setRecordSeparator(System.lineSeparator()).setQuoteMode(QuoteMode.MINIMAL).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.POSTGRESQL_CSV","Field","@formatter:off","public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder().setDelimiter(Constants.COMMA).setEscape(null).setIgnoreEmptyLines(false).setQuote(Constants.DOUBLE_QUOTE_CHAR).setRecordSeparator(Constants.LF).setNullString(Constants.EMPTY).setQuoteMode(QuoteMode.ALL_NON_NULL).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.POSTGRESQL_TEXT","Field","@formatter:off","public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder().setDelimiter(Constants.TAB).setEscape(Constants.BACKSLASH).setIgnoreEmptyLines(false).setQuote(null).setRecordSeparator(Constants.LF).setNullString(Constants.SQL_NULL_STRING).setQuoteMode(QuoteMode.ALL_NON_NULL).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.RFC4180","Field","* Comma separated format as defined by <a href=""https://tools.ietf.org/html/rfc4180"">RFC 4180</a>.
     *
     * <p>
     * The {@link Builder} settings are the {@link #DEFAULT} <em>with</em>:
     * </p>
     * <ul>
     * <li>{@link Builder#setDelimiter(char) setDelimiter}{@code (',')}</li>
     * <li>{@link Builder#setQuote(char) setQuote}{@code ('""')}</li>
     * <li>{@link Builder#setRecordSeparator(String) setRecordSeparator}{@code (""\r\n"")}</li>
     * <li>{@link Builder#setIgnoreEmptyLines(boolean) setIgnoreEmptyLines}{@code (false)}</li>
     * </ul>
     *
     * @see Predefined#RFC4180
     * @see <a href=""https://tools.ietf.org/html/rfc4180"">RFC 4180</a>","public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 2L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.TDF","Field","@formatter:off","public static final CSVFormat TDF = DEFAULT.builder().setDelimiter(Constants.TAB).setIgnoreSurroundingSpaces(true).get();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.duplicateHeaderMode","Field","How duplicate headers are handled.","private final DuplicateHeaderMode duplicateHeaderMode;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.allowMissingColumnNames","Field","Whether missing column names are allowed when parsing the header line.","private final boolean allowMissingColumnNames;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.autoFlush","Field","Whether to flush on close.","private final boolean autoFlush;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.commentMarker","Field","Set to null if commenting is disabled.","private final Character commentMarker;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.delimiter","Field","The character delimiting the values (typically "";"", "","" or ""\t"").","private final String delimiter;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.escapeCharacter","Field","Set to null if escaping is disabled.","private final Character escapeCharacter;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.headers","Field","Array of header column names.","private final String[] headers;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.headerComments","Field","Array of header comment lines.","private final String[] headerComments;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.ignoreEmptyLines","Field","Whether empty lines between records are ignored when parsing input.","private final boolean ignoreEmptyLines;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.ignoreHeaderCase","Field","Should ignore header names case.","private final boolean ignoreHeaderCase;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.ignoreSurroundingSpaces","Field","Should leading/trailing spaces be ignored around values?.","private final boolean ignoreSurroundingSpaces;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.nullString","Field","The string to be used for null values.","private final String nullString;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.quoteCharacter","Field","Set to null if quoting is disabled.","private final Character quoteCharacter;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.quotedNullString","Field","Set to {@code quoteCharacter + nullString + quoteCharacter}","private final String quotedNullString;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.quoteMode","Field","The quote policy output fields.","private final QuoteMode quoteMode;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.recordSeparator","Field","For output.","private final String recordSeparator;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.skipHeaderRecord","Field","Whether to skip the header record.","private final boolean skipHeaderRecord;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.lenientEof","Field","Whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.","private final boolean lenientEof;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.trailingData","Field","Whether reading trailing data is allowed in records, helps Excel compatibility.","private final boolean trailingData;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.trailingDelimiter","Field","Whether to add a trailing delimiter.","private final boolean trailingDelimiter;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.trim","Field","Whether to trim leading and trailing blanks.","private final boolean trim;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.maxRows","Field","The maximum number of rows to process, excluding the header row.","private final long maxRows;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.clone(Object[])","Method","* Null-safe clone of an array.
     *
     * @param <T>    The array element type.
     * @param values the source array
     * @return the cloned array.","@SafeVarargs
static <T> T[] clone(final T... values) {
    return values == null ? null : values.clone();
}","Object[]","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.clone(Object[]).values","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.clone(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.contains(String,char)","Method","* Returns true if the given string contains the search char.
     *
     * @param source   the string to check.
     * @param searchCh the character to search.
     * @return true if {@code c} contains a line break character","private static boolean contains(final String source, final char searchCh) {
    return Objects.requireNonNull(source, ""source"").indexOf(searchCh) >= 0;
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.contains(String,char).source","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.contains(String,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.contains(String,char).searchCh","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.contains(String,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.containsLineBreak(String)","Method","* Returns true if the given string contains a line break character.
     *
     * @param source the string to check.
     * @return true if {@code c} contains a line break character.","private static boolean containsLineBreak(final String source) {
    return contains(source, Constants.CR) || contains(source, Constants.LF);
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.containsLineBreak(String).source","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.containsLineBreak(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.copy(CSVFormat)","Method","* Creates a null-safe copy of the given instance.
     *
     * @return a copy of the given instance or null if the input is null.","static CSVFormat copy(final CSVFormat format) {
    return format != null ? format.copy() : null;
}","CSVFormat","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.copy(CSVFormat).format","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.copy(CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isBlank(String)","Method","No Comment","static boolean isBlank(final String value) {
    return value == null || value.trim().isEmpty();
}","boolean","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isBlank(String).value","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.isBlank(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isLineBreak(char)","Method","* Returns true if the given character is a line break character.
     *
     * @param c the character to check.
     * @return true if {@code c} is a line break character.","private static boolean isLineBreak(final char c) {
    return c == Constants.LF || c == Constants.CR;
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isLineBreak(char).c","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.isLineBreak(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isLineBreak(Character)","Method","* Returns true if the given character is a line break character.
     *
     * @param c the character to check, may be null.
     * @return true if {@code c} is a line break character (and not null).","private static boolean isLineBreak(final Character c) {
    // N.B. Explicit (un)boxing is intentional
    return c != null && isLineBreak(c.charValue());
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isLineBreak(Character).c","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.isLineBreak(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isTrimChar(char)","Method","Same test as in as {@link String#trim()}.","private static boolean isTrimChar(final char ch) {
    return ch <= Constants.SP;
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isTrimChar(char).ch","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.isTrimChar(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isTrimChar(CharSequence,int)","Method","Same test as in as {@link String#trim()}.","private static boolean isTrimChar(final CharSequence charSequence, final int pos) {
    return isTrimChar(charSequence.charAt(pos));
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isTrimChar(CharSequence,int).charSequence","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.isTrimChar(CharSequence,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isTrimChar(CharSequence,int).pos","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.isTrimChar(CharSequence,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.newFormat(char)","Method","* Creates a new CSV format with the specified delimiter.
     *
     * <p>
     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.
     * </p>
     *
     * @param delimiter the char used for value separation, must not be a line break character
     * @return a new CSV format.
     * @throws IllegalArgumentException if the delimiter is a line break character
     * @see #DEFAULT
     * @see #RFC4180
     * @see #MYSQL
     * @see #EXCEL
     * @see #TDF","public static CSVFormat newFormat(final char delimiter) {
    return new CSVFormat(new Builder().setDelimiter(delimiter));
}","CSVFormat","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.newFormat(char).delimiter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.newFormat(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.toStringArray(Object[])","Method","No Comment","static String[] toStringArray(final Object[] values) {
    if (values == null) {
        return null;
    }
    final String[] strings = new String[values.length];
    Arrays.setAll(strings, i -> Objects.toString(values[i], null));
    return strings;
}","String[]","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.toStringArray(Object[]).values","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.toStringArray(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.trim(CharSequence)","Method","No Comment","static CharSequence trim(final CharSequence charSequence) {
    if (charSequence instanceof String) {
        return ((String) charSequence).trim();
    }
    final int count = charSequence.length();
    int len = count;
    int pos = 0;
    while (pos < len && isTrimChar(charSequence, pos)) {
        pos++;
    }
    while (pos < len && isTrimChar(charSequence, len - 1)) {
        len--;
    }
    return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;
}","CharSequence","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.trim(CharSequence).charSequence","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.trim(CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.valueOf(String)","Method","* Gets one of the predefined formats from {@link CSVFormat.Predefined}.
     *
     * @param format name
     * @return one of the predefined formats
     * @since 1.2","public static CSVFormat valueOf(final String format) {
    return CSVFormat.Predefined.valueOf(format).getFormat();
}","CSVFormat","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.valueOf(String).format","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.valueOf(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.append(char,Appendable)","Method","No Comment","private void append(final char c, final Appendable appendable) throws IOException {
    // try {
    appendable.append(c);
    // } catch (final IOException e) {
    // throw new UncheckedIOException(e);
    // }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.append(char,Appendable).c","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.append(char,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.append(char,Appendable).appendable","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.append(char,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.append(CharSequence,Appendable)","Method","No Comment","private void append(final CharSequence csq, final Appendable appendable) throws IOException {
    // try {
    appendable.append(csq);
    // } catch (final IOException e) {
    // throw new UncheckedIOException(e);
    // }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.append(CharSequence,Appendable).csq","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.append(CharSequence,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.append(CharSequence,Appendable).appendable","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.append(CharSequence,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.builder()","Method","* Creates a new Builder for this instance.
     *
     * @return a new Builder.","public Builder builder() {
    return Builder.create(this);
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.copy()","Method","* Creates a copy of this instance.
     *
     * @return a copy of this instance.","CSVFormat copy() {
    return builder().get();
}","CSVFormat","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final CSVFormat other = (CSVFormat) obj;
    return allowMissingColumnNames == other.allowMissingColumnNames && autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) && duplicateHeaderMode == other.duplicateHeaderMode && Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(headerComments, other.headerComments) && Arrays.equals(headers, other.headers) && ignoreEmptyLines == other.ignoreEmptyLines && ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces && lenientEof == other.lenientEof && Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode && Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) && skipHeaderRecord == other.skipHeaderRecord && trailingData == other.trailingData && trailingDelimiter == other.trailingDelimiter && trim == other.trim;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.equals(Object).obj","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.escape(char,Appendable)","Method","No Comment","private void escape(final char c, final Appendable appendable) throws IOException {
    // N.B. Explicit (un)boxing is intentional
    append(escapeCharacter.charValue(), appendable);
    append(c, appendable);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.escape(char,Appendable).c","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.escape(char,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.escape(char,Appendable).appendable","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.escape(char,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.format(Object[])","Method","* Formats the specified values.
     *
     * @param values the values to format
     * @return the formatted values","public String format(final Object... values) {
    return Uncheck.get(() -> format_(values));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.format(Object[]).values","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.format(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.format_(Object[])","Method","No Comment","private String format_(final Object... values) throws IOException {
    final StringWriter out = new StringWriter();
    try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {
        csvPrinter.printRecord(values);
        final String res = out.toString();
        final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();
        return res.substring(0, len);
    }
}","String","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.format_(Object[]).values","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.format_(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getAllowDuplicateHeaderNames()","Method","* Gets whether duplicate names are allowed in the headers.
     *
     * @return whether duplicate header names are allowed
     * @since 1.7
     * @deprecated Use {@link #getDuplicateHeaderMode()}.","@Deprecated
public boolean getAllowDuplicateHeaderNames() {
    return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getAllowMissingColumnNames()","Method","* Gets whether missing column names are allowed when parsing the header line.
     *
     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.","public boolean getAllowMissingColumnNames() {
    return allowMissingColumnNames;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getAutoFlush()","Method","* Gets whether to flush on close.
     *
     * @return whether to flush on close.
     * @since 1.6","public boolean getAutoFlush() {
    return autoFlush;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getCommentMarker()","Method","* Gets the comment marker character, {@code null} disables comments.
     * <p>
     * The comment start character is only recognized at the start of a line.
     * </p>
     * <p>
     * Comments are printed first, before headers.
     * </p>
     * <p>
     * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment marker written at the start of each comment
     * line.
     * </p>
     * <p>
     * If the comment marker is not set, then the header comments are ignored.
     * </p>
     * <p>
     * For example:
     * </p>
     *
     * <pre>
     * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));
     * </pre>
     * <p>
     * writes:
     * </p>
     *
     * <pre>
     * # Generated by Apache Commons CSV.
     * # 1970-01-01T00:00:00Z
     * </pre>
     *
     * @return the comment start marker, may be {@code null}","public Character getCommentMarker() {
    return commentMarker;
}","Character","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getDelimiter()","Method","* Gets the first character delimiting the values (typically ';', ',' or '\t').
     *
     * @return the first delimiter character.
     * @deprecated Use {@link #getDelimiterString()}.","@Deprecated
public char getDelimiter() {
    return delimiter.charAt(0);
}","char","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getDelimiterCharArray()","Method","* Gets the character delimiting the values (typically "";"", "","" or ""\t"").
     *
     * @return the delimiter.","char[] getDelimiterCharArray() {
    return delimiter.toCharArray();
}","char[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getDelimiterString()","Method","* Gets the character delimiting the values (typically "";"", "","" or ""\t"").
     *
     * @return the delimiter.
     * @since 1.9.0","public String getDelimiterString() {
    return delimiter;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getDuplicateHeaderMode()","Method","* Gets how duplicate headers are handled.
     *
     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.
     * @since 1.10.0","public DuplicateHeaderMode getDuplicateHeaderMode() {
    return duplicateHeaderMode;
}","DuplicateHeaderMode","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getEscapeChar()","Method","* Gets the escape character.
     *
     * @return the escape character, may be {@code 0}","char getEscapeChar() {
    // N.B. Explicit (un)boxing is intentional
    return escapeCharacter != null ? escapeCharacter.charValue() : 0;
}","char","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getEscapeCharacter()","Method","* Gets the escape character.
     *
     * @return the escape character, may be {@code null}","public Character getEscapeCharacter() {
    return escapeCharacter;
}","Character","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getHeader()","Method","* Gets a copy of the header array.
     *
     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file","public String[] getHeader() {
    return headers != null ? headers.clone() : null;
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getHeaderComments()","Method","* Gets a copy of the header comment array to write before the CSV data.
     * <p>
     * This setting is ignored by the parser.
     * </p>
     * <p>
     * Comments are printed first, before headers.
     * </p>
     * <p>
     * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment marker written at the start of each comment
     * line.
     * </p>
     * <p>
     * If the comment marker is not set, then the header comments are ignored.
     * </p>
     * <p>
     * For example:
     * </p>
     *
     * <pre>
     * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));
     * </pre>
     * <p>
     * writes:
     * </p>
     *
     * <pre>
     * # Generated by Apache Commons CSV.
     * # 1970-01-01T00:00:00Z
     * </pre>
     *
     * @return a copy of the header comment array; {@code null} if disabled.","public String[] getHeaderComments() {
    return headerComments != null ? headerComments.clone() : null;
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getIgnoreEmptyLines()","Method","* Gets whether empty lines between records are ignored when parsing input.
     *
     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.","public boolean getIgnoreEmptyLines() {
    return ignoreEmptyLines;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getIgnoreHeaderCase()","Method","* Gets whether header names will be accessed ignoring case when parsing input.
     *
     * @return {@code true} if header names cases are ignored, {@code false} if they are case-sensitive.
     * @since 1.3","public boolean getIgnoreHeaderCase() {
    return ignoreHeaderCase;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getIgnoreSurroundingSpaces()","Method","* Gets whether spaces around values are ignored when parsing input.
     *
     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.","public boolean getIgnoreSurroundingSpaces() {
    return ignoreSurroundingSpaces;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getLenientEof()","Method","* Gets whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.
     *
     * @return whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.
     * @since 1.11.0","public boolean getLenientEof() {
    return lenientEof;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getMaxRows()","Method","* Gets the maximum number of rows to process, excluding the header row.
     * <p>
     * Values less than or equal to 0 mean no limit.
     * </p>
     *
     * @return The maximum number of rows to process, excluding the header row.
     * @since 1.14.0","public long getMaxRows() {
    return maxRows;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getNullString()","Method","* Gets the String to convert to and from {@code null}.
     * <ul>
     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>
     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
     * </ul>
     *
     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}","public String getNullString() {
    return nullString;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getQuoteCharacter()","Method","* Gets the character used to encapsulate values containing special characters.
     *
     * @return the quoteChar character, may be {@code null}","public Character getQuoteCharacter() {
    return quoteCharacter;
}","Character","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getQuoteMode()","Method","* Gets the quote policy output fields.
     *
     * @return the quote policy","public QuoteMode getQuoteMode() {
    return quoteMode;
}","QuoteMode","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getRecordSeparator()","Method","* Gets the record separator delimiting output records.
     *
     * @return the record separator","public String getRecordSeparator() {
    return recordSeparator;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getSkipHeaderRecord()","Method","* Gets whether to skip the header record.
     *
     * @return whether to skip the header record.","public boolean getSkipHeaderRecord() {
    return skipHeaderRecord;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getTrailingData()","Method","* Gets whether reading trailing data is allowed in records, helps Excel compatibility.
     *
     * @return whether reading trailing data is allowed in records, helps Excel compatibility.
     * @since 1.11.0","public boolean getTrailingData() {
    return trailingData;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getTrailingDelimiter()","Method","* Gets whether to add a trailing delimiter.
     *
     * @return whether to add a trailing delimiter.
     * @since 1.3","public boolean getTrailingDelimiter() {
    return trailingDelimiter;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.getTrim()","Method","* Gets whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by {CSVParser#addRecordValue(boolean)}
     *
     * @return whether to trim leading and trailing blanks.","public boolean getTrim() {
    return trim;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.hashCode()","Method","No Comment","@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + Arrays.hashCode(headerComments);
    result = prime * result + Arrays.hashCode(headers);
    return prime * result + Objects.hash(allowMissingColumnNames, autoFlush, commentMarker, delimiter, duplicateHeaderMode, escapeCharacter, ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, lenientEof, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator, skipHeaderRecord, trailingData, trailingDelimiter, trim);
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isCommentMarkerSet()","Method","* Tests whether comments are supported by this format.
     *
     * Note that the comment introducer character is only recognized at the start of a line.
     *
     * @return {@code true} is comments are supported, {@code false} otherwise","public boolean isCommentMarkerSet() {
    return commentMarker != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int)","Method","* Tests whether the next characters constitute a delimiter
     *
     * @param ch0             the first char (index 0).
     * @param charSeq         the match char sequence
     * @param startIndex      where start to match
     * @param delimiter       the delimiter
     * @param delimiterLength the delimiter length
     * @return true if the match is successful","private boolean isDelimiter(final char ch0, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {
    if (ch0 != delimiter[0]) {
        return false;
    }
    final int len = charSeq.length();
    if (startIndex + delimiterLength > len) {
        return false;
    }
    for (int i = 1; i < delimiterLength; i++) {
        if (charSeq.charAt(startIndex + i) != delimiter[i]) {
            return false;
        }
    }
    return true;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int).ch0","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int).charSeq","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int).startIndex","Parameter_3","Belong to org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int).delimiter","Parameter_4","Belong to org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int).delimiterLength","Parameter_5","Belong to org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isEscapeCharacterSet()","Method","* Tests whether escapes are being processed.
     *
     * @return {@code true} if escapes are processed","public boolean isEscapeCharacterSet() {
    return escapeCharacter != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isNullStringSet()","Method","* Tests whether a null string has been defined.
     *
     * @return {@code true} if a nullString is defined","public boolean isNullStringSet() {
    return nullString != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.isQuoteCharacterSet()","Method","* Tests whether a quoteChar has been defined.
     *
     * @return {@code true} if a quoteChar is defined","public boolean isQuoteCharacterSet() {
    return quoteCharacter != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.limit(IOStream)","Method","No Comment","<T> IOStream<T> limit(final IOStream<T> stream) {
    return useMaxRows() ? stream.limit(getMaxRows()) : stream;
}","IOStream","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.limit(IOStream).stream","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.limit(IOStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.limit(Stream)","Method","No Comment","<T> Stream<T> limit(final Stream<T> stream) {
    return useMaxRows() ? stream.limit(getMaxRows()) : stream;
}","Stream","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.limit(Stream).stream","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.limit(Stream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.parse(Reader)","Method","* Parses the specified content.
     *
     * <p>
     * See also the various static parse methods on {@link CSVParser}.
     * </p>
     *
     * @param reader the input stream
     * @return a parser over a stream of {@link CSVRecord}s.
     * @throws IOException  If an I/O error occurs
     * @throws CSVException Thrown on invalid input.","public CSVParser parse(final Reader reader) throws IOException {
    return CSVParser.builder().setReader(reader).setFormat(this).get();
}","CSVParser","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.parse(Reader).reader","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.parse(Reader)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Appendable)","Method","* Prints to the specified output.
     *
     * <p>
     * See also {@link CSVPrinter}.
     * </p>
     *
     * @param out the output.
     * @return a printer to an output.
     * @throws IOException thrown if the optional header cannot be printed.","public CSVPrinter print(final Appendable out) throws IOException {
    return new CSVPrinter(out, this);
}","CSVPrinter","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Appendable).out","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.print(Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(File,Charset)","Method","* Prints to the specified {@code File} with given {@code Charset}.
     *
     * <p>
     * See also {@link CSVPrinter}.
     * </p>
     *
     * @param out     the output.
     * @param charset A charset.
     * @return a printer to an output.
     * @throws IOException thrown if the optional header cannot be printed.
     * @since 1.5","public CSVPrinter print(final File out, final Charset charset) throws IOException {
    return print(out.toPath(), charset);
}","CSVPrinter","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(File,Charset).out","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.print(File,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(File,Charset).charset","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.print(File,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(InputStream,Appendable,boolean)","Method","No Comment","private void print(final InputStream inputStream, final Appendable out, final boolean newRecord) throws IOException {
    // InputStream is never null here
    // There is nothing to escape when quoting is used which is the default.
    if (!newRecord) {
        append(getDelimiterString(), out);
    }
    final boolean quoteCharacterSet = isQuoteCharacterSet();
    if (quoteCharacterSet) {
        // N.B. Explicit (un)boxing is intentional
        append(getQuoteCharacter().charValue(), out);
    }
    // Stream the input to the output without reading or holding the whole value in memory.
    // AppendableOutputStream cannot ""close"" an Appendable.
    try (OutputStream outputStream = new Base64OutputStream(new AppendableOutputStream<>(out))) {
        IOUtils.copy(inputStream, outputStream);
    }
    if (quoteCharacterSet) {
        // N.B. Explicit (un)boxing is intentional
        append(getQuoteCharacter().charValue(), out);
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(InputStream,Appendable,boolean).inputStream","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.print(InputStream,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(InputStream,Appendable,boolean).out","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.print(InputStream,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(InputStream,Appendable,boolean).newRecord","Parameter_3","Belong to org.apache.commons.csv.CSVFormat.print(InputStream,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Object,Appendable,boolean)","Method","* Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to
     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.
     *
     * @param value     value to output.
     * @param out       where to print the value.
     * @param newRecord if this a new record.
     * @throws IOException If an I/O error occurs.
     * @since 1.4","public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {
    // null values are considered empty
    // Only call CharSequence.toString() if you have to, helps GC-free use cases.
    CharSequence charSequence;
    if (value == null) {
        // https://issues.apache.org/jira/browse/CSV-203
        if (null == nullString) {
            charSequence = Constants.EMPTY;
        } else if (QuoteMode.ALL == quoteMode) {
            charSequence = quotedNullString;
        } else {
            charSequence = nullString;
        }
    } else if (value instanceof CharSequence) {
        charSequence = (CharSequence) value;
    } else if (value instanceof Reader) {
        print((Reader) value, out, newRecord);
        return;
    } else if (value instanceof InputStream) {
        print((InputStream) value, out, newRecord);
        return;
    } else {
        charSequence = value.toString();
    }
    charSequence = getTrim() ? trim(charSequence) : charSequence;
    print(value, charSequence, out, newRecord);
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Object,Appendable,boolean).value","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.print(Object,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Object,Appendable,boolean).out","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.print(Object,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Object,Appendable,boolean).newRecord","Parameter_3","Belong to org.apache.commons.csv.CSVFormat.print(Object,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean)","Method","No Comment","private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {
    final int offset = 0;
    final int len = value.length();
    if (!newRecord) {
        out.append(getDelimiterString());
    }
    if (object == null) {
        out.append(value);
    } else if (isQuoteCharacterSet()) {
        // The original object is needed so can check for Number
        printWithQuotes(object, value, out, newRecord);
    } else if (isEscapeCharacterSet()) {
        printWithEscapes(value, out);
    } else {
        out.append(value, offset, len);
    }
}","void","private , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean).object","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean).value","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean).out","Parameter_3","Belong to org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean).newRecord","Parameter_4","Belong to org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Path,Charset)","Method","* Prints to the specified {@code Path} with given {@code Charset}, returns a {@code CSVPrinter} which the caller MUST close.
     *
     * <p>
     * See also {@link CSVPrinter}.
     * </p>
     *
     * @param out     the output.
     * @param charset A charset.
     * @return a printer to an output.
     * @throws IOException thrown if the optional header cannot be printed.
     * @since 1.5","@SuppressWarnings(""resource"")
public CSVPrinter print(final Path out, final Charset charset) throws IOException {
    return print(Files.newBufferedWriter(out, charset));
}","CSVPrinter","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Path,Charset).out","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.print(Path,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Path,Charset).charset","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.print(Path,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Reader,Appendable,boolean)","Method","No Comment","private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {
    // Reader is never null here
    if (!newRecord) {
        append(getDelimiterString(), out);
    }
    if (isQuoteCharacterSet()) {
        printWithQuotes(reader, out);
    } else if (isEscapeCharacterSet()) {
        printWithEscapes(reader, out);
    } else if (out instanceof Writer) {
        IOUtils.copyLarge(reader, (Writer) out);
    } else {
        IOUtils.copy(reader, out);
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Reader,Appendable,boolean).reader","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.print(Reader,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Reader,Appendable,boolean).out","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.print(Reader,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.print(Reader,Appendable,boolean).newRecord","Parameter_3","Belong to org.apache.commons.csv.CSVFormat.print(Reader,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printer()","Method","* Prints to the {@link System#out}.
     *
     * <p>
     * See also {@link CSVPrinter}.
     * </p>
     *
     * @return a printer to {@link System#out}.
     * @throws IOException thrown if the optional header cannot be printed.
     * @since 1.5","public CSVPrinter printer() throws IOException {
    return new CSVPrinter(System.out, this);
}","CSVPrinter","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.println(Appendable)","Method","* Outputs the trailing delimiter (if set) followed by the record separator (if set).
     *
     * @param appendable where to write
     * @throws IOException If an I/O error occurs.
     * @since 1.4","public synchronized void println(final Appendable appendable) throws IOException {
    if (getTrailingDelimiter()) {
        append(getDelimiterString(), appendable);
    }
    if (recordSeparator != null) {
        append(recordSeparator, appendable);
    }
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.println(Appendable).appendable","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.println(Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printRecord(Appendable,Object[])","Method","* Prints the given {@code values} to {@code out} as a single record of delimiter-separated values followed by the record separator.
     *
     * <p>
     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing
     * the record, so there is no need to call {@link #println(Appendable)}.
     * </p>
     *
     * @param appendable where to write.
     * @param values     values to output.
     * @throws IOException If an I/O error occurs.
     * @since 1.4","public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {
    for (int i = 0; i < values.length; i++) {
        print(values[i], appendable, i == 0);
    }
    println(appendable);
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printRecord(Appendable,Object[]).appendable","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.printRecord(Appendable,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printRecord(Appendable,Object[]).values","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.printRecord(Appendable,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithEscapes(CharSequence,Appendable)","Method","* Note: Must only be called if escaping is enabled, otherwise can throw exceptions.","private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {
    int start = 0;
    int pos = 0;
    final int end = charSeq.length();
    final char[] delimArray = getDelimiterCharArray();
    final int delimLength = delimArray.length;
    final char escape = getEscapeChar();
    while (pos < end) {
        char c = charSeq.charAt(pos);
        final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delimArray, delimLength);
        final boolean isCr = c == Constants.CR;
        final boolean isLf = c == Constants.LF;
        if (isCr || isLf || c == escape || isDelimiterStart) {
            // write out segment up until this char
            if (pos > start) {
                appendable.append(charSeq, start, pos);
            }
            if (isLf) {
                c = 'n';
            } else if (isCr) {
                c = 'r';
            }
            escape(c, appendable);
            if (isDelimiterStart) {
                for (int i = 1; i < delimLength; i++) {
                    pos++;
                    escape(charSeq.charAt(pos), appendable);
                }
            }
            // start on the current char after this one
            start = pos + 1;
        }
        pos++;
    }
    // write last segment
    if (pos > start) {
        appendable.append(charSeq, start, pos);
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithEscapes(CharSequence,Appendable).charSeq","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.printWithEscapes(CharSequence,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithEscapes(CharSequence,Appendable).appendable","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.printWithEscapes(CharSequence,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithEscapes(Reader,Appendable)","Method","* Note: Must only be called if escaping is enabled, otherwise can throw exceptions.","private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {
    int start = 0;
    int pos = 0;
    // Temp reader on input reader.
    @SuppressWarnings(""resource"")
    final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);
    final char[] delimArray = getDelimiterCharArray();
    final int delimLength = delimArray.length;
    final char escape = getEscapeChar();
    final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);
    int c;
    final char[] lookAheadBuffer = new char[delimLength - 1];
    while (EOF != (c = bufferedReader.read())) {
        builder.append((char) c);
        Arrays.fill(lookAheadBuffer, (char) 0);
        bufferedReader.peek(lookAheadBuffer);
        final String test = builder.toString() + new String(lookAheadBuffer);
        final boolean isDelimiterStart = isDelimiter((char) c, test, pos, delimArray, delimLength);
        final boolean isCr = c == Constants.CR;
        final boolean isLf = c == Constants.LF;
        if (isCr || isLf || c == escape || isDelimiterStart) {
            // write out segment up until this char
            if (pos > start) {
                append(builder.substring(start, pos), appendable);
                builder.setLength(0);
                pos = -1;
            }
            if (isLf) {
                c = 'n';
            } else if (isCr) {
                c = 'r';
            }
            escape((char) c, appendable);
            if (isDelimiterStart) {
                for (int i = 1; i < delimLength; i++) {
                    escape((char) bufferedReader.read(), appendable);
                }
            }
            // start on the current char after this one
            start = pos + 1;
        }
        pos++;
    }
    // write last segment
    if (pos > start) {
        appendable.append(builder, start, pos);
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithEscapes(Reader,Appendable).reader","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.printWithEscapes(Reader,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithEscapes(Reader,Appendable).appendable","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.printWithEscapes(Reader,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean)","Method","the original object is needed so can check for Number","private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {
    boolean quote = false;
    int start = 0;
    int pos = 0;
    final int len = charSeq.length();
    final char[] delim = getDelimiterCharArray();
    final int delimLength = delim.length;
    // N.B. Explicit (un)boxing is intentional
    final char quoteChar = getQuoteCharacter().charValue();
    // If escape char not specified, default to the quote char
    // This avoids having to keep checking whether there is an escape character
    // at the cost of checking against quote twice
    final char escapeChar = isEscapeCharacterSet() ? getEscapeChar() : quoteChar;
    QuoteMode quoteModePolicy = getQuoteMode();
    if (quoteModePolicy == null) {
        quoteModePolicy = QuoteMode.MINIMAL;
    }
    switch(quoteModePolicy) {
        case ALL:
        case ALL_NON_NULL:
            quote = true;
            break;
        case NON_NUMERIC:
            quote = !(object instanceof Number);
            break;
        case NONE:
            // Use the existing escaping code
            printWithEscapes(charSeq, out);
            return;
        case MINIMAL:
            if (len <= 0) {
                // Always quote an empty token that is the first
                // on the line, as it may be the only thing on the
                // line. If it were not quoted in that case,
                // an empty line has no tokens.
                if (newRecord) {
                    quote = true;
                }
            } else {
                char c = charSeq.charAt(pos);
                if (c <= Constants.COMMENT) {
                    // Some other chars at the start of a value caused the parser to fail, so for now
                    // encapsulate if we start in anything less than '#'. We are being conservative
                    // by including the default comment char too.
                    quote = true;
                } else {
                    while (pos < len) {
                        c = charSeq.charAt(pos);
                        if (c == Constants.LF || c == Constants.CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {
                            quote = true;
                            break;
                        }
                        pos++;
                    }
                    if (!quote) {
                        pos = len - 1;
                        c = charSeq.charAt(pos);
                        // Some other chars at the end caused the parser to fail, so for now
                        // encapsulate if we end in anything less than ' '
                        if (isTrimChar(c)) {
                            quote = true;
                        }
                    }
                }
            }
            if (!quote) {
                // No encapsulation needed - write out the original value
                out.append(charSeq, start, len);
                return;
            }
            break;
        default:
            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);
    }
    if (!quote) {
        // No encapsulation needed - write out the original value
        out.append(charSeq, start, len);
        return;
    }
    // We hit something that needed encapsulation
    out.append(quoteChar);
    // Pick up where we left off: pos should be positioned on the first character that caused
    // the need for encapsulation.
    while (pos < len) {
        final char c = charSeq.charAt(pos);
        if (c == quoteChar || c == escapeChar) {
            // write out the chunk up until this point
            out.append(charSeq, start, pos);
            // now output the escape
            out.append(escapeChar);
            // and restart with the matched char
            start = pos;
        }
        pos++;
    }
    // Write the last segment
    out.append(charSeq, start, pos);
    out.append(quoteChar);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean).object","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean).charSeq","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean).out","Parameter_3","Belong to org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean).newRecord","Parameter_4","Belong to org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithQuotes(Reader,Appendable)","Method","* Always use quotes unless QuoteMode is NONE, so we do not have to look ahead.
     *
     * @param reader     What to print
     * @param appendable Where to print it
     * @throws IOException If an I/O error occurs","private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {
    if (getQuoteMode() == QuoteMode.NONE) {
        printWithEscapes(reader, appendable);
        return;
    }
    // N.B. Explicit (un)boxing is intentional
    final char quote = getQuoteCharacter().charValue();
    // (1) Append opening quote
    append(quote, appendable);
    // (2) Append Reader contents, doubling quotes
    int c;
    while (EOF != (c = reader.read())) {
        append((char) c, appendable);
        if (c == quote) {
            append(quote, appendable);
        }
    }
    // (3) Append closing quote
    append(quote, appendable);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithQuotes(Reader,Appendable).reader","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.printWithQuotes(Reader,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.printWithQuotes(Reader,Appendable).appendable","Parameter_2","Belong to org.apache.commons.csv.CSVFormat.printWithQuotes(Reader,Appendable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.toString()","Method","No Comment","@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append(""Delimiter=<"").append(delimiter).append('>');
    if (isEscapeCharacterSet()) {
        sb.append(' ');
        sb.append(""Escape=<"").append(escapeCharacter).append('>');
    }
    if (isQuoteCharacterSet()) {
        sb.append(' ');
        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');
    }
    if (quoteMode != null) {
        sb.append(' ');
        sb.append(""QuoteMode=<"").append(quoteMode).append('>');
    }
    if (isCommentMarkerSet()) {
        sb.append(' ');
        sb.append(""CommentStart=<"").append(commentMarker).append('>');
    }
    if (isNullStringSet()) {
        sb.append(' ');
        sb.append(""NullString=<"").append(nullString).append('>');
    }
    if (recordSeparator != null) {
        sb.append(' ');
        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');
    }
    if (getIgnoreEmptyLines()) {
        sb.append("" EmptyLines:ignored"");
    }
    if (getIgnoreSurroundingSpaces()) {
        sb.append("" SurroundingSpaces:ignored"");
    }
    if (getIgnoreHeaderCase()) {
        sb.append("" IgnoreHeaderCase:ignored"");
    }
    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);
    if (headerComments != null) {
        sb.append(' ');
        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));
    }
    if (headers != null) {
        sb.append(' ');
        sb.append(""Header:"").append(Arrays.toString(headers));
    }
    return sb.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.trim(String)","Method","No Comment","String trim(final String value) {
    return getTrim() ? value.trim() : value;
}","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.trim(String).value","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.trim(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.useMaxRows()","Method","No Comment","boolean useMaxRows() {
    return getMaxRows() > 0;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.useRow(long)","Method","No Comment","boolean useRow(final long rowNum) {
    return !useMaxRows() || rowNum <= getMaxRows();
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.useRow(long).rowNum","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.useRow(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.validate()","Method","* Verifies the validity and consistency of the attributes, and throws an {@link IllegalArgumentException} if necessary.
     * <p>
     * Because an instance can be used for both writing and parsing, not all conditions can be tested here. For example, allowMissingColumnNames is only used
     * for parsing, so it cannot be used here.
     * </p>
     *
     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.","private void validate() throws IllegalArgumentException {
    if (containsLineBreak(delimiter)) {
        throw new IllegalArgumentException(""The delimiter cannot be a line break"");
    }
    if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {
        // N.B. Explicit (un)boxing is intentional
        throw new IllegalArgumentException(""The quoteChar character and the delimiter cannot be the same ('"" + quoteCharacter + ""')"");
    }
    if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {
        // N.B. Explicit (un)boxing is intentional
        throw new IllegalArgumentException(""The escape character and the delimiter cannot be the same ('"" + escapeCharacter + ""')"");
    }
    if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {
        // N.B. Explicit (un)boxing is intentional
        throw new IllegalArgumentException(""The comment start character and the delimiter cannot be the same ('"" + commentMarker + ""')"");
    }
    if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {
        throw new IllegalArgumentException(""The comment start character and the quoteChar cannot be the same ('"" + commentMarker + ""')"");
    }
    if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {
        throw new IllegalArgumentException(""The comment start and the escape character cannot be the same ('"" + commentMarker + ""')"");
    }
    if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {
        throw new IllegalArgumentException(""Quote mode set to NONE but no escape character is set"");
    }
    // Validate headers
    if (headers != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {
        final Set<String> dupCheckSet = new HashSet<>(headers.length);
        final boolean emptyDuplicatesAllowed = duplicateHeaderMode == DuplicateHeaderMode.ALLOW_EMPTY;
        for (final String header : headers) {
            final boolean blank = isBlank(header);
            // Sanitize all empty headers to the empty string """" when checking duplicates
            final boolean containsHeader = !dupCheckSet.add(blank ? """" : header);
            if (containsHeader && !(blank && emptyDuplicatesAllowed)) {
                throw new IllegalArgumentException(String.format(""The header contains a duplicate name: \""%s\"" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode()."", header, Arrays.toString(headers)));
            }
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withAllowDuplicateHeaderNames()","Method","* Builds a new {@code CSVFormat} that allows duplicate header names.
     *
     * @return a new {@code CSVFormat} that allows duplicate header names
     * @since 1.7
     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}","@Deprecated
public CSVFormat withAllowDuplicateHeaderNames() {
    return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withAllowDuplicateHeaderNames(boolean)","Method","* Builds a new {@code CSVFormat} with duplicate header names behavior set to the given value.
     *
     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.
     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.
     * @since 1.7
     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}","@Deprecated
public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {
    final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;
    return builder().setDuplicateHeaderMode(mode).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withAllowDuplicateHeaderNames(boolean).allowDuplicateHeaderNames","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withAllowDuplicateHeaderNames(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withAllowMissingColumnNames()","Method","* Builds a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.
     *
     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.
     * @see Builder#setAllowMissingColumnNames(boolean)
     * @since 1.1
     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}","@Deprecated
public CSVFormat withAllowMissingColumnNames() {
    return builder().setAllowMissingColumnNames(true).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withAllowMissingColumnNames(boolean)","Method","* Builds a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.
     *
     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause
     *                                an {@link IllegalArgumentException} to be thrown.
     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.
     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}","@Deprecated
public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {
    return builder().setAllowMissingColumnNames(allowMissingColumnNames).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withAllowMissingColumnNames(boolean).allowMissingColumnNames","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withAllowMissingColumnNames(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withAutoFlush(boolean)","Method","* Builds a new {@code CSVFormat} with whether to flush on close.
     *
     * @param autoFlush whether to flush on close.
     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.
     * @since 1.6
     * @deprecated Use {@link Builder#setAutoFlush(boolean)}","@Deprecated
public CSVFormat withAutoFlush(final boolean autoFlush) {
    return builder().setAutoFlush(autoFlush).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withAutoFlush(boolean).autoFlush","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withAutoFlush(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withCommentMarker(char)","Method","* Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.
     *
     * Note that the comment start character is only recognized at the start of a line.
     *
     * @param commentMarker the comment start marker
     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
     * @throws IllegalArgumentException thrown if the specified character is a line break
     * @deprecated Use {@link Builder#setCommentMarker(char)}","@Deprecated
public CSVFormat withCommentMarker(final char commentMarker) {
    return builder().setCommentMarker(commentMarker).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withCommentMarker(char).commentMarker","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withCommentMarker(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withCommentMarker(Character)","Method","* Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.
     *
     * Note that the comment start character is only recognized at the start of a line.
     *
     * @param commentMarker the comment start marker, use {@code null} to disable
     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker
     * @throws IllegalArgumentException thrown if the specified character is a line break
     * @deprecated Use {@link Builder#setCommentMarker(Character)}","@Deprecated
public CSVFormat withCommentMarker(final Character commentMarker) {
    return builder().setCommentMarker(commentMarker).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withCommentMarker(Character).commentMarker","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withCommentMarker(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withDelimiter(char)","Method","* Builds a new {@code CSVFormat} with the delimiter of the format set to the specified character.
     *
     * @param delimiter the delimiter character
     * @return A new CSVFormat that is equal to this with the specified character as a delimiter
     * @throws IllegalArgumentException thrown if the specified character is a line break
     * @deprecated Use {@link Builder#setDelimiter(char)}","@Deprecated
public CSVFormat withDelimiter(final char delimiter) {
    return builder().setDelimiter(delimiter).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withDelimiter(char).delimiter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withDelimiter(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withEscape(char)","Method","* Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.
     *
     * @param escape the escape character
     * @return A new CSVFormat that is equal to this but with the specified character as the escape character
     * @throws IllegalArgumentException thrown if the specified character is a line break
     * @deprecated Use {@link Builder#setEscape(char)}","@Deprecated
public CSVFormat withEscape(final char escape) {
    return builder().setEscape(escape).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withEscape(char).escape","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withEscape(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withEscape(Character)","Method","* Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.
     *
     * @param escape the escape character, use {@code null} to disable
     * @return A new CSVFormat that is equal to this but with the specified character as the escape character
     * @throws IllegalArgumentException thrown if the specified character is a line break
     * @deprecated Use {@link Builder#setEscape(Character)}","@Deprecated
public CSVFormat withEscape(final Character escape) {
    return builder().setEscape(escape).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withEscape(Character).escape","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withEscape(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withFirstRecordAsHeader()","Method","@formatter:on","@Deprecated
public CSVFormat withFirstRecordAsHeader() {
    // @formatter:off
    return builder().setHeader().setSkipHeaderRecord(true).get();
    // @formatter:on
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeader(Class)","Method","* Builds a new {@code CSVFormat} with the header of the format defined by the enum class.
     *
     * <p>
     * Example:
     * </p>
     *
     * <pre>
     * public enum MyHeader {
     *     Name, Email, Phone
     * }
     * ...
     * CSVFormat format = aFormat.builder().setHeader(MyHeader.class).get();
     * </pre>
     * <p>
     * The header is also used by the {@link CSVPrinter}.
     * </p>
     *
     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.
     * @return A new CSVFormat that is equal to this but with the specified header
     * @see Builder#setHeader(String...)
     * @see Builder#setSkipHeaderRecord(boolean)
     * @since 1.3
     * @deprecated Use {@link Builder#setHeader(Class)}","@Deprecated
public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {
    return builder().setHeader(headerEnum).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeader(Class).headerEnum","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withHeader(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeader(ResultSet)","Method","* Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the
     * input file with:
     *
     * <pre>
     * CSVFormat format = aFormat.builder().setHeader().get();
     * </pre>
     *
     * or specified manually with:
     *
     * <pre>
     * CSVFormat format = aFormat.builder().setHeader(resultSet).get();
     * </pre>
     * <p>
     * The header is also used by the {@link CSVPrinter}.
     * </p>
     *
     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
     * @return A new CSVFormat that is equal to this but with the specified header
     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.
     * @since 1.1
     * @deprecated Use {@link Builder#setHeader(ResultSet)}","@Deprecated
public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {
    return builder().setHeader(resultSet).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeader(ResultSet).resultSet","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withHeader(ResultSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeader(ResultSetMetaData)","Method","* Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the
     * input file with:
     *
     * <pre>
     * CSVFormat format = aFormat.builder().setHeader().get()
     * </pre>
     *
     * or specified manually with:
     *
     * <pre>
     * CSVFormat format = aFormat.builder().setHeader(resultSetMetaData).get()
     * </pre>
     * <p>
     * The header is also used by the {@link CSVPrinter}.
     * </p>
     *
     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.
     * @return A new CSVFormat that is equal to this but with the specified header
     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.
     * @since 1.1
     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}","@Deprecated
public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {
    return builder().setHeader(resultSetMetaData).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeader(ResultSetMetaData).resultSetMetaData","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withHeader(ResultSetMetaData)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeader(String[])","Method","* Builds a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file
     * with:
     *
     * <pre>
     * CSVFormat format = aFormat.builder().setHeader().get();
     * </pre>
     *
     * or specified manually with:
     *
     * <pre>{@code
     * CSVFormat format = aFormat.builder().setHeader(""name"", ""email"", ""phone"").get();
     * }</pre>
     * <p>
     * The header is also used by the {@link CSVPrinter}.
     * </p>
     *
     * @param header the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
     * @return A new CSVFormat that is equal to this but with the specified header
     * @see Builder#setSkipHeaderRecord(boolean)
     * @deprecated Use {@link Builder#setHeader(String...)}","@Deprecated
public CSVFormat withHeader(final String... header) {
    return builder().setHeader(header).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeader(String[]).header","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withHeader(String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeaderComments(Object[])","Method","* Builds a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.
     * This setting is ignored by the parser.
     *
     * <pre>{@code
     * CSVFormat format = aFormat.builder().setHeaderComments(""Generated by Apache Commons CSV."", Instant.now()).get();
     * }</pre>
     *
     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.
     * @return A new CSVFormat that is equal to this but with the specified header
     * @see Builder#setSkipHeaderRecord(boolean)
     * @since 1.1
     * @deprecated Use {@link Builder#setHeaderComments(Object...)}","@Deprecated
public CSVFormat withHeaderComments(final Object... headerComments) {
    return builder().setHeaderComments(headerComments).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withHeaderComments(Object[]).headerComments","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withHeaderComments(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withIgnoreEmptyLines()","Method","* Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.
     *
     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.
     * @see Builder#setIgnoreEmptyLines(boolean)
     * @since 1.1
     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}","@Deprecated
public CSVFormat withIgnoreEmptyLines() {
    return builder().setIgnoreEmptyLines(true).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withIgnoreEmptyLines(boolean)","Method","* Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.
     *
     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty
     *                         lines to empty records.
     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.
     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}","@Deprecated
public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {
    return builder().setIgnoreEmptyLines(ignoreEmptyLines).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withIgnoreEmptyLines(boolean).ignoreEmptyLines","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withIgnoreEmptyLines(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withIgnoreHeaderCase()","Method","* Builds a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.
     *
     * @return A new CSVFormat that will ignore the new case header name behavior.
     * @see Builder#setIgnoreHeaderCase(boolean)
     * @since 1.3
     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}","@Deprecated
public CSVFormat withIgnoreHeaderCase() {
    return builder().setIgnoreHeaderCase(true).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withIgnoreHeaderCase(boolean)","Method","* Builds a new {@code CSVFormat} with whether header names should be accessed ignoring case.
     *
     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.
     * @return A new CSVFormat that will ignore case header name if specified as {@code true}
     * @since 1.3
     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}","@Deprecated
public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {
    return builder().setIgnoreHeaderCase(ignoreHeaderCase).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withIgnoreHeaderCase(boolean).ignoreHeaderCase","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withIgnoreHeaderCase(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withIgnoreSurroundingSpaces()","Method","* Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.
     *
     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.
     * @see Builder#setIgnoreSurroundingSpaces(boolean)
     * @since 1.1
     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}","@Deprecated
public CSVFormat withIgnoreSurroundingSpaces() {
    return builder().setIgnoreSurroundingSpaces(true).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withIgnoreSurroundingSpaces(boolean)","Method","* Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.
     *
     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.
     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.
     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}","@Deprecated
public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {
    return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withIgnoreSurroundingSpaces(boolean).ignoreSurroundingSpaces","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withIgnoreSurroundingSpaces(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withNullString(String)","Method","* Builds a new {@code CSVFormat} with conversions to and from null for strings on input and output.
     * <ul>
     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>
     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
     * </ul>
     *
     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}
     * @return A new CSVFormat that is equal to this but with the specified null conversion string.
     * @deprecated Use {@link Builder#setNullString(String)}","@Deprecated
public CSVFormat withNullString(final String nullString) {
    return builder().setNullString(nullString).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withNullString(String).nullString","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withNullString(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withQuote(char)","Method","* Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.
     *
     * @param quoteChar the quote character
     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
     * @throws IllegalArgumentException thrown if the specified character is a line break
     * @deprecated Use {@link Builder#setQuote(char)}","@Deprecated
public CSVFormat withQuote(final char quoteChar) {
    return builder().setQuote(quoteChar).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withQuote(char).quoteChar","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withQuote(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withQuote(Character)","Method","* Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.
     *
     * @param quoteChar the quote character, use {@code null} to disable.
     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar
     * @throws IllegalArgumentException thrown if the specified character is a line break
     * @deprecated Use {@link Builder#setQuote(Character)}","@Deprecated
public CSVFormat withQuote(final Character quoteChar) {
    return builder().setQuote(quoteChar).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withQuote(Character).quoteChar","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withQuote(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withQuoteMode(QuoteMode)","Method","* Builds a new {@code CSVFormat} with the output quote policy of the format set to the specified value.
     *
     * @param quoteMode the quote policy to use for output.
     * @return A new CSVFormat that is equal to this but with the specified quote policy
     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}","@Deprecated
public CSVFormat withQuoteMode(final QuoteMode quoteMode) {
    return builder().setQuoteMode(quoteMode).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withQuoteMode(QuoteMode).quoteMode","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withQuoteMode(QuoteMode)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withRecordSeparator(char)","Method","* Builds a new {@code CSVFormat} with the record separator of the format set to the specified character.
     *
     * <p>
     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r' and
     * ""\r\n""
     * </p>
     *
     * @param recordSeparator the record separator to use for output.
     * @return A new CSVFormat that is equal to this but with the specified output record separator
     * @deprecated Use {@link Builder#setRecordSeparator(char)}","@Deprecated
public CSVFormat withRecordSeparator(final char recordSeparator) {
    return builder().setRecordSeparator(recordSeparator).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withRecordSeparator(char).recordSeparator","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withRecordSeparator(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withRecordSeparator(String)","Method","* Builds a new {@code CSVFormat} with the record separator of the format set to the specified String.
     *
     * <p>
     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r' and
     * ""\r\n""
     * </p>
     *
     * @param recordSeparator the record separator to use for output.
     * @return A new CSVFormat that is equal to this but with the specified output record separator
     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF
     * @deprecated Use {@link Builder#setRecordSeparator(String)}","@Deprecated
public CSVFormat withRecordSeparator(final String recordSeparator) {
    return builder().setRecordSeparator(recordSeparator).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withRecordSeparator(String).recordSeparator","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withRecordSeparator(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withSkipHeaderRecord()","Method","* Builds a new {@code CSVFormat} with skipping the header record set to {@code true}.
     *
     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.
     * @see Builder#setSkipHeaderRecord(boolean)
     * @see Builder#setHeader(String...)
     * @since 1.1
     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}","@Deprecated
public CSVFormat withSkipHeaderRecord() {
    return builder().setSkipHeaderRecord(true).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withSkipHeaderRecord(boolean)","Method","* Builds a new {@code CSVFormat} with whether to skip the header record.
     *
     * @param skipHeaderRecord whether to skip the header record.
     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.
     * @see Builder#setHeader(String...)
     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}","@Deprecated
public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {
    return builder().setSkipHeaderRecord(skipHeaderRecord).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withSkipHeaderRecord(boolean).skipHeaderRecord","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withSkipHeaderRecord(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withSystemRecordSeparator()","Method","* Builds a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows
     * and LF on Linux.
     *
     * <p>
     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r' and
     * ""\r\n""
     * </p>
     *
     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.
     * @since 1.6
     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}","@Deprecated
public CSVFormat withSystemRecordSeparator() {
    return builder().setRecordSeparator(System.lineSeparator()).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withTrailingDelimiter()","Method","* Builds a new {@code CSVFormat} to add a trailing delimiter.
     *
     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.
     * @since 1.3
     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}","@Deprecated
public CSVFormat withTrailingDelimiter() {
    return builder().setTrailingDelimiter(true).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withTrailingDelimiter(boolean)","Method","* Builds a new {@code CSVFormat} with whether to add a trailing delimiter.
     *
     * @param trailingDelimiter whether to add a trailing delimiter.
     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.
     * @since 1.3
     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}","@Deprecated
public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {
    return builder().setTrailingDelimiter(trailingDelimiter).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withTrailingDelimiter(boolean).trailingDelimiter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withTrailingDelimiter(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withTrim()","Method","* Builds a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.
     *
     * @return A new CSVFormat that is equal to this but with the trim setting on.
     * @since 1.3
     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}","@Deprecated
public CSVFormat withTrim() {
    return builder().setTrim(true).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withTrim(boolean)","Method","* Builds a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.
     *
     * @param trim whether to trim leading and trailing blanks.
     * @return A new CSVFormat that is equal to this but with the specified trim setting.
     * @since 1.3
     * @deprecated Use {@link Builder#setTrim(boolean)}","@Deprecated
public CSVFormat withTrim(final boolean trim) {
    return builder().setTrim(trim).get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.withTrim(boolean).trim","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.withTrim(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.<init>(Builder)","Constructor","No Comment","private CSVFormat(final Builder builder) {
    this.allowMissingColumnNames = builder.allowMissingColumnNames;
    this.autoFlush = builder.autoFlush;
    this.commentMarker = builder.commentMarker;
    this.delimiter = builder.delimiter;
    this.duplicateHeaderMode = builder.duplicateHeaderMode;
    this.escapeCharacter = builder.escapeCharacter;
    this.headerComments = builder.headerComments;
    this.headers = builder.headers;
    this.ignoreEmptyLines = builder.ignoreEmptyLines;
    this.ignoreHeaderCase = builder.ignoreHeaderCase;
    this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;
    this.lenientEof = builder.lenientEof;
    this.maxRows = builder.maxRows;
    this.nullString = builder.nullString;
    this.quoteCharacter = builder.quoteCharacter;
    this.quoteMode = builder.quoteMode;
    this.quotedNullString = builder.quotedNullString;
    this.recordSeparator = builder.recordSeparator;
    this.skipHeaderRecord = builder.skipHeaderRecord;
    this.trailingData = builder.trailingData;
    this.trailingDelimiter = builder.trailingDelimiter;
    this.trim = builder.trim;
    validate();
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.<init>(Builder).builder","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.<init>(Builder)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder","Class","* Builds CSVFormat instances.
     *
     * @since 1.9.0","Class do not obtain Source Code","No return type","public , static ","","java.util.function.Supplier"
"org.apache.commons.csv.CSVFormat$Builder.allowMissingColumnNames","Field","No Comment","private boolean allowMissingColumnNames;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.autoFlush","Field","No Comment","private boolean autoFlush;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.commentMarker","Field","No Comment","private Character commentMarker;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.delimiter","Field","No Comment","private String delimiter;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.duplicateHeaderMode","Field","No Comment","private DuplicateHeaderMode duplicateHeaderMode;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.escapeCharacter","Field","No Comment","private Character escapeCharacter;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.headerComments","Field","No Comment","private String[] headerComments;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.headers","Field","No Comment","private String[] headers;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.ignoreEmptyLines","Field","No Comment","private boolean ignoreEmptyLines;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.ignoreHeaderCase","Field","No Comment","private boolean ignoreHeaderCase;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.ignoreSurroundingSpaces","Field","No Comment","private boolean ignoreSurroundingSpaces;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.nullString","Field","No Comment","private String nullString;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.quoteCharacter","Field","No Comment","private Character quoteCharacter;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.quotedNullString","Field","No Comment","private String quotedNullString;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.quoteMode","Field","No Comment","private QuoteMode quoteMode;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.recordSeparator","Field","No Comment","private String recordSeparator;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.skipHeaderRecord","Field","No Comment","private boolean skipHeaderRecord;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.lenientEof","Field","No Comment","private boolean lenientEof;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.trailingData","Field","No Comment","private boolean trailingData;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.trailingDelimiter","Field","No Comment","private boolean trailingDelimiter;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.trim","Field","No Comment","private boolean trim;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.maxRows","Field","The maximum number of rows to process, excluding the header row.","private long maxRows;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.create()","Method","* Creates a new default builder, as for {@link #RFC4180} but allowing empty lines.
         *
         * <p>
         * The {@link Builder} settings are:
         * </p>
         * <ul>
         * <li>{@link Builder#setDelimiter(char) setDelimiter}{@code (',')}</li>
         * <li>{@link Builder#setQuote(char) setQuote}{@code ('""')}</li>
         * <li>{@link Builder#setRecordSeparator(String) setRecordSeparator}{@code (""\r\n"")}</li>
         * <li>{@link Builder#setIgnoreEmptyLines(boolean) setIgnoreEmptyLines}{@code (true)}</li>
         * <li>{@link Builder#setDuplicateHeaderMode(DuplicateHeaderMode) setDuplicateHeaderMode}{@code (DuplicateHeaderMode.ALLOW_ALL)}</li>
         * <li>All other values take their Java defaults, {@code false} for booleans, {@code null} for object references.</li>
         * </ul>
         *
         * @see Predefined#Default
         * @see DuplicateHeaderMode#ALLOW_ALL
         *
         * @return a copy of the builder","public static Builder create() {
    // @formatter:off
    return new Builder().setDelimiter(Constants.COMMA).setQuote(Constants.DOUBLE_QUOTE_CHAR).setRecordSeparator(Constants.CRLF).setIgnoreEmptyLines(true).setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL);
    // @formatter:on
}","Builder","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.create(CSVFormat)","Method","* Creates a new builder from the given format.
         *
         * @param csvFormat the source format.
         * @return a new builder.","public static Builder create(final CSVFormat csvFormat) {
    return new Builder(csvFormat);
}","Builder","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.create(CSVFormat).csvFormat","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.create(CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.build()","Method","* Builds a new CSVFormat instance.
         *
         * @return a new CSVFormat instance.
         * @deprecated Use {@link #get()}.","@Deprecated
public CSVFormat build() {
    return get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.get()","Method","* Builds a new CSVFormat instance.
         *
         * @return a new CSVFormat instance.
         * @since 1.13.0","@Override
public CSVFormat get() {
    return new CSVFormat(this);
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setAllowDuplicateHeaderNames(boolean)","Method","* Sets the duplicate header names behavior, true to allow, false to disallow.
         *
         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.
         * @return This instance.
         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.","@Deprecated
public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {
    setDuplicateHeaderMode(allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY);
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setAllowDuplicateHeaderNames(boolean).allowDuplicateHeaderNames","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setAllowDuplicateHeaderNames(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setAllowMissingColumnNames(boolean)","Method","* Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an
         * {@link IllegalArgumentException} to be thrown.
         *
         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to
         *                                cause an {@link IllegalArgumentException} to be thrown.
         * @return This instance.","public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {
    this.allowMissingColumnNames = allowMissingColumnNames;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setAllowMissingColumnNames(boolean).allowMissingColumnNames","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setAllowMissingColumnNames(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setAutoFlush(boolean)","Method","* Sets whether to flush on close.
         *
         * @param autoFlush whether to flush on close.
         * @return This instance.","public Builder setAutoFlush(final boolean autoFlush) {
    this.autoFlush = autoFlush;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setAutoFlush(boolean).autoFlush","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setAutoFlush(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setCommentMarker(char)","Method","* Sets the comment marker character, use {@code null} to disable comments.
         * <p>
         * The comment start character is only recognized at the start of a line.
         * </p>
         * <p>
         * Comments are printed first, before headers.
         * </p>
         * <p>
         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.
         * </p>
         * <p>
         * If the comment marker is not set, then the header comments are ignored.
         * </p>
         * <p>
         * For example:
         * </p>
         *
         * <pre>
         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));
         * </pre>
         * <p>
         * writes:
         * </p>
         *
         * <pre>
         * # Generated by Apache Commons CSV.
         * # 1970-01-01T00:00:00Z
         * </pre>
         *
         * @param commentMarker the comment start marker, use {@code null} to disable.
         * @return This instance.
         * @throws IllegalArgumentException thrown if the specified character is a line break","public Builder setCommentMarker(final char commentMarker) {
    setCommentMarker(Character.valueOf(commentMarker));
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setCommentMarker(char).commentMarker","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setCommentMarker(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setCommentMarker(Character)","Method","* Sets the comment marker character, use {@code null} to disable comments.
         * <p>
         * The comment start character is only recognized at the start of a line.
         * </p>
         * <p>
         * Comments are printed first, before headers.
         * </p>
         * <p>
         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.
         * </p>
         * <p>
         * If the comment marker is not set, then the header comments are ignored.
         * </p>
         * <p>
         * For example:
         * </p>
         *
         * <pre>
         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));
         * </pre>
         * <p>
         * writes:
         * </p>
         *
         * <pre>
         * # Generated by Apache Commons CSV.
         * # 1970-01-01T00:00:00Z
         * </pre>
         *
         * @param commentMarker the comment start marker, use {@code null} to disable.
         * @return This instance.
         * @throws IllegalArgumentException thrown if the specified character is a line break","public Builder setCommentMarker(final Character commentMarker) {
    if (isLineBreak(commentMarker)) {
        throw new IllegalArgumentException(""The comment start marker character cannot be a line break"");
    }
    this.commentMarker = commentMarker;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setCommentMarker(Character).commentMarker","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setCommentMarker(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setDelimiter(char)","Method","* Sets the delimiter character.
         *
         * @param delimiter the delimiter character.
         * @return This instance.","public Builder setDelimiter(final char delimiter) {
    return setDelimiter(String.valueOf(delimiter));
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setDelimiter(char).delimiter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setDelimiter(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setDelimiter(String)","Method","* Sets the delimiter character.
         *
         * @param delimiter the delimiter character.
         * @return This instance.","public Builder setDelimiter(final String delimiter) {
    if (containsLineBreak(delimiter)) {
        throw new IllegalArgumentException(""The delimiter cannot be a line break"");
    }
    if (delimiter.isEmpty()) {
        throw new IllegalArgumentException(""The delimiter cannot be empty"");
    }
    this.delimiter = delimiter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setDelimiter(String).delimiter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setDelimiter(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setDuplicateHeaderMode(DuplicateHeaderMode)","Method","* Sets the duplicate header names behavior.
         *
         * @param duplicateHeaderMode the duplicate header names behavior
         * @return This instance.
         * @since 1.10.0","public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {
    this.duplicateHeaderMode = Objects.requireNonNull(duplicateHeaderMode, ""duplicateHeaderMode"");
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setDuplicateHeaderMode(DuplicateHeaderMode).duplicateHeaderMode","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setDuplicateHeaderMode(DuplicateHeaderMode)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setEscape(char)","Method","* Sets the escape character.
         *
         * @param escapeCharacter the escape character.
         * @return This instance.
         * @throws IllegalArgumentException thrown if the specified character is a line break","public Builder setEscape(final char escapeCharacter) {
    setEscape(Character.valueOf(escapeCharacter));
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setEscape(char).escapeCharacter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setEscape(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setEscape(Character)","Method","* Sets the escape character.
         *
         * @param escapeCharacter the escape character.
         * @return This instance.
         * @throws IllegalArgumentException thrown if the specified character is a line break","public Builder setEscape(final Character escapeCharacter) {
    if (isLineBreak(escapeCharacter)) {
        throw new IllegalArgumentException(""The escape character cannot be a line break"");
    }
    this.escapeCharacter = escapeCharacter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setEscape(Character).escapeCharacter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setEscape(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeader(Class)","Method","* Sets the header defined by the given {@link Enum} class.
         *
         * <p>
         * Example:
         * </p>
         *
         * <pre>
         * public enum HeaderEnum {
         *     Name, Email, Phone
         * }
         *
         * Builder builder = builder.setHeader(HeaderEnum.class);
         * </pre>
         * <p>
         * The header is also used by the {@link CSVPrinter}.
         * </p>
         *
         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
         * @return This instance.","public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {
    String[] header = null;
    if (headerEnum != null) {
        final Enum<?>[] enumValues = headerEnum.getEnumConstants();
        header = new String[enumValues.length];
        Arrays.setAll(header, i -> enumValues[i].name());
    }
    return setHeader(header);
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeader(Class).headerEnum","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setHeader(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeader(ResultSet)","Method","* Sets the header from the result set metadata. The header can be parsed automatically from the input file with:
         *
         * <pre>
         * builder.setHeader();
         * </pre>
         *
         * or specified manually with:
         *
         * <pre>
         * builder.setHeader(resultSet);
         * </pre>
         * <p>
         * The header is also used by the {@link CSVPrinter}.
         * </p>
         *
         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
         * @return This instance.
         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.","public Builder setHeader(final ResultSet resultSet) throws SQLException {
    return setHeader(resultSet != null ? resultSet.getMetaData() : null);
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeader(ResultSet).resultSet","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setHeader(ResultSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeader(ResultSetMetaData)","Method","* Sets the header from the result set metadata. The header can be parsed automatically from the input file with:
         *
         * <pre>
         * builder.setHeader();
         * </pre>
         *
         * or specified manually with:
         *
         * <pre>
         * builder.setHeader(resultSetMetaData);
         * </pre>
         * <p>
         * The header is also used by the {@link CSVPrinter}.
         * </p>
         *
         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
         * @return This instance.
         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.","public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {
    String[] labels = null;
    if (resultSetMetaData != null) {
        final int columnCount = resultSetMetaData.getColumnCount();
        labels = new String[columnCount];
        for (int i = 0; i < columnCount; i++) {
            labels[i] = resultSetMetaData.getColumnLabel(i + 1);
        }
    }
    return setHeader(labels);
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeader(ResultSetMetaData).resultSetMetaData","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setHeader(ResultSetMetaData)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeader(String[])","Method","* Sets the header to the given values. The header can be parsed automatically from the input file with:
         *
         * <pre>
         * builder.setHeader();
         * </pre>
         *
         * or specified manually with:
         *
         * <pre>{@code
         * builder.setHeader(""name"", ""email"", ""phone"");
         * }</pre>
         * <p>
         * The header is also used by the {@link CSVPrinter}.
         * </p>
         * <p>
         * This method keeps a copy of the input array.
         * </p>
         * @param header the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
         * @return This instance.","public Builder setHeader(final String... header) {
    this.headers = CSVFormat.clone(header);
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeader(String[]).header","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setHeader(String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeaderComments(Object[])","Method","* Sets the header comments to write before the CSV data.
         * <p>
         * This setting is ignored by the parser.
         * </p>
         * <p>
         * Comments are printed first, before headers.
         * </p>
         * <p>
         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.
         * </p>
         * <p>
         * If the comment marker is not set, then the header comments are ignored.
         * </p>
         * <p>
         * For example:
         * </p>
         *
         * <pre>
         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));
         * </pre>
         * <p>
         * writes:
         * </p>
         *
         * <pre>
         * # Generated by Apache Commons CSV.
         * # 1970-01-01T00:00:00Z
         * </pre>
         * <p>
         * This method keeps a copy of the input array.
         * </p>
         *
         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.
         * @return This instance.","public Builder setHeaderComments(final Object... headerComments) {
    this.headerComments = CSVFormat.clone(toStringArray(headerComments));
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeaderComments(Object[]).headerComments","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setHeaderComments(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeaderComments(String[])","Method","* Sets the header comments to write before the CSV data.
         * <p>
         * This setting is ignored by the parser.
         * </p>
         * <p>
         * Comments are printed first, before headers.
         * </p>
         * <p>
         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.
         * </p>
         * <p>
         * If the comment marker is not set, then the header comments are ignored.
         * </p>
         * <p>
         * For example:
         * </p>
         *
         * <pre>
         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0).toString());
         * </pre>
         * <p>
         * writes:
         * </p>
         *
         * <pre>
         * # Generated by Apache Commons CSV.
         * # 1970-01-01T00:00:00Z
         * </pre>
         * <p>
         * This method keeps a copy of the input array.
         * </p>
         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.
         * @return This instance.","public Builder setHeaderComments(final String... headerComments) {
    this.headerComments = CSVFormat.clone(headerComments);
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setHeaderComments(String[]).headerComments","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setHeaderComments(String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setIgnoreEmptyLines(boolean)","Method","* Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty
         * records.
         *
         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate
         *                         empty lines to empty records.
         * @return This instance.","public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {
    this.ignoreEmptyLines = ignoreEmptyLines;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setIgnoreEmptyLines(boolean).ignoreEmptyLines","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setIgnoreEmptyLines(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setIgnoreHeaderCase(boolean)","Method","* Sets the parser case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.
         *
         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.
         * @return This instance.","public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {
    this.ignoreHeaderCase = ignoreHeaderCase;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setIgnoreHeaderCase(boolean).ignoreHeaderCase","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setIgnoreHeaderCase(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setIgnoreSurroundingSpaces(boolean)","Method","* Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.
         *
         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.
         * @return This instance.","public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {
    this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setIgnoreSurroundingSpaces(boolean).ignoreSurroundingSpaces","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setIgnoreSurroundingSpaces(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setLenientEof(boolean)","Method","* Sets whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.
         *
         * @param lenientEof whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.
         * @return This instance.
         * @since 1.11.0","public Builder setLenientEof(final boolean lenientEof) {
    this.lenientEof = lenientEof;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setLenientEof(boolean).lenientEof","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setLenientEof(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setMaxRows(long)","Method","* Sets the maximum number of rows to process, excluding the header row.
         * <p>
         * Values less than or equal to 0 mean no limit.
         * </p>
         *
         * @param maxRows the maximum number of rows to process, excluding the header row.
         * @return This instance.
         * @since 1.14.0","public Builder setMaxRows(final long maxRows) {
    this.maxRows = maxRows;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setMaxRows(long).maxRows","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setMaxRows(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setNullString(String)","Method","* Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.
         *
         * <ul>
         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>
         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
         * </ul>
         *
         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.
         * @return This instance.","public Builder setNullString(final String nullString) {
    this.nullString = nullString;
    this.quotedNullString = quoteCharacter + nullString + quoteCharacter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setNullString(String).nullString","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setNullString(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setQuote(char)","Method","* Sets the quote character.
         *
         * @param quoteCharacter the quote character.
         * @return This instance.","public Builder setQuote(final char quoteCharacter) {
    setQuote(Character.valueOf(quoteCharacter));
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setQuote(char).quoteCharacter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setQuote(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setQuote(Character)","Method","* Sets the quote character, use {@code null} to disable.
         *
         * @param quoteCharacter the quote character, use {@code null} to disable.
         * @return This instance.","public Builder setQuote(final Character quoteCharacter) {
    if (isLineBreak(quoteCharacter)) {
        throw new IllegalArgumentException(""The quoteCharacter cannot be a line break"");
    }
    this.quoteCharacter = quoteCharacter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setQuote(Character).quoteCharacter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setQuote(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setQuoteMode(QuoteMode)","Method","* Sets the quote policy to use for output.
         *
         * @param quoteMode the quote policy to use for output.
         * @return This instance.","public Builder setQuoteMode(final QuoteMode quoteMode) {
    this.quoteMode = quoteMode;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setQuoteMode(QuoteMode).quoteMode","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setQuoteMode(QuoteMode)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setRecordSeparator(char)","Method","* Sets the record separator to use for output.
         *
         * <p>
         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r'
         * and ""\r\n""
         * </p>
         *
         * @param recordSeparator the record separator to use for output.
         * @return This instance.","public Builder setRecordSeparator(final char recordSeparator) {
    this.recordSeparator = String.valueOf(recordSeparator);
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setRecordSeparator(char).recordSeparator","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setRecordSeparator(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setRecordSeparator(String)","Method","* Sets the record separator to use for output.
         *
         * <p>
         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r'
         * and ""\r\n""
         * </p>
         *
         * @param recordSeparator the record separator to use for output.
         * @return This instance.","public Builder setRecordSeparator(final String recordSeparator) {
    this.recordSeparator = recordSeparator;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setRecordSeparator(String).recordSeparator","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setRecordSeparator(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setSkipHeaderRecord(boolean)","Method","* Sets whether to skip the header record.
         *
         * @param skipHeaderRecord whether to skip the header record.
         * @return This instance.","public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {
    this.skipHeaderRecord = skipHeaderRecord;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setSkipHeaderRecord(boolean).skipHeaderRecord","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setSkipHeaderRecord(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setTrailingData(boolean)","Method","* Sets whether reading trailing data is allowed in records, helps Excel compatibility.
         *
         * @param trailingData whether reading trailing data is allowed in records, helps Excel compatibility.
         * @return This instance.
         * @since 1.11.0","public Builder setTrailingData(final boolean trailingData) {
    this.trailingData = trailingData;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setTrailingData(boolean).trailingData","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setTrailingData(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setTrailingDelimiter(boolean)","Method","* Sets whether to add a trailing delimiter.
         *
         * @param trailingDelimiter whether to add a trailing delimiter.
         * @return This instance.","public Builder setTrailingDelimiter(final boolean trailingDelimiter) {
    this.trailingDelimiter = trailingDelimiter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setTrailingDelimiter(boolean).trailingDelimiter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setTrailingDelimiter(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setTrim(boolean)","Method","* Sets whether to trim leading and trailing blanks.
         *
         * @param trim whether to trim leading and trailing blanks.
         * @return This instance.","public Builder setTrim(final boolean trim) {
    this.trim = trim;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.setTrim(boolean).trim","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.setTrim(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.<init>()","Constructor","No Comment","private Builder() {
    // empty
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.<init>(CSVFormat)","Constructor","No Comment","private Builder(final CSVFormat csvFormat) {
    this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;
    this.autoFlush = csvFormat.autoFlush;
    this.commentMarker = csvFormat.commentMarker;
    this.delimiter = csvFormat.delimiter;
    this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;
    this.escapeCharacter = csvFormat.escapeCharacter;
    this.headerComments = csvFormat.headerComments;
    this.headers = csvFormat.headers;
    this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;
    this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;
    this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;
    this.lenientEof = csvFormat.lenientEof;
    this.maxRows = csvFormat.maxRows;
    this.nullString = csvFormat.nullString;
    this.quoteCharacter = csvFormat.quoteCharacter;
    this.quoteMode = csvFormat.quoteMode;
    this.quotedNullString = csvFormat.quotedNullString;
    this.recordSeparator = csvFormat.recordSeparator;
    this.skipHeaderRecord = csvFormat.skipHeaderRecord;
    this.trailingData = csvFormat.trailingData;
    this.trailingDelimiter = csvFormat.trailingDelimiter;
    this.trim = csvFormat.trim;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Builder.<init>(CSVFormat).csvFormat","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Builder.<init>(CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined","Enum","* Predefines formats.
     *
     * @since 1.2","Enum do not obtain Source Code","No return type","public ","enum has no extends",""
"org.apache.commons.csv.CSVFormat$Predefined","Enum","* Predefines formats.
     *
     * @since 1.2","Enum do not obtain Source Code","No return type","public ","enum has no extends",""
"org.apache.commons.csv.CSVFormat$Predefined.Default","Enum Constant","* The DEFAULT predefined format.
         *
         * @see CSVFormat#DEFAULT","Default(DEFAULT)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.Excel","Enum Constant","* The EXCEL predefined format.
         *
         * @see CSVFormat#EXCEL","Excel(EXCEL)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.InformixUnload","Enum Constant","* The INFORMIX_UNLOAD predefined format.
         *
         * @see CSVFormat#INFORMIX_UNLOAD
         * @since 1.3","InformixUnload(INFORMIX_UNLOAD)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.InformixUnloadCsv","Enum Constant","* The INFORMIX_UNLOAD_CSV predefined format.
         *
         * @see CSVFormat#INFORMIX_UNLOAD_CSV
         * @since 1.3","InformixUnloadCsv(INFORMIX_UNLOAD_CSV)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.MongoDBCsv","Enum Constant","* The MONGODB_CSV predefined format.
         *
         * @see CSVFormat#MONGODB_CSV
         * @since 1.7","MongoDBCsv(MONGODB_CSV)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.MongoDBTsv","Enum Constant","* The MONGODB_TSV predefined format.
         *
         * @see CSVFormat#MONGODB_TSV
         * @since 1.7","MongoDBTsv(MONGODB_TSV)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.MySQL","Enum Constant","* The MYSQL predefined format.
         *
         * @see CSVFormat#MYSQL","MySQL(MYSQL)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.Oracle","Enum Constant","* The ORACLE predefined format.
         *
         * @see CSVFormat#ORACLE","Oracle(ORACLE)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.PostgreSQLCsv","Enum Constant","* The POSTGRESQL_CSV predefined format.
         *
         * @see CSVFormat#POSTGRESQL_CSV
         * @since 1.5","PostgreSQLCsv(POSTGRESQL_CSV)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.PostgreSQLText","Enum Constant","* The POSTGRESQL_TEXT predefined format.
         *
         * @see CSVFormat#POSTGRESQL_TEXT","PostgreSQLText(POSTGRESQL_TEXT)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.RFC4180","Enum Constant","* The RFC4180 predefined format.
         *
         * @see CSVFormat#RFC4180","RFC4180(CSVFormat.RFC4180)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.TDF","Enum Constant","* The TDF predefined format.
         *
         * @see CSVFormat#TDF","TDF(CSVFormat.TDF)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.getFormat()","Method","* Gets the format.
         *
         * @return the format.","public CSVFormat getFormat() {
    return format;
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.<init>(CSVFormat)","Constructor","No Comment","Predefined(final CSVFormat format) {
    this.format = format;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat$Predefined.<init>(CSVFormat).format","Parameter_1","Belong to org.apache.commons.csv.CSVFormat$Predefined.<init>(CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder","Class","* Builds CSVFormat instances.
     *
     * @since 1.9.0","Class do not obtain Source Code","No return type","public , static ","","java.util.function.Supplier"
"org.apache.commons.csv.CSVFormat.Builder.allowMissingColumnNames","Field","No Comment","private boolean allowMissingColumnNames;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.autoFlush","Field","No Comment","private boolean autoFlush;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.commentMarker","Field","No Comment","private Character commentMarker;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.delimiter","Field","No Comment","private String delimiter;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.duplicateHeaderMode","Field","No Comment","private DuplicateHeaderMode duplicateHeaderMode;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.escapeCharacter","Field","No Comment","private Character escapeCharacter;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.headerComments","Field","No Comment","private String[] headerComments;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.headers","Field","No Comment","private String[] headers;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.ignoreEmptyLines","Field","No Comment","private boolean ignoreEmptyLines;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.ignoreHeaderCase","Field","No Comment","private boolean ignoreHeaderCase;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.ignoreSurroundingSpaces","Field","No Comment","private boolean ignoreSurroundingSpaces;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.nullString","Field","No Comment","private String nullString;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.quoteCharacter","Field","No Comment","private Character quoteCharacter;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.quotedNullString","Field","No Comment","private String quotedNullString;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.quoteMode","Field","No Comment","private QuoteMode quoteMode;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.recordSeparator","Field","No Comment","private String recordSeparator;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.skipHeaderRecord","Field","No Comment","private boolean skipHeaderRecord;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.lenientEof","Field","No Comment","private boolean lenientEof;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.trailingData","Field","No Comment","private boolean trailingData;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.trailingDelimiter","Field","No Comment","private boolean trailingDelimiter;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.trim","Field","No Comment","private boolean trim;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.maxRows","Field","The maximum number of rows to process, excluding the header row.","private long maxRows;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.create()","Method","* Creates a new default builder, as for {@link #RFC4180} but allowing empty lines.
         *
         * <p>
         * The {@link Builder} settings are:
         * </p>
         * <ul>
         * <li>{@link Builder#setDelimiter(char) setDelimiter}{@code (',')}</li>
         * <li>{@link Builder#setQuote(char) setQuote}{@code ('""')}</li>
         * <li>{@link Builder#setRecordSeparator(String) setRecordSeparator}{@code (""\r\n"")}</li>
         * <li>{@link Builder#setIgnoreEmptyLines(boolean) setIgnoreEmptyLines}{@code (true)}</li>
         * <li>{@link Builder#setDuplicateHeaderMode(DuplicateHeaderMode) setDuplicateHeaderMode}{@code (DuplicateHeaderMode.ALLOW_ALL)}</li>
         * <li>All other values take their Java defaults, {@code false} for booleans, {@code null} for object references.</li>
         * </ul>
         *
         * @see Predefined#Default
         * @see DuplicateHeaderMode#ALLOW_ALL
         *
         * @return a copy of the builder","public static Builder create() {
    // @formatter:off
    return new Builder().setDelimiter(Constants.COMMA).setQuote(Constants.DOUBLE_QUOTE_CHAR).setRecordSeparator(Constants.CRLF).setIgnoreEmptyLines(true).setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL);
    // @formatter:on
}","Builder","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.create(CSVFormat)","Method","* Creates a new builder from the given format.
         *
         * @param csvFormat the source format.
         * @return a new builder.","public static Builder create(final CSVFormat csvFormat) {
    return new Builder(csvFormat);
}","Builder","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.create(CSVFormat).csvFormat","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.create(CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.build()","Method","* Builds a new CSVFormat instance.
         *
         * @return a new CSVFormat instance.
         * @deprecated Use {@link #get()}.","@Deprecated
public CSVFormat build() {
    return get();
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.get()","Method","* Builds a new CSVFormat instance.
         *
         * @return a new CSVFormat instance.
         * @since 1.13.0","@Override
public CSVFormat get() {
    return new CSVFormat(this);
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setAllowDuplicateHeaderNames(boolean)","Method","* Sets the duplicate header names behavior, true to allow, false to disallow.
         *
         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.
         * @return This instance.
         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.","@Deprecated
public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {
    setDuplicateHeaderMode(allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY);
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setAllowDuplicateHeaderNames(boolean).allowDuplicateHeaderNames","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setAllowDuplicateHeaderNames(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setAllowMissingColumnNames(boolean)","Method","* Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an
         * {@link IllegalArgumentException} to be thrown.
         *
         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to
         *                                cause an {@link IllegalArgumentException} to be thrown.
         * @return This instance.","public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {
    this.allowMissingColumnNames = allowMissingColumnNames;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setAllowMissingColumnNames(boolean).allowMissingColumnNames","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setAllowMissingColumnNames(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setAutoFlush(boolean)","Method","* Sets whether to flush on close.
         *
         * @param autoFlush whether to flush on close.
         * @return This instance.","public Builder setAutoFlush(final boolean autoFlush) {
    this.autoFlush = autoFlush;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setAutoFlush(boolean).autoFlush","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setAutoFlush(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setCommentMarker(char)","Method","* Sets the comment marker character, use {@code null} to disable comments.
         * <p>
         * The comment start character is only recognized at the start of a line.
         * </p>
         * <p>
         * Comments are printed first, before headers.
         * </p>
         * <p>
         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.
         * </p>
         * <p>
         * If the comment marker is not set, then the header comments are ignored.
         * </p>
         * <p>
         * For example:
         * </p>
         *
         * <pre>
         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));
         * </pre>
         * <p>
         * writes:
         * </p>
         *
         * <pre>
         * # Generated by Apache Commons CSV.
         * # 1970-01-01T00:00:00Z
         * </pre>
         *
         * @param commentMarker the comment start marker, use {@code null} to disable.
         * @return This instance.
         * @throws IllegalArgumentException thrown if the specified character is a line break","public Builder setCommentMarker(final char commentMarker) {
    setCommentMarker(Character.valueOf(commentMarker));
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setCommentMarker(char).commentMarker","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setCommentMarker(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setCommentMarker(Character)","Method","* Sets the comment marker character, use {@code null} to disable comments.
         * <p>
         * The comment start character is only recognized at the start of a line.
         * </p>
         * <p>
         * Comments are printed first, before headers.
         * </p>
         * <p>
         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.
         * </p>
         * <p>
         * If the comment marker is not set, then the header comments are ignored.
         * </p>
         * <p>
         * For example:
         * </p>
         *
         * <pre>
         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));
         * </pre>
         * <p>
         * writes:
         * </p>
         *
         * <pre>
         * # Generated by Apache Commons CSV.
         * # 1970-01-01T00:00:00Z
         * </pre>
         *
         * @param commentMarker the comment start marker, use {@code null} to disable.
         * @return This instance.
         * @throws IllegalArgumentException thrown if the specified character is a line break","public Builder setCommentMarker(final Character commentMarker) {
    if (isLineBreak(commentMarker)) {
        throw new IllegalArgumentException(""The comment start marker character cannot be a line break"");
    }
    this.commentMarker = commentMarker;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setCommentMarker(Character).commentMarker","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setCommentMarker(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setDelimiter(char)","Method","* Sets the delimiter character.
         *
         * @param delimiter the delimiter character.
         * @return This instance.","public Builder setDelimiter(final char delimiter) {
    return setDelimiter(String.valueOf(delimiter));
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setDelimiter(char).delimiter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setDelimiter(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setDelimiter(String)","Method","* Sets the delimiter character.
         *
         * @param delimiter the delimiter character.
         * @return This instance.","public Builder setDelimiter(final String delimiter) {
    if (containsLineBreak(delimiter)) {
        throw new IllegalArgumentException(""The delimiter cannot be a line break"");
    }
    if (delimiter.isEmpty()) {
        throw new IllegalArgumentException(""The delimiter cannot be empty"");
    }
    this.delimiter = delimiter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setDelimiter(String).delimiter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setDelimiter(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setDuplicateHeaderMode(DuplicateHeaderMode)","Method","* Sets the duplicate header names behavior.
         *
         * @param duplicateHeaderMode the duplicate header names behavior
         * @return This instance.
         * @since 1.10.0","public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {
    this.duplicateHeaderMode = Objects.requireNonNull(duplicateHeaderMode, ""duplicateHeaderMode"");
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setDuplicateHeaderMode(DuplicateHeaderMode).duplicateHeaderMode","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setDuplicateHeaderMode(DuplicateHeaderMode)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setEscape(char)","Method","* Sets the escape character.
         *
         * @param escapeCharacter the escape character.
         * @return This instance.
         * @throws IllegalArgumentException thrown if the specified character is a line break","public Builder setEscape(final char escapeCharacter) {
    setEscape(Character.valueOf(escapeCharacter));
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setEscape(char).escapeCharacter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setEscape(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setEscape(Character)","Method","* Sets the escape character.
         *
         * @param escapeCharacter the escape character.
         * @return This instance.
         * @throws IllegalArgumentException thrown if the specified character is a line break","public Builder setEscape(final Character escapeCharacter) {
    if (isLineBreak(escapeCharacter)) {
        throw new IllegalArgumentException(""The escape character cannot be a line break"");
    }
    this.escapeCharacter = escapeCharacter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setEscape(Character).escapeCharacter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setEscape(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeader(Class)","Method","* Sets the header defined by the given {@link Enum} class.
         *
         * <p>
         * Example:
         * </p>
         *
         * <pre>
         * public enum HeaderEnum {
         *     Name, Email, Phone
         * }
         *
         * Builder builder = builder.setHeader(HeaderEnum.class);
         * </pre>
         * <p>
         * The header is also used by the {@link CSVPrinter}.
         * </p>
         *
         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
         * @return This instance.","public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {
    String[] header = null;
    if (headerEnum != null) {
        final Enum<?>[] enumValues = headerEnum.getEnumConstants();
        header = new String[enumValues.length];
        Arrays.setAll(header, i -> enumValues[i].name());
    }
    return setHeader(header);
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeader(Class).headerEnum","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setHeader(Class)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeader(ResultSet)","Method","* Sets the header from the result set metadata. The header can be parsed automatically from the input file with:
         *
         * <pre>
         * builder.setHeader();
         * </pre>
         *
         * or specified manually with:
         *
         * <pre>
         * builder.setHeader(resultSet);
         * </pre>
         * <p>
         * The header is also used by the {@link CSVPrinter}.
         * </p>
         *
         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
         * @return This instance.
         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.","public Builder setHeader(final ResultSet resultSet) throws SQLException {
    return setHeader(resultSet != null ? resultSet.getMetaData() : null);
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeader(ResultSet).resultSet","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setHeader(ResultSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeader(ResultSetMetaData)","Method","* Sets the header from the result set metadata. The header can be parsed automatically from the input file with:
         *
         * <pre>
         * builder.setHeader();
         * </pre>
         *
         * or specified manually with:
         *
         * <pre>
         * builder.setHeader(resultSetMetaData);
         * </pre>
         * <p>
         * The header is also used by the {@link CSVPrinter}.
         * </p>
         *
         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
         * @return This instance.
         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.","public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {
    String[] labels = null;
    if (resultSetMetaData != null) {
        final int columnCount = resultSetMetaData.getColumnCount();
        labels = new String[columnCount];
        for (int i = 0; i < columnCount; i++) {
            labels[i] = resultSetMetaData.getColumnLabel(i + 1);
        }
    }
    return setHeader(labels);
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeader(ResultSetMetaData).resultSetMetaData","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setHeader(ResultSetMetaData)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeader(String[])","Method","* Sets the header to the given values. The header can be parsed automatically from the input file with:
         *
         * <pre>
         * builder.setHeader();
         * </pre>
         *
         * or specified manually with:
         *
         * <pre>{@code
         * builder.setHeader(""name"", ""email"", ""phone"");
         * }</pre>
         * <p>
         * The header is also used by the {@link CSVPrinter}.
         * </p>
         * <p>
         * This method keeps a copy of the input array.
         * </p>
         * @param header the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.
         * @return This instance.","public Builder setHeader(final String... header) {
    this.headers = CSVFormat.clone(header);
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeader(String[]).header","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setHeader(String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeaderComments(Object[])","Method","* Sets the header comments to write before the CSV data.
         * <p>
         * This setting is ignored by the parser.
         * </p>
         * <p>
         * Comments are printed first, before headers.
         * </p>
         * <p>
         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.
         * </p>
         * <p>
         * If the comment marker is not set, then the header comments are ignored.
         * </p>
         * <p>
         * For example:
         * </p>
         *
         * <pre>
         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));
         * </pre>
         * <p>
         * writes:
         * </p>
         *
         * <pre>
         * # Generated by Apache Commons CSV.
         * # 1970-01-01T00:00:00Z
         * </pre>
         * <p>
         * This method keeps a copy of the input array.
         * </p>
         *
         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.
         * @return This instance.","public Builder setHeaderComments(final Object... headerComments) {
    this.headerComments = CSVFormat.clone(toStringArray(headerComments));
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeaderComments(Object[]).headerComments","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setHeaderComments(Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeaderComments(String[])","Method","* Sets the header comments to write before the CSV data.
         * <p>
         * This setting is ignored by the parser.
         * </p>
         * <p>
         * Comments are printed first, before headers.
         * </p>
         * <p>
         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.
         * </p>
         * <p>
         * If the comment marker is not set, then the header comments are ignored.
         * </p>
         * <p>
         * For example:
         * </p>
         *
         * <pre>
         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0).toString());
         * </pre>
         * <p>
         * writes:
         * </p>
         *
         * <pre>
         * # Generated by Apache Commons CSV.
         * # 1970-01-01T00:00:00Z
         * </pre>
         * <p>
         * This method keeps a copy of the input array.
         * </p>
         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.
         * @return This instance.","public Builder setHeaderComments(final String... headerComments) {
    this.headerComments = CSVFormat.clone(headerComments);
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setHeaderComments(String[]).headerComments","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setHeaderComments(String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setIgnoreEmptyLines(boolean)","Method","* Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty
         * records.
         *
         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate
         *                         empty lines to empty records.
         * @return This instance.","public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {
    this.ignoreEmptyLines = ignoreEmptyLines;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setIgnoreEmptyLines(boolean).ignoreEmptyLines","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setIgnoreEmptyLines(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setIgnoreHeaderCase(boolean)","Method","* Sets the parser case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.
         *
         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.
         * @return This instance.","public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {
    this.ignoreHeaderCase = ignoreHeaderCase;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setIgnoreHeaderCase(boolean).ignoreHeaderCase","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setIgnoreHeaderCase(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setIgnoreSurroundingSpaces(boolean)","Method","* Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.
         *
         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.
         * @return This instance.","public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {
    this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setIgnoreSurroundingSpaces(boolean).ignoreSurroundingSpaces","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setIgnoreSurroundingSpaces(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setLenientEof(boolean)","Method","* Sets whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.
         *
         * @param lenientEof whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.
         * @return This instance.
         * @since 1.11.0","public Builder setLenientEof(final boolean lenientEof) {
    this.lenientEof = lenientEof;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setLenientEof(boolean).lenientEof","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setLenientEof(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setMaxRows(long)","Method","* Sets the maximum number of rows to process, excluding the header row.
         * <p>
         * Values less than or equal to 0 mean no limit.
         * </p>
         *
         * @param maxRows the maximum number of rows to process, excluding the header row.
         * @return This instance.
         * @since 1.14.0","public Builder setMaxRows(final long maxRows) {
    this.maxRows = maxRows;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setMaxRows(long).maxRows","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setMaxRows(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setNullString(String)","Method","* Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.
         *
         * <ul>
         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>
         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>
         * </ul>
         *
         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.
         * @return This instance.","public Builder setNullString(final String nullString) {
    this.nullString = nullString;
    this.quotedNullString = quoteCharacter + nullString + quoteCharacter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setNullString(String).nullString","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setNullString(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setQuote(char)","Method","* Sets the quote character.
         *
         * @param quoteCharacter the quote character.
         * @return This instance.","public Builder setQuote(final char quoteCharacter) {
    setQuote(Character.valueOf(quoteCharacter));
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setQuote(char).quoteCharacter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setQuote(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setQuote(Character)","Method","* Sets the quote character, use {@code null} to disable.
         *
         * @param quoteCharacter the quote character, use {@code null} to disable.
         * @return This instance.","public Builder setQuote(final Character quoteCharacter) {
    if (isLineBreak(quoteCharacter)) {
        throw new IllegalArgumentException(""The quoteCharacter cannot be a line break"");
    }
    this.quoteCharacter = quoteCharacter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setQuote(Character).quoteCharacter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setQuote(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setQuoteMode(QuoteMode)","Method","* Sets the quote policy to use for output.
         *
         * @param quoteMode the quote policy to use for output.
         * @return This instance.","public Builder setQuoteMode(final QuoteMode quoteMode) {
    this.quoteMode = quoteMode;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setQuoteMode(QuoteMode).quoteMode","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setQuoteMode(QuoteMode)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setRecordSeparator(char)","Method","* Sets the record separator to use for output.
         *
         * <p>
         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r'
         * and ""\r\n""
         * </p>
         *
         * @param recordSeparator the record separator to use for output.
         * @return This instance.","public Builder setRecordSeparator(final char recordSeparator) {
    this.recordSeparator = String.valueOf(recordSeparator);
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setRecordSeparator(char).recordSeparator","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setRecordSeparator(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setRecordSeparator(String)","Method","* Sets the record separator to use for output.
         *
         * <p>
         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r'
         * and ""\r\n""
         * </p>
         *
         * @param recordSeparator the record separator to use for output.
         * @return This instance.","public Builder setRecordSeparator(final String recordSeparator) {
    this.recordSeparator = recordSeparator;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setRecordSeparator(String).recordSeparator","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setRecordSeparator(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setSkipHeaderRecord(boolean)","Method","* Sets whether to skip the header record.
         *
         * @param skipHeaderRecord whether to skip the header record.
         * @return This instance.","public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {
    this.skipHeaderRecord = skipHeaderRecord;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setSkipHeaderRecord(boolean).skipHeaderRecord","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setSkipHeaderRecord(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setTrailingData(boolean)","Method","* Sets whether reading trailing data is allowed in records, helps Excel compatibility.
         *
         * @param trailingData whether reading trailing data is allowed in records, helps Excel compatibility.
         * @return This instance.
         * @since 1.11.0","public Builder setTrailingData(final boolean trailingData) {
    this.trailingData = trailingData;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setTrailingData(boolean).trailingData","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setTrailingData(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setTrailingDelimiter(boolean)","Method","* Sets whether to add a trailing delimiter.
         *
         * @param trailingDelimiter whether to add a trailing delimiter.
         * @return This instance.","public Builder setTrailingDelimiter(final boolean trailingDelimiter) {
    this.trailingDelimiter = trailingDelimiter;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setTrailingDelimiter(boolean).trailingDelimiter","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setTrailingDelimiter(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setTrim(boolean)","Method","* Sets whether to trim leading and trailing blanks.
         *
         * @param trim whether to trim leading and trailing blanks.
         * @return This instance.","public Builder setTrim(final boolean trim) {
    this.trim = trim;
    return this;
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.setTrim(boolean).trim","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.setTrim(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.<init>()","Constructor","No Comment","private Builder() {
    // empty
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.<init>(CSVFormat)","Constructor","No Comment","private Builder(final CSVFormat csvFormat) {
    this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;
    this.autoFlush = csvFormat.autoFlush;
    this.commentMarker = csvFormat.commentMarker;
    this.delimiter = csvFormat.delimiter;
    this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;
    this.escapeCharacter = csvFormat.escapeCharacter;
    this.headerComments = csvFormat.headerComments;
    this.headers = csvFormat.headers;
    this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;
    this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;
    this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;
    this.lenientEof = csvFormat.lenientEof;
    this.maxRows = csvFormat.maxRows;
    this.nullString = csvFormat.nullString;
    this.quoteCharacter = csvFormat.quoteCharacter;
    this.quoteMode = csvFormat.quoteMode;
    this.quotedNullString = csvFormat.quotedNullString;
    this.recordSeparator = csvFormat.recordSeparator;
    this.skipHeaderRecord = csvFormat.skipHeaderRecord;
    this.trailingData = csvFormat.trailingData;
    this.trailingDelimiter = csvFormat.trailingDelimiter;
    this.trim = csvFormat.trim;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Builder.<init>(CSVFormat).csvFormat","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Builder.<init>(CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined","Enum","* Predefines formats.
     *
     * @since 1.2","Enum do not obtain Source Code","No return type","public ","enum has no extends",""
"org.apache.commons.csv.CSVFormat.Predefined.Default","Enum Constant","* The DEFAULT predefined format.
         *
         * @see CSVFormat#DEFAULT","Default(DEFAULT)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.Excel","Enum Constant","* The EXCEL predefined format.
         *
         * @see CSVFormat#EXCEL","Excel(EXCEL)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.InformixUnload","Enum Constant","* The INFORMIX_UNLOAD predefined format.
         *
         * @see CSVFormat#INFORMIX_UNLOAD
         * @since 1.3","InformixUnload(INFORMIX_UNLOAD)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.InformixUnloadCsv","Enum Constant","* The INFORMIX_UNLOAD_CSV predefined format.
         *
         * @see CSVFormat#INFORMIX_UNLOAD_CSV
         * @since 1.3","InformixUnloadCsv(INFORMIX_UNLOAD_CSV)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.MongoDBCsv","Enum Constant","* The MONGODB_CSV predefined format.
         *
         * @see CSVFormat#MONGODB_CSV
         * @since 1.7","MongoDBCsv(MONGODB_CSV)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.MongoDBTsv","Enum Constant","* The MONGODB_TSV predefined format.
         *
         * @see CSVFormat#MONGODB_TSV
         * @since 1.7","MongoDBTsv(MONGODB_TSV)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.MySQL","Enum Constant","* The MYSQL predefined format.
         *
         * @see CSVFormat#MYSQL","MySQL(MYSQL)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.Oracle","Enum Constant","* The ORACLE predefined format.
         *
         * @see CSVFormat#ORACLE","Oracle(ORACLE)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.PostgreSQLCsv","Enum Constant","* The POSTGRESQL_CSV predefined format.
         *
         * @see CSVFormat#POSTGRESQL_CSV
         * @since 1.5","PostgreSQLCsv(POSTGRESQL_CSV)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.PostgreSQLText","Enum Constant","* The POSTGRESQL_TEXT predefined format.
         *
         * @see CSVFormat#POSTGRESQL_TEXT","PostgreSQLText(POSTGRESQL_TEXT)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.RFC4180","Enum Constant","* The RFC4180 predefined format.
         *
         * @see CSVFormat#RFC4180","RFC4180(CSVFormat.RFC4180)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.TDF","Enum Constant","* The TDF predefined format.
         *
         * @see CSVFormat#TDF","TDF(CSVFormat.TDF)","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.getFormat()","Method","* Gets the format.
         *
         * @return the format.","public CSVFormat getFormat() {
    return format;
}","CSVFormat","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.<init>(CSVFormat)","Constructor","No Comment","Predefined(final CSVFormat format) {
    this.format = format;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVFormat.Predefined.<init>(CSVFormat).format","Parameter_1","Belong to org.apache.commons.csv.CSVFormat.Predefined.<init>(CSVFormat)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader","Class","* A special buffered reader which supports sophisticated read access.
 * <p>
 * In particular the reader supports a look-ahead option, which allows you to see the next char returned by
 * {@link #read()}. This reader also tracks how many characters have been read with {@link #getPosition()}.
 * </p>","Class do not obtain Source Code","No return type","final ","org.apache.commons.io.input.UnsynchronizedBufferedReader",""
"org.apache.commons.csv.ExtendedBufferedReader.lastChar","Field","The last char returned","private int lastChar = UNDEFINED;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.lastCharMark","Field","No Comment","private int lastCharMark = UNDEFINED;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.lineNumber","Field","The count of EOLs (CR/LF/CRLF) seen so far","private long lineNumber;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.lineNumberMark","Field","No Comment","private long lineNumberMark;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.position","Field","The position, which is the number of characters read so far","private long position;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.positionMark","Field","No Comment","private long positionMark;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.bytesRead","Field","The number of bytes read so far.","private long bytesRead;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.bytesReadMark","Field","No Comment","private long bytesReadMark;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.encoder","Field","Encoder for calculating the number of bytes for each character read.","private final CharsetEncoder encoder;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.close()","Method","* Closes the stream.
     *
     * @throws IOException
     *             If an I/O error occurs","@Override
public void close() throws IOException {
    // Set ivars before calling super close() in case close() throws an IOException.
    lastChar = EOF;
    super.close();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.getBytesRead()","Method","* Gets the number of bytes read by the reader.
     *
     * @return the number of bytes read by the read","long getBytesRead() {
    return this.bytesRead;
}","long","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.getEncodedCharLength(int)","Method","* Gets the byte length of the given character based on the the original Unicode
     * specification, which defined characters as fixed-width 16-bit entities.
     * <p>
     * The Unicode characters are divided into two main ranges:
     * <ul>
     *   <li><b>U+0000 to U+FFFF (Basic Multilingual Plane, BMP):</b>
     *     <ul>
     *       <li>Represented using a single 16-bit {@code char}.</li>
     *       <li>Includes UTF-8 encodings of 1-byte, 2-byte, and some 3-byte characters.</li>
     *     </ul>
     *   </li>
     *   <li><b>U+10000 to U+10FFFF (Supplementary Characters):</b>
     *     <ul>
     *       <li>Represented as a pair of {@code char}s:</li>
     *       <li>The first {@code char} is from the high-surrogates range (\uD800-\uDBFF).</li>
     *       <li>The second {@code char} is from the low-surrogates range (\uDC00-\uDFFF).</li>
     *       <li>Includes UTF-8 encodings of some 3-byte characters and all 4-byte characters.</li>
     *     </ul>
     *   </li>
     * </ul>
     *
     * @param current the current character to process.
     * @return the byte length of the character.
     * @throws CharacterCodingException if the character cannot be encoded.","private int getEncodedCharLength(final int current) throws CharacterCodingException {
    final char cChar = (char) current;
    final char lChar = (char) lastChar;
    if (!Character.isSurrogate(cChar)) {
        return encoder.encode(CharBuffer.wrap(new char[] { cChar })).limit();
    }
    if (Character.isHighSurrogate(cChar)) {
        // Move on to the next char (low surrogate)
        return 0;
    } else if (Character.isSurrogatePair(lChar, cChar)) {
        return encoder.encode(CharBuffer.wrap(new char[] { lChar, cChar })).limit();
    } else {
        throw new CharacterCodingException();
    }
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.getEncodedCharLength(int).current","Parameter_1","Belong to org.apache.commons.csv.ExtendedBufferedReader.getEncodedCharLength(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.getLastChar()","Method","* Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by
     * any of the read methods. This will not include a character read using the {@link #peek()} method. If no
     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached
     * on the last read then this will return {@link IOUtils#EOF}.
     *
     * @return the last character that was read","int getLastChar() {
    return lastChar;
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.getLineNumber()","Method","* Returns the current line number
     *
     * @return the current line number","long getLineNumber() {
    // Check if we are at EOL or EOF or just starting
    if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == EOF) {
        // counter is accurate
        return lineNumber;
    }
    // Allow for counter being incremented only at EOL
    return lineNumber + 1;
}","long","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.getPosition()","Method","* Gets the character position in the reader.
     *
     * @return the current position in the reader (counting characters, not bytes since this is a Reader)","long getPosition() {
    return this.position;
}","long","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.mark(int)","Method","No Comment","@Override
public void mark(final int readAheadLimit) throws IOException {
    lineNumberMark = lineNumber;
    lastCharMark = lastChar;
    positionMark = position;
    bytesReadMark = bytesRead;
    super.mark(readAheadLimit);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.mark(int).readAheadLimit","Parameter_1","Belong to org.apache.commons.csv.ExtendedBufferedReader.mark(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.read()","Method","No Comment","@Override
public int read() throws IOException {
    final int current = super.read();
    if (current == CR || current == LF && lastChar != CR || current == EOF && lastChar != CR && lastChar != LF && lastChar != EOF) {
        lineNumber++;
    }
    if (encoder != null) {
        this.bytesRead += getEncodedCharLength(current);
    }
    lastChar = current;
    position++;
    return lastChar;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.read(char[],int,int)","Method","No Comment","@Override
public int read(final char[] buf, final int offset, final int length) throws IOException {
    if (length == 0) {
        return 0;
    }
    final int len = super.read(buf, offset, length);
    if (len > 0) {
        for (int i = offset; i < offset + len; i++) {
            final char ch = buf[i];
            if (ch == LF) {
                if (CR != (i > offset ? buf[i - 1] : lastChar)) {
                    lineNumber++;
                }
            } else if (ch == CR) {
                lineNumber++;
            }
        }
        lastChar = buf[offset + len - 1];
    } else if (len == EOF) {
        lastChar = EOF;
    }
    position += len;
    return len;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.read(char[],int,int).buf","Parameter_1","Belong to org.apache.commons.csv.ExtendedBufferedReader.read(char[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.read(char[],int,int).offset","Parameter_2","Belong to org.apache.commons.csv.ExtendedBufferedReader.read(char[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.read(char[],int,int).length","Parameter_3","Belong to org.apache.commons.csv.ExtendedBufferedReader.read(char[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.readLine()","Method","* Gets the next line, dropping the line terminator(s). This method should only be called when processing a
     * comment, otherwise, information can be lost.
     * <p>
     * Increments {@link #lineNumber} and updates {@link #position}.
     * </p>
     * <p>
     * Sets {@link #lastChar} to {@code Constants.EOF} at EOF, otherwise the last EOL character.
     * </p>
     *
     * @return the line that was read, or null if reached EOF.","@Override
public String readLine() throws IOException {
    if (peek() == EOF) {
        return null;
    }
    final StringBuilder buffer = new StringBuilder();
    while (true) {
        final int current = read();
        if (current == CR) {
            final int next = peek();
            if (next == LF) {
                read();
            }
        }
        if (current == EOF || current == LF || current == CR) {
            break;
        }
        buffer.append((char) current);
    }
    return buffer.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.reset()","Method","No Comment","@Override
public void reset() throws IOException {
    lineNumber = lineNumberMark;
    lastChar = lastCharMark;
    position = positionMark;
    bytesRead = bytesReadMark;
    super.reset();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader)","Constructor","* Constructs a new instance using the default buffer size.","ExtendedBufferedReader(final Reader reader) {
    this(reader, null, false);
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader).reader","Parameter_1","Belong to org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader,Charset,boolean)","Constructor","* Constructs a new instance with the specified reader, character set,
     * and byte tracking option. Initializes an encoder if byte tracking is enabled
     * and a character set is provided.
     *
     * @param reader the reader supports a look-ahead option.
     * @param charset the character set for encoding, or {@code null} if not applicable.
     * @param trackBytes {@code true} to enable byte tracking; {@code false} to disable it.","ExtendedBufferedReader(final Reader reader, final Charset charset, final boolean trackBytes) {
    super(reader);
    encoder = charset != null && trackBytes ? charset.newEncoder() : null;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader,Charset,boolean).reader","Parameter_1","Belong to org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader,Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader,Charset,boolean).charset","Parameter_2","Belong to org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader,Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader,Charset,boolean).trackBytes","Parameter_3","Belong to org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader,Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.QuoteMode","Enum","* Defines quoting behavior.","Enum do not obtain Source Code","No return type","public ","enum has no extends",""
"org.apache.commons.csv.QuoteMode.ALL","Enum Constant","* Quotes all fields.","ALL","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.QuoteMode.ALL_NON_NULL","Enum Constant","* Quotes all non-null fields.","ALL_NON_NULL","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.QuoteMode.MINIMAL","Enum Constant","* Quotes fields that contain special characters such as a field delimiter, quote character, or any of the
     * characters in the line separator string.","MINIMAL","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.QuoteMode.NON_NUMERIC","Enum Constant","* Quotes all non-numeric fields.","NON_NUMERIC","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.QuoteMode.NONE","Enum Constant","* Never quotes fields. When the delimiter occurs in data, the printer prefixes it with the escape character. If the
     * escape character is not set, format validation throws an exception.","NONE","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer","Class","* Lexical analyzer.","Class do not obtain Source Code","No return type","final ","","java.io.Closeable"
"org.apache.commons.csv.Lexer.CR_STRING","Field","No Comment","private static final String CR_STRING = Character.toString(Constants.CR);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.LF_STRING","Field","No Comment","private static final String LF_STRING = Character.toString(Constants.LF);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.delimiter","Field","No Comment","private final char[] delimiter;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.delimiterBuf","Field","No Comment","private final char[] delimiterBuf;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.escapeDelimiterBuf","Field","No Comment","private final char[] escapeDelimiterBuf;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.escape","Field","No Comment","private final int escape;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.quoteChar","Field","No Comment","private final int quoteChar;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.commentStart","Field","No Comment","private final int commentStart;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.ignoreSurroundingSpaces","Field","No Comment","private final boolean ignoreSurroundingSpaces;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.ignoreEmptyLines","Field","No Comment","private final boolean ignoreEmptyLines;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.lenientEof","Field","No Comment","private final boolean lenientEof;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.trailingData","Field","No Comment","private final boolean trailingData;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.reader","Field","The buffered reader.","private final ExtendedBufferedReader reader;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.firstEol","Field","No Comment","private String firstEol;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isLastTokenDelimiter","Field","No Comment","private boolean isLastTokenDelimiter;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.appendNextEscapedCharacterToToken(Token)","Method","* Appends the next escaped character to the token's content.
     *
     * @param token the current token
     * @throws IOException  on stream access error
     * @throws CSVException Thrown on invalid input.","private void appendNextEscapedCharacterToToken(final Token token) throws IOException {
    if (isEscapeDelimiter()) {
        token.content.append(delimiter);
    } else {
        final int unescaped = readEscape();
        if (unescaped == EOF) {
            // unexpected char after escape
            token.content.append((char) escape).append((char) reader.getLastChar());
        } else {
            token.content.append((char) unescaped);
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.appendNextEscapedCharacterToToken(Token).token","Parameter_1","Belong to org.apache.commons.csv.Lexer.appendNextEscapedCharacterToToken(Token)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.close()","Method","* Closes resources.
     *
     * @throws IOException
     *             If an I/O error occurs","@Override
public void close() throws IOException {
    reader.close();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.getBytesRead()","Method","* Gets the number of bytes read
     *
     * @return the number of bytes read","long getBytesRead() {
    return reader.getBytesRead();
}","long","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.getCharacterPosition()","Method","* Returns the current character position
     *
     * @return the current character position","long getCharacterPosition() {
    return reader.getPosition();
}","long","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.getCurrentLineNumber()","Method","* Returns the current line number
     *
     * @return the current line number","long getCurrentLineNumber() {
    return reader.getLineNumber();
}","long","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.getFirstEol()","Method","No Comment","String getFirstEol() {
    return firstEol;
}","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isClosed()","Method","No Comment","boolean isClosed() {
    return reader.isClosed();
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isCommentStart(int)","Method","No Comment","boolean isCommentStart(final int ch) {
    return ch == commentStart;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isCommentStart(int).ch","Parameter_1","Belong to org.apache.commons.csv.Lexer.isCommentStart(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isDelimiter(int)","Method","* Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#peek(char[])}.
     *
     * @param ch
     *             the current character.
     * @return true if the next characters constitute a delimiter.
     * @throws IOException If an I/O error occurs.","boolean isDelimiter(final int ch) throws IOException {
    isLastTokenDelimiter = false;
    if (ch != delimiter[0]) {
        return false;
    }
    if (delimiter.length == 1) {
        isLastTokenDelimiter = true;
        return true;
    }
    reader.peek(delimiterBuf);
    for (int i = 0; i < delimiterBuf.length; i++) {
        if (delimiterBuf[i] != delimiter[i + 1]) {
            return false;
        }
    }
    final int count = reader.read(delimiterBuf, 0, delimiterBuf.length);
    isLastTokenDelimiter = count != EOF;
    return isLastTokenDelimiter;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isDelimiter(int).ch","Parameter_1","Belong to org.apache.commons.csv.Lexer.isDelimiter(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isEndOfFile(int)","Method","* Tests if the given character indicates the end of the file.
     *
     * @return true if the given character indicates the end of the file.","boolean isEndOfFile(final int ch) {
    return ch == EOF;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isEndOfFile(int).ch","Parameter_1","Belong to org.apache.commons.csv.Lexer.isEndOfFile(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isEscape(int)","Method","* Tests if the given character is the escape character.
     *
     * @return true if the given character is the escape character.","boolean isEscape(final int ch) {
    return ch == escape;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isEscape(int).ch","Parameter_1","Belong to org.apache.commons.csv.Lexer.isEscape(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isEscapeDelimiter()","Method","* Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#peek(char[])}.
     *
     * For example, for delimiter ""[|]"" and escape '!', return true if the next characters constitute ""![!|!]"".
     *
     * @return true if the next characters constitute an escape delimiter.
     * @throws IOException If an I/O error occurs.","boolean isEscapeDelimiter() throws IOException {
    reader.peek(escapeDelimiterBuf);
    if (escapeDelimiterBuf[0] != delimiter[0]) {
        return false;
    }
    for (int i = 1; i < delimiter.length; i++) {
        if (escapeDelimiterBuf[2 * i] != delimiter[i] || escapeDelimiterBuf[2 * i - 1] != escape) {
            return false;
        }
    }
    final int count = reader.read(escapeDelimiterBuf, 0, escapeDelimiterBuf.length);
    return count != EOF;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isMetaChar(int)","Method","No Comment","private boolean isMetaChar(final int ch) {
    return ch == escape || ch == quoteChar || ch == commentStart;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isMetaChar(int).ch","Parameter_1","Belong to org.apache.commons.csv.Lexer.isMetaChar(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isQuoteChar(int)","Method","No Comment","boolean isQuoteChar(final int ch) {
    return ch == quoteChar;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isQuoteChar(int).ch","Parameter_1","Belong to org.apache.commons.csv.Lexer.isQuoteChar(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isStartOfLine(int)","Method","* Tests if the current character represents the start of a line: a CR, LF, or is at the start of the file.
     *
     * @param ch the character to check
     * @return true if the character is at the start of a line.","boolean isStartOfLine(final int ch) {
    return ch == Constants.LF || ch == Constants.CR || ch == Constants.UNDEFINED;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.isStartOfLine(int).ch","Parameter_1","Belong to org.apache.commons.csv.Lexer.isStartOfLine(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.nextToken(Token)","Method","* Returns the next token.
     * <p>
     * A token corresponds to a term, a record change or an end-of-file indicator.
     * </p>
     *
     * @param token an existing Token object to reuse. The caller is responsible for initializing the Token.
     * @return the next token found.
     * @throws IOException  on stream access error.
     * @throws CSVException Thrown on invalid input.","Token nextToken(final Token token) throws IOException {
    // Get the last read char (required for empty line detection)
    int lastChar = reader.getLastChar();
    // read the next char and set eol
    int c = reader.read();
    // Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF - they are equivalent here.
    boolean eol = readEndOfLine(c);
    // empty line detection: eol AND (last char was EOL or beginning)
    if (ignoreEmptyLines) {
        while (eol && isStartOfLine(lastChar)) {
            // Go on char ahead ...
            lastChar = c;
            c = reader.read();
            eol = readEndOfLine(c);
            // reached the end of the file without any content (empty line at the end)
            if (isEndOfFile(c)) {
                token.type = Token.Type.EOF;
                // don't set token.isReady here because no content
                return token;
            }
        }
    }
    // Did we reach EOF during the last iteration already? EOF
    if (isEndOfFile(lastChar) || !isLastTokenDelimiter && isEndOfFile(c)) {
        token.type = Token.Type.EOF;
        // don't set token.isReady here because no content
        return token;
    }
    if (isStartOfLine(lastChar) && isCommentStart(c)) {
        final String line = reader.readLine();
        if (line == null) {
            token.type = Token.Type.EOF;
            // don't set token.isReady here because no content
            return token;
        }
        final String comment = line.trim();
        token.content.append(comment);
        token.type = Token.Type.COMMENT;
        return token;
    }
    // Important: make sure a new char gets consumed in each iteration
    while (token.type == Token.Type.INVALID) {
        // ignore whitespaces at beginning of a token
        if (ignoreSurroundingSpaces) {
            while (Character.isWhitespace((char) c) && !isDelimiter(c) && !eol) {
                c = reader.read();
                eol = readEndOfLine(c);
            }
        }
        // ok, start of token reached: encapsulated, or token
        if (isDelimiter(c)) {
            // empty token return TOKEN("""")
            token.type = Token.Type.TOKEN;
        } else if (eol) {
            // empty token return EORECORD("""")
            // noop: token.content.append("""");
            token.type = Token.Type.EORECORD;
        } else if (isQuoteChar(c)) {
            // consume encapsulated token
            parseEncapsulatedToken(token);
        } else if (isEndOfFile(c)) {
            // end of file return EOF()
            // noop: token.content.append("""");
            token.type = Token.Type.EOF;
            // there is data at EOF
            token.isReady = true;
        } else {
            // next token must be a simple token
            // add removed blanks when not ignoring whitespace chars...
            parseSimpleToken(token, c);
        }
    }
    return token;
}","Token","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.nextToken(Token).token","Parameter_1","Belong to org.apache.commons.csv.Lexer.nextToken(Token)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.nullToDisabled(Character)","Method","No Comment","private int nullToDisabled(final Character c) {
    // Explicit unboxing
    return c == null ? Constants.UNDEFINED : c.charValue();
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.nullToDisabled(Character).c","Parameter_1","Belong to org.apache.commons.csv.Lexer.nullToDisabled(Character)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.parseEncapsulatedToken(Token)","Method","* Parses an encapsulated token.
     * <p>
     * Encapsulated tokens are surrounded by the given encapsulating string. The encapsulator itself might be included
     * in the token using a doubling syntax (as """", '') or using escaping (as in \"", \'). Whitespaces before and after
     * an encapsulated token is ignored. The token is finished when one of the following conditions becomes true:
     * </p>
     * <ul>
     * <li>An unescaped encapsulator has been reached and is followed by optional whitespace then:</li>
     * <ul>
     * <li>delimiter (TOKEN)</li>
     * <li>end of line (EORECORD)</li>
     * </ul>
     * <li>end of stream has been reached (EOF)</li> </ul>
     *
     * @param token
     *            the current token
     * @return a valid token object
     * @throws IOException
     *             Thrown when in an invalid state: EOF before closing encapsulator or invalid character before
     *             delimiter or EOL.
     * @throws CSVException Thrown on invalid input.","private Token parseEncapsulatedToken(final Token token) throws IOException {
    token.isQuoted = true;
    // Save current line number in case needed for IOE
    final long startLineNumber = getCurrentLineNumber();
    int c;
    while (true) {
        c = reader.read();
        if (isQuoteChar(c)) {
            if (isQuoteChar(reader.peek())) {
                // double or escaped encapsulator -> add single encapsulator to token
                c = reader.read();
                token.content.append((char) c);
            } else {
                // token finish mark (encapsulator) reached: ignore whitespace till delimiter
                while (true) {
                    c = reader.read();
                    if (isDelimiter(c)) {
                        token.type = Token.Type.TOKEN;
                        return token;
                    }
                    if (isEndOfFile(c)) {
                        token.type = Token.Type.EOF;
                        // There is data at EOF
                        token.isReady = true;
                        return token;
                    }
                    if (readEndOfLine(c)) {
                        token.type = Token.Type.EORECORD;
                        return token;
                    }
                    if (trailingData) {
                        token.content.append((char) c);
                    } else if (!Character.isWhitespace((char) c)) {
                        // error invalid char between token and next delimiter
                        throw new CSVException(""Invalid character between encapsulated token and delimiter at line: %,d, position: %,d"", getCurrentLineNumber(), getCharacterPosition());
                    }
                }
            }
        } else if (isEscape(c)) {
            appendNextEscapedCharacterToToken(token);
        } else if (isEndOfFile(c)) {
            if (lenientEof) {
                token.type = Token.Type.EOF;
                // There is data at EOF
                token.isReady = true;
                return token;
            }
            // error condition (end of file before end of token)
            throw new CSVException(""(startline %,d) EOF reached before encapsulated token finished"", startLineNumber);
        } else {
            // consume character
            token.content.append((char) c);
        }
    }
}","Token","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.parseEncapsulatedToken(Token).token","Parameter_1","Belong to org.apache.commons.csv.Lexer.parseEncapsulatedToken(Token)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.parseSimpleToken(Token,int)","Method","* Parses a simple token.
     * <p>
     * Simple tokens are tokens that are not surrounded by encapsulators. A simple token might contain escaped delimiters (as \, or \;). The token is finished
     * when one of the following conditions becomes true:
     * </p>
     * <ul>
     * <li>The end of line has been reached (EORECORD)</li>
     * <li>The end of stream has been reached (EOF)</li>
     * <li>An unescaped delimiter has been reached (TOKEN)</li>
     * </ul>
     *
     * @param token the current token
     * @param ch     the current character
     * @return the filled token
     * @throws IOException  on stream access error
     * @throws CSVException Thrown on invalid input.","private Token parseSimpleToken(final Token token, final int ch) throws IOException {
    // Faster to use while(true)+break than while(token.type == INVALID)
    int cur = ch;
    while (true) {
        if (readEndOfLine(cur)) {
            token.type = Token.Type.EORECORD;
            break;
        }
        if (isEndOfFile(cur)) {
            token.type = Token.Type.EOF;
            // There is data at EOF
            token.isReady = true;
            break;
        }
        if (isDelimiter(cur)) {
            token.type = Token.Type.TOKEN;
            break;
        }
        // continue
        if (isEscape(cur)) {
            appendNextEscapedCharacterToToken(token);
        } else {
            token.content.append((char) cur);
        }
        // continue
        cur = reader.read();
    }
    if (ignoreSurroundingSpaces) {
        trimTrailingSpaces(token.content);
    }
    return token;
}","Token","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.parseSimpleToken(Token,int).token","Parameter_1","Belong to org.apache.commons.csv.Lexer.parseSimpleToken(Token,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.parseSimpleToken(Token,int).ch","Parameter_2","Belong to org.apache.commons.csv.Lexer.parseSimpleToken(Token,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.readEndOfLine(int)","Method","* Greedily accepts \n, \r and \r\n This checker consumes silently the second control-character...
     *
     * @return true if the given or next character is a line-terminator","boolean readEndOfLine(final int ch) throws IOException {
    // check if we have \r\n...
    int cur = ch;
    if (cur == Constants.CR && reader.peek() == Constants.LF) {
        // note: does not change ch outside of this method!
        cur = reader.read();
        // Save the EOL state
        if (firstEol == null) {
            this.firstEol = Constants.CRLF;
        }
    }
    // save EOL state here.
    if (firstEol == null) {
        if (cur == Constants.LF) {
            this.firstEol = LF_STRING;
        } else if (cur == Constants.CR) {
            this.firstEol = CR_STRING;
        }
    }
    return cur == Constants.LF || cur == Constants.CR;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.readEndOfLine(int).ch","Parameter_1","Belong to org.apache.commons.csv.Lexer.readEndOfLine(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.readEscape()","Method","* Handle an escape sequence. The current character must be the escape character. On return, the next character is available by calling
     * {@link ExtendedBufferedReader#getLastChar()} on the input stream.
     *
     * @return the unescaped character (as an int) or {@link IOUtils#EOF} if char following the escape is invalid.
     * @throws IOException  if there is a problem reading the stream or the end of stream is detected: the escape character is not allowed at end of stream
     * @throws CSVException Thrown on invalid input.","int readEscape() throws IOException {
    // the escape char has just been read (normally a backslash)
    final int ch = reader.read();
    switch(ch) {
        case 'r':
            return Constants.CR;
        case 'n':
            return Constants.LF;
        case 't':
            return Constants.TAB;
        case 'b':
            return Constants.BACKSPACE;
        case 'f':
            return Constants.FF;
        case Constants.CR:
        case Constants.LF:
        // TODO is this correct?
        case Constants.FF:
        // TODO is this correct? Do tabs need to be escaped?
        case Constants.TAB:
        case // TODO is this correct?
        Constants.BACKSPACE:
            return ch;
        case EOF:
            throw new CSVException(""EOF while processing escape sequence"");
        default:
            // Now check for meta-characters
            if (isMetaChar(ch)) {
                return ch;
            }
            // indicate unexpected char - available from in.getLastChar()
            return EOF;
    }
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.trimTrailingSpaces(StringBuilder)","Method","No Comment","void trimTrailingSpaces(final StringBuilder buffer) {
    int length = buffer.length();
    while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {
        length--;
    }
    if (length != buffer.length()) {
        buffer.setLength(length);
    }
}","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.trimTrailingSpaces(StringBuilder).buffer","Parameter_1","Belong to org.apache.commons.csv.Lexer.trimTrailingSpaces(StringBuilder)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.<init>(CSVFormat,ExtendedBufferedReader)","Constructor","No Comment","Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {
    this.reader = reader;
    this.delimiter = format.getDelimiterCharArray();
    this.escape = nullToDisabled(format.getEscapeCharacter());
    this.quoteChar = nullToDisabled(format.getQuoteCharacter());
    this.commentStart = nullToDisabled(format.getCommentMarker());
    this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();
    this.ignoreEmptyLines = format.getIgnoreEmptyLines();
    this.lenientEof = format.getLenientEof();
    this.trailingData = format.getTrailingData();
    this.delimiterBuf = new char[delimiter.length - 1];
    this.escapeDelimiterBuf = new char[2 * delimiter.length - 1];
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.<init>(CSVFormat,ExtendedBufferedReader).format","Parameter_1","Belong to org.apache.commons.csv.Lexer.<init>(CSVFormat,ExtendedBufferedReader)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Lexer.<init>(CSVFormat,ExtendedBufferedReader).reader","Parameter_2","Belong to org.apache.commons.csv.Lexer.<init>(CSVFormat,ExtendedBufferedReader)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token","Class","* Internal token representation.
 * <p>
 * It is used as a contract between the lexer and the parser.
 * </p>","Class do not obtain Source Code","No return type","final ","",""
"org.apache.commons.csv.Token.INITIAL_TOKEN_LENGTH","Field","Length of the initial token (content-)buffer","private static final int INITIAL_TOKEN_LENGTH = 50;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.type","Field","Token type","Token.Type type = INVALID;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.content","Field","The content buffer.","final StringBuilder content = new StringBuilder(INITIAL_TOKEN_LENGTH);","No return type","final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.isReady","Field","Token ready flag: indicates a valid token with content (ready for the parser).","boolean isReady;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.isQuoted","Field","No Comment","boolean isQuoted;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.reset()","Method","No Comment","void reset() {
    content.setLength(0);
    type = INVALID;
    isReady = false;
    isQuoted = false;
}","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.toString()","Method","* Eases IDE debugging.
     *
     * @return a string helpful for debugging.","@Override
public String toString() {
    return type.name() + "" ["" + content.toString() + ""]"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token$Type","Enum","No Comment","Enum do not obtain Source Code","No return type","","enum has no extends",""
"org.apache.commons.csv.Token$Type","Enum","No Comment","Enum do not obtain Source Code","No return type","default","enum has no extends",""
"org.apache.commons.csv.Token$Type.INVALID","Enum Constant","Token has no valid content, i.e. is in its initialized state.","INVALID","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token$Type.TOKEN","Enum Constant","Token with content, at the beginning or in the middle of a line.","TOKEN","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token$Type.EOF","Enum Constant","Token (which can have content) when the end of file is reached.","EOF","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token$Type.EORECORD","Enum Constant","Token with content when the end of a line is reached.","EORECORD","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token$Type.COMMENT","Enum Constant","Token is a comment line.","COMMENT","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.Type","Enum","No Comment","Enum do not obtain Source Code","No return type","default","enum has no extends",""
"org.apache.commons.csv.Token.Type.INVALID","Enum Constant","Token has no valid content, i.e. is in its initialized state.","INVALID","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.Type.TOKEN","Enum Constant","Token with content, at the beginning or in the middle of a line.","TOKEN","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.Type.EOF","Enum Constant","Token (which can have content) when the end of file is reached.","EOF","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.Type.EORECORD","Enum Constant","Token with content when the end of a line is reached.","EORECORD","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Token.Type.COMMENT","Enum Constant","Token is a comment line.","COMMENT","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVException","Class","* Signals a CSV exception. For example, this exception is thrown when parsing invalid input.
 *
 * @since 1.12.0","Class do not obtain Source Code","No return type","public ","java.io.IOException",""
"org.apache.commons.csv.CSVException.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVException.<init>(String,Object[])","Constructor","* Constructs a new instance with a formatted message.
     *
     * @param format A {@link Formatter} format string.
     * @param args   See {@link String#format(String, Object...)}.
     * @throws IllegalFormatException See {@link String#format(String, Object...)}.","public CSVException(final String format, final Object... args) {
    super(String.format(format, args));
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVException.<init>(String,Object[]).format","Parameter_1","Belong to org.apache.commons.csv.CSVException.<init>(String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVException.<init>(String,Object[]).args","Parameter_2","Belong to org.apache.commons.csv.CSVException.<init>(String,Object[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.DuplicateHeaderMode","Enum","* Determines how duplicate header fields should be handled
 * if {@link CSVFormat.Builder#setHeader(Class)} is not null.
 *
 * @since 1.10.0","Enum do not obtain Source Code","No return type","public ","enum has no extends",""
"org.apache.commons.csv.DuplicateHeaderMode.ALLOW_ALL","Enum Constant","* Allows all duplicate headers.","ALLOW_ALL","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.DuplicateHeaderMode.ALLOW_EMPTY","Enum Constant","* Allows duplicate headers only if they're empty, blank, or null strings.","ALLOW_EMPTY","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.DuplicateHeaderMode.DISALLOW","Enum Constant","* Disallows duplicate headers entirely.","DISALLOW","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants","Class","* Private constants for this package.","Class do not obtain Source Code","No return type","final ","",""
"org.apache.commons.csv.Constants.BACKSLASH","Field","No Comment","static final char BACKSLASH = '\\';","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.BACKSPACE","Field","No Comment","static final char BACKSPACE = '\b';","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.COMMA","Field","No Comment","static final String COMMA = "","";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.COMMENT","Field","* Starts a comment, the remainder of the line is the comment.","static final char COMMENT = '#';","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.CR","Field","No Comment","static final char CR = '\r';","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.CRLF","Field","RFC 4180 defines line breaks as CRLF.","static final String CRLF = ""\r\n"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR","Field","Explicit (un)boxing is intentional.","static final Character DOUBLE_QUOTE_CHAR = Character.valueOf('""');","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.EMPTY","Field","No Comment","static final String EMPTY = """";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.EMPTY_STRING_ARRAY","Field","No Comment","static final String[] EMPTY_STRING_ARRAY = {};","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.FF","Field","No Comment","static final char FF = '\f';","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.LF","Field","No Comment","static final char LF = '\n';","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.LINE_SEPARATOR","Field","* Unicode line separator.","static final String LINE_SEPARATOR = ""\u2028"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.NEXT_LINE","Field","* Unicode next line.","static final String NEXT_LINE = ""\u0085"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.PARAGRAPH_SEPARATOR","Field","* Unicode paragraph separator.","static final String PARAGRAPH_SEPARATOR = ""\u2029"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.PIPE","Field","No Comment","static final char PIPE = '|';","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.RS","Field","ASCII record separator.","static final char RS = 30;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.SP","Field","No Comment","static final char SP = ' ';","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.SQL_NULL_STRING","Field","No Comment","static final String SQL_NULL_STRING = ""\\N"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.TAB","Field","No Comment","static final char TAB = '\t';","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.UNDEFINED","Field","Undefined state for the lookahead char.","static final int UNDEFINED = -2;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.US","Field","ASCII unit separator.","static final char US = 31;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.Constants.<init>()","Constructor","No instances.","private Constants() {
    // noop
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord","Class","* A CSV record parsed from a CSV file.
 *
 * <p>
 * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.
 * In version 1.8 the mapping between the column header and the column index was
 * removed from the serialized state. The class maintains serialization compatibility
 * with versions pre-1.8 for the record values; these must be accessed by index
 * following deserialization. There will be a loss of any functionally linked to the header
 * mapping when transferring serialized forms pre-1.8 to 1.8 and vice versa.
 * </p>","Class do not obtain Source Code","No return type","public , final ","","java.io.Serializable;java.lang.Iterable"
"org.apache.commons.csv.CSVRecord.serialVersionUID","Field","No Comment","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.characterPosition","Field","* The start position of this record as a character position in the source stream. This may or may not correspond to the byte position depending on the
     * character set.","private final long characterPosition;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.bytePosition","Field","* The starting position of this record in the source stream, measured in bytes.","private final long bytePosition;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.comment","Field","The accumulated comments (if any)","private final String comment;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.recordNumber","Field","The record number.","private final long recordNumber;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.values","Field","The values of the record","private final String[] values;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.parser","Field","The parser that originates this record. This is not serialized.","private final transient CSVParser parser;","No return type","private , final , transient ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.get(Enum)","Method","* Returns a value by {@link Enum}.
     *
     * @param e
     *            an enum
     * @return the String at the given enum String","public String get(final Enum<?> e) {
    return get(e == null ? null : e.name());
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.get(Enum).e","Parameter_1","Belong to org.apache.commons.csv.CSVRecord.get(Enum)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.get(int)","Method","* Returns a value by index.
     *
     * @param i
     *            a column index (0-based)
     * @return the String at the given index","public String get(final int i) {
    return values[i];
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.get(int).i","Parameter_1","Belong to org.apache.commons.csv.CSVRecord.get(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.get(String)","Method","* Returns a value by name. If multiple instances of the header name exists, only the last occurrence is returned.
     *
     * <p>
     * Note: This requires a field mapping obtained from the original parser.
     * A check using {@link #isMapped(String)} should be used to determine if a
     * mapping exists from the provided {@code name} to a field index. In this case an
     * exception will only be thrown if the record does not contain a field corresponding
     * to the mapping, that is the record length is not consistent with the mapping size.
     * </p>
     *
     * @param name
     *            the name of the column to be retrieved.
     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.
     * @throws IllegalStateException
     *             if no header mapping was provided
     * @throws IllegalArgumentException
     *             if {@code name} is not mapped or if the record is inconsistent
     * @see #isMapped(String)
     * @see #isConsistent()
     * @see #getParser()
     * @see CSVFormat.Builder#setNullString(String)","public String get(final String name) {
    final Map<String, Integer> headerMap = getHeaderMapRaw();
    if (headerMap == null) {
        throw new IllegalStateException(""No header mapping was specified, the record values can't be accessed by name"");
    }
    final Integer index = headerMap.get(name);
    if (index == null) {
        throw new IllegalArgumentException(String.format(""Mapping for %s not found, expected one of %s"", name, headerMap.keySet()));
    }
    try {
        // N.B. Explicit (un)boxing is intentional
        return values[index.intValue()];
    } catch (final ArrayIndexOutOfBoundsException e) {
        throw new IllegalArgumentException(String.format(""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index, // N.B. Explicit (un)boxing is intentional
        Integer.valueOf(values.length)));
    }
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.get(String).name","Parameter_1","Belong to org.apache.commons.csv.CSVRecord.get(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.getBytePosition()","Method","* Returns the starting position of this record in the source stream, measured in bytes.
     *
     * @return the byte position of this record in the source stream.
     * @since 1.13.0","public long getBytePosition() {
    return bytePosition;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.getCharacterPosition()","Method","* Returns the start position of this record as a character position in the source stream. This may or may not
     * correspond to the byte position depending on the character set.
     *
     * @return the position of this record in the source stream.","public long getCharacterPosition() {
    return characterPosition;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.getComment()","Method","* Returns the comment for this record, if any.
     * Note that comments are attached to the following record.
     * If there is no following record (i.e. the comment is at EOF),
     * then the comment will be ignored.
     *
     * @return the comment for this record, or null if no comment for this record is available.","public String getComment() {
    return comment;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.getHeaderMapRaw()","Method","No Comment","private Map<String, Integer> getHeaderMapRaw() {
    return parser == null ? null : parser.getHeaderMapRaw();
}","Map","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.getParser()","Method","* Returns the parser.
     *
     * <p>
     * Note: The parser is not part of the serialized state of the record. A null check
     * should be used when the record may have originated from a serialized form.
     * </p>
     *
     * @return the parser.
     * @since 1.7","public CSVParser getParser() {
    return parser;
}","CSVParser","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.getRecordNumber()","Method","* Returns the number of this record in the parsed CSV file.
     *
     * <p>
     * <strong>NOTE:</strong>If your CSV input has multi-line values, the returned number does not correspond to
     * the current line number of the parser that created this record.
     * </p>
     *
     * @return the number of this record.
     * @see CSVParser#getCurrentLineNumber()","public long getRecordNumber() {
    return recordNumber;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.hasComment()","Method","* Checks whether this record has a comment, false otherwise.
     * Note that comments are attached to the following record.
     * If there is no following record (i.e. the comment is at EOF),
     * then the comment will be ignored.
     *
     * @return true if this record has a comment, false otherwise
     * @since 1.3","public boolean hasComment() {
    return comment != null;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.isConsistent()","Method","* Tells whether the record size matches the header size.
     *
     * <p>
     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this
     * test but still produce parsable files.
     * </p>
     *
     * @return true of this record is valid, false if not","public boolean isConsistent() {
    final Map<String, Integer> headerMap = getHeaderMapRaw();
    return headerMap == null || headerMap.size() == values.length;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.isMapped(String)","Method","* Checks whether a given column is mapped, i.e. its name has been defined to the parser.
     *
     * @param name
     *            the name of the column to be retrieved.
     * @return whether a given column is mapped.","public boolean isMapped(final String name) {
    final Map<String, Integer> headerMap = getHeaderMapRaw();
    return headerMap != null && headerMap.containsKey(name);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.isMapped(String).name","Parameter_1","Belong to org.apache.commons.csv.CSVRecord.isMapped(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.isSet(int)","Method","* Checks whether a column with a given index has a value.
     *
     * @param index
     *         a column index (0-based)
     * @return whether a column with a given index has a value","public boolean isSet(final int index) {
    return 0 <= index && index < values.length;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.isSet(int).index","Parameter_1","Belong to org.apache.commons.csv.CSVRecord.isSet(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.isSet(String)","Method","* Checks whether a given column is mapped and has a value.
     *
     * @param name
     *            the name of the column to be retrieved.
     * @return whether a given column is mapped and has a value","public boolean isSet(final String name) {
    // N.B. Explicit (un)boxing is intentional
    return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.isSet(String).name","Parameter_1","Belong to org.apache.commons.csv.CSVRecord.isSet(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.iterator()","Method","* Returns an iterator over the values of this record.
     *
     * @return an iterator over the values of this record.","@Override
public Iterator<String> iterator() {
    return toList().iterator();
}","Iterator","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.putIn(Map)","Method","* Puts all values of this record into the given Map.
     *
     * @param <M> the map type
     * @param map The Map to populate.
     * @return the given map.
     * @since 1.9.0","public <M extends Map<String, String>> M putIn(final M map) {
    if (getHeaderMapRaw() == null) {
        return map;
    }
    getHeaderMapRaw().forEach((key, value) -> {
        if (value < values.length) {
            map.put(key, values[value]);
        }
    });
    return map;
}","Map<String, String>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.putIn(Map).map","Parameter_1","Belong to org.apache.commons.csv.CSVRecord.putIn(Map)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.size()","Method","* Returns the number of values in this record.
     *
     * @return the number of values.","public int size() {
    return values.length;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.stream()","Method","* Returns a sequential ordered stream whose elements are the values.
     *
     * @return the new stream.
     * @since 1.9.0","public Stream<String> stream() {
    return Stream.of(values);
}","Stream","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.toList()","Method","* Converts the values to a new List.
     * <p>
     * Editing the list does not update this instance.
     * </p>
     *
     * @return a new List
     * @since 1.9.0","public List<String> toList() {
    return stream().collect(Collectors.toList());
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.toMap()","Method","* Copies this record into a new Map of header name to record value. If multiple instances of a header name exist,
     * then only the last occurrence is mapped.
     *
     * <p>
     * Editing the map does not update this instance.
     * </p>
     *
     * @return A new Map. The map is empty if the record has no headers.","public Map<String, String> toMap() {
    return putIn(new LinkedHashMap<>(values.length));
}","Map","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.toString()","Method","* Returns a string representation of the contents of this record. The result is constructed by comment, mapping,
     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.
     *
     * @return a String representation of this record.","@Override
public String toString() {
    return ""CSVRecord [comment='"" + comment + ""', recordNumber="" + recordNumber + "", values="" + Arrays.toString(values) + ""]"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.values()","Method","* Gets the values for this record. This is not a copy.
     *
     * @return the values for this record.
     * @since 1.10.0","public String[] values() {
    return values;
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long)","Constructor","No Comment","CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber, final long characterPosition, final long bytePosition) {
    this.recordNumber = recordNumber;
    this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;
    this.parser = parser;
    this.comment = comment;
    this.characterPosition = characterPosition;
    this.bytePosition = bytePosition;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long).parser","Parameter_1","Belong to org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long).values","Parameter_2","Belong to org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long).comment","Parameter_3","Belong to org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long).recordNumber","Parameter_4","Belong to org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long).characterPosition","Parameter_5","Belong to org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long).bytePosition","Parameter_6","Belong to org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
