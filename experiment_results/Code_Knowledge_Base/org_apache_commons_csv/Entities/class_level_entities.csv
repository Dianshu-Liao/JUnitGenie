FEN:ID,:LABEL,Comment,Modifiers,Extends,Implements
org.apache.commons.csv.CSVParser,Class,"* Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record-wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for (CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>{@code\n * File csvData = new File(""/path/to/csv"");\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }}\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=""https://tools.ietf.org/html/rfc4180"" target=""_blank"">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hand, custom formats can be defined. More information about\n * customizing CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record-wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>{@code\n * Reader in = new StringReader(""a;b\nc;d"");\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List<CSVRecord> list = parser.getRecords();\n * }</pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in-memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example, if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * The internal parser state is completely covered by the format and the reader state.\n * </p>\n *\n * @see <a href=""package-summary.html"">package documentation for more details</a>","public , final ",,java.lang.Iterable;java.io.Closeable
org.apache.commons.csv.CSVParser$Builder,Class,* Builds a new {@link CSVParser}.\n     *\n     * @since 1.13.0,"public , static ",org.apache.commons.io.build.AbstractStreamBuilder,
org.apache.commons.csv.CSVParser$CSVRecordIterator,Class,No Comment,final ,,java.util.Iterator
org.apache.commons.csv.CSVParser$Headers,Class,* Header information based on name and position.,"private , static , final ",,
org.apache.commons.csv.CSVPrinter,Class,"* Prints values in a {@link CSVFormat CSV format}.\n *\n * <p>Values can be appended to the output by calling the {@link #print(Object)} method.\n * Values are printed according to {@link String#valueOf(Object)}.\n * To complete a record the {@link #println()} method has to be called.\n * Comments can be appended by calling {@link #printComment(String)}.\n * However a comment will only be written to the output if the {@link CSVFormat} supports comments.\n * </p>\n *\n * <p>The printer also supports appending a complete record at once by calling {@link #printRecord(Object...)}\n * or {@link #printRecord(Iterable)}.\n * Furthermore {@link #printRecords(Object...)}, {@link #printRecords(Iterable)} and {@link #printRecords(ResultSet)}\n * methods can be used to print several records at once.\n * </p>\n *\n * <p>Example:</p>\n *\n * <pre>\n * try (CSVPrinter printer = new CSVPrinter(new FileWriter(""csv.txt""), CSVFormat.EXCEL)) {\n *     printer.printRecord(""id"", ""userName"", ""firstName"", ""lastName"", ""birthday"");\n *     printer.printRecord(1, ""john73"", ""John"", ""Doe"", LocalDate.of(1973, 9, 15));\n *     printer.println();\n *     printer.printRecord(2, ""mary"", ""Mary"", ""Meyer"", LocalDate.of(1985, 3, 29));\n * } catch (IOException ex) {\n *     ex.printStackTrace();\n * }\n * </pre>\n *\n * <p>This code will write the following to csv.txt:</p>\n * <pre>\n * id,userName,firstName,lastName,birthday\n * 1,john73,John,Doe,1973-09-15\n *\n * 2,mary,Mary,Meyer,1985-03-29\n * </pre>","public , final ",,java.io.Flushable;java.io.Closeable
org.apache.commons.csv.CSVFormat,Class,"* Specifies the format of a CSV file for parsing and writing.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MONGODB_CSV}</li>\n * <li>{@link #MONGODB_TSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code set} methods. For example:\n * </p>\n *\n * <pre>{@code\n * CSVFormat.EXCEL.builder().setNullString(""N/A"").setIgnoreSurroundingSpaces(true).get();\n * }</pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>{@code\n * CSVFormat.EXCEL.builder().setHeader(""Col1"", ""Col2"", ""Col3"").get();\n * }</pre>\n *\n * <p>\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\n * contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>{@code\n * Reader in = ...;\n * CSVFormat.EXCEL.builder().setHeader(""Col1"", ""Col2"", ""Col3"").get().parse(in);\n * }</pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\n * arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.builder().setHeader().get();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>{@code\n * String value = record.get(""Col1"");\n * }</pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Serialization</h2>\n * <p>\n * This class implements the {@link Serializable} interface with the following caveats:\n * </p>\n * <ul>\n * <li>This class will no longer implement Serializable in 2.0.</li>\n * <li>Serialization is not supported from one version to the next.</li>\n * </ul>\n * <p>\n * The {@code serialVersionUID} values are:\n * </p>\n * <ul>\n * <li>Version 1.10.0: {@code 2L}</li>\n * <li>Version 1.9.0 through 1.0: {@code 1L}</li>\n * </ul>\n *\n * <h2>Notes</h2>\n * <p>\n * This class is immutable.\n * </p>\n * <p>\n * Not all settings are used for both parsing and writing.\n * </p>","public , final ",,java.io.Serializable
org.apache.commons.csv.CSVFormat$Builder,Class,* Builds CSVFormat instances.\n     *\n     * @since 1.9.0,"public , static ",,java.util.function.Supplier
org.apache.commons.csv.CSVFormat$Predefined,Enum,* Predefines formats.\n     *\n     * @since 1.2,public ,enum has no extends,
org.apache.commons.csv.ExtendedBufferedReader,Class,"* A special buffered reader which supports sophisticated read access.\n * <p>\n * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n * {@link #read()}. This reader also tracks how many characters have been read with {@link #getPosition()}.\n * </p>",final ,org.apache.commons.io.input.UnsynchronizedBufferedReader,
org.apache.commons.csv.QuoteMode,Enum,* Defines quoting behavior.,public ,enum has no extends,
org.apache.commons.csv.Lexer,Class,* Lexical analyzer.,final ,,java.io.Closeable
org.apache.commons.csv.Token,Class,* Internal token representation.\n * <p>\n * It is used as a contract between the lexer and the parser.\n * </p>,final ,,
org.apache.commons.csv.Token$Type,Enum,No Comment,,enum has no extends,
org.apache.commons.csv.CSVException,Class,"* Signals a CSV exception. For example, this exception is thrown when parsing invalid input.\n *\n * @since 1.12.0",public ,java.io.IOException,
org.apache.commons.csv.DuplicateHeaderMode,Enum,* Determines how duplicate header fields should be handled\n * if {@link CSVFormat.Builder#setHeader(Class)} is not null.\n *\n * @since 1.10.0,public ,enum has no extends,
org.apache.commons.csv.Constants,Class,* Private constants for this package.,final ,,
org.apache.commons.csv.CSVRecord,Class,* A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialized state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be a loss of any functionally linked to the header\n * mapping when transferring serialized forms pre-1.8 to 1.8 and vice versa.\n * </p>,"public , final ",,java.io.Serializable;java.lang.Iterable
