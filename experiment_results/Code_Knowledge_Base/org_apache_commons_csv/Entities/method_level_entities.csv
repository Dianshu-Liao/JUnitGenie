FEN:ID,:LABEL,Comment,Source Code,Signature,CFG,Modifiers
org.apache.commons.csv.CSVParser.builder(),Method,* Creates a new builder.\n     *\n     * @return a new builder.\n     * @since 1.13.0,public static Builder builder() {\n    return new Builder();\n},org.apache.commons.csv.CSVParser$Builder builder(),"digraph cfg_builder {\n	""1"" [label=""$stack0 = new org.apache.commons.csv.CSVParser$Builder""];\n	""2"" [label=""return $stack0""];\n	""3"" [label=""specialinvoke $stack0.<org.apache.commons.csv.CSVParser$Builder: void <init>()>()""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n}\n","public , static "
"org.apache.commons.csv.CSVParser.parse(File,Charset,CSVFormat)",Method,* Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws CSVException Thrown on invalid input.,"public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n    Objects.requireNonNull(file, ""file"");\n    return parse(file.toPath(), charset, format);\n}","org.apache.commons.csv.CSVParser parse(java.io.File,java.nio.charset.Charset,org.apache.commons.csv.CSVFormat)","digraph cfg_parse {\n	""1"" [label=""$stack3 = virtualinvoke file.<java.io.File: java.nio.file.Path toPath()>()""];\n	""2"" [label=""$stack4 = staticinvoke <org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser parse(java.nio.file.Path,java.nio.charset.Charset,org.apache.commons.csv.CSVFormat)>($stack3, charset, format)""];\n	""3"" [label=""charset := @parameter1: java.nio.charset.Charset""];\n	""4"" [label=""file := @parameter0: java.io.File""];\n	""5"" [label=""format := @parameter2: org.apache.commons.csv.CSVFormat""];\n	""6"" [label=""return $stack4""];\n	""7"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(file, \""file\"")""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""1""[label=""cfg_next""];\n}\n","public , static "
"org.apache.commons.csv.CSVParser.parse(InputStream,Charset,CSVFormat)",Method,"* Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @throws CSVException Thrown on invalid input.\n     * @since 1.5","@SuppressWarnings(""resource"")\npublic static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException {\n    Objects.requireNonNull(inputStream, ""inputStream"");\n    Objects.requireNonNull(format, ""format"");\n    return parse(new InputStreamReader(inputStream, charset), format);\n}","org.apache.commons.csv.CSVParser parse(java.io.InputStream,java.nio.charset.Charset,org.apache.commons.csv.CSVFormat)","digraph cfg_parse {\n	""1"" [label=""$stack3 = new java.io.InputStreamReader""];\n	""2"" [label=""$stack4 = staticinvoke <org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser parse(java.io.Reader,org.apache.commons.csv.CSVFormat)>($stack3, format)""];\n	""3"" [label=""charset := @parameter1: java.nio.charset.Charset""];\n	""4"" [label=""format := @parameter2: org.apache.commons.csv.CSVFormat""];\n	""5"" [label=""inputStream := @parameter0: java.io.InputStream""];\n	""6"" [label=""return $stack4""];\n	""7"" [label=""specialinvoke $stack3.<java.io.InputStreamReader: void <init>(java.io.InputStream,java.nio.charset.Charset)>(inputStream, charset)""];\n	""8"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(format, \""format\"")""];\n	""9"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(inputStream, \""inputStream\"")""];\n	""1"" -> ""7""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""9""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""7"" -> ""2""[label=""cfg_next""];\n	""8"" -> ""1""[label=""cfg_next""];\n	""9"" -> ""8""[label=""cfg_next""];\n}\n","public , static "
"org.apache.commons.csv.CSVParser.parse(Path,Charset,CSVFormat)",Method,"* Creates and returns a parser for the given {@link Path}, which the caller MUST close.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws CSVException Thrown on invalid input.\n     * @since 1.5","@SuppressWarnings(""resource"")\npublic static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n    Objects.requireNonNull(path, ""path"");\n    Objects.requireNonNull(format, ""format"");\n    return parse(Files.newInputStream(path), charset, format);\n}","org.apache.commons.csv.CSVParser parse(java.nio.file.Path,java.nio.charset.Charset,org.apache.commons.csv.CSVFormat)","digraph cfg_parse {\n	""1"" [label=""$stack3 = newarray (java.nio.file.OpenOption)[0]""];\n	""2"" [label=""$stack4 = staticinvoke <java.nio.file.Files: java.io.InputStream newInputStream(java.nio.file.Path,java.nio.file.OpenOption[])>(path, $stack3)""];\n	""3"" [label=""$stack5 = staticinvoke <org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser parse(java.io.InputStream,java.nio.charset.Charset,org.apache.commons.csv.CSVFormat)>($stack4, charset, format)""];\n	""4"" [label=""charset := @parameter1: java.nio.charset.Charset""];\n	""5"" [label=""format := @parameter2: org.apache.commons.csv.CSVFormat""];\n	""6"" [label=""path := @parameter0: java.nio.file.Path""];\n	""7"" [label=""return $stack5""];\n	""8"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(format, \""format\"")""];\n	""9"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(path, \""path\"")""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""7""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""9""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n	""8"" -> ""1""[label=""cfg_next""];\n	""9"" -> ""8""[label=""cfg_next""];\n}\n","public , static "
"org.apache.commons.csv.CSVParser.parse(Reader,CSVFormat)",Method,"* Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @throws CSVException Thrown on invalid input.\n     * @since 1.5","public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n    return builder().setReader(reader).setFormat(format).get();\n}","org.apache.commons.csv.CSVParser parse(java.io.Reader,org.apache.commons.csv.CSVFormat)","digraph cfg_parse {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.io.build.AbstractOriginSupplier setReader(java.io.Reader)>(reader)""];\n	""3"" [label=""$stack4 = (org.apache.commons.csv.CSVParser$Builder) $stack3""];\n	""4"" [label=""$stack5 = virtualinvoke $stack4.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.csv.CSVParser$Builder setFormat(org.apache.commons.csv.CSVFormat)>(format)""];\n	""5"" [label=""$stack6 = virtualinvoke $stack5.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.csv.CSVParser get()>()""];\n	""6"" [label=""format := @parameter1: org.apache.commons.csv.CSVFormat""];\n	""7"" [label=""reader := @parameter0: java.io.Reader""];\n	""8"" [label=""return $stack6""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""8""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n}\n","public , static "
"org.apache.commons.csv.CSVParser.parse(String,CSVFormat)",Method,* Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws CSVException Thrown on invalid input.,"public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n    Objects.requireNonNull(string, ""string"");\n    Objects.requireNonNull(format, ""format"");\n    return parse(new StringReader(string), format);\n}","org.apache.commons.csv.CSVParser parse(java.lang.String,org.apache.commons.csv.CSVFormat)","digraph cfg_parse {\n	""1"" [label=""$stack2 = new java.io.StringReader""];\n	""2"" [label=""$stack3 = staticinvoke <org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser parse(java.io.Reader,org.apache.commons.csv.CSVFormat)>($stack2, format)""];\n	""3"" [label=""format := @parameter1: org.apache.commons.csv.CSVFormat""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""specialinvoke $stack2.<java.io.StringReader: void <init>(java.lang.String)>(string)""];\n	""6"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(format, \""format\"")""];\n	""7"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(string, \""string\"")""];\n	""8"" [label=""string := @parameter0: java.lang.String""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""7""[label=""cfg_next""];\n	""5"" -> ""2""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n	""8"" -> ""3""[label=""cfg_next""];\n}\n","public , static "
"org.apache.commons.csv.CSVParser.parse(URL,Charset,CSVFormat)",Method,"* Creates and returns a parser for the given URL, which the caller MUST close.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws CSVException Thrown on invalid input.","@SuppressWarnings(""resource"")\npublic static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n    Objects.requireNonNull(url, ""url"");\n    return parse(url.openStream(), charset, format);\n}","org.apache.commons.csv.CSVParser parse(java.net.URL,java.nio.charset.Charset,org.apache.commons.csv.CSVFormat)","digraph cfg_parse {\n	""1"" [label=""$stack3 = virtualinvoke url.<java.net.URL: java.io.InputStream openStream()>()""];\n	""2"" [label=""$stack4 = staticinvoke <org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser parse(java.io.InputStream,java.nio.charset.Charset,org.apache.commons.csv.CSVFormat)>($stack3, charset, format)""];\n	""3"" [label=""charset := @parameter1: java.nio.charset.Charset""];\n	""4"" [label=""format := @parameter2: org.apache.commons.csv.CSVFormat""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(url, \""url\"")""];\n	""7"" [label=""url := @parameter0: java.net.URL""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n	""7"" -> ""3""[label=""cfg_next""];\n}\n","public , static "
org.apache.commons.csv.CSVParser.addRecordValue(boolean),Method,No Comment,private void addRecordValue(final boolean lastRecord) {\n    final String input = format.trim(reusableToken.content.toString());\n    if (lastRecord && input.isEmpty() && format.getTrailingDelimiter()) {\n        return;\n    }\n    recordList.add(handleNull(input));\n},void addRecordValue(boolean),"digraph cfg_addRecordValue {\n	""1"" [label=""$stack10 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""2"" [label=""$stack11 = virtualinvoke $stack10.<org.apache.commons.csv.CSVFormat: boolean getTrailingDelimiter()>()""];\n	""3"" [label=""$stack3 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""4"" [label=""$stack4 = $stack3.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""5"" [label=""$stack5 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""6"" [label=""$stack6 = virtualinvoke $stack4.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""7"" [label=""$stack7 = this.<org.apache.commons.csv.CSVParser: java.util.List recordList>""];\n	""8"" [label=""$stack8 = specialinvoke this.<org.apache.commons.csv.CSVParser: java.lang.String handleNull(java.lang.String)>(input)""];\n	""9"" [label=""$stack9 = virtualinvoke input.<java.lang.String: boolean isEmpty()>()""];\n	""10"" [label=""if $stack11 == 0""];\n	""11"" [label=""if $stack9 == 0""];\n	""12"" [label=""if lastRecord == 0""];\n	""13"" [label=""input = virtualinvoke $stack5.<org.apache.commons.csv.CSVFormat: java.lang.String trim(java.lang.String)>($stack6)""];\n	""14"" [label=""interfaceinvoke $stack7.<java.util.List: boolean add(java.lang.Object)>($stack8)""];\n	""15"" [label=""lastRecord := @parameter0: boolean""];\n	""16"" [label=""return""];\n	""17"" [label=""return""];\n	""18"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""16""[label=""cfg_false""];\n	""10"" -> ""7""[label=""cfg_true""];\n	""11"" -> ""1""[label=""cfg_false""];\n	""11"" -> ""7""[label=""cfg_true""];\n	""12"" -> ""7""[label=""cfg_true""];\n	""12"" -> ""9""[label=""cfg_false""];\n	""13"" -> ""12""[label=""cfg_next""];\n	""14"" -> ""17""[label=""cfg_next""];\n	""15"" -> ""5""[label=""cfg_next""];\n	""18"" -> ""15""[label=""cfg_next""];\n	""2"" -> ""10""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""13""[label=""cfg_next""];\n	""7"" -> ""8""[label=""cfg_next""];\n	""8"" -> ""14""[label=""cfg_next""];\n	""9"" -> ""11""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVParser.close(),Method,* Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs,@Override\npublic void close() throws IOException {\n    lexer.close();\n},void close(),"digraph cfg_close {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Lexer lexer>""];\n	""2"" [label=""return""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""4"" [label=""virtualinvoke $stack1.<org.apache.commons.csv.Lexer: void close()>()""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.createEmptyHeaderMap(),Method,No Comment,"private Map<String, Integer> createEmptyHeaderMap() {\n    return format.getIgnoreHeaderCase() ? new TreeMap<>(String.CASE_INSENSITIVE_ORDER) : new LinkedHashMap<>();\n}",java.util.Map createEmptyHeaderMap(),"digraph cfg_createEmptyHeaderMap {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat: boolean getIgnoreHeaderCase()>()""];\n	""3"" [label=""$stack3 = new java.util.LinkedHashMap""];\n	""4"" [label=""$stack3 = new java.util.TreeMap""];\n	""5"" [label=""$stack4 = <java.lang.String: java.util.Comparator CASE_INSENSITIVE_ORDER>""];\n	""6"" [label=""goto""];\n	""7"" [label=""if $stack2 == 0""];\n	""8"" [label=""return $stack3""];\n	""9"" [label=""specialinvoke $stack3.<java.util.LinkedHashMap: void <init>()>()""];\n	""10"" [label=""specialinvoke $stack3.<java.util.TreeMap: void <init>(java.util.Comparator)>($stack4)""];\n	""11"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""6""[label=""cfg_next""];\n	""11"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""9""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""10""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_goto""];\n	""7"" -> ""3""[label=""cfg_true""];\n	""7"" -> ""4""[label=""cfg_false""];\n	""9"" -> ""8""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVParser.createHeaders(),Method,* Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     * @throws CSVException on invalid input.,"private Headers createHeaders() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    List<String> headerNames = null;\n    final String[] formatHeader = format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = createEmptyHeaderMap();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord nextRecord = nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n                headerComment = nextRecord.getComment();\n            }\n        } else {\n            if (format.getSkipHeaderRecord()) {\n                final CSVRecord nextRecord = nextRecord();\n                if (nextRecord != null) {\n                    headerComment = nextRecord.getComment();\n                }\n            }\n            headerRecord = formatHeader;\n        }\n        // build the name to index mappings\n        if (headerRecord != null) {\n            // Track an occurrence of a null, empty or blank header.\n            boolean observedMissing = false;\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean blankHeader = CSVFormat.isBlank(header);\n                if (blankHeader && !format.getAllowMissingColumnNames()) {\n                    throw new IllegalArgumentException(""A header name is missing in "" + Arrays.toString(headerRecord));\n                }\n                final boolean containsHeader = blankHeader ? observedMissing : hdrMap.containsKey(header);\n                final DuplicateHeaderMode headerMode = format.getDuplicateHeaderMode();\n                final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n                final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n                if (containsHeader && !duplicatesAllowed && !(blankHeader && emptyDuplicatesAllowed)) {\n                    throw new IllegalArgumentException(String.format(""The header contains a duplicate name: \""%s\"" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode()."", header, Arrays.toString(headerRecord)));\n                }\n                observedMissing |= blankHeader;\n                if (header != null) {\n                    // N.B. Explicit (un)boxing is intentional\n                    hdrMap.put(header, Integer.valueOf(i));\n                    if (headerNames == null) {\n                        headerNames = new ArrayList<>(headerRecord.length);\n                    }\n                    headerNames.add(header);\n                }\n            }\n        }\n    }\n    // Make header names Collection immutable\n    return new Headers(hdrMap, headerNames == null ? Collections.emptyList() : Collections.unmodifiableList(headerNames));\n}",org.apache.commons.csv.CSVParser$Headers createHeaders(),"digraph cfg_createHeaders {\n	""1"" [label=""$stack13 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""2"" [label=""$stack14 = staticinvoke <java.util.Collections: java.util.List emptyList()>()""];\n	""3"" [label=""$stack14 = staticinvoke <java.util.Collections: java.util.List unmodifiableList(java.util.List)>(headerNames)""];\n	""4"" [label=""$stack15 = new org.apache.commons.csv.CSVParser$Headers""];\n	""5"" [label=""$stack16 = lengthof formatHeader""];\n	""6"" [label=""$stack17 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""7"" [label=""$stack18 = virtualinvoke $stack17.<org.apache.commons.csv.CSVFormat: boolean getSkipHeaderRecord()>()""];\n	""8"" [label=""$stack19 = lengthof headerRecord""];\n	""9"" [label=""$stack20 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""10"" [label=""$stack21 = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_ALL>""];\n	""11"" [label=""$stack22 = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_EMPTY>""];\n	""12"" [label=""$stack23 = staticinvoke <java.lang.Integer: java.lang.Integer valueOf(int)>(i)""];\n	""13"" [label=""$stack24 = lengthof headerRecord""];\n	""14"" [label=""$stack25 = new java.util.ArrayList""];\n	""15"" [label=""$stack26 = newarray (java.lang.Object)[2]""];\n	""16"" [label=""$stack26[0] = header""];\n	""17"" [label=""$stack26[1] = $stack27""];\n	""18"" [label=""$stack27 = staticinvoke <java.util.Arrays: java.lang.String toString(java.lang.Object[])>(headerRecord)""];\n	""19"" [label=""$stack28 = staticinvoke <java.lang.String: java.lang.String format(java.lang.String,java.lang.Object[])>(\""The header contains a duplicate name: \\""%s\\"" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\"", $stack26)""];\n	""20"" [label=""$stack29 = new java.lang.IllegalArgumentException""];\n	""21"" [label=""$stack30 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""22"" [label=""$stack31 = virtualinvoke $stack30.<org.apache.commons.csv.CSVFormat: boolean getAllowMissingColumnNames()>()""];\n	""23"" [label=""$stack32 = new java.lang.StringBuilder""];\n	""24"" [label=""$stack33 = staticinvoke <java.util.Arrays: java.lang.String toString(java.lang.Object[])>(headerRecord)""];\n	""25"" [label=""$stack34 = virtualinvoke $stack32.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""A header name is missing in \"")""];\n	""26"" [label=""$stack35 = virtualinvoke $stack34.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack33)""];\n	""27"" [label=""$stack36 = virtualinvoke $stack35.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""28"" [label=""$stack37 = new java.lang.IllegalArgumentException""];\n	""29"" [label=""$stack38 = virtualinvoke nextRecord.<org.apache.commons.csv.CSVRecord: java.lang.String getComment()>()""];\n	""30"" [label=""$stack39 = virtualinvoke nextRecord.<org.apache.commons.csv.CSVRecord: java.lang.String getComment()>()""];\n	""31"" [label=""blankHeader = staticinvoke <org.apache.commons.csv.CSVFormat: boolean isBlank(java.lang.String)>(header)""];\n	""32"" [label=""containsHeader = interfaceinvoke hdrMap.<java.util.Map: boolean containsKey(java.lang.Object)>(header)""];\n	""33"" [label=""containsHeader = nextRecord""];\n	""34"" [label=""duplicatesAllowed = 0""];\n	""35"" [label=""duplicatesAllowed = 1""];\n	""36"" [label=""emptyDuplicatesAllowed = 0""];\n	""37"" [label=""emptyDuplicatesAllowed = 1""];\n	""38"" [label=""formatHeader = virtualinvoke $stack13.<org.apache.commons.csv.CSVFormat: java.lang.String[] getHeader()>()""];\n	""39"" [label=""goto""];\n	""40"" [label=""goto""];\n	""41"" [label=""goto""];\n	""42"" [label=""goto""];\n	""43"" [label=""goto""];\n	""44"" [label=""goto""];\n	""45"" [label=""hdrMap = null""];\n	""46"" [label=""hdrMap = specialinvoke this.<org.apache.commons.csv.CSVParser: java.util.Map createEmptyHeaderMap()>()""];\n	""47"" [label=""header = headerRecord[i]""];\n	""48"" [label=""headerMode = virtualinvoke $stack20.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode getDuplicateHeaderMode()>()""];\n	""49"" [label=""headerNames = $stack25""];\n	""50"" [label=""headerNames = null""];\n	""51"" [label=""headerRecord = formatHeader""];\n	""52"" [label=""headerRecord = null""];\n	""53"" [label=""headerRecord = virtualinvoke nextRecord.<org.apache.commons.csv.CSVRecord: java.lang.String[] values()>()""];\n	""54"" [label=""i = 0""];\n	""55"" [label=""i = i + 1""];\n	""56"" [label=""if $stack16 != 0""];\n	""57"" [label=""if $stack18 == 0""];\n	""58"" [label=""if $stack31 != 0""];\n	""59"" [label=""if blankHeader == 0""];\n	""60"" [label=""if blankHeader == 0""];\n	""61"" [label=""if blankHeader == 0""];\n	""62"" [label=""if containsHeader == 0""];\n	""63"" [label=""if duplicatesAllowed != 0""];\n	""64"" [label=""if emptyDuplicatesAllowed != 0""];\n	""65"" [label=""if formatHeader == null""];\n	""66"" [label=""if header == null""];\n	""67"" [label=""if headerMode != $stack21""];\n	""68"" [label=""if headerMode != $stack22""];\n	""69"" [label=""if headerNames != null""];\n	""70"" [label=""if headerNames != null""];\n	""71"" [label=""if headerRecord == null""];\n	""72"" [label=""if i >= $stack19""];\n	""73"" [label=""if nextRecord == null""];\n	""74"" [label=""if nextRecord == null""];\n	""75"" [label=""interfaceinvoke hdrMap.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>(header, $stack23)""];\n	""76"" [label=""interfaceinvoke headerNames.<java.util.List: boolean add(java.lang.Object)>(header)""];\n	""77"" [label=""nextRecord = 0""];\n	""78"" [label=""nextRecord = nextRecord | blankHeader""];\n	""79"" [label=""nextRecord = virtualinvoke this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVRecord nextRecord()>()""];\n	""80"" [label=""nextRecord = virtualinvoke this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVRecord nextRecord()>()""];\n	""81"" [label=""return $stack15""];\n	""82"" [label=""specialinvoke $stack15.<org.apache.commons.csv.CSVParser$Headers: void <init>(java.util.Map,java.util.List)>(hdrMap, $stack14)""];\n	""83"" [label=""specialinvoke $stack25.<java.util.ArrayList: void <init>(int)>($stack24)""];\n	""84"" [label=""specialinvoke $stack29.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack28)""];\n	""85"" [label=""specialinvoke $stack32.<java.lang.StringBuilder: void <init>()>()""];\n	""86"" [label=""specialinvoke $stack37.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack36)""];\n	""87"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""88"" [label=""this.<org.apache.commons.csv.CSVParser: java.lang.String headerComment> = $stack38""];\n	""89"" [label=""this.<org.apache.commons.csv.CSVParser: java.lang.String headerComment> = $stack39""];\n	""90"" [label=""throw $stack29""];\n	""91"" [label=""throw $stack37""];\n	""1"" -> ""38""[label=""cfg_next""];\n	""10"" -> ""67""[label=""cfg_next""];\n	""11"" -> ""68""[label=""cfg_next""];\n	""12"" -> ""75""[label=""cfg_next""];\n	""13"" -> ""83""[label=""cfg_next""];\n	""14"" -> ""13""[label=""cfg_next""];\n	""15"" -> ""16""[label=""cfg_next""];\n	""16"" -> ""18""[label=""cfg_next""];\n	""17"" -> ""19""[label=""cfg_next""];\n	""18"" -> ""17""[label=""cfg_next""];\n	""19"" -> ""84""[label=""cfg_next""];\n	""2"" -> ""44""[label=""cfg_next""];\n	""20"" -> ""15""[label=""cfg_next""];\n	""21"" -> ""22""[label=""cfg_next""];\n	""22"" -> ""58""[label=""cfg_next""];\n	""23"" -> ""85""[label=""cfg_next""];\n	""24"" -> ""26""[label=""cfg_next""];\n	""25"" -> ""24""[label=""cfg_next""];\n	""26"" -> ""27""[label=""cfg_next""];\n	""27"" -> ""86""[label=""cfg_next""];\n	""28"" -> ""23""[label=""cfg_next""];\n	""29"" -> ""88""[label=""cfg_next""];\n	""3"" -> ""82""[label=""cfg_next""];\n	""30"" -> ""89""[label=""cfg_next""];\n	""31"" -> ""59""[label=""cfg_next""];\n	""32"" -> ""9""[label=""cfg_next""];\n	""33"" -> ""40""[label=""cfg_next""];\n	""34"" -> ""11""[label=""cfg_next""];\n	""35"" -> ""41""[label=""cfg_next""];\n	""36"" -> ""62""[label=""cfg_next""];\n	""37"" -> ""42""[label=""cfg_next""];\n	""38"" -> ""65""[label=""cfg_next""];\n	""39"" -> ""71""[label=""cfg_goto""];\n	""4"" -> ""70""[label=""cfg_next""];\n	""40"" -> ""9""[label=""cfg_goto""];\n	""41"" -> ""11""[label=""cfg_goto""];\n	""42"" -> ""62""[label=""cfg_goto""];\n	""43"" -> ""8""[label=""cfg_goto""];\n	""44"" -> ""82""[label=""cfg_goto""];\n	""45"" -> ""50""[label=""cfg_next""];\n	""46"" -> ""52""[label=""cfg_next""];\n	""47"" -> ""31""[label=""cfg_next""];\n	""48"" -> ""10""[label=""cfg_next""];\n	""49"" -> ""76""[label=""cfg_next""];\n	""5"" -> ""56""[label=""cfg_next""];\n	""50"" -> ""1""[label=""cfg_next""];\n	""51"" -> ""71""[label=""cfg_next""];\n	""52"" -> ""5""[label=""cfg_next""];\n	""53"" -> ""30""[label=""cfg_next""];\n	""54"" -> ""8""[label=""cfg_next""];\n	""55"" -> ""43""[label=""cfg_next""];\n	""56"" -> ""6""[label=""cfg_true""];\n	""56"" -> ""79""[label=""cfg_false""];\n	""57"" -> ""51""[label=""cfg_true""];\n	""57"" -> ""80""[label=""cfg_false""];\n	""58"" -> ""28""[label=""cfg_false""];\n	""58"" -> ""60""[label=""cfg_true""];\n	""59"" -> ""21""[label=""cfg_false""];\n	""59"" -> ""60""[label=""cfg_true""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""60"" -> ""32""[label=""cfg_true""];\n	""60"" -> ""33""[label=""cfg_false""];\n	""61"" -> ""20""[label=""cfg_true""];\n	""61"" -> ""64""[label=""cfg_false""];\n	""62"" -> ""63""[label=""cfg_false""];\n	""62"" -> ""78""[label=""cfg_true""];\n	""63"" -> ""61""[label=""cfg_false""];\n	""63"" -> ""78""[label=""cfg_true""];\n	""64"" -> ""20""[label=""cfg_false""];\n	""64"" -> ""78""[label=""cfg_true""];\n	""65"" -> ""4""[label=""cfg_true""];\n	""65"" -> ""46""[label=""cfg_false""];\n	""66"" -> ""12""[label=""cfg_false""];\n	""66"" -> ""55""[label=""cfg_true""];\n	""67"" -> ""34""[label=""cfg_true""];\n	""67"" -> ""35""[label=""cfg_false""];\n	""68"" -> ""36""[label=""cfg_true""];\n	""68"" -> ""37""[label=""cfg_false""];\n	""69"" -> ""14""[label=""cfg_false""];\n	""69"" -> ""76""[label=""cfg_true""];\n	""7"" -> ""57""[label=""cfg_next""];\n	""70"" -> ""2""[label=""cfg_false""];\n	""70"" -> ""3""[label=""cfg_true""];\n	""71"" -> ""4""[label=""cfg_true""];\n	""71"" -> ""77""[label=""cfg_false""];\n	""72"" -> ""4""[label=""cfg_true""];\n	""72"" -> ""47""[label=""cfg_false""];\n	""73"" -> ""39""[label=""cfg_true""];\n	""73"" -> ""53""[label=""cfg_false""];\n	""74"" -> ""29""[label=""cfg_false""];\n	""74"" -> ""51""[label=""cfg_true""];\n	""75"" -> ""69""[label=""cfg_next""];\n	""76"" -> ""55""[label=""cfg_next""];\n	""77"" -> ""54""[label=""cfg_next""];\n	""78"" -> ""66""[label=""cfg_next""];\n	""79"" -> ""73""[label=""cfg_next""];\n	""8"" -> ""72""[label=""cfg_next""];\n	""80"" -> ""74""[label=""cfg_next""];\n	""82"" -> ""81""[label=""cfg_next""];\n	""83"" -> ""49""[label=""cfg_next""];\n	""84"" -> ""90""[label=""cfg_next""];\n	""85"" -> ""25""[label=""cfg_next""];\n	""86"" -> ""91""[label=""cfg_next""];\n	""87"" -> ""45""[label=""cfg_next""];\n	""88"" -> ""51""[label=""cfg_next""];\n	""89"" -> ""39""[label=""cfg_next""];\n	""9"" -> ""48""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVParser.getCurrentLineNumber(),Method,"* Gets the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number",public long getCurrentLineNumber() {\n    return lexer.getCurrentLineNumber();\n},long getCurrentLineNumber(),"digraph cfg_getCurrentLineNumber {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Lexer lexer>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.Lexer: long getCurrentLineNumber()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.getFirstEndOfLine(),Method,* Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5,public String getFirstEndOfLine() {\n    return lexer.getFirstEol();\n},java.lang.String getFirstEndOfLine(),"digraph cfg_getFirstEndOfLine {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Lexer lexer>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.Lexer: java.lang.String getFirstEol()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.getHeaderComment(),Method,"* Gets the header comment, if any.\n     * The header comment appears before the header record.\n     *\n     * @return the header comment for this stream, or null if no comment is available.\n     * @since 1.10.0",public String getHeaderComment() {\n    return headerComment;\n},java.lang.String getHeaderComment(),"digraph cfg_getHeaderComment {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: java.lang.String headerComment>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.getHeaderMap(),Method,* Gets a copy of the header map as defined in the CSVFormat's header.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * <p>\n     * Note: The map can only provide a one-to-one mapping when the format did not\n     * contain null or duplicate column names.\n     * </p>\n     *\n     * @return a copy of the header map.,"public Map<String, Integer> getHeaderMap() {\n    if (headers.headerMap == null) {\n        return null;\n    }\n    final Map<String, Integer> map = createEmptyHeaderMap();\n    map.putAll(headers.headerMap);\n    return map;\n}",java.util.Map getHeaderMap(),"digraph cfg_getHeaderMap {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$Headers headers>""];\n	""2"" [label=""$stack3 = $stack2.<org.apache.commons.csv.CSVParser$Headers: java.util.Map headerMap>""];\n	""3"" [label=""$stack4 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$Headers headers>""];\n	""4"" [label=""$stack5 = $stack4.<org.apache.commons.csv.CSVParser$Headers: java.util.Map headerMap>""];\n	""5"" [label=""if $stack3 != null""];\n	""6"" [label=""interfaceinvoke map.<java.util.Map: void putAll(java.util.Map)>($stack5)""];\n	""7"" [label=""map = specialinvoke this.<org.apache.commons.csv.CSVParser: java.util.Map createEmptyHeaderMap()>()""];\n	""8"" [label=""return map""];\n	""9"" [label=""return null""];\n	""10"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_true""];\n	""5"" -> ""9""[label=""cfg_false""];\n	""6"" -> ""8""[label=""cfg_next""];\n	""7"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.getHeaderMapRaw(),Method,* Gets the underlying header map.\n     *\n     * @return the underlying header map.,"Map<String, Integer> getHeaderMapRaw() {\n    return headers.headerMap;\n}",java.util.Map getHeaderMapRaw(),"digraph cfg_getHeaderMapRaw {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$Headers headers>""];\n	""2"" [label=""$stack2 = $stack1.<org.apache.commons.csv.CSVParser$Headers: java.util.Map headerMap>""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVParser.getHeaderNames(),Method,* Gets a read-only list of header names that iterates in column order as defined in the CSVFormat's header.\n     * <p>\n     * Note: The list provides strings that can be used as keys in the header map.\n     * The list will not contain null column names if they were present in the input\n     * format.\n     * </p>\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @see #getHeaderMap()\n     * @since 1.7,public List<String> getHeaderNames() {\n    return Collections.unmodifiableList(headers.headerNames);\n},java.util.List getHeaderNames(),"digraph cfg_getHeaderNames {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$Headers headers>""];\n	""2"" [label=""$stack2 = $stack1.<org.apache.commons.csv.CSVParser$Headers: java.util.List headerNames>""];\n	""3"" [label=""$stack3 = staticinvoke <java.util.Collections: java.util.List unmodifiableList(java.util.List)>($stack2)""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.getRecordNumber(),Method,"* Gets the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number",public long getRecordNumber() {\n    return recordNumber;\n},long getRecordNumber(),"digraph cfg_getRecordNumber {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: long recordNumber>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.getRecords(),Method,"* Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows this method produces.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws UncheckedIOException\n     *             on parse error or input read-failure",public List<CSVRecord> getRecords() {\n    return stream().collect(Collectors.toList());\n},java.util.List getRecords(),"digraph cfg_getRecords {\n	""1"" [label=""$stack1 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>()""];\n	""2"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVParser: java.util.stream.Stream stream()>()""];\n	""3"" [label=""$stack3 = interfaceinvoke $stack2.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>($stack1)""];\n	""4"" [label=""$stack4 = (java.util.List) $stack3""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""6"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.getTrailerComment(),Method,"* Gets the trailer comment, if any.\n     * Trailer comments are located between the last record and EOF\n     *\n     * @return the trailer comment for this stream, or null if no comment is available.\n     * @since 1.10.0",public String getTrailerComment() {\n    return trailerComment;\n},java.lang.String getTrailerComment(),"digraph cfg_getTrailerComment {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: java.lang.String trailerComment>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.handleNull(String),Method,"* Handles whether the input is parsed as null\n     *\n     * @param input\n     *           the cell data to further processed\n     * @return null if input is parsed as null, or input itself if the input isn't parsed as null","private String handleNull(final String input) {\n    final boolean isQuoted = reusableToken.isQuoted;\n    final String nullString = format.getNullString();\n    final boolean strictQuoteMode = isStrictQuoteMode();\n    if (input.equals(nullString)) {\n        // nullString = NULL(String), distinguish between ""NULL"" and NULL in ALL_NON_NULL or NON_NUMERIC quote mode\n        return strictQuoteMode && isQuoted ? input : null;\n    }\n    // don't set nullString, distinguish between """" and ,, (absent values) in All_NON_NULL or NON_NUMERIC quote mode\n    return strictQuoteMode && nullString == null && input.isEmpty() && !isQuoted ? null : input;\n}",java.lang.String handleNull(java.lang.String),"digraph cfg_handleNull {\n	""1"" [label=""$stack10 = input""];\n	""2"" [label=""$stack10 = null""];\n	""3"" [label=""$stack5 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""4"" [label=""$stack6 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""5"" [label=""$stack7 = virtualinvoke input.<java.lang.String: boolean equals(java.lang.Object)>(nullString)""];\n	""6"" [label=""$stack8 = virtualinvoke input.<java.lang.String: boolean isEmpty()>()""];\n	""7"" [label=""$stack9 = input""];\n	""8"" [label=""$stack9 = null""];\n	""9"" [label=""goto""];\n	""10"" [label=""goto""];\n	""11"" [label=""if $stack7 == 0""];\n	""12"" [label=""if $stack8 == 0""];\n	""13"" [label=""if isQuoted != 0""];\n	""14"" [label=""if isQuoted == 0""];\n	""15"" [label=""if nullString != null""];\n	""16"" [label=""if strictQuoteMode == 0""];\n	""17"" [label=""if strictQuoteMode == 0""];\n	""18"" [label=""input := @parameter0: java.lang.String""];\n	""19"" [label=""isQuoted = $stack5.<org.apache.commons.csv.Token: boolean isQuoted>""];\n	""20"" [label=""nullString = virtualinvoke $stack6.<org.apache.commons.csv.CSVFormat: java.lang.String getNullString()>()""];\n	""21"" [label=""return $stack10""];\n	""22"" [label=""return $stack9""];\n	""23"" [label=""strictQuoteMode = specialinvoke this.<org.apache.commons.csv.CSVParser: boolean isStrictQuoteMode()>()""];\n	""24"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""9""[label=""cfg_next""];\n	""10"" -> ""22""[label=""cfg_goto""];\n	""11"" -> ""16""[label=""cfg_false""];\n	""11"" -> ""17""[label=""cfg_true""];\n	""12"" -> ""13""[label=""cfg_false""];\n	""12"" -> ""7""[label=""cfg_true""];\n	""13"" -> ""7""[label=""cfg_true""];\n	""13"" -> ""8""[label=""cfg_false""];\n	""14"" -> ""1""[label=""cfg_false""];\n	""14"" -> ""2""[label=""cfg_true""];\n	""15"" -> ""6""[label=""cfg_false""];\n	""15"" -> ""7""[label=""cfg_true""];\n	""16"" -> ""14""[label=""cfg_false""];\n	""16"" -> ""2""[label=""cfg_true""];\n	""17"" -> ""15""[label=""cfg_false""];\n	""17"" -> ""7""[label=""cfg_true""];\n	""18"" -> ""3""[label=""cfg_next""];\n	""19"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""21""[label=""cfg_next""];\n	""20"" -> ""23""[label=""cfg_next""];\n	""23"" -> ""5""[label=""cfg_next""];\n	""24"" -> ""18""[label=""cfg_next""];\n	""3"" -> ""19""[label=""cfg_next""];\n	""4"" -> ""20""[label=""cfg_next""];\n	""5"" -> ""11""[label=""cfg_next""];\n	""6"" -> ""12""[label=""cfg_next""];\n	""7"" -> ""22""[label=""cfg_next""];\n	""8"" -> ""10""[label=""cfg_next""];\n	""9"" -> ""21""[label=""cfg_goto""];\n}\n",private 
org.apache.commons.csv.CSVParser.hasHeaderComment(),Method,"* Checks whether there is a header comment.\n     * The header comment appears before the header record.\n     * Note that if the parser's format has been given an explicit header\n     * (with {@link CSVFormat.Builder#setHeader(String... )} or another overload)\n     * and the header record is not being skipped\n     * ({@link CSVFormat.Builder#setSkipHeaderRecord} is false) then any initial comments\n     * will be associated with the first record, not the header.\n     *\n     * @return true if this parser has seen a header comment, false otherwise\n     * @since 1.10.0",public boolean hasHeaderComment() {\n    return headerComment != null;\n},boolean hasHeaderComment(),"digraph cfg_hasHeaderComment {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: java.lang.String headerComment>""];\n	""2"" [label=""$stack2 = 0""];\n	""3"" [label=""$stack2 = 1""];\n	""4"" [label=""goto""];\n	""5"" [label=""if $stack1 == null""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.hasTrailerComment(),Method,"* Checks whether there is a trailer comment.\n     * Trailer comments are located between the last record and EOF.\n     * The trailer comments will only be available after the parser has\n     * finished processing this stream.\n     *\n     * @return true if this parser has seen a trailer comment, false otherwise\n     * @since 1.10.0",public boolean hasTrailerComment() {\n    return trailerComment != null;\n},boolean hasTrailerComment(),"digraph cfg_hasTrailerComment {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: java.lang.String trailerComment>""];\n	""2"" [label=""$stack2 = 0""];\n	""3"" [label=""$stack2 = 1""];\n	""4"" [label=""goto""];\n	""5"" [label=""if $stack1 == null""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.isClosed(),Method,* Tests whether this parser is closed.\n     *\n     * @return whether this parser is closed.,public boolean isClosed() {\n    return lexer.isClosed();\n},boolean isClosed(),"digraph cfg_isClosed {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Lexer lexer>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.Lexer: boolean isClosed()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.isStrictQuoteMode(),Method,* Tests whether the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or {@link QuoteMode#NON_NUMERIC}.\n     *\n     * @return true if the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or\n     *         {@link QuoteMode#NON_NUMERIC}.,private boolean isStrictQuoteMode() {\n    return format.getQuoteMode() == QuoteMode.ALL_NON_NULL || format.getQuoteMode() == QuoteMode.NON_NUMERIC;\n},boolean isStrictQuoteMode(),"digraph cfg_isStrictQuoteMode {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""2"" [label=""$stack2 = <org.apache.commons.csv.QuoteMode: org.apache.commons.csv.QuoteMode ALL_NON_NULL>""];\n	""3"" [label=""$stack3 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode getQuoteMode()>()""];\n	""4"" [label=""$stack4 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format>""];\n	""5"" [label=""$stack5 = <org.apache.commons.csv.QuoteMode: org.apache.commons.csv.QuoteMode NON_NUMERIC>""];\n	""6"" [label=""$stack6 = virtualinvoke $stack4.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode getQuoteMode()>()""];\n	""7"" [label=""$stack7 = 0""];\n	""8"" [label=""$stack7 = 1""];\n	""9"" [label=""goto""];\n	""10"" [label=""if $stack3 == $stack2""];\n	""11"" [label=""if $stack6 != $stack5""];\n	""12"" [label=""return $stack7""];\n	""13"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""10"" -> ""4""[label=""cfg_false""];\n	""10"" -> ""8""[label=""cfg_true""];\n	""11"" -> ""7""[label=""cfg_true""];\n	""11"" -> ""8""[label=""cfg_false""];\n	""13"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""10""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""11""[label=""cfg_next""];\n	""6"" -> ""5""[label=""cfg_next""];\n	""7"" -> ""12""[label=""cfg_next""];\n	""8"" -> ""9""[label=""cfg_next""];\n	""9"" -> ""12""[label=""cfg_goto""];\n}\n",private 
org.apache.commons.csv.CSVParser.iterator(),Method,"* Returns the record iterator.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration is re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed, the iterator will not yield any more records.\n     * A call to {@link Iterator#hasNext()} will return {@code false} and\n     * a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     * <p>\n     * If it is necessary to construct an iterator which is usable after the\n     * parser is closed, one option is to extract all records as a list with\n     * {@link #getRecords()}, and return an iterator to that list.\n     * </p>\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows an Iterator produces.\n     * </p>",@Override\npublic Iterator<CSVRecord> iterator() {\n    return csvRecordIterator;\n},java.util.Iterator iterator(),"digraph cfg_iterator {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$CSVRecordIterator csvRecordIterator>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser.nextRecord(),Method,"* Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached.\n     * @throws IOException  on parse error or input read-failure.\n     * @throws CSVException on invalid input.","CSVRecord nextRecord() throws IOException {\n    CSVRecord result = null;\n    recordList.clear();\n    StringBuilder sb = null;\n    final long startCharPosition = lexer.getCharacterPosition() + characterOffset;\n    final long startBytePosition = lexer.getBytesRead() + this.characterOffset;\n    do {\n        reusableToken.reset();\n        lexer.nextToken(reusableToken);\n        switch(reusableToken.type) {\n            case TOKEN:\n                addRecordValue(false);\n                break;\n            case EORECORD:\n                addRecordValue(true);\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    addRecordValue(true);\n                } else if (sb != null) {\n                    trailerComment = sb.toString();\n                }\n                break;\n            case INVALID:\n                throw new CSVException(""(line %,d) invalid parse sequence"", getCurrentLineNumber());\n            case // Ignored currently\n            COMMENT:\n                if (sb == null) {\n                    // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(reusableToken.content);\n                // Read another token\n                reusableToken.type = TOKEN;\n                break;\n            default:\n                throw new CSVException(""Unexpected Token type: %s"", reusableToken.type);\n        }\n    } while (reusableToken.type == TOKEN);\n    if (!recordList.isEmpty()) {\n        recordNumber++;\n        final String comment = Objects.toString(sb, null);\n        result = new CSVRecord(this, recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment, recordNumber, startCharPosition, startBytePosition);\n    }\n    return result;\n}",org.apache.commons.csv.CSVRecord nextRecord(),"digraph cfg_nextRecord {\n	""1"" [label=""$stack10 = virtualinvoke $stack9.<org.apache.commons.csv.Lexer: long getCharacterPosition()>()""];\n	""2"" [label=""$stack11 = this.<org.apache.commons.csv.CSVParser: long characterOffset>""];\n	""3"" [label=""$stack12 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Lexer lexer>""];\n	""4"" [label=""$stack13 = virtualinvoke $stack12.<org.apache.commons.csv.Lexer: long getBytesRead()>()""];\n	""5"" [label=""$stack14 = this.<org.apache.commons.csv.CSVParser: long characterOffset>""];\n	""6"" [label=""$stack15 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""7"" [label=""$stack16 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""8"" [label=""$stack17 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Lexer lexer>""];\n	""9"" [label=""$stack18 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""10"" [label=""$stack19 = $stack18.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type>""];\n	""11"" [label=""$stack20 = <org.apache.commons.csv.CSVParser$1: int[] $SwitchMap$org$apache$commons$csv$Token$Type>""];\n	""12"" [label=""$stack21 = virtualinvoke $stack19.<org.apache.commons.csv.Token$Type: int ordinal()>()""];\n	""13"" [label=""$stack22 = $stack20[$stack21]""];\n	""14"" [label=""$stack23 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""15"" [label=""$stack24 = $stack23.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""16"" [label=""$stack25 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""17"" [label=""$stack25.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack26""];\n	""18"" [label=""$stack26 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type TOKEN>""];\n	""19"" [label=""$stack27 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""20"" [label=""$stack28 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type TOKEN>""];\n	""21"" [label=""$stack29 = $stack27.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type>""];\n	""22"" [label=""$stack30 = this.<org.apache.commons.csv.CSVParser: java.util.List recordList>""];\n	""23"" [label=""$stack31 = interfaceinvoke $stack30.<java.util.List: boolean isEmpty()>()""];\n	""24"" [label=""$stack32 = this.<org.apache.commons.csv.CSVParser: long recordNumber>""];\n	""25"" [label=""$stack33 = $stack32 + 1L""];\n	""26"" [label=""$stack34 = <org.apache.commons.csv.Constants: java.lang.String[] EMPTY_STRING_ARRAY>""];\n	""27"" [label=""$stack35 = this.<org.apache.commons.csv.CSVParser: java.util.List recordList>""];\n	""28"" [label=""$stack36 = interfaceinvoke $stack35.<java.util.List: java.lang.Object[] toArray(java.lang.Object[])>($stack34)""];\n	""29"" [label=""$stack37 = this.<org.apache.commons.csv.CSVParser: long recordNumber>""];\n	""30"" [label=""$stack38 = (java.lang.String[]) $stack36""];\n	""31"" [label=""$stack39 = new org.apache.commons.csv.CSVRecord""];\n	""32"" [label=""$stack40 = new java.lang.StringBuilder""];\n	""33"" [label=""$stack41 = virtualinvoke this.<org.apache.commons.csv.CSVParser: long getCurrentLineNumber()>()""];\n	""34"" [label=""$stack42 = newarray (java.lang.Object)[1]""];\n	""35"" [label=""$stack42[0] = $stack43""];\n	""36"" [label=""$stack43 = staticinvoke <java.lang.Long: java.lang.Long valueOf(long)>($stack41)""];\n	""37"" [label=""$stack44 = new org.apache.commons.csv.CSVException""];\n	""38"" [label=""$stack45 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""39"" [label=""$stack46 = $stack45.<org.apache.commons.csv.Token: boolean isReady>""];\n	""40"" [label=""$stack47 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""41"" [label=""$stack48 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken>""];\n	""42"" [label=""$stack49 = newarray (java.lang.Object)[1]""];\n	""43"" [label=""$stack49[0] = $stack50""];\n	""44"" [label=""$stack50 = $stack48.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type>""];\n	""45"" [label=""$stack51 = new org.apache.commons.csv.CSVException""];\n	""46"" [label=""$stack8 = this.<org.apache.commons.csv.CSVParser: java.util.List recordList>""];\n	""47"" [label=""$stack9 = this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Lexer lexer>""];\n	""48"" [label=""comment = staticinvoke <java.util.Objects: java.lang.String toString(java.lang.Object,java.lang.String)>(sb, null)""];\n	""49"" [label=""goto""];\n	""50"" [label=""goto""];\n	""51"" [label=""goto""];\n	""52"" [label=""goto""];\n	""53"" [label=""goto""];\n	""54"" [label=""goto""];\n	""55"" [label=""if $stack29 == $stack28""];\n	""56"" [label=""if $stack31 != 0""];\n	""57"" [label=""if $stack46 == 0""];\n	""58"" [label=""if sb != null""];\n	""59"" [label=""if sb == null""];\n	""60"" [label=""interfaceinvoke $stack8.<java.util.List: void clear()>()""];\n	""61"" [label=""result = $stack39""];\n	""62"" [label=""result = null""];\n	""63"" [label=""return result""];\n	""64"" [label=""sb = $stack40""];\n	""65"" [label=""sb = null""];\n	""66"" [label=""specialinvoke $stack39.<org.apache.commons.csv.CSVRecord: void <init>(org.apache.commons.csv.CSVParser,java.lang.String[],java.lang.String,long,long,long)>(this, $stack38, comment, $stack37, startCharPosition, startBytePosition)""];\n	""67"" [label=""specialinvoke $stack40.<java.lang.StringBuilder: void <init>()>()""];\n	""68"" [label=""specialinvoke $stack44.<org.apache.commons.csv.CSVException: void <init>(java.lang.String,java.lang.Object[])>(\""(line %,d) invalid parse sequence\"", $stack42)""];\n	""69"" [label=""specialinvoke $stack51.<org.apache.commons.csv.CSVException: void <init>(java.lang.String,java.lang.Object[])>(\""Unexpected Token type: %s\"", $stack49)""];\n	""70"" [label=""specialinvoke this.<org.apache.commons.csv.CSVParser: void addRecordValue(boolean)>(0)""];\n	""71"" [label=""specialinvoke this.<org.apache.commons.csv.CSVParser: void addRecordValue(boolean)>(1)""];\n	""72"" [label=""specialinvoke this.<org.apache.commons.csv.CSVParser: void addRecordValue(boolean)>(1)""];\n	""73"" [label=""startBytePosition = $stack13 + $stack14""];\n	""74"" [label=""startCharPosition = $stack10 + $stack11""];\n	""75"" [label=""switch($stack22) \{     case 1:     case 2:     case 3:     case 4:     case 5:     default:  \}""];\n	""76"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""77"" [label=""this.<org.apache.commons.csv.CSVParser: java.lang.String trailerComment> = $stack47""];\n	""78"" [label=""this.<org.apache.commons.csv.CSVParser: long recordNumber> = $stack33""];\n	""79"" [label=""throw $stack44""];\n	""80"" [label=""throw $stack51""];\n	""81"" [label=""virtualinvoke $stack15.<org.apache.commons.csv.Token: void reset()>()""];\n	""82"" [label=""virtualinvoke $stack17.<org.apache.commons.csv.Lexer: org.apache.commons.csv.Token nextToken(org.apache.commons.csv.Token)>($stack16)""];\n	""83"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(10)""];\n	""84"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.CharSequence)>($stack24)""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""12""[label=""cfg_next""];\n	""11"" -> ""9""[label=""cfg_next""];\n	""12"" -> ""13""[label=""cfg_next""];\n	""13"" -> ""75""[label=""cfg_next""];\n	""14"" -> ""15""[label=""cfg_next""];\n	""15"" -> ""84""[label=""cfg_next""];\n	""16"" -> ""18""[label=""cfg_next""];\n	""17"" -> ""54""[label=""cfg_next""];\n	""18"" -> ""17""[label=""cfg_next""];\n	""19"" -> ""21""[label=""cfg_next""];\n	""2"" -> ""74""[label=""cfg_next""];\n	""20"" -> ""55""[label=""cfg_next""];\n	""21"" -> ""20""[label=""cfg_next""];\n	""22"" -> ""23""[label=""cfg_next""];\n	""23"" -> ""56""[label=""cfg_next""];\n	""24"" -> ""25""[label=""cfg_next""];\n	""25"" -> ""78""[label=""cfg_next""];\n	""26"" -> ""28""[label=""cfg_next""];\n	""27"" -> ""26""[label=""cfg_next""];\n	""28"" -> ""30""[label=""cfg_next""];\n	""29"" -> ""66""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""30"" -> ""29""[label=""cfg_next""];\n	""31"" -> ""27""[label=""cfg_next""];\n	""32"" -> ""67""[label=""cfg_next""];\n	""33"" -> ""36""[label=""cfg_next""];\n	""34"" -> ""33""[label=""cfg_next""];\n	""35"" -> ""68""[label=""cfg_next""];\n	""36"" -> ""35""[label=""cfg_next""];\n	""37"" -> ""34""[label=""cfg_next""];\n	""38"" -> ""39""[label=""cfg_next""];\n	""39"" -> ""57""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""40"" -> ""77""[label=""cfg_next""];\n	""41"" -> ""44""[label=""cfg_next""];\n	""42"" -> ""41""[label=""cfg_next""];\n	""43"" -> ""69""[label=""cfg_next""];\n	""44"" -> ""43""[label=""cfg_next""];\n	""45"" -> ""42""[label=""cfg_next""];\n	""46"" -> ""60""[label=""cfg_next""];\n	""47"" -> ""1""[label=""cfg_next""];\n	""48"" -> ""31""[label=""cfg_next""];\n	""49"" -> ""19""[label=""cfg_goto""];\n	""5"" -> ""73""[label=""cfg_next""];\n	""50"" -> ""19""[label=""cfg_goto""];\n	""51"" -> ""19""[label=""cfg_goto""];\n	""52"" -> ""19""[label=""cfg_goto""];\n	""53"" -> ""14""[label=""cfg_goto""];\n	""54"" -> ""19""[label=""cfg_goto""];\n	""55"" -> ""22""[label=""cfg_false""];\n	""55"" -> ""6""[label=""cfg_true""];\n	""56"" -> ""24""[label=""cfg_false""];\n	""56"" -> ""63""[label=""cfg_true""];\n	""57"" -> ""59""[label=""cfg_true""];\n	""57"" -> ""72""[label=""cfg_false""];\n	""58"" -> ""32""[label=""cfg_false""];\n	""58"" -> ""83""[label=""cfg_true""];\n	""59"" -> ""19""[label=""cfg_true""];\n	""59"" -> ""40""[label=""cfg_false""];\n	""6"" -> ""81""[label=""cfg_next""];\n	""60"" -> ""65""[label=""cfg_next""];\n	""61"" -> ""63""[label=""cfg_next""];\n	""62"" -> ""46""[label=""cfg_next""];\n	""64"" -> ""53""[label=""cfg_next""];\n	""65"" -> ""47""[label=""cfg_next""];\n	""66"" -> ""61""[label=""cfg_next""];\n	""67"" -> ""64""[label=""cfg_next""];\n	""68"" -> ""79""[label=""cfg_next""];\n	""69"" -> ""80""[label=""cfg_next""];\n	""7"" -> ""82""[label=""cfg_next""];\n	""70"" -> ""49""[label=""cfg_next""];\n	""71"" -> ""50""[label=""cfg_next""];\n	""72"" -> ""51""[label=""cfg_next""];\n	""73"" -> ""6""[label=""cfg_next""];\n	""74"" -> ""3""[label=""cfg_next""];\n	""75"" -> ""37""[label=""cfg_switch""];\n	""75"" -> ""38""[label=""cfg_switch""];\n	""75"" -> ""45""[label=""cfg_switch""];\n	""75"" -> ""58""[label=""cfg_switch""];\n	""75"" -> ""70""[label=""cfg_switch""];\n	""75"" -> ""71""[label=""cfg_switch""];\n	""76"" -> ""62""[label=""cfg_next""];\n	""77"" -> ""52""[label=""cfg_next""];\n	""78"" -> ""48""[label=""cfg_next""];\n	""8"" -> ""7""[label=""cfg_next""];\n	""81"" -> ""8""[label=""cfg_next""];\n	""82"" -> ""11""[label=""cfg_next""];\n	""83"" -> ""14""[label=""cfg_next""];\n	""84"" -> ""16""[label=""cfg_next""];\n	""9"" -> ""10""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVParser.stream(),Method,"* Returns a sequential {@code Stream} with this collection as its source.\n     * <p>\n     * If the parser is closed, the stream will not produce any more values.\n     * See the comments in {@link #iterator()}.\n     * </p>\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a Stream produces.\n     * </p>\n     *\n     * @return a sequential {@code Stream} with this collection as its source.\n     * @since 1.9.0","public Stream<CSVRecord> stream() {\n    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(), Spliterator.ORDERED), false);\n}",java.util.stream.Stream stream(),"digraph cfg_stream {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVParser: java.util.Iterator iterator()>()""];\n	""2"" [label=""$stack2 = staticinvoke <java.util.Spliterators: java.util.Spliterator spliteratorUnknownSize(java.util.Iterator,int)>($stack1, 16)""];\n	""3"" [label=""$stack3 = staticinvoke <java.util.stream.StreamSupport: java.util.stream.Stream stream(java.util.Spliterator,boolean)>($stack2, 0)""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat)",Constructor,"* Constructs a new instance using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @throws CSVException Thrown on invalid input.\n     * @deprecated Will be removed in the next major version, use {@link Builder#get()}.","@Deprecated\npublic CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n    this(reader, format, 0, 1);\n}","void <init>(java.io.Reader,org.apache.commons.csv.CSVFormat)","digraph cfg_init {\n	""1"" [label=""format := @parameter1: org.apache.commons.csv.CSVFormat""];\n	""2"" [label=""reader := @parameter0: java.io.Reader""];\n	""3"" [label=""return""];\n	""4"" [label=""specialinvoke this.<org.apache.commons.csv.CSVParser: void <init>(java.io.Reader,org.apache.commons.csv.CSVFormat,long,long)>(reader, format, 0L, 1L)""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""5"" -> ""2""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long)",Constructor,"* Constructs a new instance using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either the reader or format is null.\n     * @throws IOException\n     *             if there is a problem reading the header or skipping the first record\n     * @throws CSVException on invalid input.\n     * @since 1.1\n     * @deprecated Will be private in the next major version, use {@link Builder#get()}.","@Deprecated\npublic CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber) throws IOException {\n    this(reader, format, characterOffset, recordNumber, null, false);\n}","void <init>(java.io.Reader,org.apache.commons.csv.CSVFormat,long,long)","digraph cfg_init {\n	""1"" [label=""characterOffset := @parameter2: long""];\n	""2"" [label=""format := @parameter1: org.apache.commons.csv.CSVFormat""];\n	""3"" [label=""reader := @parameter0: java.io.Reader""];\n	""4"" [label=""recordNumber := @parameter3: long""];\n	""5"" [label=""return""];\n	""6"" [label=""specialinvoke this.<org.apache.commons.csv.CSVParser: void <init>(java.io.Reader,org.apache.commons.csv.CSVFormat,long,long,java.nio.charset.Charset,boolean)>(reader, format, characterOffset, recordNumber, null, 0)""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""5""[label=""cfg_next""];\n	""7"" -> ""3""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVParser.<init>(Reader,CSVFormat,long,long,Charset,boolean)",Constructor,"* Constructs a new instance using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign.\n     * @param charset\n     *            The character encoding to be used for the reader when enableByteTracking is true.\n     * @param trackBytes\n     *           {@code true} to enable byte tracking for the parser; {@code false} to disable it.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either the reader or format is null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record.\n     * @throws CSVException Thrown on invalid input.","private CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber, final Charset charset, final boolean trackBytes) throws IOException {\n    Objects.requireNonNull(reader, ""reader"");\n    Objects.requireNonNull(format, ""format"");\n    this.format = format.copy();\n    this.lexer = new Lexer(format, new ExtendedBufferedReader(reader, charset, trackBytes));\n    this.csvRecordIterator = new CSVRecordIterator();\n    this.headers = createHeaders();\n    this.characterOffset = characterOffset;\n    this.recordNumber = recordNumber - 1;\n}","void <init>(java.io.Reader,org.apache.commons.csv.CSVFormat,long,long,java.nio.charset.Charset,boolean)","digraph cfg_init {\n	""1"" [label=""$stack10 = new org.apache.commons.csv.Token""];\n	""2"" [label=""$stack11 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat copy()>()""];\n	""3"" [label=""$stack12 = new org.apache.commons.csv.ExtendedBufferedReader""];\n	""4"" [label=""$stack13 = new org.apache.commons.csv.Lexer""];\n	""5"" [label=""$stack14 = new org.apache.commons.csv.CSVParser$CSVRecordIterator""];\n	""6"" [label=""$stack15 = specialinvoke this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$Headers createHeaders()>()""];\n	""7"" [label=""$stack16 = recordNumber - 1L""];\n	""8"" [label=""$stack9 = new java.util.ArrayList""];\n	""9"" [label=""characterOffset := @parameter2: long""];\n	""10"" [label=""charset := @parameter4: java.nio.charset.Charset""];\n	""11"" [label=""format := @parameter1: org.apache.commons.csv.CSVFormat""];\n	""12"" [label=""reader := @parameter0: java.io.Reader""];\n	""13"" [label=""recordNumber := @parameter3: long""];\n	""14"" [label=""return""];\n	""15"" [label=""specialinvoke $stack10.<org.apache.commons.csv.Token: void <init>()>()""];\n	""16"" [label=""specialinvoke $stack12.<org.apache.commons.csv.ExtendedBufferedReader: void <init>(java.io.Reader,java.nio.charset.Charset,boolean)>(reader, charset, trackBytes)""];\n	""17"" [label=""specialinvoke $stack13.<org.apache.commons.csv.Lexer: void <init>(org.apache.commons.csv.CSVFormat,org.apache.commons.csv.ExtendedBufferedReader)>(format, $stack12)""];\n	""18"" [label=""specialinvoke $stack14.<org.apache.commons.csv.CSVParser$CSVRecordIterator: void <init>(org.apache.commons.csv.CSVParser)>(this)""];\n	""19"" [label=""specialinvoke $stack9.<java.util.ArrayList: void <init>()>()""];\n	""20"" [label=""specialinvoke this.<java.lang.Object: void <init>()>()""];\n	""21"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(format, \""format\"")""];\n	""22"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(reader, \""reader\"")""];\n	""23"" [label=""this := @this: org.apache.commons.csv.CSVParser""];\n	""24"" [label=""this.<org.apache.commons.csv.CSVParser: java.util.List recordList> = $stack9""];\n	""25"" [label=""this.<org.apache.commons.csv.CSVParser: long characterOffset> = characterOffset""];\n	""26"" [label=""this.<org.apache.commons.csv.CSVParser: long recordNumber> = $stack16""];\n	""27"" [label=""this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat format> = $stack11""];\n	""28"" [label=""this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$CSVRecordIterator csvRecordIterator> = $stack14""];\n	""29"" [label=""this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$Headers headers> = $stack15""];\n	""30"" [label=""this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Lexer lexer> = $stack13""];\n	""31"" [label=""this.<org.apache.commons.csv.CSVParser: org.apache.commons.csv.Token reusableToken> = $stack10""];\n	""32"" [label=""trackBytes := @parameter5: boolean""];\n	""1"" -> ""15""[label=""cfg_next""];\n	""10"" -> ""32""[label=""cfg_next""];\n	""11"" -> ""9""[label=""cfg_next""];\n	""12"" -> ""11""[label=""cfg_next""];\n	""13"" -> ""10""[label=""cfg_next""];\n	""15"" -> ""31""[label=""cfg_next""];\n	""16"" -> ""17""[label=""cfg_next""];\n	""17"" -> ""30""[label=""cfg_next""];\n	""18"" -> ""28""[label=""cfg_next""];\n	""19"" -> ""24""[label=""cfg_next""];\n	""2"" -> ""27""[label=""cfg_next""];\n	""20"" -> ""8""[label=""cfg_next""];\n	""21"" -> ""2""[label=""cfg_next""];\n	""22"" -> ""21""[label=""cfg_next""];\n	""23"" -> ""12""[label=""cfg_next""];\n	""24"" -> ""1""[label=""cfg_next""];\n	""25"" -> ""7""[label=""cfg_next""];\n	""26"" -> ""14""[label=""cfg_next""];\n	""27"" -> ""4""[label=""cfg_next""];\n	""28"" -> ""6""[label=""cfg_next""];\n	""29"" -> ""25""[label=""cfg_next""];\n	""3"" -> ""16""[label=""cfg_next""];\n	""30"" -> ""5""[label=""cfg_next""];\n	""31"" -> ""22""[label=""cfg_next""];\n	""32"" -> ""20""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""5"" -> ""18""[label=""cfg_next""];\n	""6"" -> ""29""[label=""cfg_next""];\n	""7"" -> ""26""[label=""cfg_next""];\n	""8"" -> ""19""[label=""cfg_next""];\n	""9"" -> ""13""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVParser$Builder.get(),Method,No Comment,"@SuppressWarnings(""resource"")\n@Override\npublic CSVParser get() throws IOException {\n    return new CSVParser(getReader(), format != null ? format : CSVFormat.DEFAULT, characterOffset, recordNumber, getCharset(), trackBytes);\n}",org.apache.commons.csv.CSVParser get(),"digraph cfg_get {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.csv.CSVFormat format>""];\n	""2"" [label=""$stack2 = <org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat DEFAULT>""];\n	""3"" [label=""$stack2 = this.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.csv.CSVFormat format>""];\n	""4"" [label=""$stack3 = this.<org.apache.commons.csv.CSVParser$Builder: long characterOffset>""];\n	""5"" [label=""$stack4 = this.<org.apache.commons.csv.CSVParser$Builder: long recordNumber>""];\n	""6"" [label=""$stack5 = this.<org.apache.commons.csv.CSVParser$Builder: boolean trackBytes>""];\n	""7"" [label=""$stack6 = virtualinvoke this.<org.apache.commons.csv.CSVParser$Builder: java.nio.charset.Charset getCharset()>()""];\n	""8"" [label=""$stack7 = virtualinvoke this.<org.apache.commons.csv.CSVParser$Builder: java.io.Reader getReader()>()""];\n	""9"" [label=""$stack8 = new org.apache.commons.csv.CSVParser""];\n	""10"" [label=""goto""];\n	""11"" [label=""if $stack1 == null""];\n	""12"" [label=""return $stack8""];\n	""13"" [label=""specialinvoke $stack8.<org.apache.commons.csv.CSVParser: void <init>(java.io.Reader,org.apache.commons.csv.CSVFormat,long,long,java.nio.charset.Charset,boolean,org.apache.commons.csv.CSVParser$1)>($stack7, $stack2, $stack3, $stack4, $stack6, $stack5, null)""];\n	""14"" [label=""this := @this: org.apache.commons.csv.CSVParser$Builder""];\n	""1"" -> ""11""[label=""cfg_next""];\n	""10"" -> ""4""[label=""cfg_goto""];\n	""11"" -> ""2""[label=""cfg_true""];\n	""11"" -> ""3""[label=""cfg_false""];\n	""13"" -> ""12""[label=""cfg_next""];\n	""14"" -> ""9""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""10""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_next""];\n	""6"" -> ""13""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n	""8"" -> ""1""[label=""cfg_next""];\n	""9"" -> ""8""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser$Builder.setCharacterOffset(long),Method,* Sets the lexer offset when the parser does not start parsing at the beginning of the source.\n         *\n         * @param characterOffset the lexer offset.\n         * @return this instance.,public Builder setCharacterOffset(final long characterOffset) {\n    this.characterOffset = characterOffset;\n    return asThis();\n},org.apache.commons.csv.CSVParser$Builder setCharacterOffset(long),"digraph cfg_setCharacterOffset {\n	""1"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.io.build.AbstractSupplier asThis()>()""];\n	""2"" [label=""$stack4 = (org.apache.commons.csv.CSVParser$Builder) $stack3""];\n	""3"" [label=""characterOffset := @parameter0: long""];\n	""4"" [label=""return $stack4""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVParser$Builder""];\n	""6"" [label=""this.<org.apache.commons.csv.CSVParser$Builder: long characterOffset> = characterOffset""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser$Builder.setFormat(CSVFormat),Method,"* Sets the CSV format. A copy of the given format is kept.\n         *\n         * @param format the CSV format, null is equivalent to {@link CSVFormat#DEFAULT}.\n         * @return this instance.",public Builder setFormat(final CSVFormat format) {\n    this.format = CSVFormat.copy(format);\n    return asThis();\n},org.apache.commons.csv.CSVParser$Builder setFormat(org.apache.commons.csv.CSVFormat),"digraph cfg_setFormat {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat copy(org.apache.commons.csv.CSVFormat)>(format)""];\n	""2"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.io.build.AbstractSupplier asThis()>()""];\n	""3"" [label=""$stack4 = (org.apache.commons.csv.CSVParser$Builder) $stack3""];\n	""4"" [label=""format := @parameter0: org.apache.commons.csv.CSVFormat""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVParser$Builder""];\n	""7"" [label=""this.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.csv.CSVFormat format> = $stack2""];\n	""1"" -> ""7""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n	""7"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser$Builder.setRecordNumber(long),Method,"* Sets the next record number to assign, defaults to {@code 1}.\n         *\n         * @param recordNumber the next record number to assign.\n         * @return this instance.",public Builder setRecordNumber(final long recordNumber) {\n    this.recordNumber = recordNumber;\n    return asThis();\n},org.apache.commons.csv.CSVParser$Builder setRecordNumber(long),"digraph cfg_setRecordNumber {\n	""1"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.io.build.AbstractSupplier asThis()>()""];\n	""2"" [label=""$stack4 = (org.apache.commons.csv.CSVParser$Builder) $stack3""];\n	""3"" [label=""recordNumber := @parameter0: long""];\n	""4"" [label=""return $stack4""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVParser$Builder""];\n	""6"" [label=""this.<org.apache.commons.csv.CSVParser$Builder: long recordNumber> = recordNumber""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser$Builder.setTrackBytes(boolean),Method,* Sets whether to enable byte tracking for the parser.\n         *\n         * @param trackBytes {@code true} to enable byte tracking; {@code false} to disable it.\n         * @return this instance.\n         * @since 1.13.0,public Builder setTrackBytes(final boolean trackBytes) {\n    this.trackBytes = trackBytes;\n    return asThis();\n},org.apache.commons.csv.CSVParser$Builder setTrackBytes(boolean),"digraph cfg_setTrackBytes {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.io.build.AbstractSupplier asThis()>()""];\n	""2"" [label=""$stack3 = (org.apache.commons.csv.CSVParser$Builder) $stack2""];\n	""3"" [label=""return $stack3""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVParser$Builder""];\n	""5"" [label=""this.<org.apache.commons.csv.CSVParser$Builder: boolean trackBytes> = trackBytes""];\n	""6"" [label=""trackBytes := @parameter0: boolean""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""5""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser$Builder.<init>(),Constructor,* Constructs a new instance.,protected Builder() {\n    // empty\n},void <init>(),"digraph cfg_init {\n	""1"" [label=""return""];\n	""2"" [label=""specialinvoke this.<org.apache.commons.io.build.AbstractStreamBuilder: void <init>()>()""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVParser$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVParser$Builder: long recordNumber> = 1L""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",protected 
org.apache.commons.csv.CSVParser$CSVRecordIterator.getNextRecord(),Method,"* Gets the next record or null at the end of stream or max rows read.\n         *\n         * @throws IOException  on parse error or input read-failure\n         * @throws CSVException on invalid input.\n         * @return the next record, or {@code null} if the end of the stream has been reached.",private CSVRecord getNextRecord() {\n    CSVRecord record = null;\n    if (format.useRow(recordNumber + 1)) {\n        record = Uncheck.get(CSVParser.this::nextRecord);\n    }\n    return record;\n},org.apache.commons.csv.CSVRecord getNextRecord(),"digraph cfg_getNextRecord {\n	""1"" [label=""$stack10 = staticinvoke <org.apache.commons.io.function.Uncheck: java.lang.Object get(org.apache.commons.io.function.IOSupplier)>($stack9)""];\n	""2"" [label=""$stack2 = this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVParser this$0>""];\n	""3"" [label=""$stack3 = this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVParser this$0>""];\n	""4"" [label=""$stack4 = staticinvoke <org.apache.commons.csv.CSVParser: long access$100(org.apache.commons.csv.CSVParser)>($stack3)""];\n	""5"" [label=""$stack5 = $stack4 + 1L""];\n	""6"" [label=""$stack6 = staticinvoke <org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVFormat access$200(org.apache.commons.csv.CSVParser)>($stack2)""];\n	""7"" [label=""$stack7 = virtualinvoke $stack6.<org.apache.commons.csv.CSVFormat: boolean useRow(long)>($stack5)""];\n	""8"" [label=""$stack8 = this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVParser this$0>""];\n	""9"" [label=""$stack9 = dynamicinvoke \""get\"" <org.apache.commons.io.function.IOSupplier (org.apache.commons.csv.CSVParser)>($stack8) <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>(methodtype: java.lang.Object __METHODTYPE__(), methodhandle: \""REF_INVOKE_VIRTUAL\"" <org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVRecord nextRecord()>, methodtype: org.apache.commons.csv.CSVRecord __METHODTYPE__())""];\n	""10"" [label=""if $stack7 == 0""];\n	""11"" [label=""record = (org.apache.commons.csv.CSVRecord) $stack10""];\n	""12"" [label=""record = null""];\n	""13"" [label=""return record""];\n	""14"" [label=""this := @this: org.apache.commons.csv.CSVParser$CSVRecordIterator""];\n	""1"" -> ""11""[label=""cfg_next""];\n	""10"" -> ""13""[label=""cfg_true""];\n	""10"" -> ""8""[label=""cfg_false""];\n	""11"" -> ""13""[label=""cfg_next""];\n	""12"" -> ""2""[label=""cfg_next""];\n	""14"" -> ""12""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_next""];\n	""6"" -> ""3""[label=""cfg_next""];\n	""7"" -> ""10""[label=""cfg_next""];\n	""8"" -> ""9""[label=""cfg_next""];\n	""9"" -> ""1""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVParser$CSVRecordIterator.hasNext(),Method,No Comment,@Override\npublic boolean hasNext() {\n    if (isClosed()) {\n        return false;\n    }\n    if (current == null) {\n        current = getNextRecord();\n    }\n    return current != null;\n},boolean hasNext(),"digraph cfg_hasNext {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVParser this$0>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVParser: boolean isClosed()>()""];\n	""3"" [label=""$stack3 = this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVRecord current>""];\n	""4"" [label=""$stack4 = this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVRecord current>""];\n	""5"" [label=""$stack5 = 0""];\n	""6"" [label=""$stack5 = 1""];\n	""7"" [label=""$stack6 = specialinvoke this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVRecord getNextRecord()>()""];\n	""8"" [label=""goto""];\n	""9"" [label=""if $stack2 == 0""];\n	""10"" [label=""if $stack3 != null""];\n	""11"" [label=""if $stack4 == null""];\n	""12"" [label=""return $stack5""];\n	""13"" [label=""return 0""];\n	""14"" [label=""this := @this: org.apache.commons.csv.CSVParser$CSVRecordIterator""];\n	""15"" [label=""this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVRecord current> = $stack6""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""4""[label=""cfg_true""];\n	""10"" -> ""7""[label=""cfg_false""];\n	""11"" -> ""5""[label=""cfg_true""];\n	""11"" -> ""6""[label=""cfg_false""];\n	""14"" -> ""1""[label=""cfg_next""];\n	""15"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""9""[label=""cfg_next""];\n	""3"" -> ""10""[label=""cfg_next""];\n	""4"" -> ""11""[label=""cfg_next""];\n	""5"" -> ""12""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_next""];\n	""7"" -> ""15""[label=""cfg_next""];\n	""8"" -> ""12""[label=""cfg_goto""];\n	""9"" -> ""13""[label=""cfg_false""];\n	""9"" -> ""3""[label=""cfg_true""];\n}\n",public 
org.apache.commons.csv.CSVParser$CSVRecordIterator.next(),Method,No Comment,"@Override\npublic CSVRecord next() {\n    if (isClosed()) {\n        throw new NoSuchElementException(""CSVParser has been closed"");\n    }\n    CSVRecord next = current;\n    current = null;\n    if (next == null) {\n        // hasNext() wasn't called before\n        next = getNextRecord();\n        if (next == null) {\n            throw new NoSuchElementException(""No more CSV records available"");\n        }\n    }\n    return next;\n}",org.apache.commons.csv.CSVRecord next(),"digraph cfg_next {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVParser this$0>""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVParser: boolean isClosed()>()""];\n	""3"" [label=""$stack4 = new java.util.NoSuchElementException""];\n	""4"" [label=""$stack5 = new java.util.NoSuchElementException""];\n	""5"" [label=""if $stack3 == 0""];\n	""6"" [label=""if next != null""];\n	""7"" [label=""if next != null""];\n	""8"" [label=""next = specialinvoke this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVRecord getNextRecord()>()""];\n	""9"" [label=""next = this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVRecord current>""];\n	""10"" [label=""return next""];\n	""11"" [label=""specialinvoke $stack4.<java.util.NoSuchElementException: void <init>(java.lang.String)>(\""No more CSV records available\"")""];\n	""12"" [label=""specialinvoke $stack5.<java.util.NoSuchElementException: void <init>(java.lang.String)>(\""CSVParser has been closed\"")""];\n	""13"" [label=""this := @this: org.apache.commons.csv.CSVParser$CSVRecordIterator""];\n	""14"" [label=""this.<org.apache.commons.csv.CSVParser$CSVRecordIterator: org.apache.commons.csv.CSVRecord current> = null""];\n	""15"" [label=""throw $stack4""];\n	""16"" [label=""throw $stack5""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""11"" -> ""15""[label=""cfg_next""];\n	""12"" -> ""16""[label=""cfg_next""];\n	""13"" -> ""1""[label=""cfg_next""];\n	""14"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""11""[label=""cfg_next""];\n	""4"" -> ""12""[label=""cfg_next""];\n	""5"" -> ""4""[label=""cfg_false""];\n	""5"" -> ""9""[label=""cfg_true""];\n	""6"" -> ""10""[label=""cfg_true""];\n	""6"" -> ""8""[label=""cfg_false""];\n	""7"" -> ""10""[label=""cfg_true""];\n	""7"" -> ""3""[label=""cfg_false""];\n	""8"" -> ""7""[label=""cfg_next""];\n	""9"" -> ""14""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVParser$CSVRecordIterator.remove(),Method,No Comment,@Override\npublic void remove() {\n    throw new UnsupportedOperationException();\n},void remove(),"digraph cfg_remove {\n	""1"" [label=""$stack1 = new java.lang.UnsupportedOperationException""];\n	""2"" [label=""specialinvoke $stack1.<java.lang.UnsupportedOperationException: void <init>()>()""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVParser$CSVRecordIterator""];\n	""4"" [label=""throw $stack1""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVParser$Headers.<init>(Map,List)",Constructor,No Comment,"Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {\n    this.headerMap = headerMap;\n    this.headerNames = headerNames;\n}","void <init>(java.util.Map,java.util.List)","digraph cfg_init {\n	""1"" [label=""headerMap := @parameter0: java.util.Map""];\n	""2"" [label=""headerNames := @parameter1: java.util.List""];\n	""3"" [label=""return""];\n	""4"" [label=""specialinvoke this.<java.lang.Object: void <init>()>()""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVParser$Headers""];\n	""6"" [label=""this.<org.apache.commons.csv.CSVParser$Headers: java.util.List headerNames> = headerNames""];\n	""7"" [label=""this.<org.apache.commons.csv.CSVParser$Headers: java.util.Map headerMap> = headerMap""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""7""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""3""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVPrinter.close(),Method,No Comment,@Override\npublic void close() throws IOException {\n    close(false);\n},void close(),"digraph cfg_close {\n	""1"" [label=""return""];\n	""2"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""3"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void close(boolean)>(0)""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVPrinter.close(boolean),Method,* Closes the underlying stream with an optional flush first.\n     * @param flush whether to flush before the actual close.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.6,public void close(final boolean flush) throws IOException {\n    if (flush || format.getAutoFlush()) {\n        flush();\n    }\n    if (appendable instanceof Closeable) {\n        ((Closeable) appendable).close();\n    }\n},void close(boolean),"digraph cfg_close {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""2"" [label=""$stack3 = $stack2 instanceof java.io.Closeable""];\n	""3"" [label=""$stack4 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""4"" [label=""$stack5 = (java.io.Closeable) $stack4""];\n	""5"" [label=""$stack6 = this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format>""];\n	""6"" [label=""$stack7 = virtualinvoke $stack6.<org.apache.commons.csv.CSVFormat: boolean getAutoFlush()>()""];\n	""7"" [label=""flush := @parameter0: boolean""];\n	""8"" [label=""if $stack3 == 0""];\n	""9"" [label=""if $stack7 == 0""];\n	""10"" [label=""if flush != 0""];\n	""11"" [label=""interfaceinvoke $stack5.<java.io.Closeable: void close()>()""];\n	""12"" [label=""return""];\n	""13"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""14"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void flush()>()""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""14""[label=""cfg_true""];\n	""10"" -> ""5""[label=""cfg_false""];\n	""11"" -> ""12""[label=""cfg_next""];\n	""13"" -> ""7""[label=""cfg_next""];\n	""14"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""8""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""11""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""9""[label=""cfg_next""];\n	""7"" -> ""10""[label=""cfg_next""];\n	""8"" -> ""12""[label=""cfg_true""];\n	""8"" -> ""3""[label=""cfg_false""];\n	""9"" -> ""1""[label=""cfg_true""];\n	""9"" -> ""14""[label=""cfg_false""];\n}\n",public 
org.apache.commons.csv.CSVPrinter.endOfRecord(),Method,* Outputs the record separator and increments the record count.\n     *\n     * @throws IOException\n     *             If an I/O error occurs,private synchronized void endOfRecord() throws IOException {\n    println();\n    recordCount++;\n},void endOfRecord(),"digraph cfg_endOfRecord {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVPrinter: long recordCount>""];\n	""2"" [label=""$stack2 = $stack1 + 1L""];\n	""3"" [label=""return""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""5"" [label=""this.<org.apache.commons.csv.CSVPrinter: long recordCount> = $stack2""];\n	""6"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void println()>()""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n}\n","private , synchronized "
org.apache.commons.csv.CSVPrinter.flush(),Method,* Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs,@Override\npublic void flush() throws IOException {\n    if (appendable instanceof Flushable) {\n        ((Flushable) appendable).flush();\n    }\n},void flush(),"digraph cfg_flush {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""2"" [label=""$stack2 = $stack1 instanceof java.io.Flushable""];\n	""3"" [label=""$stack3 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""4"" [label=""$stack4 = (java.io.Flushable) $stack3""];\n	""5"" [label=""if $stack2 == 0""];\n	""6"" [label=""interfaceinvoke $stack4.<java.io.Flushable: void flush()>()""];\n	""7"" [label=""return""];\n	""8"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""5"" -> ""7""[label=""cfg_true""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""8"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVPrinter.getOut(),Method,* Gets the target Appendable.\n     *\n     * @return the target Appendable.,public Appendable getOut() {\n    return this.appendable;\n},java.lang.Appendable getOut(),"digraph cfg_getOut {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVPrinter.getRecordCount(),Method,"* Gets the record count printed, this does not include comments or headers.\n     *\n     * @return the record count, this does not include comments or headers.\n     * @since 1.13.0",public long getRecordCount() {\n    return recordCount;\n},long getRecordCount(),"digraph cfg_getRecordCount {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVPrinter: long recordCount>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVPrinter.print(Object),Method,* Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs,"public synchronized void print(final Object value) throws IOException {\n    format.print(value, appendable, newRecord);\n    newRecord = false;\n}",void print(java.lang.Object),"digraph cfg_print {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.CSVPrinter: boolean newRecord>""];\n	""2"" [label=""$stack3 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""3"" [label=""$stack4 = this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format>""];\n	""4"" [label=""return""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""6"" [label=""this.<org.apache.commons.csv.CSVPrinter: boolean newRecord> = 0""];\n	""7"" [label=""value := @parameter0: java.lang.Object""];\n	""8"" [label=""virtualinvoke $stack4.<org.apache.commons.csv.CSVFormat: void print(java.lang.Object,java.lang.Appendable,boolean)>(value, $stack3, $stack2)""];\n	""1"" -> ""8""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n	""7"" -> ""3""[label=""cfg_next""];\n	""8"" -> ""6""[label=""cfg_next""];\n}\n","public , synchronized "
org.apache.commons.csv.CSVPrinter.printComment(String),Method,* Prints a comment on a new line among the delimiter-separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy at least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * <p>\n     * If comments are disabled in the current CSV format this method does nothing.\n     * </p>\n     *\n     * <p>This method detects line breaks inside the comment string and inserts {@link CSVFormat#getRecordSeparator()}\n     * to start a new line of the comment. Note that this might produce unexpected results for formats that do not use\n     * line breaks as record separators.</p>\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs,public synchronized void printComment(final String comment) throws IOException {\n    if (comment == null || !format.isCommentMarkerSet()) {\n        return;\n    }\n    if (!newRecord) {\n        println();\n    }\n    // N.B. Explicit (un)boxing is intentional\n    appendable.append(format.getCommentMarker().charValue());\n    appendable.append(SP);\n    for (int i = 0; i < comment.length(); i++) {\n        final char c = comment.charAt(i);\n        switch(c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n            // falls-through: break intentionally excluded.\n            case LF:\n                println();\n                // N.B. Explicit (un)boxing is intentional\n                appendable.append(format.getCommentMarker().charValue());\n                appendable.append(SP);\n                break;\n            default:\n                appendable.append(c);\n                break;\n        }\n    }\n    println();\n},void printComment(java.lang.String),"digraph cfg_printComment {\n	""1"" [label=""$stack10 = virtualinvoke $stack9.<java.lang.Character: char charValue()>()""];\n	""2"" [label=""$stack11 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""3"" [label=""$stack12 = virtualinvoke comment.<java.lang.String: int length()>()""];\n	""4"" [label=""$stack13 = virtualinvoke comment.<java.lang.String: int length()>()""];\n	""5"" [label=""$stack14 = i + 1""];\n	""6"" [label=""$stack15 = this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format>""];\n	""7"" [label=""$stack16 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""8"" [label=""$stack17 = virtualinvoke $stack15.<org.apache.commons.csv.CSVFormat: java.lang.Character getCommentMarker()>()""];\n	""9"" [label=""$stack18 = virtualinvoke $stack17.<java.lang.Character: char charValue()>()""];\n	""10"" [label=""$stack19 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""11"" [label=""$stack20 = i + 1""];\n	""12"" [label=""$stack21 = virtualinvoke comment.<java.lang.String: char charAt(int)>($stack20)""];\n	""13"" [label=""$stack22 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""14"" [label=""$stack4 = this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format>""];\n	""15"" [label=""$stack5 = virtualinvoke $stack4.<org.apache.commons.csv.CSVFormat: boolean isCommentMarkerSet()>()""];\n	""16"" [label=""$stack6 = this.<org.apache.commons.csv.CSVPrinter: boolean newRecord>""];\n	""17"" [label=""$stack7 = this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format>""];\n	""18"" [label=""$stack8 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""19"" [label=""$stack9 = virtualinvoke $stack7.<org.apache.commons.csv.CSVFormat: java.lang.Character getCommentMarker()>()""];\n	""20"" [label=""c = virtualinvoke comment.<java.lang.String: char charAt(int)>(i)""];\n	""21"" [label=""comment := @parameter0: java.lang.String""];\n	""22"" [label=""goto""];\n	""23"" [label=""goto""];\n	""24"" [label=""i = 0""];\n	""25"" [label=""i = i + 1""];\n	""26"" [label=""i = i + 1""];\n	""27"" [label=""if $stack14 >= $stack13""];\n	""28"" [label=""if $stack21 != 10""];\n	""29"" [label=""if $stack5 != 0""];\n	""30"" [label=""if $stack6 != 0""];\n	""31"" [label=""if comment == null""];\n	""32"" [label=""if i >= $stack12""];\n	""33"" [label=""interfaceinvoke $stack11.<java.lang.Appendable: java.lang.Appendable append(char)>(32)""];\n	""34"" [label=""interfaceinvoke $stack16.<java.lang.Appendable: java.lang.Appendable append(char)>($stack18)""];\n	""35"" [label=""interfaceinvoke $stack19.<java.lang.Appendable: java.lang.Appendable append(char)>(32)""];\n	""36"" [label=""interfaceinvoke $stack22.<java.lang.Appendable: java.lang.Appendable append(char)>(c)""];\n	""37"" [label=""interfaceinvoke $stack8.<java.lang.Appendable: java.lang.Appendable append(char)>($stack10)""];\n	""38"" [label=""return""];\n	""39"" [label=""return""];\n	""40"" [label=""switch(c) \{     case 10:     case 13:     default:  \}""];\n	""41"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""42"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void println()>()""];\n	""43"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void println()>()""];\n	""44"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void println()>()""];\n	""1"" -> ""37""[label=""cfg_next""];\n	""10"" -> ""35""[label=""cfg_next""];\n	""11"" -> ""12""[label=""cfg_next""];\n	""12"" -> ""28""[label=""cfg_next""];\n	""13"" -> ""36""[label=""cfg_next""];\n	""14"" -> ""15""[label=""cfg_next""];\n	""15"" -> ""29""[label=""cfg_next""];\n	""16"" -> ""30""[label=""cfg_next""];\n	""17"" -> ""19""[label=""cfg_next""];\n	""18"" -> ""17""[label=""cfg_next""];\n	""19"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""33""[label=""cfg_next""];\n	""20"" -> ""40""[label=""cfg_next""];\n	""21"" -> ""31""[label=""cfg_next""];\n	""22"" -> ""26""[label=""cfg_goto""];\n	""23"" -> ""3""[label=""cfg_goto""];\n	""24"" -> ""3""[label=""cfg_next""];\n	""25"" -> ""44""[label=""cfg_next""];\n	""26"" -> ""23""[label=""cfg_next""];\n	""27"" -> ""11""[label=""cfg_false""];\n	""27"" -> ""44""[label=""cfg_true""];\n	""28"" -> ""25""[label=""cfg_false""];\n	""28"" -> ""44""[label=""cfg_true""];\n	""29"" -> ""16""[label=""cfg_true""];\n	""29"" -> ""38""[label=""cfg_false""];\n	""3"" -> ""32""[label=""cfg_next""];\n	""30"" -> ""18""[label=""cfg_true""];\n	""30"" -> ""42""[label=""cfg_false""];\n	""31"" -> ""14""[label=""cfg_false""];\n	""31"" -> ""38""[label=""cfg_true""];\n	""32"" -> ""20""[label=""cfg_false""];\n	""32"" -> ""43""[label=""cfg_true""];\n	""33"" -> ""24""[label=""cfg_next""];\n	""34"" -> ""10""[label=""cfg_next""];\n	""35"" -> ""22""[label=""cfg_next""];\n	""36"" -> ""26""[label=""cfg_next""];\n	""37"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""27""[label=""cfg_next""];\n	""40"" -> ""13""[label=""cfg_switch""];\n	""40"" -> ""44""[label=""cfg_switch""];\n	""40"" -> ""5""[label=""cfg_switch""];\n	""41"" -> ""21""[label=""cfg_next""];\n	""42"" -> ""18""[label=""cfg_next""];\n	""43"" -> ""39""[label=""cfg_next""];\n	""44"" -> ""7""[label=""cfg_next""];\n	""5"" -> ""4""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n	""8"" -> ""9""[label=""cfg_next""];\n	""9"" -> ""34""[label=""cfg_next""];\n}\n","public , synchronized "
org.apache.commons.csv.CSVPrinter.printHeaders(ResultSet),Method,* Prints headers for a result set based on its metadata.\n     *\n     * @param resultSet The ResultSet to query for metadata.\n     * @throws IOException If an I/O error occurs.\n     * @throws SQLException If a database access error occurs or this method is called on a closed result set.\n     * @since 1.9.0,"public synchronized void printHeaders(final ResultSet resultSet) throws IOException, SQLException {\n    try (IOStream<String> stream = IOStream.of(format.builder().setHeader(resultSet).get().getHeader())) {\n        stream.forEachOrdered(this::print);\n    }\n    println();\n}",void printHeaders(java.sql.ResultSet),"digraph cfg_printHeaders {\n	""1"" [label=""$stack10 = dynamicinvoke \""accept\"" <org.apache.commons.io.function.IOConsumer (org.apache.commons.csv.CSVPrinter)>(this) <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>(methodtype: void __METHODTYPE__(java.lang.Object), methodhandle: \""REF_INVOKE_VIRTUAL\"" <org.apache.commons.csv.CSVPrinter: void print(java.lang.Object)>, methodtype: void __METHODTYPE__(java.lang.String))""];\n	""2"" [label=""$stack11 := @caughtexception""];\n	""3"" [label=""$stack12 := @caughtexception""];\n	""4"" [label=""$stack5 = this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format>""];\n	""5"" [label=""$stack6 = virtualinvoke $stack5.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""6"" [label=""$stack7 = virtualinvoke $stack6.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeader(java.sql.ResultSet)>(resultSet)""];\n	""7"" [label=""$stack8 = virtualinvoke $stack7.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""8"" [label=""$stack9 = virtualinvoke $stack8.<org.apache.commons.csv.CSVFormat: java.lang.String[] getHeader()>()""];\n	""9"" [label=""goto""];\n	""10"" [label=""goto""];\n	""11"" [label=""if stream == null""];\n	""12"" [label=""if stream == null""];\n	""13"" [label=""interfaceinvoke stream.<org.apache.commons.io.function.IOStream: void close()>()""];\n	""14"" [label=""interfaceinvoke stream.<org.apache.commons.io.function.IOStream: void close()>()""];\n	""15"" [label=""interfaceinvoke stream.<org.apache.commons.io.function.IOStream: void forEachOrdered(org.apache.commons.io.function.IOConsumer)>($stack10)""];\n	""16"" [label=""l3 = $stack12""];\n	""17"" [label=""l4 = $stack11""];\n	""18"" [label=""resultSet := @parameter0: java.sql.ResultSet""];\n	""19"" [label=""return""];\n	""20"" [label=""stream = staticinvoke <org.apache.commons.io.function.IOStream: org.apache.commons.io.function.IOStream of(java.lang.Object[])>($stack9)""];\n	""21"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""22"" [label=""throw l3""];\n	""23"" [label=""virtualinvoke l3.<java.lang.Throwable: void addSuppressed(java.lang.Throwable)>(l4)""];\n	""24"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void println()>()""];\n	""1"" -> ""15""[label=""cfg_next""];\n	""1"" -> ""3""[label=""cfg_except""];\n	""10"" -> ""22""[label=""cfg_goto""];\n	""11"" -> ""13""[label=""cfg_false""];\n	""11"" -> ""24""[label=""cfg_true""];\n	""12"" -> ""14""[label=""cfg_false""];\n	""12"" -> ""22""[label=""cfg_true""];\n	""13"" -> ""9""[label=""cfg_next""];\n	""14"" -> ""10""[label=""cfg_next""];\n	""14"" -> ""2""[label=""cfg_except""];\n	""15"" -> ""11""[label=""cfg_next""];\n	""15"" -> ""3""[label=""cfg_except""];\n	""16"" -> ""12""[label=""cfg_next""];\n	""17"" -> ""23""[label=""cfg_next""];\n	""18"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""17""[label=""cfg_next""];\n	""20"" -> ""1""[label=""cfg_next""];\n	""21"" -> ""18""[label=""cfg_next""];\n	""23"" -> ""22""[label=""cfg_next""];\n	""24"" -> ""19""[label=""cfg_next""];\n	""3"" -> ""16""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""8""[label=""cfg_next""];\n	""8"" -> ""20""[label=""cfg_next""];\n	""9"" -> ""24""[label=""cfg_goto""];\n}\n","public , synchronized "
org.apache.commons.csv.CSVPrinter.println(),Method,* Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs,public synchronized void println() throws IOException {\n    format.println(appendable);\n    newRecord = true;\n},void println(),"digraph cfg_println {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable>""];\n	""2"" [label=""$stack2 = this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format>""];\n	""3"" [label=""return""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""5"" [label=""this.<org.apache.commons.csv.CSVPrinter: boolean newRecord> = 1""];\n	""6"" [label=""virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat: void println(java.lang.Appendable)>($stack1)""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""5""[label=""cfg_next""];\n}\n","public , synchronized "
org.apache.commons.csv.CSVPrinter.printRecord(Iterable),Method,"* Prints the given values as a single record of delimiter-separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs","@SuppressWarnings(""resource"")\npublic synchronized void printRecord(final Iterable<?> values) throws IOException {\n    IOStream.of(values).forEachOrdered(this::print);\n    endOfRecord();\n}",void printRecord(java.lang.Iterable),"digraph cfg_printRecord {\n	""1"" [label=""$stack2 = dynamicinvoke \""accept\"" <org.apache.commons.io.function.IOConsumer (org.apache.commons.csv.CSVPrinter)>(this) <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>(methodtype: void __METHODTYPE__(java.lang.Object), methodhandle: \""REF_INVOKE_VIRTUAL\"" <org.apache.commons.csv.CSVPrinter: void print(java.lang.Object)>, methodtype: void __METHODTYPE__(java.lang.Object))""];\n	""2"" [label=""$stack3 = staticinvoke <org.apache.commons.io.function.IOStream: org.apache.commons.io.function.IOStream of(java.lang.Iterable)>(values)""];\n	""3"" [label=""interfaceinvoke $stack3.<org.apache.commons.io.function.IOStream: void forEachOrdered(org.apache.commons.io.function.IOConsumer)>($stack2)""];\n	""4"" [label=""return""];\n	""5"" [label=""specialinvoke this.<org.apache.commons.csv.CSVPrinter: void endOfRecord()>()""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""7"" [label=""values := @parameter0: java.lang.Iterable""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""4""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""2""[label=""cfg_next""];\n}\n","public , synchronized "
org.apache.commons.csv.CSVPrinter.printRecord(Object[]),Method,"* Prints the given values as a single record of delimiter-separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs",public void printRecord(final Object... values) throws IOException {\n    printRecord(Arrays.asList(values));\n},void printRecord(java.lang.Object[]),"digraph cfg_printRecord {\n	""1"" [label=""$stack2 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(values)""];\n	""2"" [label=""return""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""4"" [label=""values := @parameter0: java.lang.Object[]""];\n	""5"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void printRecord(java.lang.Iterable)>($stack2)""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVPrinter.printRecord(Stream),Method,"* Prints the given values as a single record of delimiter-separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.10.0","// caller closes.\n@SuppressWarnings(""resource"")\npublic synchronized void printRecord(final Stream<?> values) throws IOException {\n    IOStream.adapt(values).forEachOrdered(this::print);\n    endOfRecord();\n}",void printRecord(java.util.stream.Stream),"digraph cfg_printRecord {\n	""1"" [label=""$stack2 = dynamicinvoke \""accept\"" <org.apache.commons.io.function.IOConsumer (org.apache.commons.csv.CSVPrinter)>(this) <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>(methodtype: void __METHODTYPE__(java.lang.Object), methodhandle: \""REF_INVOKE_VIRTUAL\"" <org.apache.commons.csv.CSVPrinter: void print(java.lang.Object)>, methodtype: void __METHODTYPE__(java.lang.Object))""];\n	""2"" [label=""$stack3 = staticinvoke <org.apache.commons.io.function.IOStream: org.apache.commons.io.function.IOStream adapt(java.util.stream.Stream)>(values)""];\n	""3"" [label=""interfaceinvoke $stack3.<org.apache.commons.io.function.IOStream: void forEachOrdered(org.apache.commons.io.function.IOConsumer)>($stack2)""];\n	""4"" [label=""return""];\n	""5"" [label=""specialinvoke this.<org.apache.commons.csv.CSVPrinter: void endOfRecord()>()""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""7"" [label=""values := @parameter0: java.util.stream.Stream""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""4""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""2""[label=""cfg_next""];\n}\n","public , synchronized "
org.apache.commons.csv.CSVPrinter.printRecordObject(Object),Method,No Comment,private void printRecordObject(final Object value) throws IOException {\n    if (value instanceof Object[]) {\n        this.printRecord((Object[]) value);\n    } else if (value instanceof Iterable) {\n        this.printRecord((Iterable<?>) value);\n    } else {\n        this.printRecord(value);\n    }\n},void printRecordObject(java.lang.Object),"digraph cfg_printRecordObject {\n	""1"" [label=""$stack2 = value instanceof java.lang.Object[]""];\n	""2"" [label=""$stack3 = value instanceof java.lang.Iterable""];\n	""3"" [label=""$stack4 = newarray (java.lang.Object)[1]""];\n	""4"" [label=""$stack4[0] = value""];\n	""5"" [label=""$stack5 = (java.lang.Iterable) value""];\n	""6"" [label=""$stack6 = (java.lang.Object[]) value""];\n	""7"" [label=""goto""];\n	""8"" [label=""goto""];\n	""9"" [label=""if $stack2 == 0""];\n	""10"" [label=""if $stack3 == 0""];\n	""11"" [label=""return""];\n	""12"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""13"" [label=""value := @parameter0: java.lang.Object""];\n	""14"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void printRecord(java.lang.Iterable)>($stack5)""];\n	""15"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void printRecord(java.lang.Object[])>($stack4)""];\n	""16"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void printRecord(java.lang.Object[])>($stack6)""];\n	""1"" -> ""9""[label=""cfg_next""];\n	""10"" -> ""3""[label=""cfg_true""];\n	""10"" -> ""5""[label=""cfg_false""];\n	""12"" -> ""13""[label=""cfg_next""];\n	""13"" -> ""1""[label=""cfg_next""];\n	""14"" -> ""8""[label=""cfg_next""];\n	""15"" -> ""11""[label=""cfg_next""];\n	""16"" -> ""7""[label=""cfg_next""];\n	""2"" -> ""10""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""15""[label=""cfg_next""];\n	""5"" -> ""14""[label=""cfg_next""];\n	""6"" -> ""16""[label=""cfg_next""];\n	""7"" -> ""11""[label=""cfg_goto""];\n	""8"" -> ""11""[label=""cfg_goto""];\n	""9"" -> ""2""[label=""cfg_true""];\n	""9"" -> ""6""[label=""cfg_false""];\n}\n",private 
org.apache.commons.csv.CSVPrinter.printRecords(IOStream),Method,No Comment,"@SuppressWarnings(""resource"")\nprivate void printRecords(final IOStream<?> stream) throws IOException {\n    format.limit(stream).forEachOrdered(this::printRecordObject);\n}",void printRecords(org.apache.commons.io.function.IOStream),"digraph cfg_printRecords {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format>""];\n	""2"" [label=""$stack3 = dynamicinvoke \""accept\"" <org.apache.commons.io.function.IOConsumer (org.apache.commons.csv.CSVPrinter)>(this) <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>(methodtype: void __METHODTYPE__(java.lang.Object), methodhandle: \""REF_INVOKE_SPECIAL\"" <org.apache.commons.csv.CSVPrinter: void printRecordObject(java.lang.Object)>, methodtype: void __METHODTYPE__(java.lang.Object))""];\n	""3"" [label=""$stack4 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat: org.apache.commons.io.function.IOStream limit(org.apache.commons.io.function.IOStream)>(stream)""];\n	""4"" [label=""interfaceinvoke $stack4.<org.apache.commons.io.function.IOStream: void forEachOrdered(org.apache.commons.io.function.IOConsumer)>($stack3)""];\n	""5"" [label=""return""];\n	""6"" [label=""stream := @parameter0: org.apache.commons.io.function.IOStream""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVPrinter.printRecords(Iterable),Method,"* Prints all the objects in the given {@link Iterable} handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given Iterable only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Iterable)}. If the given Iterable contains nested collections/arrays those nested elements\n     * will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>{@code\n     * List<String[]> data = new ArrayList<>();\n     * data.add(new String[]{ ""A"", ""B"", ""C"" });\n     * data.add(new String[]{ ""1"", ""2"", ""3"" });\n     * data.add(new String[]{ ""A1"", ""B2"", ""C3"" });\n     * }\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * {@code\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * }\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs","@SuppressWarnings(""resource"")\npublic void printRecords(final Iterable<?> values) throws IOException {\n    printRecords(IOStream.of(values));\n}",void printRecords(java.lang.Iterable),"digraph cfg_printRecords {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.io.function.IOStream: org.apache.commons.io.function.IOStream of(java.lang.Iterable)>(values)""];\n	""2"" [label=""return""];\n	""3"" [label=""specialinvoke this.<org.apache.commons.csv.CSVPrinter: void printRecords(org.apache.commons.io.function.IOStream)>($stack2)""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""5"" [label=""values := @parameter0: java.lang.Iterable""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVPrinter.printRecords(Object[]),Method,"* Prints all the objects in the given array handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given array only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Object...)}. If the given collections contain nested collections or arrays, those nested\n     * elements will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>{@code\n     * String[][] data = new String[3][]\n     * data[0] = String[]{ ""A"", ""B"", ""C"" };\n     * data[1] = new String[]{ ""1"", ""2"", ""3"" };\n     * data[2] = new String[]{ ""A1"", ""B2"", ""C3"" };\n     * }\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>{@code\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * }\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs",public void printRecords(final Object... values) throws IOException {\n    printRecords(Arrays.asList(values));\n},void printRecords(java.lang.Object[]),"digraph cfg_printRecords {\n	""1"" [label=""$stack2 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(values)""];\n	""2"" [label=""return""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""4"" [label=""values := @parameter0: java.lang.Object[]""];\n	""5"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void printRecords(java.lang.Iterable)>($stack2)""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVPrinter.printRecords(ResultSet),Method,* Prints all the objects in the given JDBC result set.\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a result set produces. This is most useful when you cannot limit rows\n     * through {@link Statement#setLargeMaxRows(long)} or {@link Statement#setMaxRows(int)}.\n     * </p>\n     *\n     * @param resultSet The values to print.\n     * @throws IOException  If an I/O error occurs.\n     * @throws SQLException Thrown when a database access error occurs.,"public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n    final int columnCount = resultSet.getMetaData().getColumnCount();\n    while (resultSet.next() && format.useRow(resultSet.getRow())) {\n        for (int i = 1; i <= columnCount; i++) {\n            final Object object = resultSet.getObject(i);\n            if (object instanceof Clob) {\n                try (Reader reader = ((Clob) object).getCharacterStream()) {\n                    print(reader);\n                }\n            } else if (object instanceof Blob) {\n                try (InputStream inputStream = ((Blob) object).getBinaryStream()) {\n                    print(inputStream);\n                }\n            } else {\n                print(object);\n            }\n        }\n        endOfRecord();\n    }\n}",void printRecords(java.sql.ResultSet),"digraph cfg_printRecords {\n	""1"" [label=""$stack10 = this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format>""];\n	""2"" [label=""$stack11 = interfaceinvoke resultSet.<java.sql.ResultSet: int getRow()>()""];\n	""3"" [label=""$stack12 = (long) $stack11""];\n	""4"" [label=""$stack13 = virtualinvoke $stack10.<org.apache.commons.csv.CSVFormat: boolean useRow(long)>($stack12)""];\n	""5"" [label=""$stack14 = object instanceof java.sql.Clob""];\n	""6"" [label=""$stack15 = object instanceof java.sql.Blob""];\n	""7"" [label=""$stack16 = (java.sql.Blob) object""];\n	""8"" [label=""$stack17 = (java.sql.Clob) object""];\n	""9"" [label=""$stack18 := @caughtexception""];\n	""10"" [label=""$stack19 := @caughtexception""];\n	""11"" [label=""$stack20 := @caughtexception""];\n	""12"" [label=""$stack21 := @caughtexception""];\n	""13"" [label=""$stack8 = interfaceinvoke resultSet.<java.sql.ResultSet: java.sql.ResultSetMetaData getMetaData()>()""];\n	""14"" [label=""$stack9 = interfaceinvoke resultSet.<java.sql.ResultSet: boolean next()>()""];\n	""15"" [label=""columnCount = interfaceinvoke $stack8.<java.sql.ResultSetMetaData: int getColumnCount()>()""];\n	""16"" [label=""goto""];\n	""17"" [label=""goto""];\n	""18"" [label=""goto""];\n	""19"" [label=""goto""];\n	""20"" [label=""goto""];\n	""21"" [label=""goto""];\n	""22"" [label=""goto""];\n	""23"" [label=""goto""];\n	""24"" [label=""i = 1""];\n	""25"" [label=""i = i + 1""];\n	""26"" [label=""if $stack13 == 0""];\n	""27"" [label=""if $stack14 == 0""];\n	""28"" [label=""if $stack15 == 0""];\n	""29"" [label=""if $stack9 == 0""];\n	""30"" [label=""if i > columnCount""];\n	""31"" [label=""if reader == null""];\n	""32"" [label=""if reader == null""];\n	""33"" [label=""if reader == null""];\n	""34"" [label=""if reader == null""];\n	""35"" [label=""l6 = $stack19""];\n	""36"" [label=""l6 = $stack21""];\n	""37"" [label=""l7 = $stack18""];\n	""38"" [label=""l7 = $stack20""];\n	""39"" [label=""object = interfaceinvoke resultSet.<java.sql.ResultSet: java.lang.Object getObject(int)>(i)""];\n	""40"" [label=""reader = interfaceinvoke $stack16.<java.sql.Blob: java.io.InputStream getBinaryStream()>()""];\n	""41"" [label=""reader = interfaceinvoke $stack17.<java.sql.Clob: java.io.Reader getCharacterStream()>()""];\n	""42"" [label=""resultSet := @parameter0: java.sql.ResultSet""];\n	""43"" [label=""return""];\n	""44"" [label=""specialinvoke this.<org.apache.commons.csv.CSVPrinter: void endOfRecord()>()""];\n	""45"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""46"" [label=""throw l6""];\n	""47"" [label=""throw l6""];\n	""48"" [label=""virtualinvoke l6.<java.lang.Throwable: void addSuppressed(java.lang.Throwable)>(l7)""];\n	""49"" [label=""virtualinvoke reader.<java.io.InputStream: void close()>()""];\n	""50"" [label=""virtualinvoke reader.<java.io.InputStream: void close()>()""];\n	""51"" [label=""virtualinvoke reader.<java.io.Reader: void close()>()""];\n	""52"" [label=""virtualinvoke reader.<java.io.Reader: void close()>()""];\n	""53"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void print(java.lang.Object)>(object)""];\n	""54"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void print(java.lang.Object)>(reader)""];\n	""55"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void print(java.lang.Object)>(reader)""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""35""[label=""cfg_next""];\n	""11"" -> ""38""[label=""cfg_next""];\n	""12"" -> ""36""[label=""cfg_next""];\n	""13"" -> ""15""[label=""cfg_next""];\n	""14"" -> ""29""[label=""cfg_next""];\n	""15"" -> ""14""[label=""cfg_next""];\n	""16"" -> ""25""[label=""cfg_goto""];\n	""17"" -> ""16""[label=""cfg_goto""];\n	""18"" -> ""46""[label=""cfg_goto""];\n	""19"" -> ""25""[label=""cfg_goto""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""20"" -> ""19""[label=""cfg_goto""];\n	""21"" -> ""47""[label=""cfg_goto""];\n	""22"" -> ""30""[label=""cfg_goto""];\n	""23"" -> ""14""[label=""cfg_goto""];\n	""24"" -> ""30""[label=""cfg_next""];\n	""25"" -> ""22""[label=""cfg_next""];\n	""26"" -> ""24""[label=""cfg_false""];\n	""26"" -> ""43""[label=""cfg_true""];\n	""27"" -> ""6""[label=""cfg_true""];\n	""27"" -> ""8""[label=""cfg_false""];\n	""28"" -> ""53""[label=""cfg_true""];\n	""28"" -> ""7""[label=""cfg_false""];\n	""29"" -> ""1""[label=""cfg_false""];\n	""29"" -> ""43""[label=""cfg_true""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""30"" -> ""39""[label=""cfg_false""];\n	""30"" -> ""44""[label=""cfg_true""];\n	""31"" -> ""16""[label=""cfg_true""];\n	""31"" -> ""51""[label=""cfg_false""];\n	""32"" -> ""46""[label=""cfg_true""];\n	""32"" -> ""52""[label=""cfg_false""];\n	""33"" -> ""19""[label=""cfg_true""];\n	""33"" -> ""49""[label=""cfg_false""];\n	""34"" -> ""47""[label=""cfg_true""];\n	""34"" -> ""50""[label=""cfg_false""];\n	""35"" -> ""34""[label=""cfg_next""];\n	""36"" -> ""32""[label=""cfg_next""];\n	""37"" -> ""48""[label=""cfg_next""];\n	""38"" -> ""48""[label=""cfg_next""];\n	""39"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""26""[label=""cfg_next""];\n	""40"" -> ""55""[label=""cfg_next""];\n	""41"" -> ""54""[label=""cfg_next""];\n	""42"" -> ""13""[label=""cfg_next""];\n	""44"" -> ""23""[label=""cfg_next""];\n	""45"" -> ""42""[label=""cfg_next""];\n	""48"" -> ""46""[label=""cfg_next""];\n	""48"" -> ""47""[label=""cfg_next""];\n	""49"" -> ""20""[label=""cfg_next""];\n	""5"" -> ""27""[label=""cfg_next""];\n	""50"" -> ""21""[label=""cfg_next""];\n	""50"" -> ""9""[label=""cfg_except""];\n	""51"" -> ""17""[label=""cfg_next""];\n	""52"" -> ""11""[label=""cfg_except""];\n	""52"" -> ""18""[label=""cfg_next""];\n	""53"" -> ""25""[label=""cfg_next""];\n	""54"" -> ""12""[label=""cfg_except""];\n	""54"" -> ""31""[label=""cfg_next""];\n	""55"" -> ""10""[label=""cfg_except""];\n	""55"" -> ""33""[label=""cfg_next""];\n	""6"" -> ""28""[label=""cfg_next""];\n	""7"" -> ""40""[label=""cfg_next""];\n	""8"" -> ""41""[label=""cfg_next""];\n	""9"" -> ""37""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVPrinter.printRecords(ResultSet,boolean)",Method,* Prints all the objects with metadata in the given JDBC result set based on the header boolean.\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a result set produces. This is most useful when you cannot limit rows\n     * through {@link Statement#setLargeMaxRows(long)} or {@link Statement#setMaxRows(int)}.\n     * </p>\n     *\n     * @param resultSet source of row data.\n     * @param printHeader whether to print headers.\n     * @throws IOException If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     * @since 1.9.0,"public void printRecords(final ResultSet resultSet, final boolean printHeader) throws SQLException, IOException {\n    if (printHeader) {\n        printHeaders(resultSet);\n    }\n    printRecords(resultSet);\n}","void printRecords(java.sql.ResultSet,boolean)","digraph cfg_printRecords {\n	""1"" [label=""if printHeader == 0""];\n	""2"" [label=""printHeader := @parameter1: boolean""];\n	""3"" [label=""resultSet := @parameter0: java.sql.ResultSet""];\n	""4"" [label=""return""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""6"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void printHeaders(java.sql.ResultSet)>(resultSet)""];\n	""7"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void printRecords(java.sql.ResultSet)>(resultSet)""];\n	""1"" -> ""6""[label=""cfg_false""];\n	""1"" -> ""7""[label=""cfg_true""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVPrinter.printRecords(Stream),Method,"* Prints all the objects in the given {@link Stream} handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given Stream only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Iterable)}. If the given Stream contains nested collections/arrays those nested elements\n     * will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>{@code\n     * List<String[]> data = new ArrayList<>();\n     * data.add(new String[]{ ""A"", ""B"", ""C"" });\n     * data.add(new String[]{ ""1"", ""2"", ""3"" });\n     * data.add(new String[]{ ""A1"", ""B2"", ""C3"" });\n     * Stream<String[]> stream = data.stream();\n     * }\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * {@code\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * }\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.10.0","// Caller closes.\n@SuppressWarnings({ ""resource"" })\npublic void printRecords(final Stream<?> values) throws IOException {\n    printRecords(IOStream.adapt(values));\n}",void printRecords(java.util.stream.Stream),"digraph cfg_printRecords {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.io.function.IOStream: org.apache.commons.io.function.IOStream adapt(java.util.stream.Stream)>(values)""];\n	""2"" [label=""return""];\n	""3"" [label=""specialinvoke this.<org.apache.commons.csv.CSVPrinter: void printRecords(org.apache.commons.io.function.IOStream)>($stack2)""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""5"" [label=""values := @parameter0: java.util.stream.Stream""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVPrinter.<init>(Appendable,CSVFormat)",Constructor,"* Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     *\n     * @param appendable\n     *            stream to which to print. Must not be null.\n     * @param format\n     *            the CSV format. Must not be null.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *             thrown if the parameters of the format are inconsistent or if either out or format are null.","public CSVPrinter(final Appendable appendable, final CSVFormat format) throws IOException {\n    Objects.requireNonNull(appendable, ""appendable"");\n    Objects.requireNonNull(format, ""format"");\n    this.appendable = appendable;\n    this.format = format.copy();\n    // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n    // It seems a pain to have to track whether the header has already been printed or not.\n    final String[] headerComments = format.getHeaderComments();\n    if (headerComments != null) {\n        for (final String line : headerComments) {\n            printComment(line);\n        }\n    }\n    if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\n        this.printRecord((Object[]) format.getHeader());\n    }\n}","void <init>(java.lang.Appendable,org.apache.commons.csv.CSVFormat)","digraph cfg_init {\n	""1"" [label=""$stack10 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: boolean getSkipHeaderRecord()>()""];\n	""2"" [label=""$stack11 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: java.lang.String[] getHeader()>()""];\n	""3"" [label=""$stack12 = (java.lang.Object[]) $stack11""];\n	""4"" [label=""$stack8 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat copy()>()""];\n	""5"" [label=""$stack9 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: java.lang.String[] getHeader()>()""];\n	""6"" [label=""appendable := @parameter0: java.lang.Appendable""];\n	""7"" [label=""format := @parameter1: org.apache.commons.csv.CSVFormat""];\n	""8"" [label=""goto""];\n	""9"" [label=""headerComments = virtualinvoke format.<org.apache.commons.csv.CSVFormat: java.lang.String[] getHeaderComments()>()""];\n	""10"" [label=""if $stack10 != 0""];\n	""11"" [label=""if $stack9 == null""];\n	""12"" [label=""if headerComments == null""];\n	""13"" [label=""if l6 >= l5""];\n	""14"" [label=""l4 = headerComments""];\n	""15"" [label=""l5 = lengthof l4""];\n	""16"" [label=""l6 = 0""];\n	""17"" [label=""l6 = l6 + 1""];\n	""18"" [label=""line = l4[l6]""];\n	""19"" [label=""return""];\n	""20"" [label=""specialinvoke this.<java.lang.Object: void <init>()>()""];\n	""21"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(appendable, \""appendable\"")""];\n	""22"" [label=""staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(format, \""format\"")""];\n	""23"" [label=""this := @this: org.apache.commons.csv.CSVPrinter""];\n	""24"" [label=""this.<org.apache.commons.csv.CSVPrinter: boolean newRecord> = 1""];\n	""25"" [label=""this.<org.apache.commons.csv.CSVPrinter: java.lang.Appendable appendable> = appendable""];\n	""26"" [label=""this.<org.apache.commons.csv.CSVPrinter: org.apache.commons.csv.CSVFormat format> = $stack8""];\n	""27"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void printComment(java.lang.String)>(line)""];\n	""28"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVPrinter: void printRecord(java.lang.Object[])>($stack12)""];\n	""1"" -> ""10""[label=""cfg_next""];\n	""10"" -> ""19""[label=""cfg_true""];\n	""10"" -> ""2""[label=""cfg_false""];\n	""11"" -> ""1""[label=""cfg_false""];\n	""11"" -> ""19""[label=""cfg_true""];\n	""12"" -> ""14""[label=""cfg_false""];\n	""12"" -> ""5""[label=""cfg_true""];\n	""13"" -> ""18""[label=""cfg_false""];\n	""13"" -> ""5""[label=""cfg_true""];\n	""14"" -> ""15""[label=""cfg_next""];\n	""15"" -> ""16""[label=""cfg_next""];\n	""16"" -> ""13""[label=""cfg_next""];\n	""17"" -> ""8""[label=""cfg_next""];\n	""18"" -> ""27""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""20"" -> ""24""[label=""cfg_next""];\n	""21"" -> ""22""[label=""cfg_next""];\n	""22"" -> ""25""[label=""cfg_next""];\n	""23"" -> ""6""[label=""cfg_next""];\n	""24"" -> ""21""[label=""cfg_next""];\n	""25"" -> ""4""[label=""cfg_next""];\n	""26"" -> ""9""[label=""cfg_next""];\n	""27"" -> ""17""[label=""cfg_next""];\n	""28"" -> ""19""[label=""cfg_next""];\n	""3"" -> ""28""[label=""cfg_next""];\n	""4"" -> ""26""[label=""cfg_next""];\n	""5"" -> ""11""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""20""[label=""cfg_next""];\n	""8"" -> ""13""[label=""cfg_goto""];\n	""9"" -> ""12""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.clone(Object[]),Method,* Null-safe clone of an array.\n     *\n     * @param <T>    The array element type.\n     * @param values the source array\n     * @return the cloned array.,@SafeVarargs\nstatic <T> T[] clone(final T... values) {\n    return values == null ? null : values.clone();\n},java.lang.Object[] clone(java.lang.Object[]),"digraph cfg_clone {\n	""1"" [label=""$stack1 = virtualinvoke values.<java.lang.Object: java.lang.Object clone()>()""];\n	""2"" [label=""$stack2 = (java.lang.Object[]) $stack1""];\n	""3"" [label=""$stack2 = null""];\n	""4"" [label=""goto""];\n	""5"" [label=""if values != null""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""values := @parameter0: java.lang.Object[]""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""1""[label=""cfg_true""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""5""[label=""cfg_next""];\n}\n",static 
"org.apache.commons.csv.CSVFormat.contains(String,char)",Method,* Returns true if the given string contains the search char.\n     *\n     * @param source   the string to check.\n     * @param searchCh the character to search.\n     * @return true if {@code c} contains a line break character,"private static boolean contains(final String source, final char searchCh) {\n    return Objects.requireNonNull(source, ""source"").indexOf(searchCh) >= 0;\n}","boolean contains(java.lang.String,char)","digraph cfg_contains {\n	""1"" [label=""$stack2 = staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(source, \""source\"")""];\n	""2"" [label=""$stack3 = (java.lang.String) $stack2""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<java.lang.String: int indexOf(int)>(searchCh)""];\n	""4"" [label=""$stack5 = 0""];\n	""5"" [label=""$stack5 = 1""];\n	""6"" [label=""goto""];\n	""7"" [label=""if $stack4 < 0""];\n	""8"" [label=""return $stack5""];\n	""9"" [label=""searchCh := @parameter1: char""];\n	""10"" [label=""source := @parameter0: java.lang.String""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""9""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""7""[label=""cfg_next""];\n	""4"" -> ""8""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_goto""];\n	""7"" -> ""4""[label=""cfg_true""];\n	""7"" -> ""5""[label=""cfg_false""];\n	""9"" -> ""1""[label=""cfg_next""];\n}\n","private , static "
org.apache.commons.csv.CSVFormat.containsLineBreak(String),Method,* Returns true if the given string contains a line break character.\n     *\n     * @param source the string to check.\n     * @return true if {@code c} contains a line break character.,"private static boolean containsLineBreak(final String source) {\n    return contains(source, Constants.CR) || contains(source, Constants.LF);\n}",boolean containsLineBreak(java.lang.String),"digraph cfg_containsLineBreak {\n	""1"" [label=""$stack1 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean contains(java.lang.String,char)>(source, 13)""];\n	""2"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean contains(java.lang.String,char)>(source, 10)""];\n	""3"" [label=""$stack3 = 0""];\n	""4"" [label=""$stack3 = 1""];\n	""5"" [label=""goto""];\n	""6"" [label=""if $stack1 != 0""];\n	""7"" [label=""if $stack2 == 0""];\n	""8"" [label=""return $stack3""];\n	""9"" [label=""source := @parameter0: java.lang.String""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""8""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""8""[label=""cfg_goto""];\n	""6"" -> ""2""[label=""cfg_false""];\n	""6"" -> ""4""[label=""cfg_true""];\n	""7"" -> ""3""[label=""cfg_true""];\n	""7"" -> ""4""[label=""cfg_false""];\n	""9"" -> ""1""[label=""cfg_next""];\n}\n","private , static "
org.apache.commons.csv.CSVFormat.copy(CSVFormat),Method,* Creates a null-safe copy of the given instance.\n     *\n     * @return a copy of the given instance or null if the input is null.,static CSVFormat copy(final CSVFormat format) {\n    return format != null ? format.copy() : null;\n},org.apache.commons.csv.CSVFormat copy(org.apache.commons.csv.CSVFormat),"digraph cfg_copy {\n	""1"" [label=""$stack1 = null""];\n	""2"" [label=""$stack1 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat copy()>()""];\n	""3"" [label=""format := @parameter0: org.apache.commons.csv.CSVFormat""];\n	""4"" [label=""goto""];\n	""5"" [label=""if format == null""];\n	""6"" [label=""return $stack1""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""1""[label=""cfg_true""];\n	""5"" -> ""2""[label=""cfg_false""];\n}\n",static 
org.apache.commons.csv.CSVFormat.isBlank(String),Method,No Comment,static boolean isBlank(final String value) {\n    return value == null || value.trim().isEmpty();\n},boolean isBlank(java.lang.String),"digraph cfg_isBlank {\n	""1"" [label=""$stack1 = virtualinvoke value.<java.lang.String: java.lang.String trim()>()""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<java.lang.String: boolean isEmpty()>()""];\n	""3"" [label=""$stack3 = 0""];\n	""4"" [label=""$stack3 = 1""];\n	""5"" [label=""goto""];\n	""6"" [label=""if $stack2 == 0""];\n	""7"" [label=""if value == null""];\n	""8"" [label=""return $stack3""];\n	""9"" [label=""value := @parameter0: java.lang.String""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""8""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""8""[label=""cfg_goto""];\n	""6"" -> ""3""[label=""cfg_true""];\n	""6"" -> ""4""[label=""cfg_false""];\n	""7"" -> ""1""[label=""cfg_false""];\n	""7"" -> ""4""[label=""cfg_true""];\n	""9"" -> ""7""[label=""cfg_next""];\n}\n",static 
org.apache.commons.csv.CSVFormat.isLineBreak(char),Method,* Returns true if the given character is a line break character.\n     *\n     * @param c the character to check.\n     * @return true if {@code c} is a line break character.,private static boolean isLineBreak(final char c) {\n    return c == Constants.LF || c == Constants.CR;\n},boolean isLineBreak(char),"digraph cfg_isLineBreak {\n	""1"" [label=""$stack1 = 0""];\n	""2"" [label=""$stack1 = 1""];\n	""3"" [label=""c := @parameter0: char""];\n	""4"" [label=""goto""];\n	""5"" [label=""if c != 13""];\n	""6"" [label=""if c == 10""];\n	""7"" [label=""return $stack1""];\n	""1"" -> ""7""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""6""[label=""cfg_next""];\n	""4"" -> ""7""[label=""cfg_goto""];\n	""5"" -> ""1""[label=""cfg_true""];\n	""5"" -> ""2""[label=""cfg_false""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""6"" -> ""5""[label=""cfg_false""];\n}\n","private , static "
org.apache.commons.csv.CSVFormat.isLineBreak(Character),Method,"* Returns true if the given character is a line break character.\n     *\n     * @param c the character to check, may be null.\n     * @return true if {@code c} is a line break character (and not null).",private static boolean isLineBreak(final Character c) {\n    // N.B. Explicit (un)boxing is intentional\n    return c != null && isLineBreak(c.charValue());\n},boolean isLineBreak(java.lang.Character),"digraph cfg_isLineBreak {\n	""1"" [label=""$stack1 = virtualinvoke c.<java.lang.Character: char charValue()>()""];\n	""2"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean isLineBreak(char)>($stack1)""];\n	""3"" [label=""$stack3 = 0""];\n	""4"" [label=""$stack3 = 1""];\n	""5"" [label=""c := @parameter0: java.lang.Character""];\n	""6"" [label=""goto""];\n	""7"" [label=""if $stack2 == 0""];\n	""8"" [label=""if c == null""];\n	""9"" [label=""return $stack3""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""9""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""8""[label=""cfg_next""];\n	""6"" -> ""9""[label=""cfg_goto""];\n	""7"" -> ""3""[label=""cfg_true""];\n	""7"" -> ""4""[label=""cfg_false""];\n	""8"" -> ""1""[label=""cfg_false""];\n	""8"" -> ""3""[label=""cfg_true""];\n}\n","private , static "
org.apache.commons.csv.CSVFormat.isTrimChar(char),Method,Same test as in as {@link String#trim()}.,private static boolean isTrimChar(final char ch) {\n    return ch <= Constants.SP;\n},boolean isTrimChar(char),"digraph cfg_isTrimChar {\n	""1"" [label=""$stack1 = 0""];\n	""2"" [label=""$stack1 = 1""];\n	""3"" [label=""ch := @parameter0: char""];\n	""4"" [label=""goto""];\n	""5"" [label=""if ch > 32""];\n	""6"" [label=""return $stack1""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""1""[label=""cfg_true""];\n	""5"" -> ""2""[label=""cfg_false""];\n}\n","private , static "
"org.apache.commons.csv.CSVFormat.isTrimChar(CharSequence,int)",Method,Same test as in as {@link String#trim()}.,"private static boolean isTrimChar(final CharSequence charSequence, final int pos) {\n    return isTrimChar(charSequence.charAt(pos));\n}","boolean isTrimChar(java.lang.CharSequence,int)","digraph cfg_isTrimChar {\n	""1"" [label=""$stack2 = interfaceinvoke charSequence.<java.lang.CharSequence: char charAt(int)>(pos)""];\n	""2"" [label=""$stack3 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean isTrimChar(char)>($stack2)""];\n	""3"" [label=""charSequence := @parameter0: java.lang.CharSequence""];\n	""4"" [label=""pos := @parameter1: int""];\n	""5"" [label=""return $stack3""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n","private , static "
org.apache.commons.csv.CSVFormat.newFormat(char),Method,"* Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\n     * </p>\n     *\n     * @param delimiter the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF",public static CSVFormat newFormat(final char delimiter) {\n    return new CSVFormat(new Builder().setDelimiter(delimiter));\n},org.apache.commons.csv.CSVFormat newFormat(char),"digraph cfg_newFormat {\n	""1"" [label=""$stack1 = new org.apache.commons.csv.CSVFormat$Builder""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setDelimiter(char)>(delimiter)""];\n	""3"" [label=""$stack3 = new org.apache.commons.csv.CSVFormat""];\n	""4"" [label=""delimiter := @parameter0: char""];\n	""5"" [label=""return $stack3""];\n	""6"" [label=""specialinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: void <init>(org.apache.commons.csv.CSVFormat$1)>(null)""];\n	""7"" [label=""specialinvoke $stack3.<org.apache.commons.csv.CSVFormat: void <init>(org.apache.commons.csv.CSVFormat$Builder)>($stack2)""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""2""[label=""cfg_next""];\n	""7"" -> ""5""[label=""cfg_next""];\n}\n","public , static "
org.apache.commons.csv.CSVFormat.toStringArray(Object[]),Method,No Comment,"static String[] toStringArray(final Object[] values) {\n    if (values == null) {\n        return null;\n    }\n    final String[] strings = new String[values.length];\n    Arrays.setAll(strings, i -> Objects.toString(values[i], null));\n    return strings;\n}",java.lang.String[] toStringArray(java.lang.Object[]),"digraph cfg_toStringArray {\n	""1"" [label=""$stack2 = lengthof values""];\n	""2"" [label=""$stack3 = dynamicinvoke \""apply\"" <java.util.function.IntFunction (java.lang.Object[])>(values) <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>(methodtype: java.lang.Object __METHODTYPE__(int), methodhandle: \""REF_INVOKE_STATIC\"" <org.apache.commons.csv.CSVFormat: java.lang.String lambda$toStringArray$0(java.lang.Object[],int)>, methodtype: java.lang.String __METHODTYPE__(int))""];\n	""3"" [label=""if values != null""];\n	""4"" [label=""return null""];\n	""5"" [label=""return strings""];\n	""6"" [label=""staticinvoke <java.util.Arrays: void setAll(java.lang.Object[],java.util.function.IntFunction)>(strings, $stack3)""];\n	""7"" [label=""strings = newarray (java.lang.String)[$stack2]""];\n	""8"" [label=""values := @parameter0: java.lang.Object[]""];\n	""1"" -> ""7""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_true""];\n	""3"" -> ""4""[label=""cfg_false""];\n	""6"" -> ""5""[label=""cfg_next""];\n	""7"" -> ""2""[label=""cfg_next""];\n	""8"" -> ""3""[label=""cfg_next""];\n}\n",static 
org.apache.commons.csv.CSVFormat.trim(CharSequence),Method,No Comment,"static CharSequence trim(final CharSequence charSequence) {\n    if (charSequence instanceof String) {\n        return ((String) charSequence).trim();\n    }\n    final int count = charSequence.length();\n    int len = count;\n    int pos = 0;\n    while (pos < len && isTrimChar(charSequence, pos)) {\n        pos++;\n    }\n    while (pos < len && isTrimChar(charSequence, len - 1)) {\n        len--;\n    }\n    return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n}",java.lang.CharSequence trim(java.lang.CharSequence),"digraph cfg_trim {\n	""1"" [label=""$stack10 = virtualinvoke $stack9.<java.lang.String: java.lang.String trim()>()""];\n	""2"" [label=""$stack4 = charSequence instanceof java.lang.String""];\n	""3"" [label=""$stack5 = charSequence""];\n	""4"" [label=""$stack5 = interfaceinvoke charSequence.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(pos, len)""];\n	""5"" [label=""$stack6 = len - 1""];\n	""6"" [label=""$stack7 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean isTrimChar(java.lang.CharSequence,int)>(charSequence, $stack6)""];\n	""7"" [label=""$stack8 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean isTrimChar(java.lang.CharSequence,int)>(charSequence, pos)""];\n	""8"" [label=""$stack9 = (java.lang.String) charSequence""];\n	""9"" [label=""charSequence := @parameter0: java.lang.CharSequence""];\n	""10"" [label=""count = interfaceinvoke charSequence.<java.lang.CharSequence: int length()>()""];\n	""11"" [label=""goto""];\n	""12"" [label=""goto""];\n	""13"" [label=""goto""];\n	""14"" [label=""if $stack4 == 0""];\n	""15"" [label=""if $stack7 == 0""];\n	""16"" [label=""if $stack8 == 0""];\n	""17"" [label=""if len >= count""];\n	""18"" [label=""if pos > 0""];\n	""19"" [label=""if pos >= len""];\n	""20"" [label=""if pos >= len""];\n	""21"" [label=""len = count""];\n	""22"" [label=""len = len + -1""];\n	""23"" [label=""pos = 0""];\n	""24"" [label=""pos = pos + 1""];\n	""25"" [label=""return $stack10""];\n	""26"" [label=""return $stack5""];\n	""1"" -> ""25""[label=""cfg_next""];\n	""10"" -> ""21""[label=""cfg_next""];\n	""11"" -> ""19""[label=""cfg_goto""];\n	""12"" -> ""20""[label=""cfg_goto""];\n	""13"" -> ""26""[label=""cfg_goto""];\n	""14"" -> ""10""[label=""cfg_true""];\n	""14"" -> ""8""[label=""cfg_false""];\n	""15"" -> ""18""[label=""cfg_true""];\n	""15"" -> ""22""[label=""cfg_false""];\n	""16"" -> ""20""[label=""cfg_true""];\n	""16"" -> ""24""[label=""cfg_false""];\n	""17"" -> ""3""[label=""cfg_true""];\n	""17"" -> ""4""[label=""cfg_false""];\n	""18"" -> ""17""[label=""cfg_false""];\n	""18"" -> ""4""[label=""cfg_true""];\n	""19"" -> ""20""[label=""cfg_true""];\n	""19"" -> ""7""[label=""cfg_false""];\n	""2"" -> ""14""[label=""cfg_next""];\n	""20"" -> ""18""[label=""cfg_true""];\n	""20"" -> ""5""[label=""cfg_false""];\n	""21"" -> ""23""[label=""cfg_next""];\n	""22"" -> ""12""[label=""cfg_next""];\n	""23"" -> ""19""[label=""cfg_next""];\n	""24"" -> ""11""[label=""cfg_next""];\n	""3"" -> ""26""[label=""cfg_next""];\n	""4"" -> ""13""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""15""[label=""cfg_next""];\n	""7"" -> ""16""[label=""cfg_next""];\n	""8"" -> ""1""[label=""cfg_next""];\n	""9"" -> ""2""[label=""cfg_next""];\n}\n",static 
org.apache.commons.csv.CSVFormat.valueOf(String),Method,* Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format name\n     * @return one of the predefined formats\n     * @since 1.2,public static CSVFormat valueOf(final String format) {\n    return CSVFormat.Predefined.valueOf(format).getFormat();\n},org.apache.commons.csv.CSVFormat valueOf(java.lang.String),"digraph cfg_valueOf {\n	""1"" [label=""$stack1 = staticinvoke <org.apache.commons.csv.CSVFormat$Predefined: org.apache.commons.csv.CSVFormat$Predefined valueOf(java.lang.String)>(format)""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Predefined: org.apache.commons.csv.CSVFormat getFormat()>()""];\n	""3"" [label=""format := @parameter0: java.lang.String""];\n	""4"" [label=""return $stack2""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n","public , static "
"org.apache.commons.csv.CSVFormat.append(char,Appendable)",Method,No Comment,"private void append(final char c, final Appendable appendable) throws IOException {\n    // try {\n    appendable.append(c);\n    // } catch (final IOException e) {\n    // throw new UncheckedIOException(e);\n    // }\n}","void append(char,java.lang.Appendable)","digraph cfg_append {\n	""1"" [label=""appendable := @parameter1: java.lang.Appendable""];\n	""2"" [label=""c := @parameter0: char""];\n	""3"" [label=""interfaceinvoke appendable.<java.lang.Appendable: java.lang.Appendable append(char)>(c)""];\n	""4"" [label=""return""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""2""[label=""cfg_next""];\n}\n",private 
"org.apache.commons.csv.CSVFormat.append(CharSequence,Appendable)",Method,No Comment,"private void append(final CharSequence csq, final Appendable appendable) throws IOException {\n    // try {\n    appendable.append(csq);\n    // } catch (final IOException e) {\n    // throw new UncheckedIOException(e);\n    // }\n}","void append(java.lang.CharSequence,java.lang.Appendable)","digraph cfg_append {\n	""1"" [label=""appendable := @parameter1: java.lang.Appendable""];\n	""2"" [label=""csq := @parameter0: java.lang.CharSequence""];\n	""3"" [label=""interfaceinvoke appendable.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence)>(csq)""];\n	""4"" [label=""return""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""2""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVFormat.builder(),Method,* Creates a new Builder for this instance.\n     *\n     * @return a new Builder.,public Builder builder() {\n    return Builder.create(this);\n},org.apache.commons.csv.CSVFormat$Builder builder(),"digraph cfg_builder {\n	""1"" [label=""$stack1 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder create(org.apache.commons.csv.CSVFormat)>(this)""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.copy(),Method,* Creates a copy of this instance.\n     *\n     * @return a copy of this instance.,CSVFormat copy() {\n    return builder().get();\n},org.apache.commons.csv.CSVFormat copy(),"digraph cfg_copy {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVFormat.equals(Object),Method,No Comment,"@Override\npublic boolean equals(final Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (getClass() != obj.getClass()) {\n        return false;\n    }\n    final CSVFormat other = (CSVFormat) obj;\n    return allowMissingColumnNames == other.allowMissingColumnNames && autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) && duplicateHeaderMode == other.duplicateHeaderMode && Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(headerComments, other.headerComments) && Arrays.equals(headers, other.headers) && ignoreEmptyLines == other.ignoreEmptyLines && ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces && lenientEof == other.lenientEof && Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode && Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) && skipHeaderRecord == other.skipHeaderRecord && trailingData == other.trailingData && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\n}",boolean equals(java.lang.Object),"digraph cfg_equals {\n	""1"" [label=""$stack10 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""2"" [label=""$stack11 = staticinvoke <java.util.Objects: boolean equals(java.lang.Object,java.lang.Object)>($stack10, $stack9)""];\n	""3"" [label=""$stack12 = other.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""4"" [label=""$stack13 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""5"" [label=""$stack14 = staticinvoke <java.util.Objects: boolean equals(java.lang.Object,java.lang.Object)>($stack13, $stack12)""];\n	""6"" [label=""$stack15 = other.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode>""];\n	""7"" [label=""$stack16 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode>""];\n	""8"" [label=""$stack17 = other.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""9"" [label=""$stack18 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""10"" [label=""$stack19 = staticinvoke <java.util.Objects: boolean equals(java.lang.Object,java.lang.Object)>($stack18, $stack17)""];\n	""11"" [label=""$stack20 = other.<org.apache.commons.csv.CSVFormat: java.lang.String[] headerComments>""];\n	""12"" [label=""$stack21 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headerComments>""];\n	""13"" [label=""$stack22 = staticinvoke <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>($stack21, $stack20)""];\n	""14"" [label=""$stack23 = other.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""15"" [label=""$stack24 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""16"" [label=""$stack25 = staticinvoke <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>($stack24, $stack23)""];\n	""17"" [label=""$stack26 = other.<org.apache.commons.csv.CSVFormat: boolean ignoreEmptyLines>""];\n	""18"" [label=""$stack27 = this.<org.apache.commons.csv.CSVFormat: boolean ignoreEmptyLines>""];\n	""19"" [label=""$stack28 = other.<org.apache.commons.csv.CSVFormat: boolean ignoreHeaderCase>""];\n	""20"" [label=""$stack29 = this.<org.apache.commons.csv.CSVFormat: boolean ignoreHeaderCase>""];\n	""21"" [label=""$stack3 = virtualinvoke obj.<java.lang.Object: java.lang.Class getClass()>()""];\n	""22"" [label=""$stack30 = other.<org.apache.commons.csv.CSVFormat: boolean ignoreSurroundingSpaces>""];\n	""23"" [label=""$stack31 = this.<org.apache.commons.csv.CSVFormat: boolean ignoreSurroundingSpaces>""];\n	""24"" [label=""$stack32 = other.<org.apache.commons.csv.CSVFormat: boolean lenientEof>""];\n	""25"" [label=""$stack33 = this.<org.apache.commons.csv.CSVFormat: boolean lenientEof>""];\n	""26"" [label=""$stack34 = other.<org.apache.commons.csv.CSVFormat: java.lang.String nullString>""];\n	""27"" [label=""$stack35 = this.<org.apache.commons.csv.CSVFormat: java.lang.String nullString>""];\n	""28"" [label=""$stack36 = staticinvoke <java.util.Objects: boolean equals(java.lang.Object,java.lang.Object)>($stack35, $stack34)""];\n	""29"" [label=""$stack37 = other.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""30"" [label=""$stack38 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""31"" [label=""$stack39 = staticinvoke <java.util.Objects: boolean equals(java.lang.Object,java.lang.Object)>($stack38, $stack37)""];\n	""32"" [label=""$stack4 = virtualinvoke this.<java.lang.Object: java.lang.Class getClass()>()""];\n	""33"" [label=""$stack40 = other.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode quoteMode>""];\n	""34"" [label=""$stack41 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode quoteMode>""];\n	""35"" [label=""$stack42 = other.<org.apache.commons.csv.CSVFormat: java.lang.String quotedNullString>""];\n	""36"" [label=""$stack43 = this.<org.apache.commons.csv.CSVFormat: java.lang.String quotedNullString>""];\n	""37"" [label=""$stack44 = staticinvoke <java.util.Objects: boolean equals(java.lang.Object,java.lang.Object)>($stack43, $stack42)""];\n	""38"" [label=""$stack45 = other.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""39"" [label=""$stack46 = this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""40"" [label=""$stack47 = staticinvoke <java.util.Objects: boolean equals(java.lang.Object,java.lang.Object)>($stack46, $stack45)""];\n	""41"" [label=""$stack48 = other.<org.apache.commons.csv.CSVFormat: boolean skipHeaderRecord>""];\n	""42"" [label=""$stack49 = this.<org.apache.commons.csv.CSVFormat: boolean skipHeaderRecord>""];\n	""43"" [label=""$stack5 = other.<org.apache.commons.csv.CSVFormat: boolean allowMissingColumnNames>""];\n	""44"" [label=""$stack50 = other.<org.apache.commons.csv.CSVFormat: boolean trailingData>""];\n	""45"" [label=""$stack51 = this.<org.apache.commons.csv.CSVFormat: boolean trailingData>""];\n	""46"" [label=""$stack52 = other.<org.apache.commons.csv.CSVFormat: boolean trailingDelimiter>""];\n	""47"" [label=""$stack53 = this.<org.apache.commons.csv.CSVFormat: boolean trailingDelimiter>""];\n	""48"" [label=""$stack54 = other.<org.apache.commons.csv.CSVFormat: boolean trim>""];\n	""49"" [label=""$stack55 = this.<org.apache.commons.csv.CSVFormat: boolean trim>""];\n	""50"" [label=""$stack56 = 0""];\n	""51"" [label=""$stack56 = 1""];\n	""52"" [label=""$stack6 = this.<org.apache.commons.csv.CSVFormat: boolean allowMissingColumnNames>""];\n	""53"" [label=""$stack7 = other.<org.apache.commons.csv.CSVFormat: boolean autoFlush>""];\n	""54"" [label=""$stack8 = this.<org.apache.commons.csv.CSVFormat: boolean autoFlush>""];\n	""55"" [label=""$stack9 = other.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""56"" [label=""goto""];\n	""57"" [label=""if $stack11 == 0""];\n	""58"" [label=""if $stack14 == 0""];\n	""59"" [label=""if $stack16 != $stack15""];\n	""60"" [label=""if $stack19 == 0""];\n	""61"" [label=""if $stack22 == 0""];\n	""62"" [label=""if $stack25 == 0""];\n	""63"" [label=""if $stack27 != $stack26""];\n	""64"" [label=""if $stack29 != $stack28""];\n	""65"" [label=""if $stack31 != $stack30""];\n	""66"" [label=""if $stack33 != $stack32""];\n	""67"" [label=""if $stack36 == 0""];\n	""68"" [label=""if $stack39 == 0""];\n	""69"" [label=""if $stack4 == $stack3""];\n	""70"" [label=""if $stack41 != $stack40""];\n	""71"" [label=""if $stack44 == 0""];\n	""72"" [label=""if $stack47 == 0""];\n	""73"" [label=""if $stack49 != $stack48""];\n	""74"" [label=""if $stack51 != $stack50""];\n	""75"" [label=""if $stack53 != $stack52""];\n	""76"" [label=""if $stack55 != $stack54""];\n	""77"" [label=""if $stack6 != $stack5""];\n	""78"" [label=""if $stack8 != $stack7""];\n	""79"" [label=""if obj != null""];\n	""80"" [label=""if this != obj""];\n	""81"" [label=""obj := @parameter0: java.lang.Object""];\n	""82"" [label=""other = (org.apache.commons.csv.CSVFormat) obj""];\n	""83"" [label=""return $stack56""];\n	""84"" [label=""return 0""];\n	""85"" [label=""return 0""];\n	""86"" [label=""return 1""];\n	""87"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""55""[label=""cfg_next""];\n	""10"" -> ""60""[label=""cfg_next""];\n	""11"" -> ""13""[label=""cfg_next""];\n	""12"" -> ""11""[label=""cfg_next""];\n	""13"" -> ""61""[label=""cfg_next""];\n	""14"" -> ""16""[label=""cfg_next""];\n	""15"" -> ""14""[label=""cfg_next""];\n	""16"" -> ""62""[label=""cfg_next""];\n	""17"" -> ""63""[label=""cfg_next""];\n	""18"" -> ""17""[label=""cfg_next""];\n	""19"" -> ""64""[label=""cfg_next""];\n	""2"" -> ""57""[label=""cfg_next""];\n	""20"" -> ""19""[label=""cfg_next""];\n	""21"" -> ""69""[label=""cfg_next""];\n	""22"" -> ""65""[label=""cfg_next""];\n	""23"" -> ""22""[label=""cfg_next""];\n	""24"" -> ""66""[label=""cfg_next""];\n	""25"" -> ""24""[label=""cfg_next""];\n	""26"" -> ""28""[label=""cfg_next""];\n	""27"" -> ""26""[label=""cfg_next""];\n	""28"" -> ""67""[label=""cfg_next""];\n	""29"" -> ""31""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""30"" -> ""29""[label=""cfg_next""];\n	""31"" -> ""68""[label=""cfg_next""];\n	""32"" -> ""21""[label=""cfg_next""];\n	""33"" -> ""70""[label=""cfg_next""];\n	""34"" -> ""33""[label=""cfg_next""];\n	""35"" -> ""37""[label=""cfg_next""];\n	""36"" -> ""35""[label=""cfg_next""];\n	""37"" -> ""71""[label=""cfg_next""];\n	""38"" -> ""40""[label=""cfg_next""];\n	""39"" -> ""38""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""40"" -> ""72""[label=""cfg_next""];\n	""41"" -> ""73""[label=""cfg_next""];\n	""42"" -> ""41""[label=""cfg_next""];\n	""43"" -> ""77""[label=""cfg_next""];\n	""44"" -> ""74""[label=""cfg_next""];\n	""45"" -> ""44""[label=""cfg_next""];\n	""46"" -> ""75""[label=""cfg_next""];\n	""47"" -> ""46""[label=""cfg_next""];\n	""48"" -> ""76""[label=""cfg_next""];\n	""49"" -> ""48""[label=""cfg_next""];\n	""5"" -> ""58""[label=""cfg_next""];\n	""50"" -> ""83""[label=""cfg_next""];\n	""51"" -> ""56""[label=""cfg_next""];\n	""52"" -> ""43""[label=""cfg_next""];\n	""53"" -> ""78""[label=""cfg_next""];\n	""54"" -> ""53""[label=""cfg_next""];\n	""55"" -> ""2""[label=""cfg_next""];\n	""56"" -> ""83""[label=""cfg_goto""];\n	""57"" -> ""4""[label=""cfg_false""];\n	""57"" -> ""50""[label=""cfg_true""];\n	""58"" -> ""50""[label=""cfg_true""];\n	""58"" -> ""7""[label=""cfg_false""];\n	""59"" -> ""50""[label=""cfg_true""];\n	""59"" -> ""9""[label=""cfg_false""];\n	""6"" -> ""59""[label=""cfg_next""];\n	""60"" -> ""12""[label=""cfg_false""];\n	""60"" -> ""50""[label=""cfg_true""];\n	""61"" -> ""15""[label=""cfg_false""];\n	""61"" -> ""50""[label=""cfg_true""];\n	""62"" -> ""18""[label=""cfg_false""];\n	""62"" -> ""50""[label=""cfg_true""];\n	""63"" -> ""20""[label=""cfg_false""];\n	""63"" -> ""50""[label=""cfg_true""];\n	""64"" -> ""23""[label=""cfg_false""];\n	""64"" -> ""50""[label=""cfg_true""];\n	""65"" -> ""25""[label=""cfg_false""];\n	""65"" -> ""50""[label=""cfg_true""];\n	""66"" -> ""27""[label=""cfg_false""];\n	""66"" -> ""50""[label=""cfg_true""];\n	""67"" -> ""30""[label=""cfg_false""];\n	""67"" -> ""50""[label=""cfg_true""];\n	""68"" -> ""34""[label=""cfg_false""];\n	""68"" -> ""50""[label=""cfg_true""];\n	""69"" -> ""82""[label=""cfg_true""];\n	""69"" -> ""85""[label=""cfg_false""];\n	""7"" -> ""6""[label=""cfg_next""];\n	""70"" -> ""36""[label=""cfg_false""];\n	""70"" -> ""50""[label=""cfg_true""];\n	""71"" -> ""39""[label=""cfg_false""];\n	""71"" -> ""50""[label=""cfg_true""];\n	""72"" -> ""42""[label=""cfg_false""];\n	""72"" -> ""50""[label=""cfg_true""];\n	""73"" -> ""45""[label=""cfg_false""];\n	""73"" -> ""50""[label=""cfg_true""];\n	""74"" -> ""47""[label=""cfg_false""];\n	""74"" -> ""50""[label=""cfg_true""];\n	""75"" -> ""49""[label=""cfg_false""];\n	""75"" -> ""50""[label=""cfg_true""];\n	""76"" -> ""50""[label=""cfg_true""];\n	""76"" -> ""51""[label=""cfg_false""];\n	""77"" -> ""50""[label=""cfg_true""];\n	""77"" -> ""54""[label=""cfg_false""];\n	""78"" -> ""1""[label=""cfg_false""];\n	""78"" -> ""50""[label=""cfg_true""];\n	""79"" -> ""32""[label=""cfg_true""];\n	""79"" -> ""84""[label=""cfg_false""];\n	""8"" -> ""10""[label=""cfg_next""];\n	""80"" -> ""79""[label=""cfg_true""];\n	""80"" -> ""86""[label=""cfg_false""];\n	""81"" -> ""80""[label=""cfg_next""];\n	""82"" -> ""52""[label=""cfg_next""];\n	""87"" -> ""81""[label=""cfg_next""];\n	""9"" -> ""8""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVFormat.escape(char,Appendable)",Method,No Comment,"private void escape(final char c, final Appendable appendable) throws IOException {\n    // N.B. Explicit (un)boxing is intentional\n    append(escapeCharacter.charValue(), appendable);\n    append(c, appendable);\n}","void escape(char,java.lang.Appendable)","digraph cfg_escape {\n	""1"" [label=""$stack3 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""2"" [label=""$stack4 = virtualinvoke $stack3.<java.lang.Character: char charValue()>()""];\n	""3"" [label=""appendable := @parameter1: java.lang.Appendable""];\n	""4"" [label=""c := @parameter0: char""];\n	""5"" [label=""return""];\n	""6"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(char,java.lang.Appendable)>($stack4, appendable)""];\n	""7"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(char,java.lang.Appendable)>(c, appendable)""];\n	""8"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""5""[label=""cfg_next""];\n	""8"" -> ""4""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVFormat.format(Object[]),Method,* Formats the specified values.\n     *\n     * @param values the values to format\n     * @return the formatted values,public String format(final Object... values) {\n    return Uncheck.get(() -> format_(values));\n},java.lang.String format(java.lang.Object[]),"digraph cfg_format {\n	""1"" [label=""$stack2 = dynamicinvoke \""get\"" <org.apache.commons.io.function.IOSupplier (org.apache.commons.csv.CSVFormat,java.lang.Object[])>(this, values) <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>(methodtype: java.lang.Object __METHODTYPE__(), methodhandle: \""REF_INVOKE_SPECIAL\"" <org.apache.commons.csv.CSVFormat: java.lang.String lambda$format$1(java.lang.Object[])>, methodtype: java.lang.String __METHODTYPE__())""];\n	""2"" [label=""$stack3 = staticinvoke <org.apache.commons.io.function.Uncheck: java.lang.Object get(org.apache.commons.io.function.IOSupplier)>($stack2)""];\n	""3"" [label=""$stack4 = (java.lang.String) $stack3""];\n	""4"" [label=""return $stack4""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""6"" [label=""values := @parameter0: java.lang.Object[]""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.format_(Object[]),Method,No Comment,"private String format_(final Object... values) throws IOException {\n    final StringWriter out = new StringWriter();\n    try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n        csvPrinter.printRecord(values);\n        final String res = out.toString();\n        final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\n        return res.substring(0, len);\n    }\n}",java.lang.String format_(java.lang.Object[]),"digraph cfg_format_ {\n	""1"" [label=""$stack10 = this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""2"" [label=""$stack11 = virtualinvoke res.<java.lang.String: int length()>()""];\n	""3"" [label=""$stack12 = virtualinvoke $stack10.<java.lang.String: int length()>()""];\n	""4"" [label=""$stack13 := @caughtexception""];\n	""5"" [label=""$stack14 := @caughtexception""];\n	""6"" [label=""$stack7 = new java.io.StringWriter""];\n	""7"" [label=""$stack8 = new org.apache.commons.csv.CSVPrinter""];\n	""8"" [label=""$stack9 = this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""9"" [label=""csvPrinter = $stack8""];\n	""10"" [label=""goto""];\n	""11"" [label=""goto""];\n	""12"" [label=""if $stack9 == null""];\n	""13"" [label=""l6 = virtualinvoke res.<java.lang.String: java.lang.String substring(int,int)>(0, len)""];\n	""14"" [label=""len = $stack11 - $stack12""];\n	""15"" [label=""len = $stack13""];\n	""16"" [label=""len = virtualinvoke res.<java.lang.String: int length()>()""];\n	""17"" [label=""out = $stack7""];\n	""18"" [label=""res = $stack14""];\n	""19"" [label=""res = virtualinvoke out.<java.io.StringWriter: java.lang.String toString()>()""];\n	""20"" [label=""return l6""];\n	""21"" [label=""specialinvoke $stack7.<java.io.StringWriter: void <init>()>()""];\n	""22"" [label=""specialinvoke $stack8.<org.apache.commons.csv.CSVPrinter: void <init>(java.lang.Appendable,org.apache.commons.csv.CSVFormat)>(out, this)""];\n	""23"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""24"" [label=""throw res""];\n	""25"" [label=""values := @parameter0: java.lang.Object[]""];\n	""26"" [label=""virtualinvoke csvPrinter.<org.apache.commons.csv.CSVPrinter: void close()>()""];\n	""27"" [label=""virtualinvoke csvPrinter.<org.apache.commons.csv.CSVPrinter: void close()>()""];\n	""28"" [label=""virtualinvoke csvPrinter.<org.apache.commons.csv.CSVPrinter: void printRecord(java.lang.Object[])>(values)""];\n	""29"" [label=""virtualinvoke res.<java.lang.Throwable: void addSuppressed(java.lang.Throwable)>(len)""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""1"" -> ""5""[label=""cfg_except""];\n	""10"" -> ""13""[label=""cfg_goto""];\n	""10"" -> ""5""[label=""cfg_except""];\n	""11"" -> ""24""[label=""cfg_goto""];\n	""12"" -> ""16""[label=""cfg_true""];\n	""12"" -> ""2""[label=""cfg_false""];\n	""12"" -> ""5""[label=""cfg_except""];\n	""13"" -> ""27""[label=""cfg_next""];\n	""13"" -> ""5""[label=""cfg_except""];\n	""14"" -> ""10""[label=""cfg_next""];\n	""14"" -> ""5""[label=""cfg_except""];\n	""15"" -> ""29""[label=""cfg_next""];\n	""16"" -> ""13""[label=""cfg_next""];\n	""16"" -> ""5""[label=""cfg_except""];\n	""17"" -> ""7""[label=""cfg_next""];\n	""18"" -> ""26""[label=""cfg_next""];\n	""19"" -> ""5""[label=""cfg_except""];\n	""19"" -> ""8""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_except""];\n	""21"" -> ""17""[label=""cfg_next""];\n	""22"" -> ""9""[label=""cfg_next""];\n	""23"" -> ""25""[label=""cfg_next""];\n	""25"" -> ""6""[label=""cfg_next""];\n	""26"" -> ""11""[label=""cfg_next""];\n	""26"" -> ""4""[label=""cfg_except""];\n	""27"" -> ""20""[label=""cfg_next""];\n	""28"" -> ""19""[label=""cfg_next""];\n	""28"" -> ""5""[label=""cfg_except""];\n	""29"" -> ""24""[label=""cfg_next""];\n	""3"" -> ""14""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_except""];\n	""4"" -> ""15""[label=""cfg_next""];\n	""5"" -> ""18""[label=""cfg_next""];\n	""6"" -> ""21""[label=""cfg_next""];\n	""7"" -> ""22""[label=""cfg_next""];\n	""8"" -> ""12""[label=""cfg_next""];\n	""8"" -> ""5""[label=""cfg_except""];\n	""9"" -> ""28""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVFormat.getAllowDuplicateHeaderNames(),Method,* Gets whether duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     * @deprecated Use {@link #getDuplicateHeaderMode()}.,@Deprecated\npublic boolean getAllowDuplicateHeaderNames() {\n    return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\n},boolean getAllowDuplicateHeaderNames(),"digraph cfg_getAllowDuplicateHeaderNames {\n	""1"" [label=""$stack1 = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_ALL>""];\n	""2"" [label=""$stack2 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode>""];\n	""3"" [label=""$stack3 = 0""];\n	""4"" [label=""$stack3 = 1""];\n	""5"" [label=""goto""];\n	""6"" [label=""if $stack2 != $stack1""];\n	""7"" [label=""return $stack3""];\n	""8"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""7""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_goto""];\n	""6"" -> ""3""[label=""cfg_true""];\n	""6"" -> ""4""[label=""cfg_false""];\n	""8"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getAllowMissingColumnNames(),Method,"* Gets whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.",public boolean getAllowMissingColumnNames() {\n    return allowMissingColumnNames;\n},boolean getAllowMissingColumnNames(),"digraph cfg_getAllowMissingColumnNames {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean allowMissingColumnNames>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getAutoFlush(),Method,* Gets whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6,public boolean getAutoFlush() {\n    return autoFlush;\n},boolean getAutoFlush(),"digraph cfg_getAutoFlush {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean autoFlush>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getCommentMarker(),Method,"* Gets the comment marker character, {@code null} disables comments.\n     * <p>\n     * The comment start character is only recognized at the start of a line.\n     * </p>\n     * <p>\n     * Comments are printed first, before headers.\n     * </p>\n     * <p>\n     * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment marker written at the start of each comment\n     * line.\n     * </p>\n     * <p>\n     * If the comment marker is not set, then the header comments are ignored.\n     * </p>\n     * <p>\n     * For example:\n     * </p>\n     *\n     * <pre>\n     * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));\n     * </pre>\n     * <p>\n     * writes:\n     * </p>\n     *\n     * <pre>\n     * # Generated by Apache Commons CSV.\n     * # 1970-01-01T00:00:00Z\n     * </pre>\n     *\n     * @return the comment start marker, may be {@code null}",public Character getCommentMarker() {\n    return commentMarker;\n},java.lang.Character getCommentMarker(),"digraph cfg_getCommentMarker {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getDelimiter(),Method,"* Gets the first character delimiting the values (typically ';', ',' or '\t').\n     *\n     * @return the first delimiter character.\n     * @deprecated Use {@link #getDelimiterString()}.",@Deprecated\npublic char getDelimiter() {\n    return delimiter.charAt(0);\n},char getDelimiter(),"digraph cfg_getDelimiter {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<java.lang.String: char charAt(int)>(0)""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getDelimiterCharArray(),Method,"* Gets the character delimiting the values (typically "";"", "","" or ""\t"").\n     *\n     * @return the delimiter.",char[] getDelimiterCharArray() {\n    return delimiter.toCharArray();\n},char[] getDelimiterCharArray(),"digraph cfg_getDelimiterCharArray {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<java.lang.String: char[] toCharArray()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVFormat.getDelimiterString(),Method,"* Gets the character delimiting the values (typically "";"", "","" or ""\t"").\n     *\n     * @return the delimiter.\n     * @since 1.9.0",public String getDelimiterString() {\n    return delimiter;\n},java.lang.String getDelimiterString(),"digraph cfg_getDelimiterString {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getDuplicateHeaderMode(),Method,"* Gets how duplicate headers are handled.\n     *\n     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\n     * @since 1.10.0",public DuplicateHeaderMode getDuplicateHeaderMode() {\n    return duplicateHeaderMode;\n},org.apache.commons.csv.DuplicateHeaderMode getDuplicateHeaderMode(),"digraph cfg_getDuplicateHeaderMode {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getEscapeChar(),Method,"* Gets the escape character.\n     *\n     * @return the escape character, may be {@code 0}",char getEscapeChar() {\n    // N.B. Explicit (un)boxing is intentional\n    return escapeCharacter != null ? escapeCharacter.charValue() : 0;\n},char getEscapeChar(),"digraph cfg_getEscapeChar {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""2"" [label=""$stack2 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""3"" [label=""$stack3 = 0""];\n	""4"" [label=""$stack3 = virtualinvoke $stack2.<java.lang.Character: char charValue()>()""];\n	""5"" [label=""goto""];\n	""6"" [label=""if $stack1 == null""];\n	""7"" [label=""return $stack3""];\n	""8"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""7""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_goto""];\n	""6"" -> ""2""[label=""cfg_false""];\n	""6"" -> ""3""[label=""cfg_true""];\n	""8"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVFormat.getEscapeCharacter(),Method,"* Gets the escape character.\n     *\n     * @return the escape character, may be {@code null}",public Character getEscapeCharacter() {\n    return escapeCharacter;\n},java.lang.Character getEscapeCharacter(),"digraph cfg_getEscapeCharacter {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getHeader(),Method,"* Gets a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file",public String[] getHeader() {\n    return headers != null ? headers.clone() : null;\n},java.lang.String[] getHeader(),"digraph cfg_getHeader {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""2"" [label=""$stack2 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<java.lang.Object: java.lang.Object clone()>()""];\n	""4"" [label=""$stack4 = (java.lang.String[]) $stack3""];\n	""5"" [label=""$stack4 = null""];\n	""6"" [label=""goto""];\n	""7"" [label=""if $stack1 == null""];\n	""8"" [label=""return $stack4""];\n	""9"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""7""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""8""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_goto""];\n	""7"" -> ""2""[label=""cfg_false""];\n	""7"" -> ""5""[label=""cfg_true""];\n	""9"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getHeaderComments(),Method,"* Gets a copy of the header comment array to write before the CSV data.\n     * <p>\n     * This setting is ignored by the parser.\n     * </p>\n     * <p>\n     * Comments are printed first, before headers.\n     * </p>\n     * <p>\n     * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment marker written at the start of each comment\n     * line.\n     * </p>\n     * <p>\n     * If the comment marker is not set, then the header comments are ignored.\n     * </p>\n     * <p>\n     * For example:\n     * </p>\n     *\n     * <pre>\n     * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));\n     * </pre>\n     * <p>\n     * writes:\n     * </p>\n     *\n     * <pre>\n     * # Generated by Apache Commons CSV.\n     * # 1970-01-01T00:00:00Z\n     * </pre>\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.",public String[] getHeaderComments() {\n    return headerComments != null ? headerComments.clone() : null;\n},java.lang.String[] getHeaderComments(),"digraph cfg_getHeaderComments {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headerComments>""];\n	""2"" [label=""$stack2 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headerComments>""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<java.lang.Object: java.lang.Object clone()>()""];\n	""4"" [label=""$stack4 = (java.lang.String[]) $stack3""];\n	""5"" [label=""$stack4 = null""];\n	""6"" [label=""goto""];\n	""7"" [label=""if $stack1 == null""];\n	""8"" [label=""return $stack4""];\n	""9"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""7""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""8""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_goto""];\n	""7"" -> ""2""[label=""cfg_false""];\n	""7"" -> ""5""[label=""cfg_true""];\n	""9"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getIgnoreEmptyLines(),Method,"* Gets whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.",public boolean getIgnoreEmptyLines() {\n    return ignoreEmptyLines;\n},boolean getIgnoreEmptyLines(),"digraph cfg_getIgnoreEmptyLines {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean ignoreEmptyLines>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getIgnoreHeaderCase(),Method,"* Gets whether header names will be accessed ignoring case when parsing input.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case-sensitive.\n     * @since 1.3",public boolean getIgnoreHeaderCase() {\n    return ignoreHeaderCase;\n},boolean getIgnoreHeaderCase(),"digraph cfg_getIgnoreHeaderCase {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean ignoreHeaderCase>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getIgnoreSurroundingSpaces(),Method,"* Gets whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.",public boolean getIgnoreSurroundingSpaces() {\n    return ignoreSurroundingSpaces;\n},boolean getIgnoreSurroundingSpaces(),"digraph cfg_getIgnoreSurroundingSpaces {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean ignoreSurroundingSpaces>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getLenientEof(),Method,"* Gets whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.\n     *\n     * @return whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.\n     * @since 1.11.0",public boolean getLenientEof() {\n    return lenientEof;\n},boolean getLenientEof(),"digraph cfg_getLenientEof {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean lenientEof>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getMaxRows(),Method,"* Gets the maximum number of rows to process, excluding the header row.\n     * <p>\n     * Values less than or equal to 0 mean no limit.\n     * </p>\n     *\n     * @return The maximum number of rows to process, excluding the header row.\n     * @since 1.14.0",public long getMaxRows() {\n    return maxRows;\n},long getMaxRows(),"digraph cfg_getMaxRows {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: long maxRows>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getNullString(),Method,* Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null},public String getNullString() {\n    return nullString;\n},java.lang.String getNullString(),"digraph cfg_getNullString {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.String nullString>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getQuoteCharacter(),Method,"* Gets the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}",public Character getQuoteCharacter() {\n    return quoteCharacter;\n},java.lang.Character getQuoteCharacter(),"digraph cfg_getQuoteCharacter {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getQuoteMode(),Method,* Gets the quote policy output fields.\n     *\n     * @return the quote policy,public QuoteMode getQuoteMode() {\n    return quoteMode;\n},org.apache.commons.csv.QuoteMode getQuoteMode(),"digraph cfg_getQuoteMode {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode quoteMode>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getRecordSeparator(),Method,* Gets the record separator delimiting output records.\n     *\n     * @return the record separator,public String getRecordSeparator() {\n    return recordSeparator;\n},java.lang.String getRecordSeparator(),"digraph cfg_getRecordSeparator {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getSkipHeaderRecord(),Method,* Gets whether to skip the header record.\n     *\n     * @return whether to skip the header record.,public boolean getSkipHeaderRecord() {\n    return skipHeaderRecord;\n},boolean getSkipHeaderRecord(),"digraph cfg_getSkipHeaderRecord {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean skipHeaderRecord>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getTrailingData(),Method,"* Gets whether reading trailing data is allowed in records, helps Excel compatibility.\n     *\n     * @return whether reading trailing data is allowed in records, helps Excel compatibility.\n     * @since 1.11.0",public boolean getTrailingData() {\n    return trailingData;\n},boolean getTrailingData(),"digraph cfg_getTrailingData {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean trailingData>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getTrailingDelimiter(),Method,* Gets whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3,public boolean getTrailingDelimiter() {\n    return trailingDelimiter;\n},boolean getTrailingDelimiter(),"digraph cfg_getTrailingDelimiter {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean trailingDelimiter>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.getTrim(),Method,"* Gets whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by {CSVParser#addRecordValue(boolean)}\n     *\n     * @return whether to trim leading and trailing blanks.",public boolean getTrim() {\n    return trim;\n},boolean getTrim(),"digraph cfg_getTrim {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: boolean trim>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.hashCode(),Method,No Comment,"@Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + Arrays.hashCode(headerComments);\n    result = prime * result + Arrays.hashCode(headers);\n    return prime * result + Objects.hash(allowMissingColumnNames, autoFlush, commentMarker, delimiter, duplicateHeaderMode, escapeCharacter, ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, lenientEof, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator, skipHeaderRecord, trailingData, trailingDelimiter, trim);\n}",int hashCode(),"digraph cfg_hashCode {\n	""1"" [label=""$stack10 = newarray (java.lang.Object)[19]""];\n	""2"" [label=""$stack10[0] = $stack11""];\n	""3"" [label=""$stack10[10] = $stack26""];\n	""4"" [label=""$stack10[11] = $stack27""];\n	""5"" [label=""$stack10[12] = $stack28""];\n	""6"" [label=""$stack10[13] = $stack29""];\n	""7"" [label=""$stack10[14] = $stack30""];\n	""8"" [label=""$stack10[15] = $stack32""];\n	""9"" [label=""$stack10[16] = $stack34""];\n	""10"" [label=""$stack10[17] = $stack36""];\n	""11"" [label=""$stack10[18] = $stack38""];\n	""12"" [label=""$stack10[1] = $stack13""];\n	""13"" [label=""$stack10[2] = $stack14""];\n	""14"" [label=""$stack10[3] = $stack15""];\n	""15"" [label=""$stack10[4] = $stack16""];\n	""16"" [label=""$stack10[5] = $stack17""];\n	""17"" [label=""$stack10[6] = $stack19""];\n	""18"" [label=""$stack10[7] = $stack21""];\n	""19"" [label=""$stack10[8] = $stack23""];\n	""20"" [label=""$stack10[9] = $stack25""];\n	""21"" [label=""$stack11 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack9)""];\n	""22"" [label=""$stack12 = this.<org.apache.commons.csv.CSVFormat: boolean autoFlush>""];\n	""23"" [label=""$stack13 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack12)""];\n	""24"" [label=""$stack14 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""25"" [label=""$stack15 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""26"" [label=""$stack16 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode>""];\n	""27"" [label=""$stack17 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""28"" [label=""$stack18 = this.<org.apache.commons.csv.CSVFormat: boolean ignoreEmptyLines>""];\n	""29"" [label=""$stack19 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack18)""];\n	""30"" [label=""$stack20 = this.<org.apache.commons.csv.CSVFormat: boolean ignoreHeaderCase>""];\n	""31"" [label=""$stack21 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack20)""];\n	""32"" [label=""$stack22 = this.<org.apache.commons.csv.CSVFormat: boolean ignoreSurroundingSpaces>""];\n	""33"" [label=""$stack23 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack22)""];\n	""34"" [label=""$stack24 = this.<org.apache.commons.csv.CSVFormat: boolean lenientEof>""];\n	""35"" [label=""$stack25 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack24)""];\n	""36"" [label=""$stack26 = this.<org.apache.commons.csv.CSVFormat: java.lang.String nullString>""];\n	""37"" [label=""$stack27 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""38"" [label=""$stack28 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode quoteMode>""];\n	""39"" [label=""$stack29 = this.<org.apache.commons.csv.CSVFormat: java.lang.String quotedNullString>""];\n	""40"" [label=""$stack3 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headerComments>""];\n	""41"" [label=""$stack30 = this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""42"" [label=""$stack31 = this.<org.apache.commons.csv.CSVFormat: boolean skipHeaderRecord>""];\n	""43"" [label=""$stack32 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack31)""];\n	""44"" [label=""$stack33 = this.<org.apache.commons.csv.CSVFormat: boolean trailingData>""];\n	""45"" [label=""$stack34 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack33)""];\n	""46"" [label=""$stack35 = this.<org.apache.commons.csv.CSVFormat: boolean trailingDelimiter>""];\n	""47"" [label=""$stack36 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack35)""];\n	""48"" [label=""$stack37 = this.<org.apache.commons.csv.CSVFormat: boolean trim>""];\n	""49"" [label=""$stack38 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>($stack37)""];\n	""50"" [label=""$stack39 = 31 * result""];\n	""51"" [label=""$stack4 = 31 * result""];\n	""52"" [label=""$stack40 = staticinvoke <java.util.Objects: int hash(java.lang.Object[])>($stack10)""];\n	""53"" [label=""$stack41 = $stack39 + $stack40""];\n	""54"" [label=""$stack5 = staticinvoke <java.util.Arrays: int hashCode(java.lang.Object[])>($stack3)""];\n	""55"" [label=""$stack6 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""56"" [label=""$stack7 = 31 * result""];\n	""57"" [label=""$stack8 = staticinvoke <java.util.Arrays: int hashCode(java.lang.Object[])>($stack6)""];\n	""58"" [label=""$stack9 = this.<org.apache.commons.csv.CSVFormat: boolean allowMissingColumnNames>""];\n	""59"" [label=""prime = 31""];\n	""60"" [label=""result = $stack4 + $stack5""];\n	""61"" [label=""result = $stack7 + $stack8""];\n	""62"" [label=""result = 1""];\n	""63"" [label=""return $stack41""];\n	""64"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""58""[label=""cfg_next""];\n	""10"" -> ""48""[label=""cfg_next""];\n	""11"" -> ""52""[label=""cfg_next""];\n	""12"" -> ""24""[label=""cfg_next""];\n	""13"" -> ""25""[label=""cfg_next""];\n	""14"" -> ""26""[label=""cfg_next""];\n	""15"" -> ""27""[label=""cfg_next""];\n	""16"" -> ""28""[label=""cfg_next""];\n	""17"" -> ""30""[label=""cfg_next""];\n	""18"" -> ""32""[label=""cfg_next""];\n	""19"" -> ""34""[label=""cfg_next""];\n	""2"" -> ""22""[label=""cfg_next""];\n	""20"" -> ""36""[label=""cfg_next""];\n	""21"" -> ""2""[label=""cfg_next""];\n	""22"" -> ""23""[label=""cfg_next""];\n	""23"" -> ""12""[label=""cfg_next""];\n	""24"" -> ""13""[label=""cfg_next""];\n	""25"" -> ""14""[label=""cfg_next""];\n	""26"" -> ""15""[label=""cfg_next""];\n	""27"" -> ""16""[label=""cfg_next""];\n	""28"" -> ""29""[label=""cfg_next""];\n	""29"" -> ""17""[label=""cfg_next""];\n	""3"" -> ""37""[label=""cfg_next""];\n	""30"" -> ""31""[label=""cfg_next""];\n	""31"" -> ""18""[label=""cfg_next""];\n	""32"" -> ""33""[label=""cfg_next""];\n	""33"" -> ""19""[label=""cfg_next""];\n	""34"" -> ""35""[label=""cfg_next""];\n	""35"" -> ""20""[label=""cfg_next""];\n	""36"" -> ""3""[label=""cfg_next""];\n	""37"" -> ""4""[label=""cfg_next""];\n	""38"" -> ""5""[label=""cfg_next""];\n	""39"" -> ""6""[label=""cfg_next""];\n	""4"" -> ""38""[label=""cfg_next""];\n	""40"" -> ""54""[label=""cfg_next""];\n	""41"" -> ""7""[label=""cfg_next""];\n	""42"" -> ""43""[label=""cfg_next""];\n	""43"" -> ""8""[label=""cfg_next""];\n	""44"" -> ""45""[label=""cfg_next""];\n	""45"" -> ""9""[label=""cfg_next""];\n	""46"" -> ""47""[label=""cfg_next""];\n	""47"" -> ""10""[label=""cfg_next""];\n	""48"" -> ""49""[label=""cfg_next""];\n	""49"" -> ""11""[label=""cfg_next""];\n	""5"" -> ""39""[label=""cfg_next""];\n	""50"" -> ""1""[label=""cfg_next""];\n	""51"" -> ""40""[label=""cfg_next""];\n	""52"" -> ""53""[label=""cfg_next""];\n	""53"" -> ""63""[label=""cfg_next""];\n	""54"" -> ""60""[label=""cfg_next""];\n	""55"" -> ""57""[label=""cfg_next""];\n	""56"" -> ""55""[label=""cfg_next""];\n	""57"" -> ""61""[label=""cfg_next""];\n	""58"" -> ""21""[label=""cfg_next""];\n	""59"" -> ""62""[label=""cfg_next""];\n	""6"" -> ""41""[label=""cfg_next""];\n	""60"" -> ""56""[label=""cfg_next""];\n	""61"" -> ""50""[label=""cfg_next""];\n	""62"" -> ""51""[label=""cfg_next""];\n	""64"" -> ""59""[label=""cfg_next""];\n	""7"" -> ""42""[label=""cfg_next""];\n	""8"" -> ""44""[label=""cfg_next""];\n	""9"" -> ""46""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.isCommentMarkerSet(),Method,"* Tests whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise",public boolean isCommentMarkerSet() {\n    return commentMarker != null;\n},boolean isCommentMarkerSet(),"digraph cfg_isCommentMarkerSet {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""2"" [label=""$stack2 = 0""];\n	""3"" [label=""$stack2 = 1""];\n	""4"" [label=""goto""];\n	""5"" [label=""if $stack1 == null""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""1""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVFormat.isDelimiter(char,CharSequence,int,char[],int)",Method,* Tests whether the next characters constitute a delimiter\n     *\n     * @param ch0             the first char (index 0).\n     * @param charSeq         the match char sequence\n     * @param startIndex      where start to match\n     * @param delimiter       the delimiter\n     * @param delimiterLength the delimiter length\n     * @return true if the match is successful,"private boolean isDelimiter(final char ch0, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\n    if (ch0 != delimiter[0]) {\n        return false;\n    }\n    final int len = charSeq.length();\n    if (startIndex + delimiterLength > len) {\n        return false;\n    }\n    for (int i = 1; i < delimiterLength; i++) {\n        if (charSeq.charAt(startIndex + i) != delimiter[i]) {\n            return false;\n        }\n    }\n    return true;\n}","boolean isDelimiter(char,java.lang.CharSequence,int,char[],int)","digraph cfg_isDelimiter {\n	""1"" [label=""$stack10 = startIndex + i""];\n	""2"" [label=""$stack11 = delimiter[i]""];\n	""3"" [label=""$stack12 = interfaceinvoke charSeq.<java.lang.CharSequence: char charAt(int)>($stack10)""];\n	""4"" [label=""$stack8 = delimiter[0]""];\n	""5"" [label=""$stack9 = startIndex + delimiterLength""];\n	""6"" [label=""ch0 := @parameter0: char""];\n	""7"" [label=""charSeq := @parameter1: java.lang.CharSequence""];\n	""8"" [label=""delimiter := @parameter3: char[]""];\n	""9"" [label=""delimiterLength := @parameter4: int""];\n	""10"" [label=""goto""];\n	""11"" [label=""i = 1""];\n	""12"" [label=""i = i + 1""];\n	""13"" [label=""if $stack12 == $stack11""];\n	""14"" [label=""if $stack9 <= len""];\n	""15"" [label=""if ch0 == $stack8""];\n	""16"" [label=""if i >= delimiterLength""];\n	""17"" [label=""len = interfaceinvoke charSeq.<java.lang.CharSequence: int length()>()""];\n	""18"" [label=""return 0""];\n	""19"" [label=""return 0""];\n	""20"" [label=""return 0""];\n	""21"" [label=""return 1""];\n	""22"" [label=""startIndex := @parameter2: int""];\n	""23"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""10"" -> ""16""[label=""cfg_goto""];\n	""11"" -> ""16""[label=""cfg_next""];\n	""12"" -> ""10""[label=""cfg_next""];\n	""13"" -> ""12""[label=""cfg_true""];\n	""13"" -> ""20""[label=""cfg_false""];\n	""14"" -> ""11""[label=""cfg_true""];\n	""14"" -> ""19""[label=""cfg_false""];\n	""15"" -> ""17""[label=""cfg_true""];\n	""15"" -> ""18""[label=""cfg_false""];\n	""16"" -> ""1""[label=""cfg_false""];\n	""16"" -> ""21""[label=""cfg_true""];\n	""17"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""13""[label=""cfg_next""];\n	""22"" -> ""8""[label=""cfg_next""];\n	""23"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""15""[label=""cfg_next""];\n	""5"" -> ""14""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""22""[label=""cfg_next""];\n	""8"" -> ""9""[label=""cfg_next""];\n	""9"" -> ""4""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVFormat.isEscapeCharacterSet(),Method,* Tests whether escapes are being processed.\n     *\n     * @return {@code true} if escapes are processed,public boolean isEscapeCharacterSet() {\n    return escapeCharacter != null;\n},boolean isEscapeCharacterSet(),"digraph cfg_isEscapeCharacterSet {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""2"" [label=""$stack2 = 0""];\n	""3"" [label=""$stack2 = 1""];\n	""4"" [label=""goto""];\n	""5"" [label=""if $stack1 == null""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.isNullStringSet(),Method,* Tests whether a null string has been defined.\n     *\n     * @return {@code true} if a nullString is defined,public boolean isNullStringSet() {\n    return nullString != null;\n},boolean isNullStringSet(),"digraph cfg_isNullStringSet {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.String nullString>""];\n	""2"" [label=""$stack2 = 0""];\n	""3"" [label=""$stack2 = 1""];\n	""4"" [label=""goto""];\n	""5"" [label=""if $stack1 == null""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.isQuoteCharacterSet(),Method,* Tests whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined,public boolean isQuoteCharacterSet() {\n    return quoteCharacter != null;\n},boolean isQuoteCharacterSet(),"digraph cfg_isQuoteCharacterSet {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""2"" [label=""$stack2 = 0""];\n	""3"" [label=""$stack2 = 1""];\n	""4"" [label=""goto""];\n	""5"" [label=""if $stack1 == null""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.limit(IOStream),Method,No Comment,<T> IOStream<T> limit(final IOStream<T> stream) {\n    return useMaxRows() ? stream.limit(getMaxRows()) : stream;\n},org.apache.commons.io.function.IOStream limit(org.apache.commons.io.function.IOStream),"digraph cfg_limit {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean useMaxRows()>()""];\n	""2"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: long getMaxRows()>()""];\n	""3"" [label=""$stack4 = interfaceinvoke stream.<org.apache.commons.io.function.IOStream: org.apache.commons.io.function.IOStream limit(long)>($stack3)""];\n	""4"" [label=""$stack4 = stream""];\n	""5"" [label=""goto""];\n	""6"" [label=""if $stack2 == 0""];\n	""7"" [label=""return $stack4""];\n	""8"" [label=""stream := @parameter0: org.apache.commons.io.function.IOStream""];\n	""9"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""7""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_goto""];\n	""6"" -> ""2""[label=""cfg_false""];\n	""6"" -> ""4""[label=""cfg_true""];\n	""8"" -> ""1""[label=""cfg_next""];\n	""9"" -> ""8""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVFormat.limit(Stream),Method,No Comment,<T> Stream<T> limit(final Stream<T> stream) {\n    return useMaxRows() ? stream.limit(getMaxRows()) : stream;\n},java.util.stream.Stream limit(java.util.stream.Stream),"digraph cfg_limit {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean useMaxRows()>()""];\n	""2"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: long getMaxRows()>()""];\n	""3"" [label=""$stack4 = interfaceinvoke stream.<java.util.stream.Stream: java.util.stream.Stream limit(long)>($stack3)""];\n	""4"" [label=""$stack4 = stream""];\n	""5"" [label=""goto""];\n	""6"" [label=""if $stack2 == 0""];\n	""7"" [label=""return $stack4""];\n	""8"" [label=""stream := @parameter0: java.util.stream.Stream""];\n	""9"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""7""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_goto""];\n	""6"" -> ""2""[label=""cfg_false""];\n	""6"" -> ""4""[label=""cfg_true""];\n	""8"" -> ""1""[label=""cfg_next""];\n	""9"" -> ""8""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVFormat.parse(Reader),Method,* Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param reader the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException  If an I/O error occurs\n     * @throws CSVException Thrown on invalid input.,public CSVParser parse(final Reader reader) throws IOException {\n    return CSVParser.builder().setReader(reader).setFormat(this).get();\n},org.apache.commons.csv.CSVParser parse(java.io.Reader),"digraph cfg_parse {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVParser: org.apache.commons.csv.CSVParser$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.io.build.AbstractOriginSupplier setReader(java.io.Reader)>(reader)""];\n	""3"" [label=""$stack4 = (org.apache.commons.csv.CSVParser$Builder) $stack3""];\n	""4"" [label=""$stack5 = virtualinvoke $stack4.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.csv.CSVParser$Builder setFormat(org.apache.commons.csv.CSVFormat)>(this)""];\n	""5"" [label=""$stack6 = virtualinvoke $stack5.<org.apache.commons.csv.CSVParser$Builder: org.apache.commons.csv.CSVParser get()>()""];\n	""6"" [label=""reader := @parameter0: java.io.Reader""];\n	""7"" [label=""return $stack6""];\n	""8"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n	""8"" -> ""6""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.print(Appendable),Method,* Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out the output.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.,"public CSVPrinter print(final Appendable out) throws IOException {\n    return new CSVPrinter(out, this);\n}",org.apache.commons.csv.CSVPrinter print(java.lang.Appendable),"digraph cfg_print {\n	""1"" [label=""$stack2 = new org.apache.commons.csv.CSVPrinter""];\n	""2"" [label=""out := @parameter0: java.lang.Appendable""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""specialinvoke $stack2.<org.apache.commons.csv.CSVPrinter: void <init>(java.lang.Appendable,org.apache.commons.csv.CSVFormat)>(out, this)""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""5"" -> ""2""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVFormat.print(File,Charset)",Method,* Prints to the specified {@code File} with given {@code Charset}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out     the output.\n     * @param charset A charset.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5,"public CSVPrinter print(final File out, final Charset charset) throws IOException {\n    return print(out.toPath(), charset);\n}","org.apache.commons.csv.CSVPrinter print(java.io.File,java.nio.charset.Charset)","digraph cfg_print {\n	""1"" [label=""$stack3 = virtualinvoke out.<java.io.File: java.nio.file.Path toPath()>()""];\n	""2"" [label=""$stack4 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVPrinter print(java.nio.file.Path,java.nio.charset.Charset)>($stack3, charset)""];\n	""3"" [label=""charset := @parameter1: java.nio.charset.Charset""];\n	""4"" [label=""out := @parameter0: java.io.File""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVFormat.print(InputStream,Appendable,boolean)",Method,No Comment,"private void print(final InputStream inputStream, final Appendable out, final boolean newRecord) throws IOException {\n    // InputStream is never null here\n    // There is nothing to escape when quoting is used which is the default.\n    if (!newRecord) {\n        append(getDelimiterString(), out);\n    }\n    final boolean quoteCharacterSet = isQuoteCharacterSet();\n    if (quoteCharacterSet) {\n        // N.B. Explicit (un)boxing is intentional\n        append(getQuoteCharacter().charValue(), out);\n    }\n    // Stream the input to the output without reading or holding the whole value in memory.\n    // AppendableOutputStream cannot ""close"" an Appendable.\n    try (OutputStream outputStream = new Base64OutputStream(new AppendableOutputStream<>(out))) {\n        IOUtils.copy(inputStream, outputStream);\n    }\n    if (quoteCharacterSet) {\n        // N.B. Explicit (un)boxing is intentional\n        append(getQuoteCharacter().charValue(), out);\n    }\n}","void print(java.io.InputStream,java.lang.Appendable,boolean)","digraph cfg_print {\n	""1"" [label=""$stack10 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: java.lang.Character getQuoteCharacter()>()""];\n	""2"" [label=""$stack11 = virtualinvoke $stack10.<java.lang.Character: char charValue()>()""];\n	""3"" [label=""$stack12 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: java.lang.Character getQuoteCharacter()>()""];\n	""4"" [label=""$stack13 = virtualinvoke $stack12.<java.lang.Character: char charValue()>()""];\n	""5"" [label=""$stack14 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: java.lang.String getDelimiterString()>()""];\n	""6"" [label=""$stack15 := @caughtexception""];\n	""7"" [label=""$stack16 := @caughtexception""];\n	""8"" [label=""$stack8 = new org.apache.commons.io.output.AppendableOutputStream""];\n	""9"" [label=""$stack9 = new org.apache.commons.codec.binary.Base64OutputStream""];\n	""10"" [label=""goto""];\n	""11"" [label=""goto""];\n	""12"" [label=""if newRecord != 0""];\n	""13"" [label=""if quoteCharacterSet == 0""];\n	""14"" [label=""if quoteCharacterSet == 0""];\n	""15"" [label=""inputStream := @parameter0: java.io.InputStream""];\n	""16"" [label=""l6 = $stack16""];\n	""17"" [label=""l7 = $stack15""];\n	""18"" [label=""newRecord := @parameter2: boolean""];\n	""19"" [label=""out := @parameter1: java.lang.Appendable""];\n	""20"" [label=""outputStream = $stack9""];\n	""21"" [label=""quoteCharacterSet = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isQuoteCharacterSet()>()""];\n	""22"" [label=""return""];\n	""23"" [label=""specialinvoke $stack8.<org.apache.commons.io.output.AppendableOutputStream: void <init>(java.lang.Appendable)>(out)""];\n	""24"" [label=""specialinvoke $stack9.<org.apache.commons.codec.binary.Base64OutputStream: void <init>(java.io.OutputStream)>($stack8)""];\n	""25"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(char,java.lang.Appendable)>($stack11, out)""];\n	""26"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(char,java.lang.Appendable)>($stack13, out)""];\n	""27"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(java.lang.CharSequence,java.lang.Appendable)>($stack14, out)""];\n	""28"" [label=""staticinvoke <org.apache.commons.io.IOUtils: int copy(java.io.InputStream,java.io.OutputStream)>(inputStream, outputStream)""];\n	""29"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""30"" [label=""throw l6""];\n	""31"" [label=""virtualinvoke l6.<java.lang.Throwable: void addSuppressed(java.lang.Throwable)>(l7)""];\n	""32"" [label=""virtualinvoke outputStream.<java.io.OutputStream: void close()>()""];\n	""33"" [label=""virtualinvoke outputStream.<java.io.OutputStream: void close()>()""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""14""[label=""cfg_goto""];\n	""11"" -> ""30""[label=""cfg_goto""];\n	""12"" -> ""21""[label=""cfg_true""];\n	""12"" -> ""5""[label=""cfg_false""];\n	""13"" -> ""3""[label=""cfg_false""];\n	""13"" -> ""9""[label=""cfg_true""];\n	""14"" -> ""1""[label=""cfg_false""];\n	""14"" -> ""22""[label=""cfg_true""];\n	""15"" -> ""19""[label=""cfg_next""];\n	""16"" -> ""33""[label=""cfg_next""];\n	""17"" -> ""31""[label=""cfg_next""];\n	""18"" -> ""12""[label=""cfg_next""];\n	""19"" -> ""18""[label=""cfg_next""];\n	""2"" -> ""25""[label=""cfg_next""];\n	""20"" -> ""28""[label=""cfg_next""];\n	""21"" -> ""13""[label=""cfg_next""];\n	""23"" -> ""24""[label=""cfg_next""];\n	""24"" -> ""20""[label=""cfg_next""];\n	""25"" -> ""22""[label=""cfg_next""];\n	""26"" -> ""9""[label=""cfg_next""];\n	""27"" -> ""21""[label=""cfg_next""];\n	""28"" -> ""32""[label=""cfg_next""];\n	""28"" -> ""7""[label=""cfg_except""];\n	""29"" -> ""15""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""31"" -> ""30""[label=""cfg_next""];\n	""32"" -> ""10""[label=""cfg_next""];\n	""33"" -> ""11""[label=""cfg_next""];\n	""33"" -> ""6""[label=""cfg_except""];\n	""4"" -> ""26""[label=""cfg_next""];\n	""5"" -> ""27""[label=""cfg_next""];\n	""6"" -> ""17""[label=""cfg_next""];\n	""7"" -> ""16""[label=""cfg_next""];\n	""8"" -> ""23""[label=""cfg_next""];\n	""9"" -> ""8""[label=""cfg_next""];\n}\n",private 
"org.apache.commons.csv.CSVFormat.print(Object,Appendable,boolean)",Method,* Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\n     *\n     * @param value     value to output.\n     * @param out       where to print the value.\n     * @param newRecord if this a new record.\n     * @throws IOException If an I/O error occurs.\n     * @since 1.4,"public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n    // null values are considered empty\n    // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n    CharSequence charSequence;\n    if (value == null) {\n        // https://issues.apache.org/jira/browse/CSV-203\n        if (null == nullString) {\n            charSequence = Constants.EMPTY;\n        } else if (QuoteMode.ALL == quoteMode) {\n            charSequence = quotedNullString;\n        } else {\n            charSequence = nullString;\n        }\n    } else if (value instanceof CharSequence) {\n        charSequence = (CharSequence) value;\n    } else if (value instanceof Reader) {\n        print((Reader) value, out, newRecord);\n        return;\n    } else if (value instanceof InputStream) {\n        print((InputStream) value, out, newRecord);\n        return;\n    } else {\n        charSequence = value.toString();\n    }\n    charSequence = getTrim() ? trim(charSequence) : charSequence;\n    print(value, charSequence, out, newRecord);\n}","void print(java.lang.Object,java.lang.Appendable,boolean)","digraph cfg_print {\n	""1"" [label=""$stack10 = (java.io.Reader) value""];\n	""2"" [label=""$stack11 = this.<org.apache.commons.csv.CSVFormat: java.lang.String nullString>""];\n	""3"" [label=""$stack12 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode quoteMode>""];\n	""4"" [label=""$stack13 = <org.apache.commons.csv.QuoteMode: org.apache.commons.csv.QuoteMode ALL>""];\n	""5"" [label=""$stack5 = value instanceof java.lang.CharSequence""];\n	""6"" [label=""$stack6 = value instanceof java.io.Reader""];\n	""7"" [label=""$stack7 = value instanceof java.io.InputStream""];\n	""8"" [label=""$stack8 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean getTrim()>()""];\n	""9"" [label=""$stack9 = (java.io.InputStream) value""];\n	""10"" [label=""charSequence = \""\""""];\n	""11"" [label=""charSequence = (java.lang.CharSequence) value""];\n	""12"" [label=""charSequence = charSequence""];\n	""13"" [label=""charSequence = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.CharSequence trim(java.lang.CharSequence)>(charSequence)""];\n	""14"" [label=""charSequence = this.<org.apache.commons.csv.CSVFormat: java.lang.String nullString>""];\n	""15"" [label=""charSequence = this.<org.apache.commons.csv.CSVFormat: java.lang.String quotedNullString>""];\n	""16"" [label=""charSequence = virtualinvoke value.<java.lang.Object: java.lang.String toString()>()""];\n	""17"" [label=""goto""];\n	""18"" [label=""goto""];\n	""19"" [label=""goto""];\n	""20"" [label=""goto""];\n	""21"" [label=""goto""];\n	""22"" [label=""if $stack13 != $stack12""];\n	""23"" [label=""if $stack5 == 0""];\n	""24"" [label=""if $stack6 == 0""];\n	""25"" [label=""if $stack7 == 0""];\n	""26"" [label=""if $stack8 == 0""];\n	""27"" [label=""if null != $stack11""];\n	""28"" [label=""if value != null""];\n	""29"" [label=""newRecord := @parameter2: boolean""];\n	""30"" [label=""out := @parameter1: java.lang.Appendable""];\n	""31"" [label=""return""];\n	""32"" [label=""return""];\n	""33"" [label=""return""];\n	""34"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void print(java.io.InputStream,java.lang.Appendable,boolean)>($stack9, out, newRecord)""];\n	""35"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void print(java.io.Reader,java.lang.Appendable,boolean)>($stack10, out, newRecord)""];\n	""36"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void print(java.lang.Object,java.lang.CharSequence,java.lang.Appendable,boolean)>(value, charSequence, out, newRecord)""];\n	""37"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""38"" [label=""value := @parameter0: java.lang.Object""];\n	""1"" -> ""35""[label=""cfg_next""];\n	""10"" -> ""17""[label=""cfg_next""];\n	""11"" -> ""20""[label=""cfg_next""];\n	""12"" -> ""36""[label=""cfg_next""];\n	""13"" -> ""21""[label=""cfg_next""];\n	""14"" -> ""19""[label=""cfg_next""];\n	""15"" -> ""18""[label=""cfg_next""];\n	""16"" -> ""8""[label=""cfg_next""];\n	""17"" -> ""8""[label=""cfg_goto""];\n	""18"" -> ""8""[label=""cfg_goto""];\n	""19"" -> ""8""[label=""cfg_goto""];\n	""2"" -> ""27""[label=""cfg_next""];\n	""20"" -> ""8""[label=""cfg_goto""];\n	""21"" -> ""36""[label=""cfg_goto""];\n	""22"" -> ""14""[label=""cfg_true""];\n	""22"" -> ""15""[label=""cfg_false""];\n	""23"" -> ""11""[label=""cfg_false""];\n	""23"" -> ""6""[label=""cfg_true""];\n	""24"" -> ""1""[label=""cfg_false""];\n	""24"" -> ""7""[label=""cfg_true""];\n	""25"" -> ""16""[label=""cfg_true""];\n	""25"" -> ""9""[label=""cfg_false""];\n	""26"" -> ""12""[label=""cfg_true""];\n	""26"" -> ""13""[label=""cfg_false""];\n	""27"" -> ""10""[label=""cfg_false""];\n	""27"" -> ""4""[label=""cfg_true""];\n	""28"" -> ""2""[label=""cfg_false""];\n	""28"" -> ""5""[label=""cfg_true""];\n	""29"" -> ""28""[label=""cfg_next""];\n	""3"" -> ""22""[label=""cfg_next""];\n	""30"" -> ""29""[label=""cfg_next""];\n	""34"" -> ""32""[label=""cfg_next""];\n	""35"" -> ""31""[label=""cfg_next""];\n	""36"" -> ""33""[label=""cfg_next""];\n	""37"" -> ""38""[label=""cfg_next""];\n	""38"" -> ""30""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""5"" -> ""23""[label=""cfg_next""];\n	""6"" -> ""24""[label=""cfg_next""];\n	""7"" -> ""25""[label=""cfg_next""];\n	""8"" -> ""26""[label=""cfg_next""];\n	""9"" -> ""34""[label=""cfg_next""];\n}\n","public , synchronized "
"org.apache.commons.csv.CSVFormat.print(Object,CharSequence,Appendable,boolean)",Method,No Comment,"private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\n    final int offset = 0;\n    final int len = value.length();\n    if (!newRecord) {\n        out.append(getDelimiterString());\n    }\n    if (object == null) {\n        out.append(value);\n    } else if (isQuoteCharacterSet()) {\n        // The original object is needed so can check for Number\n        printWithQuotes(object, value, out, newRecord);\n    } else if (isEscapeCharacterSet()) {\n        printWithEscapes(value, out);\n    } else {\n        out.append(value, offset, len);\n    }\n}","void print(java.lang.Object,java.lang.CharSequence,java.lang.Appendable,boolean)","digraph cfg_print {\n	""1"" [label=""$stack7 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isQuoteCharacterSet()>()""];\n	""2"" [label=""$stack8 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isEscapeCharacterSet()>()""];\n	""3"" [label=""$stack9 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: java.lang.String getDelimiterString()>()""];\n	""4"" [label=""goto""];\n	""5"" [label=""goto""];\n	""6"" [label=""goto""];\n	""7"" [label=""if $stack7 == 0""];\n	""8"" [label=""if $stack8 == 0""];\n	""9"" [label=""if newRecord != 0""];\n	""10"" [label=""if object != null""];\n	""11"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence)>($stack9)""];\n	""12"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence)>(value)""];\n	""13"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence,int,int)>(value, 0, len)""];\n	""14"" [label=""len = interfaceinvoke value.<java.lang.CharSequence: int length()>()""];\n	""15"" [label=""newRecord := @parameter3: boolean""];\n	""16"" [label=""object := @parameter0: java.lang.Object""];\n	""17"" [label=""offset = 0""];\n	""18"" [label=""out := @parameter2: java.lang.Appendable""];\n	""19"" [label=""return""];\n	""20"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void printWithEscapes(java.lang.CharSequence,java.lang.Appendable)>(value, out)""];\n	""21"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void printWithQuotes(java.lang.Object,java.lang.CharSequence,java.lang.Appendable,boolean)>(object, value, out, newRecord)""];\n	""22"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""23"" [label=""value := @parameter1: java.lang.CharSequence""];\n	""1"" -> ""7""[label=""cfg_next""];\n	""10"" -> ""1""[label=""cfg_true""];\n	""10"" -> ""12""[label=""cfg_false""];\n	""11"" -> ""10""[label=""cfg_next""];\n	""12"" -> ""4""[label=""cfg_next""];\n	""13"" -> ""19""[label=""cfg_next""];\n	""14"" -> ""9""[label=""cfg_next""];\n	""15"" -> ""17""[label=""cfg_next""];\n	""16"" -> ""23""[label=""cfg_next""];\n	""17"" -> ""14""[label=""cfg_next""];\n	""18"" -> ""15""[label=""cfg_next""];\n	""2"" -> ""8""[label=""cfg_next""];\n	""20"" -> ""6""[label=""cfg_next""];\n	""21"" -> ""5""[label=""cfg_next""];\n	""22"" -> ""16""[label=""cfg_next""];\n	""23"" -> ""18""[label=""cfg_next""];\n	""3"" -> ""11""[label=""cfg_next""];\n	""4"" -> ""19""[label=""cfg_goto""];\n	""5"" -> ""19""[label=""cfg_goto""];\n	""6"" -> ""19""[label=""cfg_goto""];\n	""7"" -> ""2""[label=""cfg_true""];\n	""7"" -> ""21""[label=""cfg_false""];\n	""8"" -> ""13""[label=""cfg_true""];\n	""8"" -> ""20""[label=""cfg_false""];\n	""9"" -> ""10""[label=""cfg_true""];\n	""9"" -> ""3""[label=""cfg_false""];\n}\n","private , synchronized "
"org.apache.commons.csv.CSVFormat.print(Path,Charset)",Method,"* Prints to the specified {@code Path} with given {@code Charset}, returns a {@code CSVPrinter} which the caller MUST close.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out     the output.\n     * @param charset A charset.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5","@SuppressWarnings(""resource"")\npublic CSVPrinter print(final Path out, final Charset charset) throws IOException {\n    return print(Files.newBufferedWriter(out, charset));\n}","org.apache.commons.csv.CSVPrinter print(java.nio.file.Path,java.nio.charset.Charset)","digraph cfg_print {\n	""1"" [label=""$stack3 = newarray (java.nio.file.OpenOption)[0]""];\n	""2"" [label=""$stack4 = staticinvoke <java.nio.file.Files: java.io.BufferedWriter newBufferedWriter(java.nio.file.Path,java.nio.charset.Charset,java.nio.file.OpenOption[])>(out, charset, $stack3)""];\n	""3"" [label=""$stack5 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVPrinter print(java.lang.Appendable)>($stack4)""];\n	""4"" [label=""charset := @parameter1: java.nio.charset.Charset""];\n	""5"" [label=""out := @parameter0: java.nio.file.Path""];\n	""6"" [label=""return $stack5""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""6""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""4""[label=""cfg_next""];\n	""7"" -> ""5""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVFormat.print(Reader,Appendable,boolean)",Method,No Comment,"private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n    // Reader is never null here\n    if (!newRecord) {\n        append(getDelimiterString(), out);\n    }\n    if (isQuoteCharacterSet()) {\n        printWithQuotes(reader, out);\n    } else if (isEscapeCharacterSet()) {\n        printWithEscapes(reader, out);\n    } else if (out instanceof Writer) {\n        IOUtils.copyLarge(reader, (Writer) out);\n    } else {\n        IOUtils.copy(reader, out);\n    }\n}","void print(java.io.Reader,java.lang.Appendable,boolean)","digraph cfg_print {\n	""1"" [label=""$stack4 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isQuoteCharacterSet()>()""];\n	""2"" [label=""$stack5 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isEscapeCharacterSet()>()""];\n	""3"" [label=""$stack6 = out instanceof java.io.Writer""];\n	""4"" [label=""$stack7 = (java.io.Writer) out""];\n	""5"" [label=""$stack8 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: java.lang.String getDelimiterString()>()""];\n	""6"" [label=""goto""];\n	""7"" [label=""goto""];\n	""8"" [label=""goto""];\n	""9"" [label=""if $stack4 == 0""];\n	""10"" [label=""if $stack5 == 0""];\n	""11"" [label=""if $stack6 == 0""];\n	""12"" [label=""if newRecord != 0""];\n	""13"" [label=""newRecord := @parameter2: boolean""];\n	""14"" [label=""out := @parameter1: java.lang.Appendable""];\n	""15"" [label=""reader := @parameter0: java.io.Reader""];\n	""16"" [label=""return""];\n	""17"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(java.lang.CharSequence,java.lang.Appendable)>($stack8, out)""];\n	""18"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void printWithEscapes(java.io.Reader,java.lang.Appendable)>(reader, out)""];\n	""19"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void printWithQuotes(java.io.Reader,java.lang.Appendable)>(reader, out)""];\n	""20"" [label=""staticinvoke <org.apache.commons.io.IOUtils: long copy(java.io.Reader,java.lang.Appendable)>(reader, out)""];\n	""21"" [label=""staticinvoke <org.apache.commons.io.IOUtils: long copyLarge(java.io.Reader,java.io.Writer)>(reader, $stack7)""];\n	""22"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""9""[label=""cfg_next""];\n	""10"" -> ""18""[label=""cfg_false""];\n	""10"" -> ""3""[label=""cfg_true""];\n	""11"" -> ""20""[label=""cfg_true""];\n	""11"" -> ""4""[label=""cfg_false""];\n	""12"" -> ""1""[label=""cfg_true""];\n	""12"" -> ""5""[label=""cfg_false""];\n	""13"" -> ""12""[label=""cfg_next""];\n	""14"" -> ""13""[label=""cfg_next""];\n	""15"" -> ""14""[label=""cfg_next""];\n	""17"" -> ""1""[label=""cfg_next""];\n	""18"" -> ""7""[label=""cfg_next""];\n	""19"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""10""[label=""cfg_next""];\n	""20"" -> ""16""[label=""cfg_next""];\n	""21"" -> ""8""[label=""cfg_next""];\n	""22"" -> ""15""[label=""cfg_next""];\n	""3"" -> ""11""[label=""cfg_next""];\n	""4"" -> ""21""[label=""cfg_next""];\n	""5"" -> ""17""[label=""cfg_next""];\n	""6"" -> ""16""[label=""cfg_goto""];\n	""7"" -> ""16""[label=""cfg_goto""];\n	""8"" -> ""16""[label=""cfg_goto""];\n	""9"" -> ""19""[label=""cfg_false""];\n	""9"" -> ""2""[label=""cfg_true""];\n}\n",private 
org.apache.commons.csv.CSVFormat.printer(),Method,* Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5,"public CSVPrinter printer() throws IOException {\n    return new CSVPrinter(System.out, this);\n}",org.apache.commons.csv.CSVPrinter printer(),"digraph cfg_printer {\n	""1"" [label=""$stack1 = <java.lang.System: java.io.PrintStream out>""];\n	""2"" [label=""$stack2 = new org.apache.commons.csv.CSVPrinter""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""specialinvoke $stack2.<org.apache.commons.csv.CSVPrinter: void <init>(java.lang.Appendable,org.apache.commons.csv.CSVFormat)>($stack1, this)""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""5"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.println(Appendable),Method,* Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param appendable where to write\n     * @throws IOException If an I/O error occurs.\n     * @since 1.4,"public synchronized void println(final Appendable appendable) throws IOException {\n    if (getTrailingDelimiter()) {\n        append(getDelimiterString(), appendable);\n    }\n    if (recordSeparator != null) {\n        append(recordSeparator, appendable);\n    }\n}",void println(java.lang.Appendable),"digraph cfg_println {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean getTrailingDelimiter()>()""];\n	""2"" [label=""$stack3 = this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""3"" [label=""$stack4 = this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""4"" [label=""$stack5 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: java.lang.String getDelimiterString()>()""];\n	""5"" [label=""appendable := @parameter0: java.lang.Appendable""];\n	""6"" [label=""if $stack2 == 0""];\n	""7"" [label=""if $stack3 == null""];\n	""8"" [label=""return""];\n	""9"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(java.lang.CharSequence,java.lang.Appendable)>($stack4, appendable)""];\n	""10"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(java.lang.CharSequence,java.lang.Appendable)>($stack5, appendable)""];\n	""11"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""10"" -> ""2""[label=""cfg_next""];\n	""11"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""9""[label=""cfg_next""];\n	""4"" -> ""10""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""6"" -> ""4""[label=""cfg_false""];\n	""7"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""8""[label=""cfg_true""];\n	""9"" -> ""8""[label=""cfg_next""];\n}\n","public , synchronized "
"org.apache.commons.csv.CSVFormat.printRecord(Appendable,Object[])",Method,"* Prints the given {@code values} to {@code out} as a single record of delimiter-separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\n     * the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param appendable where to write.\n     * @param values     values to output.\n     * @throws IOException If an I/O error occurs.\n     * @since 1.4","public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {\n    for (int i = 0; i < values.length; i++) {\n        print(values[i], appendable, i == 0);\n    }\n    println(appendable);\n}","void printRecord(java.lang.Appendable,java.lang.Object[])","digraph cfg_printRecord {\n	""1"" [label=""$stack4 = lengthof values""];\n	""2"" [label=""$stack5 = values[i]""];\n	""3"" [label=""$stack6 = 0""];\n	""4"" [label=""$stack6 = 1""];\n	""5"" [label=""appendable := @parameter0: java.lang.Appendable""];\n	""6"" [label=""goto""];\n	""7"" [label=""goto""];\n	""8"" [label=""i = 0""];\n	""9"" [label=""i = i + 1""];\n	""10"" [label=""if i != 0""];\n	""11"" [label=""if i >= $stack4""];\n	""12"" [label=""return""];\n	""13"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""14"" [label=""values := @parameter1: java.lang.Object[]""];\n	""15"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVFormat: void print(java.lang.Object,java.lang.Appendable,boolean)>($stack5, appendable, $stack6)""];\n	""16"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVFormat: void println(java.lang.Appendable)>(appendable)""];\n	""1"" -> ""11""[label=""cfg_next""];\n	""10"" -> ""3""[label=""cfg_true""];\n	""10"" -> ""4""[label=""cfg_false""];\n	""11"" -> ""16""[label=""cfg_true""];\n	""11"" -> ""2""[label=""cfg_false""];\n	""13"" -> ""5""[label=""cfg_next""];\n	""14"" -> ""8""[label=""cfg_next""];\n	""15"" -> ""9""[label=""cfg_next""];\n	""16"" -> ""12""[label=""cfg_next""];\n	""2"" -> ""10""[label=""cfg_next""];\n	""3"" -> ""15""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""14""[label=""cfg_next""];\n	""6"" -> ""15""[label=""cfg_goto""];\n	""7"" -> ""1""[label=""cfg_goto""];\n	""8"" -> ""1""[label=""cfg_next""];\n	""9"" -> ""7""[label=""cfg_next""];\n}\n","public , synchronized "
"org.apache.commons.csv.CSVFormat.printWithEscapes(CharSequence,Appendable)",Method,"* Note: Must only be called if escaping is enabled, otherwise can throw exceptions.","private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\n    int start = 0;\n    int pos = 0;\n    final int end = charSeq.length();\n    final char[] delimArray = getDelimiterCharArray();\n    final int delimLength = delimArray.length;\n    final char escape = getEscapeChar();\n    while (pos < end) {\n        char c = charSeq.charAt(pos);\n        final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delimArray, delimLength);\n        final boolean isCr = c == Constants.CR;\n        final boolean isLf = c == Constants.LF;\n        if (isCr || isLf || c == escape || isDelimiterStart) {\n            // write out segment up until this char\n            if (pos > start) {\n                appendable.append(charSeq, start, pos);\n            }\n            if (isLf) {\n                c = 'n';\n            } else if (isCr) {\n                c = 'r';\n            }\n            escape(c, appendable);\n            if (isDelimiterStart) {\n                for (int i = 1; i < delimLength; i++) {\n                    pos++;\n                    escape(charSeq.charAt(pos), appendable);\n                }\n            }\n            // start on the current char after this one\n            start = pos + 1;\n        }\n        pos++;\n    }\n    // write last segment\n    if (pos > start) {\n        appendable.append(charSeq, start, pos);\n    }\n}","void printWithEscapes(java.lang.CharSequence,java.lang.Appendable)","digraph cfg_printWithEscapes {\n	""1"" [label=""$stack14 = interfaceinvoke charSeq.<java.lang.CharSequence: char charAt(int)>(pos)""];\n	""2"" [label=""appendable := @parameter1: java.lang.Appendable""];\n	""3"" [label=""c = 110""];\n	""4"" [label=""c = 114""];\n	""5"" [label=""c = interfaceinvoke charSeq.<java.lang.CharSequence: char charAt(int)>(pos)""];\n	""6"" [label=""charSeq := @parameter0: java.lang.CharSequence""];\n	""7"" [label=""delimArray = virtualinvoke this.<org.apache.commons.csv.CSVFormat: char[] getDelimiterCharArray()>()""];\n	""8"" [label=""delimLength = lengthof delimArray""];\n	""9"" [label=""end = interfaceinvoke charSeq.<java.lang.CharSequence: int length()>()""];\n	""10"" [label=""escape = virtualinvoke this.<org.apache.commons.csv.CSVFormat: char getEscapeChar()>()""];\n	""11"" [label=""goto""];\n	""12"" [label=""goto""];\n	""13"" [label=""goto""];\n	""14"" [label=""goto""];\n	""15"" [label=""goto""];\n	""16"" [label=""i = 1""];\n	""17"" [label=""i = i + 1""];\n	""18"" [label=""if c != 10""];\n	""19"" [label=""if c != 13""];\n	""20"" [label=""if c == escape""];\n	""21"" [label=""if i >= delimLength""];\n	""22"" [label=""if isCr != 0""];\n	""23"" [label=""if isCr == 0""];\n	""24"" [label=""if isDelimiterStart == 0""];\n	""25"" [label=""if isDelimiterStart == 0""];\n	""26"" [label=""if isLf != 0""];\n	""27"" [label=""if isLf == 0""];\n	""28"" [label=""if pos <= start""];\n	""29"" [label=""if pos <= start""];\n	""30"" [label=""if pos >= end""];\n	""31"" [label=""interfaceinvoke appendable.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence,int,int)>(charSeq, start, pos)""];\n	""32"" [label=""interfaceinvoke appendable.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence,int,int)>(charSeq, start, pos)""];\n	""33"" [label=""isCr = 0""];\n	""34"" [label=""isCr = 1""];\n	""35"" [label=""isDelimiterStart = specialinvoke this.<org.apache.commons.csv.CSVFormat: boolean isDelimiter(char,java.lang.CharSequence,int,char[],int)>(c, charSeq, pos, delimArray, delimLength)""];\n	""36"" [label=""isLf = 0""];\n	""37"" [label=""isLf = 1""];\n	""38"" [label=""pos = 0""];\n	""39"" [label=""pos = pos + 1""];\n	""40"" [label=""pos = pos + 1""];\n	""41"" [label=""return""];\n	""42"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void escape(char,java.lang.Appendable)>($stack14, appendable)""];\n	""43"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void escape(char,java.lang.Appendable)>(c, appendable)""];\n	""44"" [label=""start = 0""];\n	""45"" [label=""start = pos + 1""];\n	""46"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""42""[label=""cfg_next""];\n	""10"" -> ""30""[label=""cfg_next""];\n	""11"" -> ""18""[label=""cfg_goto""];\n	""12"" -> ""22""[label=""cfg_goto""];\n	""13"" -> ""43""[label=""cfg_goto""];\n	""14"" -> ""21""[label=""cfg_goto""];\n	""15"" -> ""30""[label=""cfg_goto""];\n	""16"" -> ""21""[label=""cfg_next""];\n	""17"" -> ""14""[label=""cfg_next""];\n	""18"" -> ""36""[label=""cfg_true""];\n	""18"" -> ""37""[label=""cfg_false""];\n	""19"" -> ""33""[label=""cfg_true""];\n	""19"" -> ""34""[label=""cfg_false""];\n	""2"" -> ""44""[label=""cfg_next""];\n	""20"" -> ""24""[label=""cfg_false""];\n	""20"" -> ""29""[label=""cfg_true""];\n	""21"" -> ""40""[label=""cfg_false""];\n	""21"" -> ""45""[label=""cfg_true""];\n	""22"" -> ""26""[label=""cfg_false""];\n	""22"" -> ""29""[label=""cfg_true""];\n	""23"" -> ""4""[label=""cfg_false""];\n	""23"" -> ""43""[label=""cfg_true""];\n	""24"" -> ""29""[label=""cfg_false""];\n	""24"" -> ""39""[label=""cfg_true""];\n	""25"" -> ""16""[label=""cfg_false""];\n	""25"" -> ""45""[label=""cfg_true""];\n	""26"" -> ""20""[label=""cfg_false""];\n	""26"" -> ""29""[label=""cfg_true""];\n	""27"" -> ""23""[label=""cfg_true""];\n	""27"" -> ""3""[label=""cfg_false""];\n	""28"" -> ""32""[label=""cfg_false""];\n	""28"" -> ""41""[label=""cfg_true""];\n	""29"" -> ""27""[label=""cfg_true""];\n	""29"" -> ""31""[label=""cfg_false""];\n	""3"" -> ""13""[label=""cfg_next""];\n	""30"" -> ""28""[label=""cfg_true""];\n	""30"" -> ""5""[label=""cfg_false""];\n	""31"" -> ""27""[label=""cfg_next""];\n	""32"" -> ""41""[label=""cfg_next""];\n	""33"" -> ""18""[label=""cfg_next""];\n	""34"" -> ""11""[label=""cfg_next""];\n	""35"" -> ""19""[label=""cfg_next""];\n	""36"" -> ""22""[label=""cfg_next""];\n	""37"" -> ""12""[label=""cfg_next""];\n	""38"" -> ""9""[label=""cfg_next""];\n	""39"" -> ""15""[label=""cfg_next""];\n	""4"" -> ""43""[label=""cfg_next""];\n	""40"" -> ""1""[label=""cfg_next""];\n	""42"" -> ""17""[label=""cfg_next""];\n	""43"" -> ""25""[label=""cfg_next""];\n	""44"" -> ""38""[label=""cfg_next""];\n	""45"" -> ""39""[label=""cfg_next""];\n	""46"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""35""[label=""cfg_next""];\n	""6"" -> ""2""[label=""cfg_next""];\n	""7"" -> ""8""[label=""cfg_next""];\n	""8"" -> ""10""[label=""cfg_next""];\n	""9"" -> ""7""[label=""cfg_next""];\n}\n",private 
"org.apache.commons.csv.CSVFormat.printWithEscapes(Reader,Appendable)",Method,"* Note: Must only be called if escaping is enabled, otherwise can throw exceptions.","private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\n    int start = 0;\n    int pos = 0;\n    // Temp reader on input reader.\n    @SuppressWarnings(""resource"")\n    final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\n    final char[] delimArray = getDelimiterCharArray();\n    final int delimLength = delimArray.length;\n    final char escape = getEscapeChar();\n    final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n    int c;\n    final char[] lookAheadBuffer = new char[delimLength - 1];\n    while (EOF != (c = bufferedReader.read())) {\n        builder.append((char) c);\n        Arrays.fill(lookAheadBuffer, (char) 0);\n        bufferedReader.peek(lookAheadBuffer);\n        final String test = builder.toString() + new String(lookAheadBuffer);\n        final boolean isDelimiterStart = isDelimiter((char) c, test, pos, delimArray, delimLength);\n        final boolean isCr = c == Constants.CR;\n        final boolean isLf = c == Constants.LF;\n        if (isCr || isLf || c == escape || isDelimiterStart) {\n            // write out segment up until this char\n            if (pos > start) {\n                append(builder.substring(start, pos), appendable);\n                builder.setLength(0);\n                pos = -1;\n            }\n            if (isLf) {\n                c = 'n';\n            } else if (isCr) {\n                c = 'r';\n            }\n            escape((char) c, appendable);\n            if (isDelimiterStart) {\n                for (int i = 1; i < delimLength; i++) {\n                    escape((char) bufferedReader.read(), appendable);\n                }\n            }\n            // start on the current char after this one\n            start = pos + 1;\n        }\n        pos++;\n    }\n    // write last segment\n    if (pos > start) {\n        appendable.append(builder, start, pos);\n    }\n}","void printWithEscapes(java.io.Reader,java.lang.Appendable)","digraph cfg_printWithEscapes {\n	""1"" [label=""$stack17 = new org.apache.commons.csv.ExtendedBufferedReader""];\n	""2"" [label=""$stack18 = new java.lang.StringBuilder""];\n	""3"" [label=""$stack19 = delimLength - 1""];\n	""4"" [label=""$stack20 = (char) c""];\n	""5"" [label=""$stack21 = new java.lang.StringBuilder""];\n	""6"" [label=""$stack22 = virtualinvoke builder.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""7"" [label=""$stack23 = new java.lang.String""];\n	""8"" [label=""$stack24 = virtualinvoke $stack21.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack22)""];\n	""9"" [label=""$stack25 = virtualinvoke $stack24.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack23)""];\n	""10"" [label=""$stack26 = (char) c""];\n	""11"" [label=""$stack27 = (char) c""];\n	""12"" [label=""$stack28 = virtualinvoke bufferedReader.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""13"" [label=""$stack29 = (char) $stack28""];\n	""14"" [label=""$stack30 = virtualinvoke builder.<java.lang.StringBuilder: java.lang.String substring(int,int)>(start, pos)""];\n	""15"" [label=""appendable := @parameter1: java.lang.Appendable""];\n	""16"" [label=""bufferedReader = $stack17""];\n	""17"" [label=""builder = $stack18""];\n	""18"" [label=""c = 110""];\n	""19"" [label=""c = 114""];\n	""20"" [label=""c = virtualinvoke bufferedReader.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""21"" [label=""delimArray = virtualinvoke this.<org.apache.commons.csv.CSVFormat: char[] getDelimiterCharArray()>()""];\n	""22"" [label=""delimLength = lengthof delimArray""];\n	""23"" [label=""escape = virtualinvoke this.<org.apache.commons.csv.CSVFormat: char getEscapeChar()>()""];\n	""24"" [label=""goto""];\n	""25"" [label=""goto""];\n	""26"" [label=""goto""];\n	""27"" [label=""goto""];\n	""28"" [label=""goto""];\n	""29"" [label=""i = 1""];\n	""30"" [label=""i = i + 1""];\n	""31"" [label=""if -1 == c""];\n	""32"" [label=""if c != 10""];\n	""33"" [label=""if c != 13""];\n	""34"" [label=""if c == escape""];\n	""35"" [label=""if i >= delimLength""];\n	""36"" [label=""if isCr != 0""];\n	""37"" [label=""if isCr == 0""];\n	""38"" [label=""if isDelimiterStart == 0""];\n	""39"" [label=""if isDelimiterStart == 0""];\n	""40"" [label=""if isLf != 0""];\n	""41"" [label=""if isLf == 0""];\n	""42"" [label=""if pos <= start""];\n	""43"" [label=""if pos <= start""];\n	""44"" [label=""interfaceinvoke appendable.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence,int,int)>(builder, start, pos)""];\n	""45"" [label=""isCr = 0""];\n	""46"" [label=""isCr = 1""];\n	""47"" [label=""isDelimiterStart = specialinvoke this.<org.apache.commons.csv.CSVFormat: boolean isDelimiter(char,java.lang.CharSequence,int,char[],int)>($stack26, test, pos, delimArray, delimLength)""];\n	""48"" [label=""isLf = 0""];\n	""49"" [label=""isLf = 1""];\n	""50"" [label=""lookAheadBuffer = newarray (char)[$stack19]""];\n	""51"" [label=""pos = -1""];\n	""52"" [label=""pos = 0""];\n	""53"" [label=""pos = pos + 1""];\n	""54"" [label=""reader := @parameter0: java.io.Reader""];\n	""55"" [label=""return""];\n	""56"" [label=""specialinvoke $stack17.<org.apache.commons.csv.ExtendedBufferedReader: void <init>(java.io.Reader)>(reader)""];\n	""57"" [label=""specialinvoke $stack18.<java.lang.StringBuilder: void <init>(int)>(8192)""];\n	""58"" [label=""specialinvoke $stack21.<java.lang.StringBuilder: void <init>()>()""];\n	""59"" [label=""specialinvoke $stack23.<java.lang.String: void <init>(char[])>(lookAheadBuffer)""];\n	""60"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(java.lang.CharSequence,java.lang.Appendable)>($stack30, appendable)""];\n	""61"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void escape(char,java.lang.Appendable)>($stack27, appendable)""];\n	""62"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void escape(char,java.lang.Appendable)>($stack29, appendable)""];\n	""63"" [label=""start = 0""];\n	""64"" [label=""start = pos + 1""];\n	""65"" [label=""staticinvoke <java.util.Arrays: void fill(char[],char)>(lookAheadBuffer, 0)""];\n	""66"" [label=""test = virtualinvoke $stack25.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""67"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""68"" [label=""virtualinvoke bufferedReader.<org.apache.commons.csv.ExtendedBufferedReader: int peek(char[])>(lookAheadBuffer)""];\n	""69"" [label=""virtualinvoke builder.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack20)""];\n	""70"" [label=""virtualinvoke builder.<java.lang.StringBuilder: void setLength(int)>(0)""];\n	""1"" -> ""56""[label=""cfg_next""];\n	""10"" -> ""47""[label=""cfg_next""];\n	""11"" -> ""61""[label=""cfg_next""];\n	""12"" -> ""13""[label=""cfg_next""];\n	""13"" -> ""62""[label=""cfg_next""];\n	""14"" -> ""60""[label=""cfg_next""];\n	""15"" -> ""63""[label=""cfg_next""];\n	""16"" -> ""21""[label=""cfg_next""];\n	""17"" -> ""3""[label=""cfg_next""];\n	""18"" -> ""26""[label=""cfg_next""];\n	""19"" -> ""11""[label=""cfg_next""];\n	""2"" -> ""57""[label=""cfg_next""];\n	""20"" -> ""31""[label=""cfg_next""];\n	""21"" -> ""22""[label=""cfg_next""];\n	""22"" -> ""23""[label=""cfg_next""];\n	""23"" -> ""2""[label=""cfg_next""];\n	""24"" -> ""32""[label=""cfg_goto""];\n	""25"" -> ""36""[label=""cfg_goto""];\n	""26"" -> ""11""[label=""cfg_goto""];\n	""27"" -> ""35""[label=""cfg_goto""];\n	""28"" -> ""20""[label=""cfg_goto""];\n	""29"" -> ""35""[label=""cfg_next""];\n	""3"" -> ""50""[label=""cfg_next""];\n	""30"" -> ""27""[label=""cfg_next""];\n	""31"" -> ""4""[label=""cfg_false""];\n	""31"" -> ""42""[label=""cfg_true""];\n	""32"" -> ""48""[label=""cfg_true""];\n	""32"" -> ""49""[label=""cfg_false""];\n	""33"" -> ""45""[label=""cfg_true""];\n	""33"" -> ""46""[label=""cfg_false""];\n	""34"" -> ""38""[label=""cfg_false""];\n	""34"" -> ""43""[label=""cfg_true""];\n	""35"" -> ""12""[label=""cfg_false""];\n	""35"" -> ""64""[label=""cfg_true""];\n	""36"" -> ""40""[label=""cfg_false""];\n	""36"" -> ""43""[label=""cfg_true""];\n	""37"" -> ""11""[label=""cfg_true""];\n	""37"" -> ""19""[label=""cfg_false""];\n	""38"" -> ""43""[label=""cfg_false""];\n	""38"" -> ""53""[label=""cfg_true""];\n	""39"" -> ""29""[label=""cfg_false""];\n	""39"" -> ""64""[label=""cfg_true""];\n	""4"" -> ""69""[label=""cfg_next""];\n	""40"" -> ""34""[label=""cfg_false""];\n	""40"" -> ""43""[label=""cfg_true""];\n	""41"" -> ""18""[label=""cfg_false""];\n	""41"" -> ""37""[label=""cfg_true""];\n	""42"" -> ""44""[label=""cfg_false""];\n	""42"" -> ""55""[label=""cfg_true""];\n	""43"" -> ""14""[label=""cfg_false""];\n	""43"" -> ""41""[label=""cfg_true""];\n	""44"" -> ""55""[label=""cfg_next""];\n	""45"" -> ""32""[label=""cfg_next""];\n	""46"" -> ""24""[label=""cfg_next""];\n	""47"" -> ""33""[label=""cfg_next""];\n	""48"" -> ""36""[label=""cfg_next""];\n	""49"" -> ""25""[label=""cfg_next""];\n	""5"" -> ""58""[label=""cfg_next""];\n	""50"" -> ""20""[label=""cfg_next""];\n	""51"" -> ""41""[label=""cfg_next""];\n	""52"" -> ""1""[label=""cfg_next""];\n	""53"" -> ""28""[label=""cfg_next""];\n	""54"" -> ""15""[label=""cfg_next""];\n	""56"" -> ""16""[label=""cfg_next""];\n	""57"" -> ""17""[label=""cfg_next""];\n	""58"" -> ""6""[label=""cfg_next""];\n	""59"" -> ""9""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_next""];\n	""60"" -> ""70""[label=""cfg_next""];\n	""61"" -> ""39""[label=""cfg_next""];\n	""62"" -> ""30""[label=""cfg_next""];\n	""63"" -> ""52""[label=""cfg_next""];\n	""64"" -> ""53""[label=""cfg_next""];\n	""65"" -> ""68""[label=""cfg_next""];\n	""66"" -> ""10""[label=""cfg_next""];\n	""67"" -> ""54""[label=""cfg_next""];\n	""68"" -> ""5""[label=""cfg_next""];\n	""69"" -> ""65""[label=""cfg_next""];\n	""7"" -> ""59""[label=""cfg_next""];\n	""70"" -> ""51""[label=""cfg_next""];\n	""8"" -> ""7""[label=""cfg_next""];\n	""9"" -> ""66""[label=""cfg_next""];\n}\n",private 
"org.apache.commons.csv.CSVFormat.printWithQuotes(Object,CharSequence,Appendable,boolean)",Method,the original object is needed so can check for Number,"private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = 0;\n    int pos = 0;\n    final int len = charSeq.length();\n    final char[] delim = getDelimiterCharArray();\n    final int delimLength = delim.length;\n    // N.B. Explicit (un)boxing is intentional\n    final char quoteChar = getQuoteCharacter().charValue();\n    // If escape char not specified, default to the quote char\n    // This avoids having to keep checking whether there is an escape character\n    // at the cost of checking against quote twice\n    final char escapeChar = isEscapeCharacterSet() ? getEscapeChar() : quoteChar;\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch(quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(charSeq, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // Always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = charSeq.charAt(pos);\n                if (c <= Constants.COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < len) {\n                        c = charSeq.charAt(pos);\n                        if (c == Constants.LF || c == Constants.CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        pos = len - 1;\n                        c = charSeq.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (isTrimChar(c)) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                // No encapsulation needed - write out the original value\n                out.append(charSeq, start, len);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(""Unexpected Quote value: "" + quoteModePolicy);\n    }\n    if (!quote) {\n        // No encapsulation needed - write out the original value\n        out.append(charSeq, start, len);\n        return;\n    }\n    // We hit something that needed encapsulation\n    out.append(quoteChar);\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < len) {\n        final char c = charSeq.charAt(pos);\n        if (c == quoteChar || c == escapeChar) {\n            // write out the chunk up until this point\n            out.append(charSeq, start, pos);\n            // now output the escape\n            out.append(escapeChar);\n            // and restart with the matched char\n            start = pos;\n        }\n        pos++;\n    }\n    // Write the last segment\n    out.append(charSeq, start, pos);\n    out.append(quoteChar);\n}","void printWithQuotes(java.lang.Object,java.lang.CharSequence,java.lang.Appendable,boolean)","digraph cfg_printWithQuotes {\n	""1"" [label=""$stack15 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: java.lang.Character getQuoteCharacter()>()""];\n	""2"" [label=""$stack16 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isEscapeCharacterSet()>()""];\n	""3"" [label=""$stack17 = <org.apache.commons.csv.CSVFormat$1: int[] $SwitchMap$org$apache$commons$csv$QuoteMode>""];\n	""4"" [label=""$stack18 = virtualinvoke quoteModePolicy.<org.apache.commons.csv.QuoteMode: int ordinal()>()""];\n	""5"" [label=""$stack19 = $stack17[$stack18]""];\n	""6"" [label=""$stack20 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean isTrimChar(char)>(c)""];\n	""7"" [label=""$stack21 = specialinvoke this.<org.apache.commons.csv.CSVFormat: boolean isDelimiter(char,java.lang.CharSequence,int,char[],int)>(c, charSeq, pos, delim, delimLength)""];\n	""8"" [label=""$stack22 = object instanceof java.lang.Number""];\n	""9"" [label=""$stack23 = new java.lang.StringBuilder""];\n	""10"" [label=""$stack24 = virtualinvoke $stack23.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""Unexpected Quote value: \"")""];\n	""11"" [label=""$stack25 = virtualinvoke $stack24.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(quoteModePolicy)""];\n	""12"" [label=""$stack26 = virtualinvoke $stack25.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""13"" [label=""$stack27 = new java.lang.IllegalStateException""];\n	""14"" [label=""c = interfaceinvoke charSeq.<java.lang.CharSequence: char charAt(int)>(pos)""];\n	""15"" [label=""c = interfaceinvoke charSeq.<java.lang.CharSequence: char charAt(int)>(pos)""];\n	""16"" [label=""c = interfaceinvoke charSeq.<java.lang.CharSequence: char charAt(int)>(pos)""];\n	""17"" [label=""c = interfaceinvoke charSeq.<java.lang.CharSequence: char charAt(int)>(pos)""];\n	""18"" [label=""charSeq := @parameter1: java.lang.CharSequence""];\n	""19"" [label=""delim = virtualinvoke this.<org.apache.commons.csv.CSVFormat: char[] getDelimiterCharArray()>()""];\n	""20"" [label=""delimLength = lengthof delim""];\n	""21"" [label=""escapeChar = quoteChar""];\n	""22"" [label=""escapeChar = virtualinvoke this.<org.apache.commons.csv.CSVFormat: char getEscapeChar()>()""];\n	""23"" [label=""goto""];\n	""24"" [label=""goto""];\n	""25"" [label=""goto""];\n	""26"" [label=""goto""];\n	""27"" [label=""goto""];\n	""28"" [label=""goto""];\n	""29"" [label=""goto""];\n	""30"" [label=""goto""];\n	""31"" [label=""goto""];\n	""32"" [label=""if $stack16 == 0""];\n	""33"" [label=""if $stack20 == 0""];\n	""34"" [label=""if $stack21 == 0""];\n	""35"" [label=""if $stack22 != 0""];\n	""36"" [label=""if c != escapeChar""];\n	""37"" [label=""if c == 10""];\n	""38"" [label=""if c == 13""];\n	""39"" [label=""if c == escapeChar""];\n	""40"" [label=""if c == quoteChar""];\n	""41"" [label=""if c == quoteChar""];\n	""42"" [label=""if c > 35""];\n	""43"" [label=""if len > 0""];\n	""44"" [label=""if newRecord == 0""];\n	""45"" [label=""if pos >= len""];\n	""46"" [label=""if pos >= len""];\n	""47"" [label=""if quote != 0""];\n	""48"" [label=""if quote != 0""];\n	""49"" [label=""if quote != 0""];\n	""50"" [label=""if quoteModePolicy != null""];\n	""51"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(char)>(escapeChar)""];\n	""52"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(char)>(quoteChar)""];\n	""53"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(char)>(quoteChar)""];\n	""54"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence,int,int)>(charSeq, start, len)""];\n	""55"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence,int,int)>(charSeq, start, len)""];\n	""56"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence,int,int)>(charSeq, start, pos)""];\n	""57"" [label=""interfaceinvoke out.<java.lang.Appendable: java.lang.Appendable append(java.lang.CharSequence,int,int)>(charSeq, start, pos)""];\n	""58"" [label=""len = interfaceinvoke charSeq.<java.lang.CharSequence: int length()>()""];\n	""59"" [label=""newRecord := @parameter3: boolean""];\n	""60"" [label=""object := @parameter0: java.lang.Object""];\n	""61"" [label=""out := @parameter2: java.lang.Appendable""];\n	""62"" [label=""pos = 0""];\n	""63"" [label=""pos = len - 1""];\n	""64"" [label=""pos = pos + 1""];\n	""65"" [label=""pos = pos + 1""];\n	""66"" [label=""quote = 0""];\n	""67"" [label=""quote = 0""];\n	""68"" [label=""quote = 1""];\n	""69"" [label=""quote = 1""];\n	""70"" [label=""quote = 1""];\n	""71"" [label=""quote = 1""];\n	""72"" [label=""quote = 1""];\n	""73"" [label=""quote = 1""];\n	""74"" [label=""quoteChar = virtualinvoke $stack15.<java.lang.Character: char charValue()>()""];\n	""75"" [label=""quoteModePolicy = <org.apache.commons.csv.QuoteMode: org.apache.commons.csv.QuoteMode MINIMAL>""];\n	""76"" [label=""quoteModePolicy = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode getQuoteMode()>()""];\n	""77"" [label=""return""];\n	""78"" [label=""return""];\n	""79"" [label=""return""];\n	""80"" [label=""return""];\n	""81"" [label=""specialinvoke $stack23.<java.lang.StringBuilder: void <init>()>()""];\n	""82"" [label=""specialinvoke $stack27.<java.lang.IllegalStateException: void <init>(java.lang.String)>($stack26)""];\n	""83"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void printWithEscapes(java.lang.CharSequence,java.lang.Appendable)>(charSeq, out)""];\n	""84"" [label=""start = 0""];\n	""85"" [label=""start = pos""];\n	""86"" [label=""switch($stack19) \{     case 1:     case 2:     case 3:     case 4:     case 5:     default:  \}""];\n	""87"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""88"" [label=""throw $stack27""];\n	""1"" -> ""74""[label=""cfg_next""];\n	""10"" -> ""11""[label=""cfg_next""];\n	""11"" -> ""12""[label=""cfg_next""];\n	""12"" -> ""82""[label=""cfg_next""];\n	""13"" -> ""9""[label=""cfg_next""];\n	""14"" -> ""42""[label=""cfg_next""];\n	""15"" -> ""6""[label=""cfg_next""];\n	""16"" -> ""40""[label=""cfg_next""];\n	""17"" -> ""37""[label=""cfg_next""];\n	""18"" -> ""61""[label=""cfg_next""];\n	""19"" -> ""20""[label=""cfg_next""];\n	""2"" -> ""32""[label=""cfg_next""];\n	""20"" -> ""1""[label=""cfg_next""];\n	""21"" -> ""76""[label=""cfg_next""];\n	""22"" -> ""23""[label=""cfg_next""];\n	""23"" -> ""76""[label=""cfg_goto""];\n	""24"" -> ""47""[label=""cfg_goto""];\n	""25"" -> ""26""[label=""cfg_goto""];\n	""26"" -> ""47""[label=""cfg_goto""];\n	""27"" -> ""48""[label=""cfg_goto""];\n	""28"" -> ""45""[label=""cfg_goto""];\n	""29"" -> ""48""[label=""cfg_goto""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""30"" -> ""49""[label=""cfg_goto""];\n	""31"" -> ""46""[label=""cfg_goto""];\n	""32"" -> ""21""[label=""cfg_true""];\n	""32"" -> ""22""[label=""cfg_false""];\n	""33"" -> ""48""[label=""cfg_true""];\n	""33"" -> ""71""[label=""cfg_false""];\n	""34"" -> ""65""[label=""cfg_true""];\n	""34"" -> ""73""[label=""cfg_false""];\n	""35"" -> ""67""[label=""cfg_true""];\n	""35"" -> ""69""[label=""cfg_false""];\n	""36"" -> ""57""[label=""cfg_false""];\n	""36"" -> ""64""[label=""cfg_true""];\n	""37"" -> ""38""[label=""cfg_false""];\n	""37"" -> ""73""[label=""cfg_true""];\n	""38"" -> ""41""[label=""cfg_false""];\n	""38"" -> ""73""[label=""cfg_true""];\n	""39"" -> ""7""[label=""cfg_false""];\n	""39"" -> ""73""[label=""cfg_true""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""40"" -> ""36""[label=""cfg_false""];\n	""40"" -> ""57""[label=""cfg_true""];\n	""41"" -> ""39""[label=""cfg_false""];\n	""41"" -> ""73""[label=""cfg_true""];\n	""42"" -> ""46""[label=""cfg_true""];\n	""42"" -> ""72""[label=""cfg_false""];\n	""43"" -> ""14""[label=""cfg_true""];\n	""43"" -> ""44""[label=""cfg_false""];\n	""44"" -> ""48""[label=""cfg_true""];\n	""44"" -> ""70""[label=""cfg_false""];\n	""45"" -> ""16""[label=""cfg_false""];\n	""45"" -> ""56""[label=""cfg_true""];\n	""46"" -> ""17""[label=""cfg_false""];\n	""46"" -> ""49""[label=""cfg_true""];\n	""47"" -> ""52""[label=""cfg_true""];\n	""47"" -> ""55""[label=""cfg_false""];\n	""48"" -> ""47""[label=""cfg_true""];\n	""48"" -> ""54""[label=""cfg_false""];\n	""49"" -> ""48""[label=""cfg_true""];\n	""49"" -> ""63""[label=""cfg_false""];\n	""5"" -> ""86""[label=""cfg_next""];\n	""50"" -> ""3""[label=""cfg_true""];\n	""50"" -> ""75""[label=""cfg_false""];\n	""51"" -> ""85""[label=""cfg_next""];\n	""52"" -> ""45""[label=""cfg_next""];\n	""53"" -> ""80""[label=""cfg_next""];\n	""54"" -> ""77""[label=""cfg_next""];\n	""55"" -> ""78""[label=""cfg_next""];\n	""56"" -> ""53""[label=""cfg_next""];\n	""57"" -> ""51""[label=""cfg_next""];\n	""58"" -> ""19""[label=""cfg_next""];\n	""59"" -> ""66""[label=""cfg_next""];\n	""6"" -> ""33""[label=""cfg_next""];\n	""60"" -> ""18""[label=""cfg_next""];\n	""61"" -> ""59""[label=""cfg_next""];\n	""62"" -> ""58""[label=""cfg_next""];\n	""63"" -> ""15""[label=""cfg_next""];\n	""64"" -> ""28""[label=""cfg_next""];\n	""65"" -> ""31""[label=""cfg_next""];\n	""66"" -> ""84""[label=""cfg_next""];\n	""67"" -> ""26""[label=""cfg_next""];\n	""68"" -> ""24""[label=""cfg_next""];\n	""69"" -> ""25""[label=""cfg_next""];\n	""7"" -> ""34""[label=""cfg_next""];\n	""70"" -> ""27""[label=""cfg_next""];\n	""71"" -> ""48""[label=""cfg_next""];\n	""72"" -> ""29""[label=""cfg_next""];\n	""73"" -> ""30""[label=""cfg_next""];\n	""74"" -> ""2""[label=""cfg_next""];\n	""75"" -> ""3""[label=""cfg_next""];\n	""76"" -> ""50""[label=""cfg_next""];\n	""8"" -> ""35""[label=""cfg_next""];\n	""81"" -> ""10""[label=""cfg_next""];\n	""82"" -> ""88""[label=""cfg_next""];\n	""83"" -> ""79""[label=""cfg_next""];\n	""84"" -> ""62""[label=""cfg_next""];\n	""85"" -> ""64""[label=""cfg_next""];\n	""86"" -> ""13""[label=""cfg_switch""];\n	""86"" -> ""43""[label=""cfg_switch""];\n	""86"" -> ""68""[label=""cfg_switch""];\n	""86"" -> ""8""[label=""cfg_switch""];\n	""86"" -> ""83""[label=""cfg_switch""];\n	""87"" -> ""60""[label=""cfg_next""];\n	""9"" -> ""81""[label=""cfg_next""];\n}\n",private 
"org.apache.commons.csv.CSVFormat.printWithQuotes(Reader,Appendable)",Method,"* Always use quotes unless QuoteMode is NONE, so we do not have to look ahead.\n     *\n     * @param reader     What to print\n     * @param appendable Where to print it\n     * @throws IOException If an I/O error occurs","private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\n    if (getQuoteMode() == QuoteMode.NONE) {\n        printWithEscapes(reader, appendable);\n        return;\n    }\n    // N.B. Explicit (un)boxing is intentional\n    final char quote = getQuoteCharacter().charValue();\n    // (1) Append opening quote\n    append(quote, appendable);\n    // (2) Append Reader contents, doubling quotes\n    int c;\n    while (EOF != (c = reader.read())) {\n        append((char) c, appendable);\n        if (c == quote) {\n            append(quote, appendable);\n        }\n    }\n    // (3) Append closing quote\n    append(quote, appendable);\n}","void printWithQuotes(java.io.Reader,java.lang.Appendable)","digraph cfg_printWithQuotes {\n	""1"" [label=""$stack5 = <org.apache.commons.csv.QuoteMode: org.apache.commons.csv.QuoteMode NONE>""];\n	""2"" [label=""$stack6 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode getQuoteMode()>()""];\n	""3"" [label=""$stack7 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: java.lang.Character getQuoteCharacter()>()""];\n	""4"" [label=""$stack8 = (char) c""];\n	""5"" [label=""appendable := @parameter1: java.lang.Appendable""];\n	""6"" [label=""c = virtualinvoke reader.<java.io.Reader: int read()>()""];\n	""7"" [label=""goto""];\n	""8"" [label=""if $stack6 != $stack5""];\n	""9"" [label=""if -1 == c""];\n	""10"" [label=""if c != quote""];\n	""11"" [label=""quote = virtualinvoke $stack7.<java.lang.Character: char charValue()>()""];\n	""12"" [label=""reader := @parameter0: java.io.Reader""];\n	""13"" [label=""return""];\n	""14"" [label=""return""];\n	""15"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(char,java.lang.Appendable)>($stack8, appendable)""];\n	""16"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(char,java.lang.Appendable)>(quote, appendable)""];\n	""17"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(char,java.lang.Appendable)>(quote, appendable)""];\n	""18"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void append(char,java.lang.Appendable)>(quote, appendable)""];\n	""19"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void printWithEscapes(java.io.Reader,java.lang.Appendable)>(reader, appendable)""];\n	""20"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""8""[label=""cfg_next""];\n	""10"" -> ""18""[label=""cfg_false""];\n	""10"" -> ""6""[label=""cfg_true""];\n	""11"" -> ""16""[label=""cfg_next""];\n	""12"" -> ""5""[label=""cfg_next""];\n	""15"" -> ""10""[label=""cfg_next""];\n	""16"" -> ""6""[label=""cfg_next""];\n	""17"" -> ""14""[label=""cfg_next""];\n	""18"" -> ""7""[label=""cfg_next""];\n	""19"" -> ""13""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""20"" -> ""12""[label=""cfg_next""];\n	""3"" -> ""11""[label=""cfg_next""];\n	""4"" -> ""15""[label=""cfg_next""];\n	""5"" -> ""2""[label=""cfg_next""];\n	""6"" -> ""9""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_goto""];\n	""8"" -> ""19""[label=""cfg_false""];\n	""8"" -> ""3""[label=""cfg_true""];\n	""9"" -> ""17""[label=""cfg_true""];\n	""9"" -> ""4""[label=""cfg_false""];\n}\n",private 
org.apache.commons.csv.CSVFormat.toString(),Method,No Comment,"@Override\npublic String toString() {\n    final StringBuilder sb = new StringBuilder();\n    sb.append(""Delimiter=<"").append(delimiter).append('>');\n    if (isEscapeCharacterSet()) {\n        sb.append(' ');\n        sb.append(""Escape=<"").append(escapeCharacter).append('>');\n    }\n    if (isQuoteCharacterSet()) {\n        sb.append(' ');\n        sb.append(""QuoteChar=<"").append(quoteCharacter).append('>');\n    }\n    if (quoteMode != null) {\n        sb.append(' ');\n        sb.append(""QuoteMode=<"").append(quoteMode).append('>');\n    }\n    if (isCommentMarkerSet()) {\n        sb.append(' ');\n        sb.append(""CommentStart=<"").append(commentMarker).append('>');\n    }\n    if (isNullStringSet()) {\n        sb.append(' ');\n        sb.append(""NullString=<"").append(nullString).append('>');\n    }\n    if (recordSeparator != null) {\n        sb.append(' ');\n        sb.append(""RecordSeparator=<"").append(recordSeparator).append('>');\n    }\n    if (getIgnoreEmptyLines()) {\n        sb.append("" EmptyLines:ignored"");\n    }\n    if (getIgnoreSurroundingSpaces()) {\n        sb.append("" SurroundingSpaces:ignored"");\n    }\n    if (getIgnoreHeaderCase()) {\n        sb.append("" IgnoreHeaderCase:ignored"");\n    }\n    sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord);\n    if (headerComments != null) {\n        sb.append(' ');\n        sb.append(""HeaderComments:"").append(Arrays.toString(headerComments));\n    }\n    if (headers != null) {\n        sb.append(' ');\n        sb.append(""Header:"").append(Arrays.toString(headers));\n    }\n    return sb.toString();\n}",java.lang.String toString(),"digraph cfg_toString {\n	""1"" [label=""$stack10 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isNullStringSet()>()""];\n	""2"" [label=""$stack11 = this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""3"" [label=""$stack12 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean getIgnoreEmptyLines()>()""];\n	""4"" [label=""$stack13 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean getIgnoreSurroundingSpaces()>()""];\n	""5"" [label=""$stack14 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean getIgnoreHeaderCase()>()""];\n	""6"" [label=""$stack15 = this.<org.apache.commons.csv.CSVFormat: boolean skipHeaderRecord>""];\n	""7"" [label=""$stack16 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\"" SkipHeaderRecord:\"")""];\n	""8"" [label=""$stack17 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headerComments>""];\n	""9"" [label=""$stack18 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""10"" [label=""$stack19 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""11"" [label=""$stack2 = new java.lang.StringBuilder""];\n	""12"" [label=""$stack20 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""13"" [label=""$stack21 = staticinvoke <java.util.Arrays: java.lang.String toString(java.lang.Object[])>($stack20)""];\n	""14"" [label=""$stack22 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""Header:\"")""];\n	""15"" [label=""$stack23 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headerComments>""];\n	""16"" [label=""$stack24 = staticinvoke <java.util.Arrays: java.lang.String toString(java.lang.Object[])>($stack23)""];\n	""17"" [label=""$stack25 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""HeaderComments:\"")""];\n	""18"" [label=""$stack26 = this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator>""];\n	""19"" [label=""$stack27 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""RecordSeparator=<\"")""];\n	""20"" [label=""$stack28 = virtualinvoke $stack27.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack26)""];\n	""21"" [label=""$stack29 = this.<org.apache.commons.csv.CSVFormat: java.lang.String nullString>""];\n	""22"" [label=""$stack3 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""23"" [label=""$stack30 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""NullString=<\"")""];\n	""24"" [label=""$stack31 = virtualinvoke $stack30.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack29)""];\n	""25"" [label=""$stack32 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""26"" [label=""$stack33 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""CommentStart=<\"")""];\n	""27"" [label=""$stack34 = virtualinvoke $stack33.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack32)""];\n	""28"" [label=""$stack35 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode quoteMode>""];\n	""29"" [label=""$stack36 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""QuoteMode=<\"")""];\n	""30"" [label=""$stack37 = virtualinvoke $stack36.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack35)""];\n	""31"" [label=""$stack38 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""32"" [label=""$stack39 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""QuoteChar=<\"")""];\n	""33"" [label=""$stack4 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""Delimiter=<\"")""];\n	""34"" [label=""$stack40 = virtualinvoke $stack39.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack38)""];\n	""35"" [label=""$stack41 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""36"" [label=""$stack42 = virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""Escape=<\"")""];\n	""37"" [label=""$stack43 = virtualinvoke $stack42.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack41)""];\n	""38"" [label=""$stack5 = virtualinvoke $stack4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack3)""];\n	""39"" [label=""$stack6 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isEscapeCharacterSet()>()""];\n	""40"" [label=""$stack7 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isQuoteCharacterSet()>()""];\n	""41"" [label=""$stack8 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode quoteMode>""];\n	""42"" [label=""$stack9 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean isCommentMarkerSet()>()""];\n	""43"" [label=""if $stack10 == 0""];\n	""44"" [label=""if $stack11 == null""];\n	""45"" [label=""if $stack12 == 0""];\n	""46"" [label=""if $stack13 == 0""];\n	""47"" [label=""if $stack14 == 0""];\n	""48"" [label=""if $stack17 == null""];\n	""49"" [label=""if $stack18 == null""];\n	""50"" [label=""if $stack6 == 0""];\n	""51"" [label=""if $stack7 == 0""];\n	""52"" [label=""if $stack8 == null""];\n	""53"" [label=""if $stack9 == 0""];\n	""54"" [label=""return $stack19""];\n	""55"" [label=""sb = $stack2""];\n	""56"" [label=""specialinvoke $stack2.<java.lang.StringBuilder: void <init>()>()""];\n	""57"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""58"" [label=""virtualinvoke $stack16.<java.lang.StringBuilder: java.lang.StringBuilder append(boolean)>($stack15)""];\n	""59"" [label=""virtualinvoke $stack22.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack21)""];\n	""60"" [label=""virtualinvoke $stack25.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack24)""];\n	""61"" [label=""virtualinvoke $stack28.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(62)""];\n	""62"" [label=""virtualinvoke $stack31.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(62)""];\n	""63"" [label=""virtualinvoke $stack34.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(62)""];\n	""64"" [label=""virtualinvoke $stack37.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(62)""];\n	""65"" [label=""virtualinvoke $stack40.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(62)""];\n	""66"" [label=""virtualinvoke $stack43.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(62)""];\n	""67"" [label=""virtualinvoke $stack5.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(62)""];\n	""68"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(32)""];\n	""69"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(32)""];\n	""70"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(32)""];\n	""71"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(32)""];\n	""72"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(32)""];\n	""73"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(32)""];\n	""74"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(32)""];\n	""75"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(32)""];\n	""76"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\"" EmptyLines:ignored\"")""];\n	""77"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\"" IgnoreHeaderCase:ignored\"")""];\n	""78"" [label=""virtualinvoke sb.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\"" SurroundingSpaces:ignored\"")""];\n	""1"" -> ""43""[label=""cfg_next""];\n	""10"" -> ""54""[label=""cfg_next""];\n	""11"" -> ""56""[label=""cfg_next""];\n	""12"" -> ""13""[label=""cfg_next""];\n	""13"" -> ""59""[label=""cfg_next""];\n	""14"" -> ""12""[label=""cfg_next""];\n	""15"" -> ""16""[label=""cfg_next""];\n	""16"" -> ""60""[label=""cfg_next""];\n	""17"" -> ""15""[label=""cfg_next""];\n	""18"" -> ""20""[label=""cfg_next""];\n	""19"" -> ""18""[label=""cfg_next""];\n	""2"" -> ""44""[label=""cfg_next""];\n	""20"" -> ""61""[label=""cfg_next""];\n	""21"" -> ""24""[label=""cfg_next""];\n	""22"" -> ""38""[label=""cfg_next""];\n	""23"" -> ""21""[label=""cfg_next""];\n	""24"" -> ""62""[label=""cfg_next""];\n	""25"" -> ""27""[label=""cfg_next""];\n	""26"" -> ""25""[label=""cfg_next""];\n	""27"" -> ""63""[label=""cfg_next""];\n	""28"" -> ""30""[label=""cfg_next""];\n	""29"" -> ""28""[label=""cfg_next""];\n	""3"" -> ""45""[label=""cfg_next""];\n	""30"" -> ""64""[label=""cfg_next""];\n	""31"" -> ""34""[label=""cfg_next""];\n	""32"" -> ""31""[label=""cfg_next""];\n	""33"" -> ""22""[label=""cfg_next""];\n	""34"" -> ""65""[label=""cfg_next""];\n	""35"" -> ""37""[label=""cfg_next""];\n	""36"" -> ""35""[label=""cfg_next""];\n	""37"" -> ""66""[label=""cfg_next""];\n	""38"" -> ""67""[label=""cfg_next""];\n	""39"" -> ""50""[label=""cfg_next""];\n	""4"" -> ""46""[label=""cfg_next""];\n	""40"" -> ""51""[label=""cfg_next""];\n	""41"" -> ""52""[label=""cfg_next""];\n	""42"" -> ""53""[label=""cfg_next""];\n	""43"" -> ""2""[label=""cfg_true""];\n	""43"" -> ""72""[label=""cfg_false""];\n	""44"" -> ""3""[label=""cfg_true""];\n	""44"" -> ""73""[label=""cfg_false""];\n	""45"" -> ""4""[label=""cfg_true""];\n	""45"" -> ""76""[label=""cfg_false""];\n	""46"" -> ""5""[label=""cfg_true""];\n	""46"" -> ""78""[label=""cfg_false""];\n	""47"" -> ""7""[label=""cfg_true""];\n	""47"" -> ""77""[label=""cfg_false""];\n	""48"" -> ""74""[label=""cfg_false""];\n	""48"" -> ""9""[label=""cfg_true""];\n	""49"" -> ""10""[label=""cfg_true""];\n	""49"" -> ""75""[label=""cfg_false""];\n	""5"" -> ""47""[label=""cfg_next""];\n	""50"" -> ""40""[label=""cfg_true""];\n	""50"" -> ""68""[label=""cfg_false""];\n	""51"" -> ""41""[label=""cfg_true""];\n	""51"" -> ""69""[label=""cfg_false""];\n	""52"" -> ""42""[label=""cfg_true""];\n	""52"" -> ""70""[label=""cfg_false""];\n	""53"" -> ""1""[label=""cfg_true""];\n	""53"" -> ""71""[label=""cfg_false""];\n	""55"" -> ""33""[label=""cfg_next""];\n	""56"" -> ""55""[label=""cfg_next""];\n	""57"" -> ""11""[label=""cfg_next""];\n	""58"" -> ""8""[label=""cfg_next""];\n	""59"" -> ""10""[label=""cfg_next""];\n	""6"" -> ""58""[label=""cfg_next""];\n	""60"" -> ""9""[label=""cfg_next""];\n	""61"" -> ""3""[label=""cfg_next""];\n	""62"" -> ""2""[label=""cfg_next""];\n	""63"" -> ""1""[label=""cfg_next""];\n	""64"" -> ""42""[label=""cfg_next""];\n	""65"" -> ""41""[label=""cfg_next""];\n	""66"" -> ""40""[label=""cfg_next""];\n	""67"" -> ""39""[label=""cfg_next""];\n	""68"" -> ""36""[label=""cfg_next""];\n	""69"" -> ""32""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n	""70"" -> ""29""[label=""cfg_next""];\n	""71"" -> ""26""[label=""cfg_next""];\n	""72"" -> ""23""[label=""cfg_next""];\n	""73"" -> ""19""[label=""cfg_next""];\n	""74"" -> ""17""[label=""cfg_next""];\n	""75"" -> ""14""[label=""cfg_next""];\n	""76"" -> ""4""[label=""cfg_next""];\n	""77"" -> ""7""[label=""cfg_next""];\n	""78"" -> ""5""[label=""cfg_next""];\n	""8"" -> ""48""[label=""cfg_next""];\n	""9"" -> ""49""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.trim(String),Method,No Comment,String trim(final String value) {\n    return getTrim() ? value.trim() : value;\n},java.lang.String trim(java.lang.String),"digraph cfg_trim {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean getTrim()>()""];\n	""2"" [label=""$stack3 = value""];\n	""3"" [label=""$stack3 = virtualinvoke value.<java.lang.String: java.lang.String trim()>()""];\n	""4"" [label=""goto""];\n	""5"" [label=""if $stack2 == 0""];\n	""6"" [label=""return $stack3""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""8"" [label=""value := @parameter0: java.lang.String""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""8""[label=""cfg_next""];\n	""8"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVFormat.useMaxRows(),Method,No Comment,boolean useMaxRows() {\n    return getMaxRows() > 0;\n},boolean useMaxRows(),"digraph cfg_useMaxRows {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: long getMaxRows()>()""];\n	""2"" [label=""$stack2 = $stack1 cmp 0L""];\n	""3"" [label=""$stack3 = 0""];\n	""4"" [label=""$stack3 = 1""];\n	""5"" [label=""goto""];\n	""6"" [label=""if $stack2 <= 0""];\n	""7"" [label=""return $stack3""];\n	""8"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""7""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_goto""];\n	""6"" -> ""3""[label=""cfg_true""];\n	""6"" -> ""4""[label=""cfg_false""];\n	""8"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.CSVFormat.useRow(long),Method,No Comment,boolean useRow(final long rowNum) {\n    return !useMaxRows() || rowNum <= getMaxRows();\n},boolean useRow(long),"digraph cfg_useRow {\n	""1"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: boolean useMaxRows()>()""];\n	""2"" [label=""$stack4 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: long getMaxRows()>()""];\n	""3"" [label=""$stack5 = rowNum cmp $stack4""];\n	""4"" [label=""$stack6 = 0""];\n	""5"" [label=""$stack6 = 1""];\n	""6"" [label=""goto""];\n	""7"" [label=""if $stack3 == 0""];\n	""8"" [label=""if $stack5 > 0""];\n	""9"" [label=""return $stack6""];\n	""10"" [label=""rowNum := @parameter0: long""];\n	""11"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""7""[label=""cfg_next""];\n	""10"" -> ""1""[label=""cfg_next""];\n	""11"" -> ""10""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""8""[label=""cfg_next""];\n	""4"" -> ""9""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""9""[label=""cfg_goto""];\n	""7"" -> ""2""[label=""cfg_false""];\n	""7"" -> ""5""[label=""cfg_true""];\n	""8"" -> ""4""[label=""cfg_true""];\n	""8"" -> ""5""[label=""cfg_false""];\n}\n",default
org.apache.commons.csv.CSVFormat.validate(),Method,"* Verifies the validity and consistency of the attributes, and throws an {@link IllegalArgumentException} if necessary.\n     * <p>\n     * Because an instance can be used for both writing and parsing, not all conditions can be tested here. For example, allowMissingColumnNames is only used\n     * for parsing, so it cannot be used here.\n     * </p>\n     *\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.","private void validate() throws IllegalArgumentException {\n    if (containsLineBreak(delimiter)) {\n        throw new IllegalArgumentException(""The delimiter cannot be a line break"");\n    }\n    if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {\n        // N.B. Explicit (un)boxing is intentional\n        throw new IllegalArgumentException(""The quoteChar character and the delimiter cannot be the same ('"" + quoteCharacter + ""')"");\n    }\n    if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {\n        // N.B. Explicit (un)boxing is intentional\n        throw new IllegalArgumentException(""The escape character and the delimiter cannot be the same ('"" + escapeCharacter + ""')"");\n    }\n    if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {\n        // N.B. Explicit (un)boxing is intentional\n        throw new IllegalArgumentException(""The comment start character and the delimiter cannot be the same ('"" + commentMarker + ""')"");\n    }\n    if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n        throw new IllegalArgumentException(""The comment start character and the quoteChar cannot be the same ('"" + commentMarker + ""')"");\n    }\n    if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n        throw new IllegalArgumentException(""The comment start and the escape character cannot be the same ('"" + commentMarker + ""')"");\n    }\n    if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n        throw new IllegalArgumentException(""Quote mode set to NONE but no escape character is set"");\n    }\n    // Validate headers\n    if (headers != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\n        final Set<String> dupCheckSet = new HashSet<>(headers.length);\n        final boolean emptyDuplicatesAllowed = duplicateHeaderMode == DuplicateHeaderMode.ALLOW_EMPTY;\n        for (final String header : headers) {\n            final boolean blank = isBlank(header);\n            // Sanitize all empty headers to the empty string """" when checking duplicates\n            final boolean containsHeader = !dupCheckSet.add(blank ? """" : header);\n            if (containsHeader && !(blank && emptyDuplicatesAllowed)) {\n                throw new IllegalArgumentException(String.format(""The header contains a duplicate name: \""%s\"" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode()."", header, Arrays.toString(headers)));\n            }\n        }\n    }\n}",void validate(),"digraph cfg_validate {\n	""1"" [label=""$stack10 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean containsLineBreak(java.lang.String)>($stack9)""];\n	""2"" [label=""$stack11 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""3"" [label=""$stack12 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""4"" [label=""$stack13 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""5"" [label=""$stack14 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""6"" [label=""$stack15 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""7"" [label=""$stack16 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""8"" [label=""$stack17 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""9"" [label=""$stack18 = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_ALL>""];\n	""10"" [label=""$stack19 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode>""];\n	""11"" [label=""$stack20 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""12"" [label=""$stack21 = lengthof $stack20""];\n	""13"" [label=""$stack22 = new java.util.HashSet""];\n	""14"" [label=""$stack23 = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_EMPTY>""];\n	""15"" [label=""$stack24 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode>""];\n	""16"" [label=""$stack25 = interfaceinvoke dupCheckSet.<java.util.Set: boolean add(java.lang.Object)>($stack31)""];\n	""17"" [label=""$stack26 = newarray (java.lang.Object)[2]""];\n	""18"" [label=""$stack26[0] = header""];\n	""19"" [label=""$stack26[1] = $stack28""];\n	""20"" [label=""$stack27 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""21"" [label=""$stack28 = staticinvoke <java.util.Arrays: java.lang.String toString(java.lang.Object[])>($stack27)""];\n	""22"" [label=""$stack29 = staticinvoke <java.lang.String: java.lang.String format(java.lang.String,java.lang.Object[])>(\""The header contains a duplicate name: \\""%s\\"" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\"", $stack26)""];\n	""23"" [label=""$stack30 = new java.lang.IllegalArgumentException""];\n	""24"" [label=""$stack31 = \""\""""];\n	""25"" [label=""$stack31 = header""];\n	""26"" [label=""$stack32 = <org.apache.commons.csv.QuoteMode: org.apache.commons.csv.QuoteMode NONE>""];\n	""27"" [label=""$stack33 = this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode quoteMode>""];\n	""28"" [label=""$stack34 = new java.lang.IllegalArgumentException""];\n	""29"" [label=""$stack35 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""30"" [label=""$stack36 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""31"" [label=""$stack37 = virtualinvoke $stack36.<java.lang.Character: boolean equals(java.lang.Object)>($stack35)""];\n	""32"" [label=""$stack38 = new java.lang.StringBuilder""];\n	""33"" [label=""$stack39 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""34"" [label=""$stack40 = virtualinvoke $stack38.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""The comment start and the escape character cannot be the same (\'\"")""];\n	""35"" [label=""$stack41 = virtualinvoke $stack40.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack39)""];\n	""36"" [label=""$stack42 = virtualinvoke $stack41.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""\')\"")""];\n	""37"" [label=""$stack43 = virtualinvoke $stack42.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""38"" [label=""$stack44 = new java.lang.IllegalArgumentException""];\n	""39"" [label=""$stack45 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""40"" [label=""$stack46 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""41"" [label=""$stack47 = virtualinvoke $stack46.<java.lang.Character: boolean equals(java.lang.Object)>($stack45)""];\n	""42"" [label=""$stack48 = new java.lang.StringBuilder""];\n	""43"" [label=""$stack49 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""44"" [label=""$stack50 = virtualinvoke $stack48.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""The comment start character and the quoteChar cannot be the same (\'\"")""];\n	""45"" [label=""$stack51 = virtualinvoke $stack50.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack49)""];\n	""46"" [label=""$stack52 = virtualinvoke $stack51.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""\')\"")""];\n	""47"" [label=""$stack53 = virtualinvoke $stack52.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""48"" [label=""$stack54 = new java.lang.IllegalArgumentException""];\n	""49"" [label=""$stack55 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""50"" [label=""$stack56 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""51"" [label=""$stack57 = virtualinvoke $stack55.<java.lang.Character: char charValue()>()""];\n	""52"" [label=""$stack58 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean contains(java.lang.String,char)>($stack56, $stack57)""];\n	""53"" [label=""$stack59 = new java.lang.StringBuilder""];\n	""54"" [label=""$stack60 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker>""];\n	""55"" [label=""$stack61 = virtualinvoke $stack59.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""The comment start character and the delimiter cannot be the same (\'\"")""];\n	""56"" [label=""$stack62 = virtualinvoke $stack61.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack60)""];\n	""57"" [label=""$stack63 = virtualinvoke $stack62.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""\')\"")""];\n	""58"" [label=""$stack64 = virtualinvoke $stack63.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""59"" [label=""$stack65 = new java.lang.IllegalArgumentException""];\n	""60"" [label=""$stack66 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""61"" [label=""$stack67 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""62"" [label=""$stack68 = virtualinvoke $stack66.<java.lang.Character: char charValue()>()""];\n	""63"" [label=""$stack69 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean contains(java.lang.String,char)>($stack67, $stack68)""];\n	""64"" [label=""$stack70 = new java.lang.StringBuilder""];\n	""65"" [label=""$stack71 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter>""];\n	""66"" [label=""$stack72 = virtualinvoke $stack70.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""The escape character and the delimiter cannot be the same (\'\"")""];\n	""67"" [label=""$stack73 = virtualinvoke $stack72.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack71)""];\n	""68"" [label=""$stack74 = virtualinvoke $stack73.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""\')\"")""];\n	""69"" [label=""$stack75 = virtualinvoke $stack74.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""70"" [label=""$stack76 = new java.lang.IllegalArgumentException""];\n	""71"" [label=""$stack77 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""72"" [label=""$stack78 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""73"" [label=""$stack79 = virtualinvoke $stack77.<java.lang.Character: char charValue()>()""];\n	""74"" [label=""$stack80 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean contains(java.lang.String,char)>($stack78, $stack79)""];\n	""75"" [label=""$stack81 = new java.lang.StringBuilder""];\n	""76"" [label=""$stack82 = this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter>""];\n	""77"" [label=""$stack83 = virtualinvoke $stack81.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""The quoteChar character and the delimiter cannot be the same (\'\"")""];\n	""78"" [label=""$stack84 = virtualinvoke $stack83.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack82)""];\n	""79"" [label=""$stack85 = virtualinvoke $stack84.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""\')\"")""];\n	""80"" [label=""$stack86 = virtualinvoke $stack85.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""81"" [label=""$stack87 = new java.lang.IllegalArgumentException""];\n	""82"" [label=""$stack88 = new java.lang.IllegalArgumentException""];\n	""83"" [label=""$stack9 = this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter>""];\n	""84"" [label=""blank = staticinvoke <org.apache.commons.csv.CSVFormat: boolean isBlank(java.lang.String)>(header)""];\n	""85"" [label=""containsHeader = 0""];\n	""86"" [label=""containsHeader = 1""];\n	""87"" [label=""dupCheckSet = $stack22""];\n	""88"" [label=""emptyDuplicatesAllowed = 0""];\n	""89"" [label=""emptyDuplicatesAllowed = 1""];\n	""90"" [label=""goto""];\n	""91"" [label=""goto""];\n	""92"" [label=""goto""];\n	""93"" [label=""goto""];\n	""94"" [label=""header = l3[l5]""];\n	""95"" [label=""if $stack10 == 0""];\n	""96"" [label=""if $stack11 == null""];\n	""97"" [label=""if $stack12 == null""];\n	""98"" [label=""if $stack13 == null""];\n	""99"" [label=""if $stack14 == null""];\n	""100"" [label=""if $stack15 == null""];\n	""101"" [label=""if $stack16 != null""];\n	""102"" [label=""if $stack17 == null""];\n	""103"" [label=""if $stack19 == $stack18""];\n	""104"" [label=""if $stack24 != $stack23""];\n	""105"" [label=""if $stack25 != 0""];\n	""106"" [label=""if $stack33 != $stack32""];\n	""107"" [label=""if $stack37 == 0""];\n	""108"" [label=""if $stack47 == 0""];\n	""109"" [label=""if $stack58 == 0""];\n	""110"" [label=""if $stack69 == 0""];\n	""111"" [label=""if $stack80 == 0""];\n	""112"" [label=""if blank == 0""];\n	""113"" [label=""if blank == 0""];\n	""114"" [label=""if containsHeader == 0""];\n	""115"" [label=""if emptyDuplicatesAllowed != 0""];\n	""116"" [label=""if l5 >= l4""];\n	""117"" [label=""l3 = this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers>""];\n	""118"" [label=""l4 = lengthof l3""];\n	""119"" [label=""l5 = 0""];\n	""120"" [label=""l5 = l5 + 1""];\n	""121"" [label=""return""];\n	""122"" [label=""specialinvoke $stack22.<java.util.HashSet: void <init>(int)>($stack21)""];\n	""123"" [label=""specialinvoke $stack30.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack29)""];\n	""124"" [label=""specialinvoke $stack34.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(\""Quote mode set to NONE but no escape character is set\"")""];\n	""125"" [label=""specialinvoke $stack38.<java.lang.StringBuilder: void <init>()>()""];\n	""126"" [label=""specialinvoke $stack44.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack43)""];\n	""127"" [label=""specialinvoke $stack48.<java.lang.StringBuilder: void <init>()>()""];\n	""128"" [label=""specialinvoke $stack54.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack53)""];\n	""129"" [label=""specialinvoke $stack59.<java.lang.StringBuilder: void <init>()>()""];\n	""130"" [label=""specialinvoke $stack65.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack64)""];\n	""131"" [label=""specialinvoke $stack70.<java.lang.StringBuilder: void <init>()>()""];\n	""132"" [label=""specialinvoke $stack76.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack75)""];\n	""133"" [label=""specialinvoke $stack81.<java.lang.StringBuilder: void <init>()>()""];\n	""134"" [label=""specialinvoke $stack87.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack86)""];\n	""135"" [label=""specialinvoke $stack88.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(\""The delimiter cannot be a line break\"")""];\n	""136"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""137"" [label=""throw $stack30""];\n	""138"" [label=""throw $stack34""];\n	""139"" [label=""throw $stack44""];\n	""140"" [label=""throw $stack54""];\n	""141"" [label=""throw $stack65""];\n	""142"" [label=""throw $stack76""];\n	""143"" [label=""throw $stack87""];\n	""144"" [label=""throw $stack88""];\n	""1"" -> ""95""[label=""cfg_next""];\n	""10"" -> ""9""[label=""cfg_next""];\n	""100"" -> ""30""[label=""cfg_false""];\n	""100"" -> ""7""[label=""cfg_true""];\n	""101"" -> ""27""[label=""cfg_false""];\n	""101"" -> ""8""[label=""cfg_true""];\n	""102"" -> ""10""[label=""cfg_false""];\n	""102"" -> ""121""[label=""cfg_true""];\n	""103"" -> ""121""[label=""cfg_true""];\n	""103"" -> ""13""[label=""cfg_false""];\n	""104"" -> ""88""[label=""cfg_true""];\n	""104"" -> ""89""[label=""cfg_false""];\n	""105"" -> ""85""[label=""cfg_true""];\n	""105"" -> ""86""[label=""cfg_false""];\n	""106"" -> ""28""[label=""cfg_false""];\n	""106"" -> ""8""[label=""cfg_true""];\n	""107"" -> ""38""[label=""cfg_false""];\n	""107"" -> ""7""[label=""cfg_true""];\n	""108"" -> ""48""[label=""cfg_false""];\n	""108"" -> ""6""[label=""cfg_true""];\n	""109"" -> ""5""[label=""cfg_true""];\n	""109"" -> ""59""[label=""cfg_false""];\n	""11"" -> ""12""[label=""cfg_next""];\n	""110"" -> ""4""[label=""cfg_true""];\n	""110"" -> ""70""[label=""cfg_false""];\n	""111"" -> ""3""[label=""cfg_true""];\n	""111"" -> ""81""[label=""cfg_false""];\n	""112"" -> ""24""[label=""cfg_false""];\n	""112"" -> ""25""[label=""cfg_true""];\n	""113"" -> ""115""[label=""cfg_false""];\n	""113"" -> ""23""[label=""cfg_true""];\n	""114"" -> ""113""[label=""cfg_false""];\n	""114"" -> ""120""[label=""cfg_true""];\n	""115"" -> ""120""[label=""cfg_true""];\n	""115"" -> ""23""[label=""cfg_false""];\n	""116"" -> ""121""[label=""cfg_true""];\n	""116"" -> ""94""[label=""cfg_false""];\n	""117"" -> ""118""[label=""cfg_next""];\n	""118"" -> ""119""[label=""cfg_next""];\n	""119"" -> ""116""[label=""cfg_next""];\n	""12"" -> ""122""[label=""cfg_next""];\n	""120"" -> ""93""[label=""cfg_next""];\n	""122"" -> ""87""[label=""cfg_next""];\n	""123"" -> ""137""[label=""cfg_next""];\n	""124"" -> ""138""[label=""cfg_next""];\n	""125"" -> ""34""[label=""cfg_next""];\n	""126"" -> ""139""[label=""cfg_next""];\n	""127"" -> ""44""[label=""cfg_next""];\n	""128"" -> ""140""[label=""cfg_next""];\n	""129"" -> ""55""[label=""cfg_next""];\n	""13"" -> ""11""[label=""cfg_next""];\n	""130"" -> ""141""[label=""cfg_next""];\n	""131"" -> ""66""[label=""cfg_next""];\n	""132"" -> ""142""[label=""cfg_next""];\n	""133"" -> ""77""[label=""cfg_next""];\n	""134"" -> ""143""[label=""cfg_next""];\n	""135"" -> ""144""[label=""cfg_next""];\n	""136"" -> ""83""[label=""cfg_next""];\n	""14"" -> ""104""[label=""cfg_next""];\n	""15"" -> ""14""[label=""cfg_next""];\n	""16"" -> ""105""[label=""cfg_next""];\n	""17"" -> ""18""[label=""cfg_next""];\n	""18"" -> ""20""[label=""cfg_next""];\n	""19"" -> ""22""[label=""cfg_next""];\n	""2"" -> ""96""[label=""cfg_next""];\n	""20"" -> ""21""[label=""cfg_next""];\n	""21"" -> ""19""[label=""cfg_next""];\n	""22"" -> ""123""[label=""cfg_next""];\n	""23"" -> ""17""[label=""cfg_next""];\n	""24"" -> ""91""[label=""cfg_next""];\n	""25"" -> ""16""[label=""cfg_next""];\n	""26"" -> ""106""[label=""cfg_next""];\n	""27"" -> ""26""[label=""cfg_next""];\n	""28"" -> ""124""[label=""cfg_next""];\n	""29"" -> ""31""[label=""cfg_next""];\n	""3"" -> ""97""[label=""cfg_next""];\n	""30"" -> ""29""[label=""cfg_next""];\n	""31"" -> ""107""[label=""cfg_next""];\n	""32"" -> ""125""[label=""cfg_next""];\n	""33"" -> ""35""[label=""cfg_next""];\n	""34"" -> ""33""[label=""cfg_next""];\n	""35"" -> ""36""[label=""cfg_next""];\n	""36"" -> ""37""[label=""cfg_next""];\n	""37"" -> ""126""[label=""cfg_next""];\n	""38"" -> ""32""[label=""cfg_next""];\n	""39"" -> ""41""[label=""cfg_next""];\n	""4"" -> ""98""[label=""cfg_next""];\n	""40"" -> ""39""[label=""cfg_next""];\n	""41"" -> ""108""[label=""cfg_next""];\n	""42"" -> ""127""[label=""cfg_next""];\n	""43"" -> ""45""[label=""cfg_next""];\n	""44"" -> ""43""[label=""cfg_next""];\n	""45"" -> ""46""[label=""cfg_next""];\n	""46"" -> ""47""[label=""cfg_next""];\n	""47"" -> ""128""[label=""cfg_next""];\n	""48"" -> ""42""[label=""cfg_next""];\n	""49"" -> ""51""[label=""cfg_next""];\n	""5"" -> ""99""[label=""cfg_next""];\n	""50"" -> ""49""[label=""cfg_next""];\n	""51"" -> ""52""[label=""cfg_next""];\n	""52"" -> ""109""[label=""cfg_next""];\n	""53"" -> ""129""[label=""cfg_next""];\n	""54"" -> ""56""[label=""cfg_next""];\n	""55"" -> ""54""[label=""cfg_next""];\n	""56"" -> ""57""[label=""cfg_next""];\n	""57"" -> ""58""[label=""cfg_next""];\n	""58"" -> ""130""[label=""cfg_next""];\n	""59"" -> ""53""[label=""cfg_next""];\n	""6"" -> ""100""[label=""cfg_next""];\n	""60"" -> ""62""[label=""cfg_next""];\n	""61"" -> ""60""[label=""cfg_next""];\n	""62"" -> ""63""[label=""cfg_next""];\n	""63"" -> ""110""[label=""cfg_next""];\n	""64"" -> ""131""[label=""cfg_next""];\n	""65"" -> ""67""[label=""cfg_next""];\n	""66"" -> ""65""[label=""cfg_next""];\n	""67"" -> ""68""[label=""cfg_next""];\n	""68"" -> ""69""[label=""cfg_next""];\n	""69"" -> ""132""[label=""cfg_next""];\n	""7"" -> ""101""[label=""cfg_next""];\n	""70"" -> ""64""[label=""cfg_next""];\n	""71"" -> ""73""[label=""cfg_next""];\n	""72"" -> ""71""[label=""cfg_next""];\n	""73"" -> ""74""[label=""cfg_next""];\n	""74"" -> ""111""[label=""cfg_next""];\n	""75"" -> ""133""[label=""cfg_next""];\n	""76"" -> ""78""[label=""cfg_next""];\n	""77"" -> ""76""[label=""cfg_next""];\n	""78"" -> ""79""[label=""cfg_next""];\n	""79"" -> ""80""[label=""cfg_next""];\n	""8"" -> ""102""[label=""cfg_next""];\n	""80"" -> ""134""[label=""cfg_next""];\n	""81"" -> ""75""[label=""cfg_next""];\n	""82"" -> ""135""[label=""cfg_next""];\n	""83"" -> ""1""[label=""cfg_next""];\n	""84"" -> ""112""[label=""cfg_next""];\n	""85"" -> ""114""[label=""cfg_next""];\n	""86"" -> ""92""[label=""cfg_next""];\n	""87"" -> ""15""[label=""cfg_next""];\n	""88"" -> ""117""[label=""cfg_next""];\n	""89"" -> ""90""[label=""cfg_next""];\n	""9"" -> ""103""[label=""cfg_next""];\n	""90"" -> ""117""[label=""cfg_goto""];\n	""91"" -> ""16""[label=""cfg_goto""];\n	""92"" -> ""114""[label=""cfg_goto""];\n	""93"" -> ""116""[label=""cfg_goto""];\n	""94"" -> ""84""[label=""cfg_next""];\n	""95"" -> ""2""[label=""cfg_true""];\n	""95"" -> ""82""[label=""cfg_false""];\n	""96"" -> ""3""[label=""cfg_true""];\n	""96"" -> ""72""[label=""cfg_false""];\n	""97"" -> ""4""[label=""cfg_true""];\n	""97"" -> ""61""[label=""cfg_false""];\n	""98"" -> ""5""[label=""cfg_true""];\n	""98"" -> ""50""[label=""cfg_false""];\n	""99"" -> ""40""[label=""cfg_false""];\n	""99"" -> ""6""[label=""cfg_true""];\n}\n",private 
org.apache.commons.csv.CSVFormat.withAllowDuplicateHeaderNames(),Method,* Builds a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)},@Deprecated\npublic CSVFormat withAllowDuplicateHeaderNames() {\n    return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get();\n},org.apache.commons.csv.CSVFormat withAllowDuplicateHeaderNames(),"digraph cfg_withAllowDuplicateHeaderNames {\n	""1"" [label=""$stack1 = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_ALL>""];\n	""2"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setDuplicateHeaderMode(org.apache.commons.csv.DuplicateHeaderMode)>($stack1)""];\n	""4"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""6"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withAllowDuplicateHeaderNames(boolean),Method,"* Builds a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}",@Deprecated\npublic CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n    final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\n    return builder().setDuplicateHeaderMode(mode).get();\n},org.apache.commons.csv.CSVFormat withAllowDuplicateHeaderNames(boolean),"digraph cfg_withAllowDuplicateHeaderNames {\n	""1"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setDuplicateHeaderMode(org.apache.commons.csv.DuplicateHeaderMode)>(mode)""];\n	""3"" [label=""$stack5 = virtualinvoke $stack4.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""allowDuplicateHeaderNames := @parameter0: boolean""];\n	""5"" [label=""goto""];\n	""6"" [label=""if allowDuplicateHeaderNames == 0""];\n	""7"" [label=""mode = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_ALL>""];\n	""8"" [label=""mode = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_EMPTY>""];\n	""9"" [label=""return $stack5""];\n	""10"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""9""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_goto""];\n	""6"" -> ""7""[label=""cfg_false""];\n	""6"" -> ""8""[label=""cfg_true""];\n	""7"" -> ""5""[label=""cfg_next""];\n	""8"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withAllowMissingColumnNames(),Method,* Builds a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see Builder#setAllowMissingColumnNames(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)},@Deprecated\npublic CSVFormat withAllowMissingColumnNames() {\n    return builder().setAllowMissingColumnNames(true).get();\n},org.apache.commons.csv.CSVFormat withAllowMissingColumnNames(),"digraph cfg_withAllowMissingColumnNames {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setAllowMissingColumnNames(boolean)>(1)""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withAllowMissingColumnNames(boolean),Method,"* Builds a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\n     *                                an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}",@Deprecated\npublic CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n    return builder().setAllowMissingColumnNames(allowMissingColumnNames).get();\n},org.apache.commons.csv.CSVFormat withAllowMissingColumnNames(boolean),"digraph cfg_withAllowMissingColumnNames {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setAllowMissingColumnNames(boolean)>(allowMissingColumnNames)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""allowMissingColumnNames := @parameter0: boolean""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withAutoFlush(boolean),Method,* Builds a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush whether to flush on close.\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)},@Deprecated\npublic CSVFormat withAutoFlush(final boolean autoFlush) {\n    return builder().setAutoFlush(autoFlush).get();\n},org.apache.commons.csv.CSVFormat withAutoFlush(boolean),"digraph cfg_withAutoFlush {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setAutoFlush(boolean)>(autoFlush)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""autoFlush := @parameter0: boolean""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withCommentMarker(char),Method,* Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setCommentMarker(char)},@Deprecated\npublic CSVFormat withCommentMarker(final char commentMarker) {\n    return builder().setCommentMarker(commentMarker).get();\n},org.apache.commons.csv.CSVFormat withCommentMarker(char),"digraph cfg_withCommentMarker {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setCommentMarker(char)>(commentMarker)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""commentMarker := @parameter0: char""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withCommentMarker(Character),Method,"* Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}",@Deprecated\npublic CSVFormat withCommentMarker(final Character commentMarker) {\n    return builder().setCommentMarker(commentMarker).get();\n},org.apache.commons.csv.CSVFormat withCommentMarker(java.lang.Character),"digraph cfg_withCommentMarker {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setCommentMarker(java.lang.Character)>(commentMarker)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""commentMarker := @parameter0: java.lang.Character""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withDelimiter(char),Method,* Builds a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as a delimiter\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setDelimiter(char)},@Deprecated\npublic CSVFormat withDelimiter(final char delimiter) {\n    return builder().setDelimiter(delimiter).get();\n},org.apache.commons.csv.CSVFormat withDelimiter(char),"digraph cfg_withDelimiter {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setDelimiter(char)>(delimiter)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""delimiter := @parameter0: char""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withEscape(char),Method,* Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape the escape character\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setEscape(char)},@Deprecated\npublic CSVFormat withEscape(final char escape) {\n    return builder().setEscape(escape).get();\n},org.apache.commons.csv.CSVFormat withEscape(char),"digraph cfg_withEscape {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setEscape(char)>(escape)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""escape := @parameter0: char""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withEscape(Character),Method,"* Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setEscape(Character)}",@Deprecated\npublic CSVFormat withEscape(final Character escape) {\n    return builder().setEscape(escape).get();\n},org.apache.commons.csv.CSVFormat withEscape(java.lang.Character),"digraph cfg_withEscape {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setEscape(java.lang.Character)>(escape)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""escape := @parameter0: java.lang.Character""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withFirstRecordAsHeader(),Method,@formatter:on,@Deprecated\npublic CSVFormat withFirstRecordAsHeader() {\n    // @formatter:off\n    return builder().setHeader().setSkipHeaderRecord(true).get();\n    // @formatter:on\n},org.apache.commons.csv.CSVFormat withFirstRecordAsHeader(),"digraph cfg_withFirstRecordAsHeader {\n	""1"" [label=""$stack1 = newarray (java.lang.String)[0]""];\n	""2"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeader(java.lang.String[])>($stack1)""];\n	""4"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setSkipHeaderRecord(boolean)>(1)""];\n	""5"" [label=""$stack5 = virtualinvoke $stack4.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""6"" [label=""return $stack5""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""7"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withHeader(Class),Method,"* Builds a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum MyHeader {\n     *     Name, Email, Phone\n     * }\n     * ...\n     * CSVFormat format = aFormat.builder().setHeader(MyHeader.class).get();\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see Builder#setHeader(String...)\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @since 1.3\n     * @deprecated Use {@link Builder#setHeader(Class)}",@Deprecated\npublic CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n    return builder().setHeader(headerEnum).get();\n},org.apache.commons.csv.CSVFormat withHeader(java.lang.Class),"digraph cfg_withHeader {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeader(java.lang.Class)>(headerEnum)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""headerEnum := @parameter0: java.lang.Class""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withHeader(ResultSet),Method,"* Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\n     * input file with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader().get();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader(resultSet).get();\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}",@Deprecated\npublic CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n    return builder().setHeader(resultSet).get();\n},org.apache.commons.csv.CSVFormat withHeader(java.sql.ResultSet),"digraph cfg_withHeader {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeader(java.sql.ResultSet)>(resultSet)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""resultSet := @parameter0: java.sql.ResultSet""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withHeader(ResultSetMetaData),Method,"* Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\n     * input file with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader().get()\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader(resultSetMetaData).get()\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}",@Deprecated\npublic CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\n    return builder().setHeader(resultSetMetaData).get();\n},org.apache.commons.csv.CSVFormat withHeader(java.sql.ResultSetMetaData),"digraph cfg_withHeader {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeader(java.sql.ResultSetMetaData)>(resultSetMetaData)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""resultSetMetaData := @parameter0: java.sql.ResultSetMetaData""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withHeader(String[]),Method,"* Builds a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\n     * with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader().get();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>{@code\n     * CSVFormat format = aFormat.builder().setHeader(""name"", ""email"", ""phone"").get();\n     * }</pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @deprecated Use {@link Builder#setHeader(String...)}",@Deprecated\npublic CSVFormat withHeader(final String... header) {\n    return builder().setHeader(header).get();\n},org.apache.commons.csv.CSVFormat withHeader(java.lang.String[]),"digraph cfg_withHeader {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeader(java.lang.String[])>(header)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""header := @parameter0: java.lang.String[]""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withHeaderComments(Object[]),Method,"* Builds a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\n     * This setting is ignored by the parser.\n     *\n     * <pre>{@code\n     * CSVFormat format = aFormat.builder().setHeaderComments(""Generated by Apache Commons CSV."", Instant.now()).get();\n     * }</pre>\n     *\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}",@Deprecated\npublic CSVFormat withHeaderComments(final Object... headerComments) {\n    return builder().setHeaderComments(headerComments).get();\n},org.apache.commons.csv.CSVFormat withHeaderComments(java.lang.Object[]),"digraph cfg_withHeaderComments {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeaderComments(java.lang.Object[])>(headerComments)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""headerComments := @parameter0: java.lang.Object[]""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withIgnoreEmptyLines(),Method,* Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @see Builder#setIgnoreEmptyLines(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)},@Deprecated\npublic CSVFormat withIgnoreEmptyLines() {\n    return builder().setIgnoreEmptyLines(true).get();\n},org.apache.commons.csv.CSVFormat withIgnoreEmptyLines(),"digraph cfg_withIgnoreEmptyLines {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setIgnoreEmptyLines(boolean)>(1)""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withIgnoreEmptyLines(boolean),Method,"* Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\n     *                         lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}",@Deprecated\npublic CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n    return builder().setIgnoreEmptyLines(ignoreEmptyLines).get();\n},org.apache.commons.csv.CSVFormat withIgnoreEmptyLines(boolean),"digraph cfg_withIgnoreEmptyLines {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setIgnoreEmptyLines(boolean)>(ignoreEmptyLines)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""ignoreEmptyLines := @parameter0: boolean""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withIgnoreHeaderCase(),Method,* Builds a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore the new case header name behavior.\n     * @see Builder#setIgnoreHeaderCase(boolean)\n     * @since 1.3\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)},@Deprecated\npublic CSVFormat withIgnoreHeaderCase() {\n    return builder().setIgnoreHeaderCase(true).get();\n},org.apache.commons.csv.CSVFormat withIgnoreHeaderCase(),"digraph cfg_withIgnoreHeaderCase {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setIgnoreHeaderCase(boolean)>(1)""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withIgnoreHeaderCase(boolean),Method,"* Builds a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}",@Deprecated\npublic CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n    return builder().setIgnoreHeaderCase(ignoreHeaderCase).get();\n},org.apache.commons.csv.CSVFormat withIgnoreHeaderCase(boolean),"digraph cfg_withIgnoreHeaderCase {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setIgnoreHeaderCase(boolean)>(ignoreHeaderCase)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""ignoreHeaderCase := @parameter0: boolean""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withIgnoreSurroundingSpaces(),Method,* Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)},@Deprecated\npublic CSVFormat withIgnoreSurroundingSpaces() {\n    return builder().setIgnoreSurroundingSpaces(true).get();\n},org.apache.commons.csv.CSVFormat withIgnoreSurroundingSpaces(),"digraph cfg_withIgnoreSurroundingSpaces {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setIgnoreSurroundingSpaces(boolean)>(1)""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withIgnoreSurroundingSpaces(boolean),Method,"* Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}",@Deprecated\npublic CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n    return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).get();\n},org.apache.commons.csv.CSVFormat withIgnoreSurroundingSpaces(boolean),"digraph cfg_withIgnoreSurroundingSpaces {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setIgnoreSurroundingSpaces(boolean)>(ignoreSurroundingSpaces)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""ignoreSurroundingSpaces := @parameter0: boolean""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withNullString(String),Method,* Builds a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     * @deprecated Use {@link Builder#setNullString(String)},@Deprecated\npublic CSVFormat withNullString(final String nullString) {\n    return builder().setNullString(nullString).get();\n},org.apache.commons.csv.CSVFormat withNullString(java.lang.String),"digraph cfg_withNullString {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setNullString(java.lang.String)>(nullString)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""nullString := @parameter0: java.lang.String""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withQuote(char),Method,* Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar the quote character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setQuote(char)},@Deprecated\npublic CSVFormat withQuote(final char quoteChar) {\n    return builder().setQuote(quoteChar).get();\n},org.apache.commons.csv.CSVFormat withQuote(char),"digraph cfg_withQuote {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setQuote(char)>(quoteChar)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""quoteChar := @parameter0: char""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withQuote(Character),Method,"* Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar the quote character, use {@code null} to disable.\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setQuote(Character)}",@Deprecated\npublic CSVFormat withQuote(final Character quoteChar) {\n    return builder().setQuote(quoteChar).get();\n},org.apache.commons.csv.CSVFormat withQuote(java.lang.Character),"digraph cfg_withQuote {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setQuote(java.lang.Character)>(quoteChar)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""quoteChar := @parameter0: java.lang.Character""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withQuoteMode(QuoteMode),Method,* Builds a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteMode the quote policy to use for output.\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)},@Deprecated\npublic CSVFormat withQuoteMode(final QuoteMode quoteMode) {\n    return builder().setQuoteMode(quoteMode).get();\n},org.apache.commons.csv.CSVFormat withQuoteMode(org.apache.commons.csv.QuoteMode),"digraph cfg_withQuoteMode {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setQuoteMode(org.apache.commons.csv.QuoteMode)>(quoteMode)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""quoteMode := @parameter0: org.apache.commons.csv.QuoteMode""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withRecordSeparator(char),Method,"* Builds a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r' and\n     * ""\r\n""\n     * </p>\n     *\n     * @param recordSeparator the record separator to use for output.\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}",@Deprecated\npublic CSVFormat withRecordSeparator(final char recordSeparator) {\n    return builder().setRecordSeparator(recordSeparator).get();\n},org.apache.commons.csv.CSVFormat withRecordSeparator(char),"digraph cfg_withRecordSeparator {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setRecordSeparator(char)>(recordSeparator)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""recordSeparator := @parameter0: char""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withRecordSeparator(String),Method,"* Builds a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r' and\n     * ""\r\n""\n     * </p>\n     *\n     * @param recordSeparator the record separator to use for output.\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}",@Deprecated\npublic CSVFormat withRecordSeparator(final String recordSeparator) {\n    return builder().setRecordSeparator(recordSeparator).get();\n},org.apache.commons.csv.CSVFormat withRecordSeparator(java.lang.String),"digraph cfg_withRecordSeparator {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setRecordSeparator(java.lang.String)>(recordSeparator)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""recordSeparator := @parameter0: java.lang.String""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withSkipHeaderRecord(),Method,* Builds a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @see Builder#setHeader(String...)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)},@Deprecated\npublic CSVFormat withSkipHeaderRecord() {\n    return builder().setSkipHeaderRecord(true).get();\n},org.apache.commons.csv.CSVFormat withSkipHeaderRecord(),"digraph cfg_withSkipHeaderRecord {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setSkipHeaderRecord(boolean)>(1)""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withSkipHeaderRecord(boolean),Method,* Builds a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord whether to skip the header record.\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see Builder#setHeader(String...)\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)},@Deprecated\npublic CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n    return builder().setSkipHeaderRecord(skipHeaderRecord).get();\n},org.apache.commons.csv.CSVFormat withSkipHeaderRecord(boolean),"digraph cfg_withSkipHeaderRecord {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setSkipHeaderRecord(boolean)>(skipHeaderRecord)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack4""];\n	""5"" [label=""skipHeaderRecord := @parameter0: boolean""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""5""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withSystemRecordSeparator(),Method,"* Builds a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\n     * and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r' and\n     * ""\r\n""\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}",@Deprecated\npublic CSVFormat withSystemRecordSeparator() {\n    return builder().setRecordSeparator(System.lineSeparator()).get();\n},org.apache.commons.csv.CSVFormat withSystemRecordSeparator(),"digraph cfg_withSystemRecordSeparator {\n	""1"" [label=""$stack1 = staticinvoke <java.lang.System: java.lang.String lineSeparator()>()""];\n	""2"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setRecordSeparator(java.lang.String)>($stack1)""];\n	""4"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""6"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withTrailingDelimiter(),Method,* Builds a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)},@Deprecated\npublic CSVFormat withTrailingDelimiter() {\n    return builder().setTrailingDelimiter(true).get();\n},org.apache.commons.csv.CSVFormat withTrailingDelimiter(),"digraph cfg_withTrailingDelimiter {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setTrailingDelimiter(boolean)>(1)""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withTrailingDelimiter(boolean),Method,* Builds a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter whether to add a trailing delimiter.\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)},@Deprecated\npublic CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n    return builder().setTrailingDelimiter(trailingDelimiter).get();\n},org.apache.commons.csv.CSVFormat withTrailingDelimiter(boolean),"digraph cfg_withTrailingDelimiter {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setTrailingDelimiter(boolean)>(trailingDelimiter)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack4""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""6"" [label=""trailingDelimiter := @parameter0: boolean""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withTrim(),Method,* Builds a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)},@Deprecated\npublic CSVFormat withTrim() {\n    return builder().setTrim(true).get();\n},org.apache.commons.csv.CSVFormat withTrim(),"digraph cfg_withTrim {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setTrim(boolean)>(1)""];\n	""3"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.withTrim(boolean),Method,* Builds a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\n     *\n     * @param trim whether to trim leading and trailing blanks.\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrim(boolean)},@Deprecated\npublic CSVFormat withTrim(final boolean trim) {\n    return builder().setTrim(trim).get();\n},org.apache.commons.csv.CSVFormat withTrim(boolean),"digraph cfg_withTrim {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.CSVFormat$Builder builder()>()""];\n	""2"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setTrim(boolean)>(trim)""];\n	""3"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""4"" [label=""return $stack4""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""6"" [label=""trim := @parameter0: boolean""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat.<init>(Builder),Constructor,No Comment,private CSVFormat(final Builder builder) {\n    this.allowMissingColumnNames = builder.allowMissingColumnNames;\n    this.autoFlush = builder.autoFlush;\n    this.commentMarker = builder.commentMarker;\n    this.delimiter = builder.delimiter;\n    this.duplicateHeaderMode = builder.duplicateHeaderMode;\n    this.escapeCharacter = builder.escapeCharacter;\n    this.headerComments = builder.headerComments;\n    this.headers = builder.headers;\n    this.ignoreEmptyLines = builder.ignoreEmptyLines;\n    this.ignoreHeaderCase = builder.ignoreHeaderCase;\n    this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;\n    this.lenientEof = builder.lenientEof;\n    this.maxRows = builder.maxRows;\n    this.nullString = builder.nullString;\n    this.quoteCharacter = builder.quoteCharacter;\n    this.quoteMode = builder.quoteMode;\n    this.quotedNullString = builder.quotedNullString;\n    this.recordSeparator = builder.recordSeparator;\n    this.skipHeaderRecord = builder.skipHeaderRecord;\n    this.trailingData = builder.trailingData;\n    this.trailingDelimiter = builder.trailingDelimiter;\n    this.trim = builder.trim;\n    validate();\n},void <init>(org.apache.commons.csv.CSVFormat$Builder),"digraph cfg_init {\n	""1"" [label=""$stack10 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$3400(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""2"" [label=""$stack11 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$3500(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""3"" [label=""$stack12 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$3600(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""4"" [label=""$stack13 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$3700(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""5"" [label=""$stack14 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: long access$3800(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""6"" [label=""$stack15 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: java.lang.String access$3900(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""7"" [label=""$stack16 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: java.lang.Character access$4000(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""8"" [label=""$stack17 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.QuoteMode access$4100(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""9"" [label=""$stack18 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: java.lang.String access$4200(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""10"" [label=""$stack19 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: java.lang.String access$4300(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""11"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$2600(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""12"" [label=""$stack20 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$4400(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""13"" [label=""$stack21 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$4500(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""14"" [label=""$stack22 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$4600(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""15"" [label=""$stack23 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$4700(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""16"" [label=""$stack3 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: boolean access$2700(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""17"" [label=""$stack4 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: java.lang.Character access$2800(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""18"" [label=""$stack5 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: java.lang.String access$2900(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""19"" [label=""$stack6 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.DuplicateHeaderMode access$3000(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""20"" [label=""$stack7 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: java.lang.Character access$3100(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""21"" [label=""$stack8 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: java.lang.String[] access$3200(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""22"" [label=""$stack9 = staticinvoke <org.apache.commons.csv.CSVFormat$Builder: java.lang.String[] access$3300(org.apache.commons.csv.CSVFormat$Builder)>(builder)""];\n	""23"" [label=""builder := @parameter0: org.apache.commons.csv.CSVFormat$Builder""];\n	""24"" [label=""return""];\n	""25"" [label=""specialinvoke this.<java.lang.Object: void <init>()>()""];\n	""26"" [label=""specialinvoke this.<org.apache.commons.csv.CSVFormat: void validate()>()""];\n	""27"" [label=""this := @this: org.apache.commons.csv.CSVFormat""];\n	""28"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean allowMissingColumnNames> = $stack2""];\n	""29"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean autoFlush> = $stack3""];\n	""30"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean ignoreEmptyLines> = $stack10""];\n	""31"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean ignoreHeaderCase> = $stack11""];\n	""32"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean ignoreSurroundingSpaces> = $stack12""];\n	""33"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean lenientEof> = $stack13""];\n	""34"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean skipHeaderRecord> = $stack20""];\n	""35"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean trailingData> = $stack21""];\n	""36"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean trailingDelimiter> = $stack22""];\n	""37"" [label=""this.<org.apache.commons.csv.CSVFormat: boolean trim> = $stack23""];\n	""38"" [label=""this.<org.apache.commons.csv.CSVFormat: java.lang.Character commentMarker> = $stack4""];\n	""39"" [label=""this.<org.apache.commons.csv.CSVFormat: java.lang.Character escapeCharacter> = $stack7""];\n	""40"" [label=""this.<org.apache.commons.csv.CSVFormat: java.lang.Character quoteCharacter> = $stack16""];\n	""41"" [label=""this.<org.apache.commons.csv.CSVFormat: java.lang.String delimiter> = $stack5""];\n	""42"" [label=""this.<org.apache.commons.csv.CSVFormat: java.lang.String nullString> = $stack15""];\n	""43"" [label=""this.<org.apache.commons.csv.CSVFormat: java.lang.String quotedNullString> = $stack18""];\n	""44"" [label=""this.<org.apache.commons.csv.CSVFormat: java.lang.String recordSeparator> = $stack19""];\n	""45"" [label=""this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headerComments> = $stack8""];\n	""46"" [label=""this.<org.apache.commons.csv.CSVFormat: java.lang.String[] headers> = $stack9""];\n	""47"" [label=""this.<org.apache.commons.csv.CSVFormat: long maxRows> = $stack14""];\n	""48"" [label=""this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode> = $stack6""];\n	""49"" [label=""this.<org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode quoteMode> = $stack17""];\n	""1"" -> ""30""[label=""cfg_next""];\n	""10"" -> ""44""[label=""cfg_next""];\n	""11"" -> ""28""[label=""cfg_next""];\n	""12"" -> ""34""[label=""cfg_next""];\n	""13"" -> ""35""[label=""cfg_next""];\n	""14"" -> ""36""[label=""cfg_next""];\n	""15"" -> ""37""[label=""cfg_next""];\n	""16"" -> ""29""[label=""cfg_next""];\n	""17"" -> ""38""[label=""cfg_next""];\n	""18"" -> ""41""[label=""cfg_next""];\n	""19"" -> ""48""[label=""cfg_next""];\n	""2"" -> ""31""[label=""cfg_next""];\n	""20"" -> ""39""[label=""cfg_next""];\n	""21"" -> ""45""[label=""cfg_next""];\n	""22"" -> ""46""[label=""cfg_next""];\n	""23"" -> ""25""[label=""cfg_next""];\n	""25"" -> ""11""[label=""cfg_next""];\n	""26"" -> ""24""[label=""cfg_next""];\n	""27"" -> ""23""[label=""cfg_next""];\n	""28"" -> ""16""[label=""cfg_next""];\n	""29"" -> ""17""[label=""cfg_next""];\n	""3"" -> ""32""[label=""cfg_next""];\n	""30"" -> ""2""[label=""cfg_next""];\n	""31"" -> ""3""[label=""cfg_next""];\n	""32"" -> ""4""[label=""cfg_next""];\n	""33"" -> ""5""[label=""cfg_next""];\n	""34"" -> ""13""[label=""cfg_next""];\n	""35"" -> ""14""[label=""cfg_next""];\n	""36"" -> ""15""[label=""cfg_next""];\n	""37"" -> ""26""[label=""cfg_next""];\n	""38"" -> ""18""[label=""cfg_next""];\n	""39"" -> ""21""[label=""cfg_next""];\n	""4"" -> ""33""[label=""cfg_next""];\n	""40"" -> ""8""[label=""cfg_next""];\n	""41"" -> ""19""[label=""cfg_next""];\n	""42"" -> ""7""[label=""cfg_next""];\n	""43"" -> ""10""[label=""cfg_next""];\n	""44"" -> ""12""[label=""cfg_next""];\n	""45"" -> ""22""[label=""cfg_next""];\n	""46"" -> ""1""[label=""cfg_next""];\n	""47"" -> ""6""[label=""cfg_next""];\n	""48"" -> ""20""[label=""cfg_next""];\n	""49"" -> ""9""[label=""cfg_next""];\n	""5"" -> ""47""[label=""cfg_next""];\n	""6"" -> ""42""[label=""cfg_next""];\n	""7"" -> ""40""[label=""cfg_next""];\n	""8"" -> ""49""[label=""cfg_next""];\n	""9"" -> ""43""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVFormat$Builder.create(),Method,"* Creates a new default builder, as for {@link #RFC4180} but allowing empty lines.\n         *\n         * <p>\n         * The {@link Builder} settings are:\n         * </p>\n         * <ul>\n         * <li>{@link Builder#setDelimiter(char) setDelimiter}{@code (',')}</li>\n         * <li>{@link Builder#setQuote(char) setQuote}{@code ('""')}</li>\n         * <li>{@link Builder#setRecordSeparator(String) setRecordSeparator}{@code (""\r\n"")}</li>\n         * <li>{@link Builder#setIgnoreEmptyLines(boolean) setIgnoreEmptyLines}{@code (true)}</li>\n         * <li>{@link Builder#setDuplicateHeaderMode(DuplicateHeaderMode) setDuplicateHeaderMode}{@code (DuplicateHeaderMode.ALLOW_ALL)}</li>\n         * <li>All other values take their Java defaults, {@code false} for booleans, {@code null} for object references.</li>\n         * </ul>\n         *\n         * @see Predefined#Default\n         * @see DuplicateHeaderMode#ALLOW_ALL\n         *\n         * @return a copy of the builder",public static Builder create() {\n    // @formatter:off\n    return new Builder().setDelimiter(Constants.COMMA).setQuote(Constants.DOUBLE_QUOTE_CHAR).setRecordSeparator(Constants.CRLF).setIgnoreEmptyLines(true).setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL);\n    // @formatter:on\n},org.apache.commons.csv.CSVFormat$Builder create(),"digraph cfg_create {\n	""1"" [label=""$stack0 = new org.apache.commons.csv.CSVFormat$Builder""];\n	""2"" [label=""$stack1 = <org.apache.commons.csv.Constants: java.lang.Character DOUBLE_QUOTE_CHAR>""];\n	""3"" [label=""$stack2 = virtualinvoke $stack0.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setDelimiter(java.lang.String)>(\"",\"")""];\n	""4"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setQuote(java.lang.Character)>($stack1)""];\n	""5"" [label=""$stack4 = virtualinvoke $stack3.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setRecordSeparator(java.lang.String)>(\""\r\n\"")""];\n	""6"" [label=""$stack5 = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_ALL>""];\n	""7"" [label=""$stack6 = virtualinvoke $stack4.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setIgnoreEmptyLines(boolean)>(1)""];\n	""8"" [label=""$stack7 = virtualinvoke $stack6.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setDuplicateHeaderMode(org.apache.commons.csv.DuplicateHeaderMode)>($stack5)""];\n	""9"" [label=""return $stack7""];\n	""10"" [label=""specialinvoke $stack0.<org.apache.commons.csv.CSVFormat$Builder: void <init>()>()""];\n	""1"" -> ""10""[label=""cfg_next""];\n	""10"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n	""8"" -> ""9""[label=""cfg_next""];\n}\n","public , static "
org.apache.commons.csv.CSVFormat$Builder.create(CSVFormat),Method,* Creates a new builder from the given format.\n         *\n         * @param csvFormat the source format.\n         * @return a new builder.,public static Builder create(final CSVFormat csvFormat) {\n    return new Builder(csvFormat);\n},org.apache.commons.csv.CSVFormat$Builder create(org.apache.commons.csv.CSVFormat),"digraph cfg_create {\n	""1"" [label=""$stack1 = new org.apache.commons.csv.CSVFormat$Builder""];\n	""2"" [label=""csvFormat := @parameter0: org.apache.commons.csv.CSVFormat""];\n	""3"" [label=""return $stack1""];\n	""4"" [label=""specialinvoke $stack1.<org.apache.commons.csv.CSVFormat$Builder: void <init>(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n}\n","public , static "
org.apache.commons.csv.CSVFormat$Builder.build(),Method,* Builds a new CSVFormat instance.\n         *\n         * @return a new CSVFormat instance.\n         * @deprecated Use {@link #get()}.,@Deprecated\npublic CSVFormat build() {\n    return get();\n},org.apache.commons.csv.CSVFormat build(),"digraph cfg_build {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat get()>()""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.get(),Method,* Builds a new CSVFormat instance.\n         *\n         * @return a new CSVFormat instance.\n         * @since 1.13.0,@Override\npublic CSVFormat get() {\n    return new CSVFormat(this);\n},org.apache.commons.csv.CSVFormat get(),"digraph cfg_get {\n	""1"" [label=""$stack1 = new org.apache.commons.csv.CSVFormat""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""specialinvoke $stack1.<org.apache.commons.csv.CSVFormat: void <init>(org.apache.commons.csv.CSVFormat$Builder,org.apache.commons.csv.CSVFormat$1)>(this, null)""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setAllowDuplicateHeaderNames(boolean),Method,"* Sets the duplicate header names behavior, true to allow, false to disallow.\n         *\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n         * @return This instance.\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.",@Deprecated\npublic Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n    setDuplicateHeaderMode(allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY);\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setAllowDuplicateHeaderNames(boolean),"digraph cfg_setAllowDuplicateHeaderNames {\n	""1"" [label=""$stack2 = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_ALL>""];\n	""2"" [label=""$stack2 = <org.apache.commons.csv.DuplicateHeaderMode: org.apache.commons.csv.DuplicateHeaderMode ALLOW_EMPTY>""];\n	""3"" [label=""allowDuplicateHeaderNames := @parameter0: boolean""];\n	""4"" [label=""goto""];\n	""5"" [label=""if allowDuplicateHeaderNames == 0""];\n	""6"" [label=""return this""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""8"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setDuplicateHeaderMode(org.apache.commons.csv.DuplicateHeaderMode)>($stack2)""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""8""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""8""[label=""cfg_goto""];\n	""5"" -> ""1""[label=""cfg_false""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""7"" -> ""3""[label=""cfg_next""];\n	""8"" -> ""6""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setAllowMissingColumnNames(boolean),Method,"* Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\n         * {@link IllegalArgumentException} to be thrown.\n         *\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\n         *                                cause an {@link IllegalArgumentException} to be thrown.\n         * @return This instance.",public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n    this.allowMissingColumnNames = allowMissingColumnNames;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setAllowMissingColumnNames(boolean),"digraph cfg_setAllowMissingColumnNames {\n	""1"" [label=""allowMissingColumnNames := @parameter0: boolean""];\n	""2"" [label=""return this""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean allowMissingColumnNames> = allowMissingColumnNames""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setAutoFlush(boolean),Method,* Sets whether to flush on close.\n         *\n         * @param autoFlush whether to flush on close.\n         * @return This instance.,public Builder setAutoFlush(final boolean autoFlush) {\n    this.autoFlush = autoFlush;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setAutoFlush(boolean),"digraph cfg_setAutoFlush {\n	""1"" [label=""autoFlush := @parameter0: boolean""];\n	""2"" [label=""return this""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean autoFlush> = autoFlush""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setCommentMarker(char),Method,"* Sets the comment marker character, use {@code null} to disable comments.\n         * <p>\n         * The comment start character is only recognized at the start of a line.\n         * </p>\n         * <p>\n         * Comments are printed first, before headers.\n         * </p>\n         * <p>\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.\n         * </p>\n         * <p>\n         * If the comment marker is not set, then the header comments are ignored.\n         * </p>\n         * <p>\n         * For example:\n         * </p>\n         *\n         * <pre>\n         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));\n         * </pre>\n         * <p>\n         * writes:\n         * </p>\n         *\n         * <pre>\n         * # Generated by Apache Commons CSV.\n         * # 1970-01-01T00:00:00Z\n         * </pre>\n         *\n         * @param commentMarker the comment start marker, use {@code null} to disable.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break",public Builder setCommentMarker(final char commentMarker) {\n    setCommentMarker(Character.valueOf(commentMarker));\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setCommentMarker(char),"digraph cfg_setCommentMarker {\n	""1"" [label=""$stack2 = staticinvoke <java.lang.Character: java.lang.Character valueOf(char)>(commentMarker)""];\n	""2"" [label=""commentMarker := @parameter0: char""];\n	""3"" [label=""return this""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""5"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setCommentMarker(java.lang.Character)>($stack2)""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setCommentMarker(Character),Method,"* Sets the comment marker character, use {@code null} to disable comments.\n         * <p>\n         * The comment start character is only recognized at the start of a line.\n         * </p>\n         * <p>\n         * Comments are printed first, before headers.\n         * </p>\n         * <p>\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.\n         * </p>\n         * <p>\n         * If the comment marker is not set, then the header comments are ignored.\n         * </p>\n         * <p>\n         * For example:\n         * </p>\n         *\n         * <pre>\n         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));\n         * </pre>\n         * <p>\n         * writes:\n         * </p>\n         *\n         * <pre>\n         * # Generated by Apache Commons CSV.\n         * # 1970-01-01T00:00:00Z\n         * </pre>\n         *\n         * @param commentMarker the comment start marker, use {@code null} to disable.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break","public Builder setCommentMarker(final Character commentMarker) {\n    if (isLineBreak(commentMarker)) {\n        throw new IllegalArgumentException(""The comment start marker character cannot be a line break"");\n    }\n    this.commentMarker = commentMarker;\n    return this;\n}",org.apache.commons.csv.CSVFormat$Builder setCommentMarker(java.lang.Character),"digraph cfg_setCommentMarker {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$2300(java.lang.Character)>(commentMarker)""];\n	""2"" [label=""$stack3 = new java.lang.IllegalArgumentException""];\n	""3"" [label=""commentMarker := @parameter0: java.lang.Character""];\n	""4"" [label=""if $stack2 == 0""];\n	""5"" [label=""return this""];\n	""6"" [label=""specialinvoke $stack3.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(\""The comment start marker character cannot be a line break\"")""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""8"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.Character commentMarker> = commentMarker""];\n	""9"" [label=""throw $stack3""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_false""];\n	""4"" -> ""8""[label=""cfg_true""];\n	""6"" -> ""9""[label=""cfg_next""];\n	""7"" -> ""3""[label=""cfg_next""];\n	""8"" -> ""5""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setDelimiter(char),Method,* Sets the delimiter character.\n         *\n         * @param delimiter the delimiter character.\n         * @return This instance.,public Builder setDelimiter(final char delimiter) {\n    return setDelimiter(String.valueOf(delimiter));\n},org.apache.commons.csv.CSVFormat$Builder setDelimiter(char),"digraph cfg_setDelimiter {\n	""1"" [label=""$stack2 = staticinvoke <java.lang.String: java.lang.String valueOf(char)>(delimiter)""];\n	""2"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setDelimiter(java.lang.String)>($stack2)""];\n	""3"" [label=""delimiter := @parameter0: char""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setDelimiter(String),Method,* Sets the delimiter character.\n         *\n         * @param delimiter the delimiter character.\n         * @return This instance.,"public Builder setDelimiter(final String delimiter) {\n    if (containsLineBreak(delimiter)) {\n        throw new IllegalArgumentException(""The delimiter cannot be a line break"");\n    }\n    if (delimiter.isEmpty()) {\n        throw new IllegalArgumentException(""The delimiter cannot be empty"");\n    }\n    this.delimiter = delimiter;\n    return this;\n}",org.apache.commons.csv.CSVFormat$Builder setDelimiter(java.lang.String),"digraph cfg_setDelimiter {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$2400(java.lang.String)>(delimiter)""];\n	""2"" [label=""$stack3 = virtualinvoke delimiter.<java.lang.String: boolean isEmpty()>()""];\n	""3"" [label=""$stack4 = new java.lang.IllegalArgumentException""];\n	""4"" [label=""$stack5 = new java.lang.IllegalArgumentException""];\n	""5"" [label=""delimiter := @parameter0: java.lang.String""];\n	""6"" [label=""if $stack2 == 0""];\n	""7"" [label=""if $stack3 == 0""];\n	""8"" [label=""return this""];\n	""9"" [label=""specialinvoke $stack4.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(\""The delimiter cannot be empty\"")""];\n	""10"" [label=""specialinvoke $stack5.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(\""The delimiter cannot be a line break\"")""];\n	""11"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""12"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String delimiter> = delimiter""];\n	""13"" [label=""throw $stack4""];\n	""14"" [label=""throw $stack5""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""10"" -> ""14""[label=""cfg_next""];\n	""11"" -> ""5""[label=""cfg_next""];\n	""12"" -> ""8""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""9""[label=""cfg_next""];\n	""4"" -> ""10""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""6"" -> ""4""[label=""cfg_false""];\n	""7"" -> ""12""[label=""cfg_true""];\n	""7"" -> ""3""[label=""cfg_false""];\n	""9"" -> ""13""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setDuplicateHeaderMode(DuplicateHeaderMode),Method,* Sets the duplicate header names behavior.\n         *\n         * @param duplicateHeaderMode the duplicate header names behavior\n         * @return This instance.\n         * @since 1.10.0,"public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\n    this.duplicateHeaderMode = Objects.requireNonNull(duplicateHeaderMode, ""duplicateHeaderMode"");\n    return this;\n}",org.apache.commons.csv.CSVFormat$Builder setDuplicateHeaderMode(org.apache.commons.csv.DuplicateHeaderMode),"digraph cfg_setDuplicateHeaderMode {\n	""1"" [label=""$stack2 = staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(duplicateHeaderMode, \""duplicateHeaderMode\"")""];\n	""2"" [label=""$stack3 = (org.apache.commons.csv.DuplicateHeaderMode) $stack2""];\n	""3"" [label=""duplicateHeaderMode := @parameter0: org.apache.commons.csv.DuplicateHeaderMode""];\n	""4"" [label=""return this""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""6"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode> = $stack3""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setEscape(char),Method,* Sets the escape character.\n         *\n         * @param escapeCharacter the escape character.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break,public Builder setEscape(final char escapeCharacter) {\n    setEscape(Character.valueOf(escapeCharacter));\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setEscape(char),"digraph cfg_setEscape {\n	""1"" [label=""$stack2 = staticinvoke <java.lang.Character: java.lang.Character valueOf(char)>(escapeCharacter)""];\n	""2"" [label=""escapeCharacter := @parameter0: char""];\n	""3"" [label=""return this""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""5"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setEscape(java.lang.Character)>($stack2)""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setEscape(Character),Method,* Sets the escape character.\n         *\n         * @param escapeCharacter the escape character.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break,"public Builder setEscape(final Character escapeCharacter) {\n    if (isLineBreak(escapeCharacter)) {\n        throw new IllegalArgumentException(""The escape character cannot be a line break"");\n    }\n    this.escapeCharacter = escapeCharacter;\n    return this;\n}",org.apache.commons.csv.CSVFormat$Builder setEscape(java.lang.Character),"digraph cfg_setEscape {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$2300(java.lang.Character)>(escapeCharacter)""];\n	""2"" [label=""$stack3 = new java.lang.IllegalArgumentException""];\n	""3"" [label=""escapeCharacter := @parameter0: java.lang.Character""];\n	""4"" [label=""if $stack2 == 0""];\n	""5"" [label=""return this""];\n	""6"" [label=""specialinvoke $stack3.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(\""The escape character cannot be a line break\"")""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""8"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.Character escapeCharacter> = escapeCharacter""];\n	""9"" [label=""throw $stack3""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_false""];\n	""4"" -> ""8""[label=""cfg_true""];\n	""6"" -> ""9""[label=""cfg_next""];\n	""7"" -> ""3""[label=""cfg_next""];\n	""8"" -> ""5""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setHeader(Class),Method,"* Sets the header defined by the given {@link Enum} class.\n         *\n         * <p>\n         * Example:\n         * </p>\n         *\n         * <pre>\n         * public enum HeaderEnum {\n         *     Name, Email, Phone\n         * }\n         *\n         * Builder builder = builder.setHeader(HeaderEnum.class);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n         * @return This instance.","public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\n    String[] header = null;\n    if (headerEnum != null) {\n        final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n        header = new String[enumValues.length];\n        Arrays.setAll(header, i -> enumValues[i].name());\n    }\n    return setHeader(header);\n}",org.apache.commons.csv.CSVFormat$Builder setHeader(java.lang.Class),"digraph cfg_setHeader {\n	""1"" [label=""$stack4 = virtualinvoke this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeader(java.lang.String[])>(header)""];\n	""2"" [label=""$stack5 = virtualinvoke headerEnum.<java.lang.Class: java.lang.Object[] getEnumConstants()>()""];\n	""3"" [label=""$stack6 = lengthof enumValues""];\n	""4"" [label=""$stack7 = dynamicinvoke \""apply\"" <java.util.function.IntFunction (java.lang.Enum[])>(enumValues) <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>(methodtype: java.lang.Object __METHODTYPE__(int), methodhandle: \""REF_INVOKE_STATIC\"" <org.apache.commons.csv.CSVFormat$Builder: java.lang.String lambda$setHeader$0(java.lang.Enum[],int)>, methodtype: java.lang.String __METHODTYPE__(int))""];\n	""5"" [label=""enumValues = (java.lang.Enum[]) $stack5""];\n	""6"" [label=""header = newarray (java.lang.String)[$stack6]""];\n	""7"" [label=""header = null""];\n	""8"" [label=""headerEnum := @parameter0: java.lang.Class""];\n	""9"" [label=""if headerEnum == null""];\n	""10"" [label=""return $stack4""];\n	""11"" [label=""staticinvoke <java.util.Arrays: void setAll(java.lang.Object[],java.util.function.IntFunction)>(header, $stack7)""];\n	""12"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""1"" -> ""10""[label=""cfg_next""];\n	""11"" -> ""1""[label=""cfg_next""];\n	""12"" -> ""8""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""6""[label=""cfg_next""];\n	""4"" -> ""11""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n	""7"" -> ""9""[label=""cfg_next""];\n	""8"" -> ""7""[label=""cfg_next""];\n	""9"" -> ""1""[label=""cfg_true""];\n	""9"" -> ""2""[label=""cfg_false""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setHeader(ResultSet),Method,"* Sets the header from the result set metadata. The header can be parsed automatically from the input file with:\n         *\n         * <pre>\n         * builder.setHeader();\n         * </pre>\n         *\n         * or specified manually with:\n         *\n         * <pre>\n         * builder.setHeader(resultSet);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n         * @return This instance.\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.",public Builder setHeader(final ResultSet resultSet) throws SQLException {\n    return setHeader(resultSet != null ? resultSet.getMetaData() : null);\n},org.apache.commons.csv.CSVFormat$Builder setHeader(java.sql.ResultSet),"digraph cfg_setHeader {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeader(java.sql.ResultSetMetaData)>($stack3)""];\n	""2"" [label=""$stack3 = interfaceinvoke resultSet.<java.sql.ResultSet: java.sql.ResultSetMetaData getMetaData()>()""];\n	""3"" [label=""$stack3 = null""];\n	""4"" [label=""goto""];\n	""5"" [label=""if resultSet == null""];\n	""6"" [label=""resultSet := @parameter0: java.sql.ResultSet""];\n	""7"" [label=""return $stack2""];\n	""8"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""1"" -> ""7""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_goto""];\n	""5"" -> ""2""[label=""cfg_false""];\n	""5"" -> ""3""[label=""cfg_true""];\n	""6"" -> ""5""[label=""cfg_next""];\n	""8"" -> ""6""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setHeader(ResultSetMetaData),Method,"* Sets the header from the result set metadata. The header can be parsed automatically from the input file with:\n         *\n         * <pre>\n         * builder.setHeader();\n         * </pre>\n         *\n         * or specified manually with:\n         *\n         * <pre>\n         * builder.setHeader(resultSetMetaData);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n         * @return This instance.\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.",public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\n    String[] labels = null;\n    if (resultSetMetaData != null) {\n        final int columnCount = resultSetMetaData.getColumnCount();\n        labels = new String[columnCount];\n        for (int i = 0; i < columnCount; i++) {\n            labels[i] = resultSetMetaData.getColumnLabel(i + 1);\n        }\n    }\n    return setHeader(labels);\n},org.apache.commons.csv.CSVFormat$Builder setHeader(java.sql.ResultSetMetaData),"digraph cfg_setHeader {\n	""1"" [label=""$stack5 = virtualinvoke this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setHeader(java.lang.String[])>(labels)""];\n	""2"" [label=""$stack6 = i + 1""];\n	""3"" [label=""$stack7 = interfaceinvoke resultSetMetaData.<java.sql.ResultSetMetaData: java.lang.String getColumnLabel(int)>($stack6)""];\n	""4"" [label=""columnCount = interfaceinvoke resultSetMetaData.<java.sql.ResultSetMetaData: int getColumnCount()>()""];\n	""5"" [label=""goto""];\n	""6"" [label=""i = 0""];\n	""7"" [label=""i = i + 1""];\n	""8"" [label=""if i >= columnCount""];\n	""9"" [label=""if resultSetMetaData == null""];\n	""10"" [label=""labels = newarray (java.lang.String)[columnCount]""];\n	""11"" [label=""labels = null""];\n	""12"" [label=""labels[i] = $stack7""];\n	""13"" [label=""resultSetMetaData := @parameter0: java.sql.ResultSetMetaData""];\n	""14"" [label=""return $stack5""];\n	""15"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""1"" -> ""14""[label=""cfg_next""];\n	""10"" -> ""6""[label=""cfg_next""];\n	""11"" -> ""9""[label=""cfg_next""];\n	""12"" -> ""7""[label=""cfg_next""];\n	""13"" -> ""11""[label=""cfg_next""];\n	""15"" -> ""13""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""12""[label=""cfg_next""];\n	""4"" -> ""10""[label=""cfg_next""];\n	""5"" -> ""8""[label=""cfg_goto""];\n	""6"" -> ""8""[label=""cfg_next""];\n	""7"" -> ""5""[label=""cfg_next""];\n	""8"" -> ""1""[label=""cfg_true""];\n	""8"" -> ""2""[label=""cfg_false""];\n	""9"" -> ""1""[label=""cfg_true""];\n	""9"" -> ""4""[label=""cfg_false""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setHeader(String[]),Method,"* Sets the header to the given values. The header can be parsed automatically from the input file with:\n         *\n         * <pre>\n         * builder.setHeader();\n         * </pre>\n         *\n         * or specified manually with:\n         *\n         * <pre>{@code\n         * builder.setHeader(""name"", ""email"", ""phone"");\n         * }</pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         * <p>\n         * This method keeps a copy of the input array.\n         * </p>\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n         * @return This instance.",public Builder setHeader(final String... header) {\n    this.headers = CSVFormat.clone(header);\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setHeader(java.lang.String[]),"digraph cfg_setHeader {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.Object[] clone(java.lang.Object[])>(header)""];\n	""2"" [label=""$stack3 = (java.lang.String[]) $stack2""];\n	""3"" [label=""header := @parameter0: java.lang.String[]""];\n	""4"" [label=""return this""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""6"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String[] headers> = $stack3""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setHeaderComments(Object[]),Method,"* Sets the header comments to write before the CSV data.\n         * <p>\n         * This setting is ignored by the parser.\n         * </p>\n         * <p>\n         * Comments are printed first, before headers.\n         * </p>\n         * <p>\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.\n         * </p>\n         * <p>\n         * If the comment marker is not set, then the header comments are ignored.\n         * </p>\n         * <p>\n         * For example:\n         * </p>\n         *\n         * <pre>\n         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0));\n         * </pre>\n         * <p>\n         * writes:\n         * </p>\n         *\n         * <pre>\n         * # Generated by Apache Commons CSV.\n         * # 1970-01-01T00:00:00Z\n         * </pre>\n         * <p>\n         * This method keeps a copy of the input array.\n         * </p>\n         *\n         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.\n         * @return This instance.",public Builder setHeaderComments(final Object... headerComments) {\n    this.headerComments = CSVFormat.clone(toStringArray(headerComments));\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setHeaderComments(java.lang.Object[]),"digraph cfg_setHeaderComments {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.String[] toStringArray(java.lang.Object[])>(headerComments)""];\n	""2"" [label=""$stack3 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.Object[] clone(java.lang.Object[])>($stack2)""];\n	""3"" [label=""$stack4 = (java.lang.String[]) $stack3""];\n	""4"" [label=""headerComments := @parameter0: java.lang.Object[]""];\n	""5"" [label=""return this""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""7"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String[] headerComments> = $stack4""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""7""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n	""7"" -> ""5""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setHeaderComments(String[]),Method,"* Sets the header comments to write before the CSV data.\n         * <p>\n         * This setting is ignored by the parser.\n         * </p>\n         * <p>\n         * Comments are printed first, before headers.\n         * </p>\n         * <p>\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.\n         * </p>\n         * <p>\n         * If the comment marker is not set, then the header comments are ignored.\n         * </p>\n         * <p>\n         * For example:\n         * </p>\n         *\n         * <pre>\n         * builder.setCommentMarker('#').setHeaderComments(""Generated by Apache Commons CSV"", Instant.ofEpochMilli(0).toString());\n         * </pre>\n         * <p>\n         * writes:\n         * </p>\n         *\n         * <pre>\n         * # Generated by Apache Commons CSV.\n         * # 1970-01-01T00:00:00Z\n         * </pre>\n         * <p>\n         * This method keeps a copy of the input array.\n         * </p>\n         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.\n         * @return This instance.",public Builder setHeaderComments(final String... headerComments) {\n    this.headerComments = CSVFormat.clone(headerComments);\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setHeaderComments(java.lang.String[]),"digraph cfg_setHeaderComments {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.Object[] clone(java.lang.Object[])>(headerComments)""];\n	""2"" [label=""$stack3 = (java.lang.String[]) $stack2""];\n	""3"" [label=""headerComments := @parameter0: java.lang.String[]""];\n	""4"" [label=""return this""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""6"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String[] headerComments> = $stack3""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setIgnoreEmptyLines(boolean),Method,"* Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\n         * records.\n         *\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\n         *                         empty lines to empty records.\n         * @return This instance.",public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n    this.ignoreEmptyLines = ignoreEmptyLines;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setIgnoreEmptyLines(boolean),"digraph cfg_setIgnoreEmptyLines {\n	""1"" [label=""ignoreEmptyLines := @parameter0: boolean""];\n	""2"" [label=""return this""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean ignoreEmptyLines> = ignoreEmptyLines""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setIgnoreHeaderCase(boolean),Method,"* Sets the parser case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\n         *\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\n         * @return This instance.",public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n    this.ignoreHeaderCase = ignoreHeaderCase;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setIgnoreHeaderCase(boolean),"digraph cfg_setIgnoreHeaderCase {\n	""1"" [label=""ignoreHeaderCase := @parameter0: boolean""];\n	""2"" [label=""return this""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean ignoreHeaderCase> = ignoreHeaderCase""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setIgnoreSurroundingSpaces(boolean),Method,"* Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\n         *\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\n         * @return This instance.",public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n    this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setIgnoreSurroundingSpaces(boolean),"digraph cfg_setIgnoreSurroundingSpaces {\n	""1"" [label=""ignoreSurroundingSpaces := @parameter0: boolean""];\n	""2"" [label=""return this""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean ignoreSurroundingSpaces> = ignoreSurroundingSpaces""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setLenientEof(boolean),Method,"* Sets whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.\n         *\n         * @param lenientEof whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.\n         * @return This instance.\n         * @since 1.11.0",public Builder setLenientEof(final boolean lenientEof) {\n    this.lenientEof = lenientEof;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setLenientEof(boolean),"digraph cfg_setLenientEof {\n	""1"" [label=""lenientEof := @parameter0: boolean""];\n	""2"" [label=""return this""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean lenientEof> = lenientEof""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setMaxRows(long),Method,"* Sets the maximum number of rows to process, excluding the header row.\n         * <p>\n         * Values less than or equal to 0 mean no limit.\n         * </p>\n         *\n         * @param maxRows the maximum number of rows to process, excluding the header row.\n         * @return This instance.\n         * @since 1.14.0",public Builder setMaxRows(final long maxRows) {\n    this.maxRows = maxRows;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setMaxRows(long),"digraph cfg_setMaxRows {\n	""1"" [label=""maxRows := @parameter0: long""];\n	""2"" [label=""return this""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: long maxRows> = maxRows""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setNullString(String),Method,* Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\n         *\n         * <ul>\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n         * </ul>\n         *\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\n         * @return This instance.,public Builder setNullString(final String nullString) {\n    this.nullString = nullString;\n    this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setNullString(java.lang.String),"digraph cfg_setNullString {\n	""1"" [label=""$stack2 = new java.lang.StringBuilder""];\n	""2"" [label=""$stack3 = this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.Character quoteCharacter>""];\n	""3"" [label=""$stack4 = virtualinvoke $stack2.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack3)""];\n	""4"" [label=""$stack5 = this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.Character quoteCharacter>""];\n	""5"" [label=""$stack6 = virtualinvoke $stack4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(nullString)""];\n	""6"" [label=""$stack7 = virtualinvoke $stack6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($stack5)""];\n	""7"" [label=""$stack8 = virtualinvoke $stack7.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""8"" [label=""nullString := @parameter0: java.lang.String""];\n	""9"" [label=""return this""];\n	""10"" [label=""specialinvoke $stack2.<java.lang.StringBuilder: void <init>()>()""];\n	""11"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""12"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String nullString> = nullString""];\n	""13"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String quotedNullString> = $stack8""];\n	""1"" -> ""10""[label=""cfg_next""];\n	""10"" -> ""2""[label=""cfg_next""];\n	""11"" -> ""8""[label=""cfg_next""];\n	""12"" -> ""1""[label=""cfg_next""];\n	""13"" -> ""9""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""4""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""13""[label=""cfg_next""];\n	""8"" -> ""12""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setQuote(char),Method,* Sets the quote character.\n         *\n         * @param quoteCharacter the quote character.\n         * @return This instance.,public Builder setQuote(final char quoteCharacter) {\n    setQuote(Character.valueOf(quoteCharacter));\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setQuote(char),"digraph cfg_setQuote {\n	""1"" [label=""$stack2 = staticinvoke <java.lang.Character: java.lang.Character valueOf(char)>(quoteCharacter)""];\n	""2"" [label=""quoteCharacter := @parameter0: char""];\n	""3"" [label=""return this""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""5"" [label=""virtualinvoke this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.CSVFormat$Builder setQuote(java.lang.Character)>($stack2)""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setQuote(Character),Method,"* Sets the quote character, use {@code null} to disable.\n         *\n         * @param quoteCharacter the quote character, use {@code null} to disable.\n         * @return This instance.","public Builder setQuote(final Character quoteCharacter) {\n    if (isLineBreak(quoteCharacter)) {\n        throw new IllegalArgumentException(""The quoteCharacter cannot be a line break"");\n    }\n    this.quoteCharacter = quoteCharacter;\n    return this;\n}",org.apache.commons.csv.CSVFormat$Builder setQuote(java.lang.Character),"digraph cfg_setQuote {\n	""1"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$2300(java.lang.Character)>(quoteCharacter)""];\n	""2"" [label=""$stack3 = new java.lang.IllegalArgumentException""];\n	""3"" [label=""if $stack2 == 0""];\n	""4"" [label=""quoteCharacter := @parameter0: java.lang.Character""];\n	""5"" [label=""return this""];\n	""6"" [label=""specialinvoke $stack3.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(\""The quoteCharacter cannot be a line break\"")""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""8"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.Character quoteCharacter> = quoteCharacter""];\n	""9"" [label=""throw $stack3""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_false""];\n	""3"" -> ""8""[label=""cfg_true""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""6"" -> ""9""[label=""cfg_next""];\n	""7"" -> ""4""[label=""cfg_next""];\n	""8"" -> ""5""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setQuoteMode(QuoteMode),Method,* Sets the quote policy to use for output.\n         *\n         * @param quoteMode the quote policy to use for output.\n         * @return This instance.,public Builder setQuoteMode(final QuoteMode quoteMode) {\n    this.quoteMode = quoteMode;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setQuoteMode(org.apache.commons.csv.QuoteMode),"digraph cfg_setQuoteMode {\n	""1"" [label=""quoteMode := @parameter0: org.apache.commons.csv.QuoteMode""];\n	""2"" [label=""return this""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.QuoteMode quoteMode> = quoteMode""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setRecordSeparator(char),Method,"* Sets the record separator to use for output.\n         *\n         * <p>\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r'\n         * and ""\r\n""\n         * </p>\n         *\n         * @param recordSeparator the record separator to use for output.\n         * @return This instance.",public Builder setRecordSeparator(final char recordSeparator) {\n    this.recordSeparator = String.valueOf(recordSeparator);\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setRecordSeparator(char),"digraph cfg_setRecordSeparator {\n	""1"" [label=""$stack2 = staticinvoke <java.lang.String: java.lang.String valueOf(char)>(recordSeparator)""];\n	""2"" [label=""recordSeparator := @parameter0: char""];\n	""3"" [label=""return this""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""5"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String recordSeparator> = $stack2""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setRecordSeparator(String),Method,"* Sets the record separator to use for output.\n         *\n         * <p>\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\n', '\r'\n         * and ""\r\n""\n         * </p>\n         *\n         * @param recordSeparator the record separator to use for output.\n         * @return This instance.",public Builder setRecordSeparator(final String recordSeparator) {\n    this.recordSeparator = recordSeparator;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setRecordSeparator(java.lang.String),"digraph cfg_setRecordSeparator {\n	""1"" [label=""recordSeparator := @parameter0: java.lang.String""];\n	""2"" [label=""return this""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String recordSeparator> = recordSeparator""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setSkipHeaderRecord(boolean),Method,* Sets whether to skip the header record.\n         *\n         * @param skipHeaderRecord whether to skip the header record.\n         * @return This instance.,public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {\n    this.skipHeaderRecord = skipHeaderRecord;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setSkipHeaderRecord(boolean),"digraph cfg_setSkipHeaderRecord {\n	""1"" [label=""return this""];\n	""2"" [label=""skipHeaderRecord := @parameter0: boolean""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""4"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean skipHeaderRecord> = skipHeaderRecord""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setTrailingData(boolean),Method,"* Sets whether reading trailing data is allowed in records, helps Excel compatibility.\n         *\n         * @param trailingData whether reading trailing data is allowed in records, helps Excel compatibility.\n         * @return This instance.\n         * @since 1.11.0",public Builder setTrailingData(final boolean trailingData) {\n    this.trailingData = trailingData;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setTrailingData(boolean),"digraph cfg_setTrailingData {\n	""1"" [label=""return this""];\n	""2"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""3"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean trailingData> = trailingData""];\n	""4"" [label=""trailingData := @parameter0: boolean""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setTrailingDelimiter(boolean),Method,* Sets whether to add a trailing delimiter.\n         *\n         * @param trailingDelimiter whether to add a trailing delimiter.\n         * @return This instance.,public Builder setTrailingDelimiter(final boolean trailingDelimiter) {\n    this.trailingDelimiter = trailingDelimiter;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setTrailingDelimiter(boolean),"digraph cfg_setTrailingDelimiter {\n	""1"" [label=""return this""];\n	""2"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""3"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean trailingDelimiter> = trailingDelimiter""];\n	""4"" [label=""trailingDelimiter := @parameter0: boolean""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.setTrim(boolean),Method,* Sets whether to trim leading and trailing blanks.\n         *\n         * @param trim whether to trim leading and trailing blanks.\n         * @return This instance.,public Builder setTrim(final boolean trim) {\n    this.trim = trim;\n    return this;\n},org.apache.commons.csv.CSVFormat$Builder setTrim(boolean),"digraph cfg_setTrim {\n	""1"" [label=""return this""];\n	""2"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""3"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean trim> = trim""];\n	""4"" [label=""trim := @parameter0: boolean""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVFormat$Builder.<init>(),Constructor,No Comment,private Builder() {\n    // empty\n},void <init>(),"digraph cfg_init {\n	""1"" [label=""return""];\n	""2"" [label=""specialinvoke this.<java.lang.Object: void <init>()>()""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVFormat$Builder.<init>(CSVFormat),Constructor,No Comment,private Builder(final CSVFormat csvFormat) {\n    this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;\n    this.autoFlush = csvFormat.autoFlush;\n    this.commentMarker = csvFormat.commentMarker;\n    this.delimiter = csvFormat.delimiter;\n    this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\n    this.escapeCharacter = csvFormat.escapeCharacter;\n    this.headerComments = csvFormat.headerComments;\n    this.headers = csvFormat.headers;\n    this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;\n    this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;\n    this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;\n    this.lenientEof = csvFormat.lenientEof;\n    this.maxRows = csvFormat.maxRows;\n    this.nullString = csvFormat.nullString;\n    this.quoteCharacter = csvFormat.quoteCharacter;\n    this.quoteMode = csvFormat.quoteMode;\n    this.quotedNullString = csvFormat.quotedNullString;\n    this.recordSeparator = csvFormat.recordSeparator;\n    this.skipHeaderRecord = csvFormat.skipHeaderRecord;\n    this.trailingData = csvFormat.trailingData;\n    this.trailingDelimiter = csvFormat.trailingDelimiter;\n    this.trim = csvFormat.trim;\n},void <init>(org.apache.commons.csv.CSVFormat),"digraph cfg_init {\n	""1"" [label=""$stack10 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$800(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""2"" [label=""$stack11 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$900(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""3"" [label=""$stack12 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$1000(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""4"" [label=""$stack13 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$1100(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""5"" [label=""$stack14 = staticinvoke <org.apache.commons.csv.CSVFormat: long access$1200(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""6"" [label=""$stack15 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.String access$1300(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""7"" [label=""$stack16 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.Character access$1400(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""8"" [label=""$stack17 = staticinvoke <org.apache.commons.csv.CSVFormat: org.apache.commons.csv.QuoteMode access$1500(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""9"" [label=""$stack18 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.String access$1600(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""10"" [label=""$stack19 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.String access$1700(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""11"" [label=""$stack2 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$000(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""12"" [label=""$stack20 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$1800(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""13"" [label=""$stack21 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$1900(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""14"" [label=""$stack22 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$2000(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""15"" [label=""$stack23 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$2100(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""16"" [label=""$stack3 = staticinvoke <org.apache.commons.csv.CSVFormat: boolean access$100(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""17"" [label=""$stack4 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.Character access$200(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""18"" [label=""$stack5 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.String access$300(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""19"" [label=""$stack6 = staticinvoke <org.apache.commons.csv.CSVFormat: org.apache.commons.csv.DuplicateHeaderMode access$400(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""20"" [label=""$stack7 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.Character access$500(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""21"" [label=""$stack8 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.String[] access$600(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""22"" [label=""$stack9 = staticinvoke <org.apache.commons.csv.CSVFormat: java.lang.String[] access$700(org.apache.commons.csv.CSVFormat)>(csvFormat)""];\n	""23"" [label=""csvFormat := @parameter0: org.apache.commons.csv.CSVFormat""];\n	""24"" [label=""return""];\n	""25"" [label=""specialinvoke this.<java.lang.Object: void <init>()>()""];\n	""26"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Builder""];\n	""27"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean allowMissingColumnNames> = $stack2""];\n	""28"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean autoFlush> = $stack3""];\n	""29"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean ignoreEmptyLines> = $stack10""];\n	""30"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean ignoreHeaderCase> = $stack11""];\n	""31"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean ignoreSurroundingSpaces> = $stack12""];\n	""32"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean lenientEof> = $stack13""];\n	""33"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean skipHeaderRecord> = $stack20""];\n	""34"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean trailingData> = $stack21""];\n	""35"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean trailingDelimiter> = $stack22""];\n	""36"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: boolean trim> = $stack23""];\n	""37"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.Character commentMarker> = $stack4""];\n	""38"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.Character escapeCharacter> = $stack7""];\n	""39"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.Character quoteCharacter> = $stack16""];\n	""40"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String delimiter> = $stack5""];\n	""41"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String nullString> = $stack15""];\n	""42"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String quotedNullString> = $stack18""];\n	""43"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String recordSeparator> = $stack19""];\n	""44"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String[] headerComments> = $stack8""];\n	""45"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: java.lang.String[] headers> = $stack9""];\n	""46"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: long maxRows> = $stack14""];\n	""47"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.DuplicateHeaderMode duplicateHeaderMode> = $stack6""];\n	""48"" [label=""this.<org.apache.commons.csv.CSVFormat$Builder: org.apache.commons.csv.QuoteMode quoteMode> = $stack17""];\n	""1"" -> ""29""[label=""cfg_next""];\n	""10"" -> ""43""[label=""cfg_next""];\n	""11"" -> ""27""[label=""cfg_next""];\n	""12"" -> ""33""[label=""cfg_next""];\n	""13"" -> ""34""[label=""cfg_next""];\n	""14"" -> ""35""[label=""cfg_next""];\n	""15"" -> ""36""[label=""cfg_next""];\n	""16"" -> ""28""[label=""cfg_next""];\n	""17"" -> ""37""[label=""cfg_next""];\n	""18"" -> ""40""[label=""cfg_next""];\n	""19"" -> ""47""[label=""cfg_next""];\n	""2"" -> ""30""[label=""cfg_next""];\n	""20"" -> ""38""[label=""cfg_next""];\n	""21"" -> ""44""[label=""cfg_next""];\n	""22"" -> ""45""[label=""cfg_next""];\n	""23"" -> ""25""[label=""cfg_next""];\n	""25"" -> ""11""[label=""cfg_next""];\n	""26"" -> ""23""[label=""cfg_next""];\n	""27"" -> ""16""[label=""cfg_next""];\n	""28"" -> ""17""[label=""cfg_next""];\n	""29"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""31""[label=""cfg_next""];\n	""30"" -> ""3""[label=""cfg_next""];\n	""31"" -> ""4""[label=""cfg_next""];\n	""32"" -> ""5""[label=""cfg_next""];\n	""33"" -> ""13""[label=""cfg_next""];\n	""34"" -> ""14""[label=""cfg_next""];\n	""35"" -> ""15""[label=""cfg_next""];\n	""36"" -> ""24""[label=""cfg_next""];\n	""37"" -> ""18""[label=""cfg_next""];\n	""38"" -> ""21""[label=""cfg_next""];\n	""39"" -> ""8""[label=""cfg_next""];\n	""4"" -> ""32""[label=""cfg_next""];\n	""40"" -> ""19""[label=""cfg_next""];\n	""41"" -> ""7""[label=""cfg_next""];\n	""42"" -> ""10""[label=""cfg_next""];\n	""43"" -> ""12""[label=""cfg_next""];\n	""44"" -> ""22""[label=""cfg_next""];\n	""45"" -> ""1""[label=""cfg_next""];\n	""46"" -> ""6""[label=""cfg_next""];\n	""47"" -> ""20""[label=""cfg_next""];\n	""48"" -> ""9""[label=""cfg_next""];\n	""5"" -> ""46""[label=""cfg_next""];\n	""6"" -> ""41""[label=""cfg_next""];\n	""7"" -> ""39""[label=""cfg_next""];\n	""8"" -> ""48""[label=""cfg_next""];\n	""9"" -> ""42""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVFormat$Predefined.getFormat(),Method,* Gets the format.\n         *\n         * @return the format.,public CSVFormat getFormat() {\n    return format;\n},org.apache.commons.csv.CSVFormat getFormat(),"digraph cfg_getFormat {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVFormat$Predefined: org.apache.commons.csv.CSVFormat format>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVFormat$Predefined""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.ExtendedBufferedReader.close(),Method,* Closes the stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs,@Override\npublic void close() throws IOException {\n    // Set ivars before calling super close() in case close() throws an IOException.\n    lastChar = EOF;\n    super.close();\n},void close(),"digraph cfg_close {\n	""1"" [label=""return""];\n	""2"" [label=""specialinvoke this.<org.apache.commons.io.input.UnsynchronizedBufferedReader: void close()>()""];\n	""3"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""4"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar> = -1""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.ExtendedBufferedReader.getBytesRead(),Method,* Gets the number of bytes read by the reader.\n     *\n     * @return the number of bytes read by the read,long getBytesRead() {\n    return this.bytesRead;\n},long getBytesRead(),"digraph cfg_getBytesRead {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.ExtendedBufferedReader: long bytesRead>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.ExtendedBufferedReader.getEncodedCharLength(int),Method,"* Gets the byte length of the given character based on the the original Unicode\n     * specification, which defined characters as fixed-width 16-bit entities.\n     * <p>\n     * The Unicode characters are divided into two main ranges:\n     * <ul>\n     *   <li><b>U+0000 to U+FFFF (Basic Multilingual Plane, BMP):</b>\n     *     <ul>\n     *       <li>Represented using a single 16-bit {@code char}.</li>\n     *       <li>Includes UTF-8 encodings of 1-byte, 2-byte, and some 3-byte characters.</li>\n     *     </ul>\n     *   </li>\n     *   <li><b>U+10000 to U+10FFFF (Supplementary Characters):</b>\n     *     <ul>\n     *       <li>Represented as a pair of {@code char}s:</li>\n     *       <li>The first {@code char} is from the high-surrogates range (\uD800-\uDBFF).</li>\n     *       <li>The second {@code char} is from the low-surrogates range (\uDC00-\uDFFF).</li>\n     *       <li>Includes UTF-8 encodings of some 3-byte characters and all 4-byte characters.</li>\n     *     </ul>\n     *   </li>\n     * </ul>\n     *\n     * @param current the current character to process.\n     * @return the byte length of the character.\n     * @throws CharacterCodingException if the character cannot be encoded.","private int getEncodedCharLength(final int current) throws CharacterCodingException {\n    final char cChar = (char) current;\n    final char lChar = (char) lastChar;\n    if (!Character.isSurrogate(cChar)) {\n        return encoder.encode(CharBuffer.wrap(new char[] { cChar })).limit();\n    }\n    if (Character.isHighSurrogate(cChar)) {\n        // Move on to the next char (low surrogate)\n        return 0;\n    } else if (Character.isSurrogatePair(lChar, cChar)) {\n        return encoder.encode(CharBuffer.wrap(new char[] { lChar, cChar })).limit();\n    } else {\n        throw new CharacterCodingException();\n    }\n}",int getEncodedCharLength(int),"digraph cfg_getEncodedCharLength {\n	""1"" [label=""$stack10 = this.<org.apache.commons.csv.ExtendedBufferedReader: java.nio.charset.CharsetEncoder encoder>""];\n	""2"" [label=""$stack11 = staticinvoke <java.nio.CharBuffer: java.nio.CharBuffer wrap(char[])>($stack9)""];\n	""3"" [label=""$stack12 = virtualinvoke $stack10.<java.nio.charset.CharsetEncoder: java.nio.ByteBuffer encode(java.nio.CharBuffer)>($stack11)""];\n	""4"" [label=""$stack13 = virtualinvoke $stack12.<java.nio.ByteBuffer: int limit()>()""];\n	""5"" [label=""$stack14 = newarray (char)[1]""];\n	""6"" [label=""$stack14[0] = cChar""];\n	""7"" [label=""$stack15 = this.<org.apache.commons.csv.ExtendedBufferedReader: java.nio.charset.CharsetEncoder encoder>""];\n	""8"" [label=""$stack16 = staticinvoke <java.nio.CharBuffer: java.nio.CharBuffer wrap(char[])>($stack14)""];\n	""9"" [label=""$stack17 = virtualinvoke $stack15.<java.nio.charset.CharsetEncoder: java.nio.ByteBuffer encode(java.nio.CharBuffer)>($stack16)""];\n	""10"" [label=""$stack18 = virtualinvoke $stack17.<java.nio.ByteBuffer: int limit()>()""];\n	""11"" [label=""$stack4 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""12"" [label=""$stack5 = staticinvoke <java.lang.Character: boolean isSurrogate(char)>(cChar)""];\n	""13"" [label=""$stack6 = staticinvoke <java.lang.Character: boolean isHighSurrogate(char)>(cChar)""];\n	""14"" [label=""$stack7 = staticinvoke <java.lang.Character: boolean isSurrogatePair(char,char)>(lChar, cChar)""];\n	""15"" [label=""$stack8 = new java.nio.charset.CharacterCodingException""];\n	""16"" [label=""$stack9 = newarray (char)[2]""];\n	""17"" [label=""$stack9[0] = lChar""];\n	""18"" [label=""$stack9[1] = cChar""];\n	""19"" [label=""cChar = (char) current""];\n	""20"" [label=""current := @parameter0: int""];\n	""21"" [label=""if $stack5 != 0""];\n	""22"" [label=""if $stack6 == 0""];\n	""23"" [label=""if $stack7 == 0""];\n	""24"" [label=""lChar = (char) $stack4""];\n	""25"" [label=""return $stack13""];\n	""26"" [label=""return $stack18""];\n	""27"" [label=""return 0""];\n	""28"" [label=""specialinvoke $stack8.<java.nio.charset.CharacterCodingException: void <init>()>()""];\n	""29"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""30"" [label=""throw $stack8""];\n	""1"" -> ""16""[label=""cfg_next""];\n	""10"" -> ""26""[label=""cfg_next""];\n	""11"" -> ""24""[label=""cfg_next""];\n	""12"" -> ""21""[label=""cfg_next""];\n	""13"" -> ""22""[label=""cfg_next""];\n	""14"" -> ""23""[label=""cfg_next""];\n	""15"" -> ""28""[label=""cfg_next""];\n	""16"" -> ""17""[label=""cfg_next""];\n	""17"" -> ""18""[label=""cfg_next""];\n	""18"" -> ""2""[label=""cfg_next""];\n	""19"" -> ""11""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""20"" -> ""19""[label=""cfg_next""];\n	""21"" -> ""13""[label=""cfg_true""];\n	""21"" -> ""7""[label=""cfg_false""];\n	""22"" -> ""14""[label=""cfg_true""];\n	""22"" -> ""27""[label=""cfg_false""];\n	""23"" -> ""1""[label=""cfg_false""];\n	""23"" -> ""15""[label=""cfg_true""];\n	""24"" -> ""12""[label=""cfg_next""];\n	""28"" -> ""30""[label=""cfg_next""];\n	""29"" -> ""20""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""25""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_next""];\n	""7"" -> ""5""[label=""cfg_next""];\n	""8"" -> ""9""[label=""cfg_next""];\n	""9"" -> ""10""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.ExtendedBufferedReader.getLastChar(),Method,* Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link IOUtils#EOF}.\n     *\n     * @return the last character that was read,int getLastChar() {\n    return lastChar;\n},int getLastChar(),"digraph cfg_getLastChar {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.ExtendedBufferedReader.getLineNumber(),Method,* Returns the current line number\n     *\n     * @return the current line number,long getLineNumber() {\n    // Check if we are at EOL or EOF or just starting\n    if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == EOF) {\n        // counter is accurate\n        return lineNumber;\n    }\n    // Allow for counter being incremented only at EOL\n    return lineNumber + 1;\n},long getLineNumber(),"digraph cfg_getLineNumber {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""2"" [label=""$stack2 = this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber>""];\n	""3"" [label=""$stack3 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""4"" [label=""$stack4 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""5"" [label=""$stack5 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""6"" [label=""$stack6 = this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber>""];\n	""7"" [label=""$stack7 = $stack6 + 1L""];\n	""8"" [label=""if $stack1 == 13""];\n	""9"" [label=""if $stack3 == 10""];\n	""10"" [label=""if $stack4 == -2""];\n	""11"" [label=""if $stack5 != -1""];\n	""12"" [label=""return $stack2""];\n	""13"" [label=""return $stack7""];\n	""14"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""1"" -> ""8""[label=""cfg_next""];\n	""10"" -> ""2""[label=""cfg_true""];\n	""10"" -> ""5""[label=""cfg_false""];\n	""11"" -> ""2""[label=""cfg_false""];\n	""11"" -> ""6""[label=""cfg_true""];\n	""14"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""12""[label=""cfg_next""];\n	""3"" -> ""9""[label=""cfg_next""];\n	""4"" -> ""10""[label=""cfg_next""];\n	""5"" -> ""11""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""13""[label=""cfg_next""];\n	""8"" -> ""2""[label=""cfg_true""];\n	""8"" -> ""3""[label=""cfg_false""];\n	""9"" -> ""2""[label=""cfg_true""];\n	""9"" -> ""4""[label=""cfg_false""];\n}\n",default
org.apache.commons.csv.ExtendedBufferedReader.getPosition(),Method,"* Gets the character position in the reader.\n     *\n     * @return the current position in the reader (counting characters, not bytes since this is a Reader)",long getPosition() {\n    return this.position;\n},long getPosition(),"digraph cfg_getPosition {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.ExtendedBufferedReader: long position>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.ExtendedBufferedReader.mark(int),Method,No Comment,@Override\npublic void mark(final int readAheadLimit) throws IOException {\n    lineNumberMark = lineNumber;\n    lastCharMark = lastChar;\n    positionMark = position;\n    bytesReadMark = bytesRead;\n    super.mark(readAheadLimit);\n},void mark(int),"digraph cfg_mark {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber>""];\n	""2"" [label=""$stack3 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""3"" [label=""$stack4 = this.<org.apache.commons.csv.ExtendedBufferedReader: long position>""];\n	""4"" [label=""$stack5 = this.<org.apache.commons.csv.ExtendedBufferedReader: long bytesRead>""];\n	""5"" [label=""readAheadLimit := @parameter0: int""];\n	""6"" [label=""return""];\n	""7"" [label=""specialinvoke this.<org.apache.commons.io.input.UnsynchronizedBufferedReader: void mark(int)>(readAheadLimit)""];\n	""8"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""9"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: int lastCharMark> = $stack3""];\n	""10"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long bytesReadMark> = $stack5""];\n	""11"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumberMark> = $stack2""];\n	""12"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long positionMark> = $stack4""];\n	""1"" -> ""11""[label=""cfg_next""];\n	""10"" -> ""7""[label=""cfg_next""];\n	""11"" -> ""2""[label=""cfg_next""];\n	""12"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""9""[label=""cfg_next""];\n	""3"" -> ""12""[label=""cfg_next""];\n	""4"" -> ""10""[label=""cfg_next""];\n	""5"" -> ""1""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n	""8"" -> ""5""[label=""cfg_next""];\n	""9"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.ExtendedBufferedReader.read(),Method,No Comment,@Override\npublic int read() throws IOException {\n    final int current = super.read();\n    if (current == CR || current == LF && lastChar != CR || current == EOF && lastChar != CR && lastChar != LF && lastChar != EOF) {\n        lineNumber++;\n    }\n    if (encoder != null) {\n        this.bytesRead += getEncodedCharLength(current);\n    }\n    lastChar = current;\n    position++;\n    return lastChar;\n},int read(),"digraph cfg_read {\n	""1"" [label=""$stack10 = (long) $stack9""];\n	""2"" [label=""$stack11 = $stack8 + $stack10""];\n	""3"" [label=""$stack12 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""4"" [label=""$stack13 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""5"" [label=""$stack14 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""6"" [label=""$stack15 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""7"" [label=""$stack2 = this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber>""];\n	""8"" [label=""$stack3 = $stack2 + 1L""];\n	""9"" [label=""$stack4 = this.<org.apache.commons.csv.ExtendedBufferedReader: java.nio.charset.CharsetEncoder encoder>""];\n	""10"" [label=""$stack5 = this.<org.apache.commons.csv.ExtendedBufferedReader: long position>""];\n	""11"" [label=""$stack6 = $stack5 + 1L""];\n	""12"" [label=""$stack7 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""13"" [label=""$stack8 = this.<org.apache.commons.csv.ExtendedBufferedReader: long bytesRead>""];\n	""14"" [label=""$stack9 = specialinvoke this.<org.apache.commons.csv.ExtendedBufferedReader: int getEncodedCharLength(int)>(current)""];\n	""15"" [label=""current = specialinvoke this.<org.apache.commons.io.input.UnsynchronizedBufferedReader: int read()>()""];\n	""16"" [label=""if $stack12 == 13""];\n	""17"" [label=""if $stack13 == 10""];\n	""18"" [label=""if $stack14 == -1""];\n	""19"" [label=""if $stack15 != 13""];\n	""20"" [label=""if $stack4 == null""];\n	""21"" [label=""if current != -1""];\n	""22"" [label=""if current != 10""];\n	""23"" [label=""if current == 13""];\n	""24"" [label=""return $stack7""];\n	""25"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""26"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar> = current""];\n	""27"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long bytesRead> = $stack11""];\n	""28"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber> = $stack3""];\n	""29"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long position> = $stack6""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""11""[label=""cfg_next""];\n	""11"" -> ""29""[label=""cfg_next""];\n	""12"" -> ""24""[label=""cfg_next""];\n	""13"" -> ""14""[label=""cfg_next""];\n	""14"" -> ""1""[label=""cfg_next""];\n	""15"" -> ""23""[label=""cfg_next""];\n	""16"" -> ""4""[label=""cfg_false""];\n	""16"" -> ""9""[label=""cfg_true""];\n	""17"" -> ""5""[label=""cfg_false""];\n	""17"" -> ""9""[label=""cfg_true""];\n	""18"" -> ""7""[label=""cfg_false""];\n	""18"" -> ""9""[label=""cfg_true""];\n	""19"" -> ""21""[label=""cfg_false""];\n	""19"" -> ""7""[label=""cfg_true""];\n	""2"" -> ""27""[label=""cfg_next""];\n	""20"" -> ""13""[label=""cfg_false""];\n	""20"" -> ""26""[label=""cfg_true""];\n	""21"" -> ""3""[label=""cfg_false""];\n	""21"" -> ""9""[label=""cfg_true""];\n	""22"" -> ""21""[label=""cfg_true""];\n	""22"" -> ""6""[label=""cfg_false""];\n	""23"" -> ""22""[label=""cfg_false""];\n	""23"" -> ""7""[label=""cfg_true""];\n	""25"" -> ""15""[label=""cfg_next""];\n	""26"" -> ""10""[label=""cfg_next""];\n	""27"" -> ""26""[label=""cfg_next""];\n	""28"" -> ""9""[label=""cfg_next""];\n	""29"" -> ""12""[label=""cfg_next""];\n	""3"" -> ""16""[label=""cfg_next""];\n	""4"" -> ""17""[label=""cfg_next""];\n	""5"" -> ""18""[label=""cfg_next""];\n	""6"" -> ""19""[label=""cfg_next""];\n	""7"" -> ""8""[label=""cfg_next""];\n	""8"" -> ""28""[label=""cfg_next""];\n	""9"" -> ""20""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.ExtendedBufferedReader.read(char[],int,int)",Method,No Comment,"@Override\npublic int read(final char[] buf, final int offset, final int length) throws IOException {\n    if (length == 0) {\n        return 0;\n    }\n    final int len = super.read(buf, offset, length);\n    if (len > 0) {\n        for (int i = offset; i < offset + len; i++) {\n            final char ch = buf[i];\n            if (ch == LF) {\n                if (CR != (i > offset ? buf[i - 1] : lastChar)) {\n                    lineNumber++;\n                }\n            } else if (ch == CR) {\n                lineNumber++;\n            }\n        }\n        lastChar = buf[offset + len - 1];\n    } else if (len == EOF) {\n        lastChar = EOF;\n    }\n    position += len;\n    return len;\n}","int read(char[],int,int)","digraph cfg_read {\n	""1"" [label=""$stack10 = offset + len""];\n	""2"" [label=""$stack11 = offset + len""];\n	""3"" [label=""$stack12 = $stack11 - 1""];\n	""4"" [label=""$stack13 = buf[$stack12]""];\n	""5"" [label=""$stack14 = this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber>""];\n	""6"" [label=""$stack15 = $stack14 + 1L""];\n	""7"" [label=""$stack16 = buf[$stack19]""];\n	""8"" [label=""$stack16 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar>""];\n	""9"" [label=""$stack17 = this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber>""];\n	""10"" [label=""$stack18 = $stack17 + 1L""];\n	""11"" [label=""$stack19 = i - 1""];\n	""12"" [label=""$stack7 = this.<org.apache.commons.csv.ExtendedBufferedReader: long position>""];\n	""13"" [label=""$stack8 = (long) len""];\n	""14"" [label=""$stack9 = $stack7 + $stack8""];\n	""15"" [label=""buf := @parameter0: char[]""];\n	""16"" [label=""ch = buf[i]""];\n	""17"" [label=""goto""];\n	""18"" [label=""goto""];\n	""19"" [label=""goto""];\n	""20"" [label=""goto""];\n	""21"" [label=""i = i + 1""];\n	""22"" [label=""i = offset""];\n	""23"" [label=""if 13 == $stack16""];\n	""24"" [label=""if ch != 10""];\n	""25"" [label=""if ch != 13""];\n	""26"" [label=""if i <= offset""];\n	""27"" [label=""if i >= $stack10""];\n	""28"" [label=""if len != -1""];\n	""29"" [label=""if len <= 0""];\n	""30"" [label=""if length != 0""];\n	""31"" [label=""len = specialinvoke this.<org.apache.commons.io.input.UnsynchronizedBufferedReader: int read(char[],int,int)>(buf, offset, length)""];\n	""32"" [label=""length := @parameter2: int""];\n	""33"" [label=""offset := @parameter1: int""];\n	""34"" [label=""return 0""];\n	""35"" [label=""return len""];\n	""36"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""37"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar> = $stack13""];\n	""38"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar> = -1""];\n	""39"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber> = $stack15""];\n	""40"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber> = $stack18""];\n	""41"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long position> = $stack9""];\n	""1"" -> ""27""[label=""cfg_next""];\n	""10"" -> ""40""[label=""cfg_next""];\n	""11"" -> ""7""[label=""cfg_next""];\n	""12"" -> ""13""[label=""cfg_next""];\n	""13"" -> ""14""[label=""cfg_next""];\n	""14"" -> ""41""[label=""cfg_next""];\n	""15"" -> ""33""[label=""cfg_next""];\n	""16"" -> ""24""[label=""cfg_next""];\n	""17"" -> ""23""[label=""cfg_goto""];\n	""18"" -> ""21""[label=""cfg_goto""];\n	""19"" -> ""1""[label=""cfg_goto""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""20"" -> ""12""[label=""cfg_goto""];\n	""21"" -> ""19""[label=""cfg_next""];\n	""22"" -> ""1""[label=""cfg_next""];\n	""23"" -> ""21""[label=""cfg_true""];\n	""23"" -> ""9""[label=""cfg_false""];\n	""24"" -> ""25""[label=""cfg_true""];\n	""24"" -> ""26""[label=""cfg_false""];\n	""25"" -> ""21""[label=""cfg_true""];\n	""25"" -> ""5""[label=""cfg_false""];\n	""26"" -> ""11""[label=""cfg_false""];\n	""26"" -> ""8""[label=""cfg_true""];\n	""27"" -> ""16""[label=""cfg_false""];\n	""27"" -> ""2""[label=""cfg_true""];\n	""28"" -> ""12""[label=""cfg_true""];\n	""28"" -> ""38""[label=""cfg_false""];\n	""29"" -> ""22""[label=""cfg_false""];\n	""29"" -> ""28""[label=""cfg_true""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""30"" -> ""31""[label=""cfg_true""];\n	""30"" -> ""34""[label=""cfg_false""];\n	""31"" -> ""29""[label=""cfg_next""];\n	""32"" -> ""30""[label=""cfg_next""];\n	""33"" -> ""32""[label=""cfg_next""];\n	""36"" -> ""15""[label=""cfg_next""];\n	""37"" -> ""20""[label=""cfg_next""];\n	""38"" -> ""12""[label=""cfg_next""];\n	""39"" -> ""21""[label=""cfg_next""];\n	""4"" -> ""37""[label=""cfg_next""];\n	""40"" -> ""18""[label=""cfg_next""];\n	""41"" -> ""35""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""39""[label=""cfg_next""];\n	""7"" -> ""17""[label=""cfg_next""];\n	""8"" -> ""23""[label=""cfg_next""];\n	""9"" -> ""10""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.ExtendedBufferedReader.readLine(),Method,"* Gets the next line, dropping the line terminator(s). This method should only be called when processing a\n     * comment, otherwise, information can be lost.\n     * <p>\n     * Increments {@link #lineNumber} and updates {@link #position}.\n     * </p>\n     * <p>\n     * Sets {@link #lastChar} to {@code Constants.EOF} at EOF, otherwise the last EOL character.\n     * </p>\n     *\n     * @return the line that was read, or null if reached EOF.",@Override\npublic String readLine() throws IOException {\n    if (peek() == EOF) {\n        return null;\n    }\n    final StringBuilder buffer = new StringBuilder();\n    while (true) {\n        final int current = read();\n        if (current == CR) {\n            final int next = peek();\n            if (next == LF) {\n                read();\n            }\n        }\n        if (current == EOF || current == LF || current == CR) {\n            break;\n        }\n        buffer.append((char) current);\n    }\n    return buffer.toString();\n},java.lang.String readLine(),"digraph cfg_readLine {\n	""1"" [label=""$stack4 = virtualinvoke this.<org.apache.commons.csv.ExtendedBufferedReader: int peek()>()""];\n	""2"" [label=""$stack5 = new java.lang.StringBuilder""];\n	""3"" [label=""$stack6 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""4"" [label=""$stack7 = (char) current""];\n	""5"" [label=""buffer = $stack5""];\n	""6"" [label=""current = virtualinvoke this.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""7"" [label=""goto""];\n	""8"" [label=""goto""];\n	""9"" [label=""if $stack4 != -1""];\n	""10"" [label=""if current != 13""];\n	""11"" [label=""if current != 13""];\n	""12"" [label=""if current == -1""];\n	""13"" [label=""if current == 10""];\n	""14"" [label=""if next != 10""];\n	""15"" [label=""next = virtualinvoke this.<org.apache.commons.csv.ExtendedBufferedReader: int peek()>()""];\n	""16"" [label=""return $stack6""];\n	""17"" [label=""return null""];\n	""18"" [label=""specialinvoke $stack5.<java.lang.StringBuilder: void <init>()>()""];\n	""19"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""20"" [label=""virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack7)""];\n	""21"" [label=""virtualinvoke this.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""1"" -> ""9""[label=""cfg_next""];\n	""10"" -> ""12""[label=""cfg_true""];\n	""10"" -> ""15""[label=""cfg_false""];\n	""11"" -> ""4""[label=""cfg_true""];\n	""11"" -> ""7""[label=""cfg_false""];\n	""12"" -> ""13""[label=""cfg_false""];\n	""12"" -> ""3""[label=""cfg_true""];\n	""13"" -> ""11""[label=""cfg_false""];\n	""13"" -> ""3""[label=""cfg_true""];\n	""14"" -> ""12""[label=""cfg_true""];\n	""14"" -> ""21""[label=""cfg_false""];\n	""15"" -> ""14""[label=""cfg_next""];\n	""18"" -> ""5""[label=""cfg_next""];\n	""19"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""18""[label=""cfg_next""];\n	""20"" -> ""8""[label=""cfg_next""];\n	""21"" -> ""12""[label=""cfg_next""];\n	""3"" -> ""16""[label=""cfg_next""];\n	""4"" -> ""20""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""10""[label=""cfg_next""];\n	""7"" -> ""3""[label=""cfg_goto""];\n	""8"" -> ""6""[label=""cfg_goto""];\n	""9"" -> ""17""[label=""cfg_false""];\n	""9"" -> ""2""[label=""cfg_true""];\n}\n",public 
org.apache.commons.csv.ExtendedBufferedReader.reset(),Method,No Comment,@Override\npublic void reset() throws IOException {\n    lineNumber = lineNumberMark;\n    lastChar = lastCharMark;\n    position = positionMark;\n    bytesRead = bytesReadMark;\n    super.reset();\n},void reset(),"digraph cfg_reset {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumberMark>""];\n	""2"" [label=""$stack2 = this.<org.apache.commons.csv.ExtendedBufferedReader: int lastCharMark>""];\n	""3"" [label=""$stack3 = this.<org.apache.commons.csv.ExtendedBufferedReader: long positionMark>""];\n	""4"" [label=""$stack4 = this.<org.apache.commons.csv.ExtendedBufferedReader: long bytesReadMark>""];\n	""5"" [label=""return""];\n	""6"" [label=""specialinvoke this.<org.apache.commons.io.input.UnsynchronizedBufferedReader: void reset()>()""];\n	""7"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""8"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar> = $stack2""];\n	""9"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long bytesRead> = $stack4""];\n	""10"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long lineNumber> = $stack1""];\n	""11"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: long position> = $stack3""];\n	""1"" -> ""10""[label=""cfg_next""];\n	""10"" -> ""2""[label=""cfg_next""];\n	""11"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""8""[label=""cfg_next""];\n	""3"" -> ""11""[label=""cfg_next""];\n	""4"" -> ""9""[label=""cfg_next""];\n	""6"" -> ""5""[label=""cfg_next""];\n	""7"" -> ""1""[label=""cfg_next""];\n	""8"" -> ""3""[label=""cfg_next""];\n	""9"" -> ""6""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader),Constructor,* Constructs a new instance using the default buffer size.,"ExtendedBufferedReader(final Reader reader) {\n    this(reader, null, false);\n}",void <init>(java.io.Reader),"digraph cfg_init {\n	""1"" [label=""reader := @parameter0: java.io.Reader""];\n	""2"" [label=""return""];\n	""3"" [label=""specialinvoke this.<org.apache.commons.csv.ExtendedBufferedReader: void <init>(java.io.Reader,java.nio.charset.Charset,boolean)>(reader, null, 0)""];\n	""4"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",default
"org.apache.commons.csv.ExtendedBufferedReader.<init>(Reader,Charset,boolean)",Constructor,"* Constructs a new instance with the specified reader, character set,\n     * and byte tracking option. Initializes an encoder if byte tracking is enabled\n     * and a character set is provided.\n     *\n     * @param reader the reader supports a look-ahead option.\n     * @param charset the character set for encoding, or {@code null} if not applicable.\n     * @param trackBytes {@code true} to enable byte tracking; {@code false} to disable it.","ExtendedBufferedReader(final Reader reader, final Charset charset, final boolean trackBytes) {\n    super(reader);\n    encoder = charset != null && trackBytes ? charset.newEncoder() : null;\n}","void <init>(java.io.Reader,java.nio.charset.Charset,boolean)","digraph cfg_init {\n	""1"" [label=""$stack4 = null""];\n	""2"" [label=""$stack4 = virtualinvoke charset.<java.nio.charset.Charset: java.nio.charset.CharsetEncoder newEncoder()>()""];\n	""3"" [label=""charset := @parameter1: java.nio.charset.Charset""];\n	""4"" [label=""goto""];\n	""5"" [label=""if charset == null""];\n	""6"" [label=""if trackBytes == 0""];\n	""7"" [label=""reader := @parameter0: java.io.Reader""];\n	""8"" [label=""return""];\n	""9"" [label=""specialinvoke this.<org.apache.commons.io.input.UnsynchronizedBufferedReader: void <init>(java.io.Reader)>(reader)""];\n	""10"" [label=""this := @this: org.apache.commons.csv.ExtendedBufferedReader""];\n	""11"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: int lastChar> = -2""];\n	""12"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: int lastCharMark> = -2""];\n	""13"" [label=""this.<org.apache.commons.csv.ExtendedBufferedReader: java.nio.charset.CharsetEncoder encoder> = $stack4""];\n	""14"" [label=""trackBytes := @parameter2: boolean""];\n	""1"" -> ""13""[label=""cfg_next""];\n	""10"" -> ""7""[label=""cfg_next""];\n	""11"" -> ""12""[label=""cfg_next""];\n	""12"" -> ""5""[label=""cfg_next""];\n	""13"" -> ""8""[label=""cfg_next""];\n	""14"" -> ""9""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""14""[label=""cfg_next""];\n	""4"" -> ""13""[label=""cfg_goto""];\n	""5"" -> ""1""[label=""cfg_true""];\n	""5"" -> ""6""[label=""cfg_false""];\n	""6"" -> ""1""[label=""cfg_true""];\n	""6"" -> ""2""[label=""cfg_false""];\n	""7"" -> ""3""[label=""cfg_next""];\n	""9"" -> ""11""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.appendNextEscapedCharacterToToken(Token),Method,* Appends the next escaped character to the token's content.\n     *\n     * @param token the current token\n     * @throws IOException  on stream access error\n     * @throws CSVException Thrown on invalid input.,private void appendNextEscapedCharacterToToken(final Token token) throws IOException {\n    if (isEscapeDelimiter()) {\n        token.content.append(delimiter);\n    } else {\n        final int unescaped = readEscape();\n        if (unescaped == EOF) {\n            // unexpected char after escape\n            token.content.append((char) escape).append((char) reader.getLastChar());\n        } else {\n            token.content.append((char) unescaped);\n        }\n    }\n},void appendNextEscapedCharacterToToken(org.apache.commons.csv.Token),"digraph cfg_appendNextEscapedCharacterToToken {\n	""1"" [label=""$stack10 = virtualinvoke $stack9.<org.apache.commons.csv.ExtendedBufferedReader: int getLastChar()>()""];\n	""2"" [label=""$stack11 = (char) $stack10""];\n	""3"" [label=""$stack12 = virtualinvoke $stack8.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack7)""];\n	""4"" [label=""$stack13 = this.<org.apache.commons.csv.Lexer: char[] delimiter>""];\n	""5"" [label=""$stack14 = token.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""6"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEscapeDelimiter()>()""];\n	""7"" [label=""$stack4 = (char) unescaped""];\n	""8"" [label=""$stack5 = token.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""9"" [label=""$stack6 = this.<org.apache.commons.csv.Lexer: int escape>""];\n	""10"" [label=""$stack7 = (char) $stack6""];\n	""11"" [label=""$stack8 = token.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""12"" [label=""$stack9 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""13"" [label=""goto""];\n	""14"" [label=""goto""];\n	""15"" [label=""if $stack3 == 0""];\n	""16"" [label=""if unescaped != -1""];\n	""17"" [label=""return""];\n	""18"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""19"" [label=""token := @parameter0: org.apache.commons.csv.Token""];\n	""20"" [label=""unescaped = virtualinvoke this.<org.apache.commons.csv.Lexer: int readEscape()>()""];\n	""21"" [label=""virtualinvoke $stack12.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack11)""];\n	""22"" [label=""virtualinvoke $stack14.<java.lang.StringBuilder: java.lang.StringBuilder append(char[])>($stack13)""];\n	""23"" [label=""virtualinvoke $stack5.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack4)""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""3""[label=""cfg_next""];\n	""11"" -> ""9""[label=""cfg_next""];\n	""12"" -> ""1""[label=""cfg_next""];\n	""13"" -> ""17""[label=""cfg_goto""];\n	""14"" -> ""17""[label=""cfg_goto""];\n	""15"" -> ""20""[label=""cfg_true""];\n	""15"" -> ""5""[label=""cfg_false""];\n	""16"" -> ""11""[label=""cfg_false""];\n	""16"" -> ""8""[label=""cfg_true""];\n	""18"" -> ""19""[label=""cfg_next""];\n	""19"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""21""[label=""cfg_next""];\n	""20"" -> ""16""[label=""cfg_next""];\n	""21"" -> ""14""[label=""cfg_next""];\n	""22"" -> ""13""[label=""cfg_next""];\n	""23"" -> ""17""[label=""cfg_next""];\n	""3"" -> ""12""[label=""cfg_next""];\n	""4"" -> ""22""[label=""cfg_next""];\n	""5"" -> ""4""[label=""cfg_next""];\n	""6"" -> ""15""[label=""cfg_next""];\n	""7"" -> ""23""[label=""cfg_next""];\n	""8"" -> ""7""[label=""cfg_next""];\n	""9"" -> ""10""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.Lexer.close(),Method,* Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs,@Override\npublic void close() throws IOException {\n    reader.close();\n},void close(),"digraph cfg_close {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""2"" [label=""return""];\n	""3"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""4"" [label=""virtualinvoke $stack1.<org.apache.commons.csv.ExtendedBufferedReader: void close()>()""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.Lexer.getBytesRead(),Method,* Gets the number of bytes read\n     *\n     * @return the number of bytes read,long getBytesRead() {\n    return reader.getBytesRead();\n},long getBytesRead(),"digraph cfg_getBytesRead {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.ExtendedBufferedReader: long getBytesRead()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.getCharacterPosition(),Method,* Returns the current character position\n     *\n     * @return the current character position,long getCharacterPosition() {\n    return reader.getPosition();\n},long getCharacterPosition(),"digraph cfg_getCharacterPosition {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.ExtendedBufferedReader: long getPosition()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.getCurrentLineNumber(),Method,* Returns the current line number\n     *\n     * @return the current line number,long getCurrentLineNumber() {\n    return reader.getLineNumber();\n},long getCurrentLineNumber(),"digraph cfg_getCurrentLineNumber {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.ExtendedBufferedReader: long getLineNumber()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.getFirstEol(),Method,No Comment,String getFirstEol() {\n    return firstEol;\n},java.lang.String getFirstEol(),"digraph cfg_getFirstEol {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.Lexer: java.lang.String firstEol>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.isClosed(),Method,No Comment,boolean isClosed() {\n    return reader.isClosed();\n},boolean isClosed(),"digraph cfg_isClosed {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""2"" [label=""$stack2 = virtualinvoke $stack1.<org.apache.commons.csv.ExtendedBufferedReader: boolean isClosed()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.isCommentStart(int),Method,No Comment,boolean isCommentStart(final int ch) {\n    return ch == commentStart;\n},boolean isCommentStart(int),"digraph cfg_isCommentStart {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.Lexer: int commentStart>""];\n	""2"" [label=""$stack3 = 0""];\n	""3"" [label=""$stack3 = 1""];\n	""4"" [label=""ch := @parameter0: int""];\n	""5"" [label=""goto""];\n	""6"" [label=""if ch != $stack2""];\n	""7"" [label=""return $stack3""];\n	""8"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_goto""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""6"" -> ""3""[label=""cfg_false""];\n	""8"" -> ""4""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.isDelimiter(int),Method,* Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#peek(char[])}.\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs.,"boolean isDelimiter(final int ch) throws IOException {\n    isLastTokenDelimiter = false;\n    if (ch != delimiter[0]) {\n        return false;\n    }\n    if (delimiter.length == 1) {\n        isLastTokenDelimiter = true;\n        return true;\n    }\n    reader.peek(delimiterBuf);\n    for (int i = 0; i < delimiterBuf.length; i++) {\n        if (delimiterBuf[i] != delimiter[i + 1]) {\n            return false;\n        }\n    }\n    final int count = reader.read(delimiterBuf, 0, delimiterBuf.length);\n    isLastTokenDelimiter = count != EOF;\n    return isLastTokenDelimiter;\n}",boolean isDelimiter(int),"digraph cfg_isDelimiter {\n	""1"" [label=""$stack10 = lengthof $stack9""];\n	""2"" [label=""$stack11 = this.<org.apache.commons.csv.Lexer: char[] delimiterBuf>""];\n	""3"" [label=""$stack12 = lengthof $stack11""];\n	""4"" [label=""$stack13 = this.<org.apache.commons.csv.Lexer: char[] delimiterBuf>""];\n	""5"" [label=""$stack14 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""6"" [label=""$stack15 = this.<org.apache.commons.csv.Lexer: boolean isLastTokenDelimiter>""];\n	""7"" [label=""$stack16 = 0""];\n	""8"" [label=""$stack16 = 1""];\n	""9"" [label=""$stack17 = this.<org.apache.commons.csv.Lexer: char[] delimiterBuf>""];\n	""10"" [label=""$stack18 = this.<org.apache.commons.csv.Lexer: char[] delimiter>""];\n	""11"" [label=""$stack19 = i + 1""];\n	""12"" [label=""$stack20 = $stack18[$stack19]""];\n	""13"" [label=""$stack21 = $stack17[i]""];\n	""14"" [label=""$stack3 = this.<org.apache.commons.csv.Lexer: char[] delimiter>""];\n	""15"" [label=""$stack4 = $stack3[0]""];\n	""16"" [label=""$stack5 = this.<org.apache.commons.csv.Lexer: char[] delimiter>""];\n	""17"" [label=""$stack6 = lengthof $stack5""];\n	""18"" [label=""$stack7 = this.<org.apache.commons.csv.Lexer: char[] delimiterBuf>""];\n	""19"" [label=""$stack8 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""20"" [label=""$stack9 = this.<org.apache.commons.csv.Lexer: char[] delimiterBuf>""];\n	""21"" [label=""ch := @parameter0: int""];\n	""22"" [label=""goto""];\n	""23"" [label=""goto""];\n	""24"" [label=""i = 0""];\n	""25"" [label=""i = i + 1""];\n	""26"" [label=""i = virtualinvoke $stack14.<org.apache.commons.csv.ExtendedBufferedReader: int read(char[],int,int)>($stack13, 0, $stack12)""];\n	""27"" [label=""if $stack21 == $stack20""];\n	""28"" [label=""if $stack6 != 1""];\n	""29"" [label=""if ch == $stack4""];\n	""30"" [label=""if i == -1""];\n	""31"" [label=""if i >= $stack10""];\n	""32"" [label=""return $stack15""];\n	""33"" [label=""return 0""];\n	""34"" [label=""return 0""];\n	""35"" [label=""return 1""];\n	""36"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""37"" [label=""this.<org.apache.commons.csv.Lexer: boolean isLastTokenDelimiter> = $stack16""];\n	""38"" [label=""this.<org.apache.commons.csv.Lexer: boolean isLastTokenDelimiter> = 0""];\n	""39"" [label=""this.<org.apache.commons.csv.Lexer: boolean isLastTokenDelimiter> = 1""];\n	""40"" [label=""virtualinvoke $stack8.<org.apache.commons.csv.ExtendedBufferedReader: int peek(char[])>($stack7)""];\n	""1"" -> ""31""[label=""cfg_next""];\n	""10"" -> ""11""[label=""cfg_next""];\n	""11"" -> ""12""[label=""cfg_next""];\n	""12"" -> ""27""[label=""cfg_next""];\n	""13"" -> ""10""[label=""cfg_next""];\n	""14"" -> ""15""[label=""cfg_next""];\n	""15"" -> ""29""[label=""cfg_next""];\n	""16"" -> ""17""[label=""cfg_next""];\n	""17"" -> ""28""[label=""cfg_next""];\n	""18"" -> ""40""[label=""cfg_next""];\n	""19"" -> ""18""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""20"" -> ""1""[label=""cfg_next""];\n	""21"" -> ""38""[label=""cfg_next""];\n	""22"" -> ""20""[label=""cfg_goto""];\n	""23"" -> ""37""[label=""cfg_goto""];\n	""24"" -> ""20""[label=""cfg_next""];\n	""25"" -> ""22""[label=""cfg_next""];\n	""26"" -> ""30""[label=""cfg_next""];\n	""27"" -> ""25""[label=""cfg_true""];\n	""27"" -> ""34""[label=""cfg_false""];\n	""28"" -> ""19""[label=""cfg_true""];\n	""28"" -> ""39""[label=""cfg_false""];\n	""29"" -> ""16""[label=""cfg_true""];\n	""29"" -> ""33""[label=""cfg_false""];\n	""3"" -> ""26""[label=""cfg_next""];\n	""30"" -> ""7""[label=""cfg_true""];\n	""30"" -> ""8""[label=""cfg_false""];\n	""31"" -> ""5""[label=""cfg_true""];\n	""31"" -> ""9""[label=""cfg_false""];\n	""36"" -> ""21""[label=""cfg_next""];\n	""37"" -> ""6""[label=""cfg_next""];\n	""38"" -> ""14""[label=""cfg_next""];\n	""39"" -> ""35""[label=""cfg_next""];\n	""4"" -> ""2""[label=""cfg_next""];\n	""40"" -> ""24""[label=""cfg_next""];\n	""5"" -> ""4""[label=""cfg_next""];\n	""6"" -> ""32""[label=""cfg_next""];\n	""7"" -> ""37""[label=""cfg_next""];\n	""8"" -> ""23""[label=""cfg_next""];\n	""9"" -> ""13""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.isEndOfFile(int),Method,* Tests if the given character indicates the end of the file.\n     *\n     * @return true if the given character indicates the end of the file.,boolean isEndOfFile(final int ch) {\n    return ch == EOF;\n},boolean isEndOfFile(int),"digraph cfg_isEndOfFile {\n	""1"" [label=""$stack2 = 0""];\n	""2"" [label=""$stack2 = 1""];\n	""3"" [label=""ch := @parameter0: int""];\n	""4"" [label=""goto""];\n	""5"" [label=""if ch != -1""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""1""[label=""cfg_true""];\n	""5"" -> ""2""[label=""cfg_false""];\n	""7"" -> ""3""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.isEscape(int),Method,* Tests if the given character is the escape character.\n     *\n     * @return true if the given character is the escape character.,boolean isEscape(final int ch) {\n    return ch == escape;\n},boolean isEscape(int),"digraph cfg_isEscape {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.Lexer: int escape>""];\n	""2"" [label=""$stack3 = 0""];\n	""3"" [label=""$stack3 = 1""];\n	""4"" [label=""ch := @parameter0: int""];\n	""5"" [label=""goto""];\n	""6"" [label=""if ch != $stack2""];\n	""7"" [label=""return $stack3""];\n	""8"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_goto""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""6"" -> ""3""[label=""cfg_false""];\n	""8"" -> ""4""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.isEscapeDelimiter(),Method,"* Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#peek(char[])}.\n     *\n     * For example, for delimiter ""[|]"" and escape '!', return true if the next characters constitute ""![!|!]"".\n     *\n     * @return true if the next characters constitute an escape delimiter.\n     * @throws IOException If an I/O error occurs.","boolean isEscapeDelimiter() throws IOException {\n    reader.peek(escapeDelimiterBuf);\n    if (escapeDelimiterBuf[0] != delimiter[0]) {\n        return false;\n    }\n    for (int i = 1; i < delimiter.length; i++) {\n        if (escapeDelimiterBuf[2 * i] != delimiter[i] || escapeDelimiterBuf[2 * i - 1] != escape) {\n            return false;\n        }\n    }\n    final int count = reader.read(escapeDelimiterBuf, 0, escapeDelimiterBuf.length);\n    return count != EOF;\n}",boolean isEscapeDelimiter(),"digraph cfg_isEscapeDelimiter {\n	""1"" [label=""$stack10 = this.<org.apache.commons.csv.Lexer: char[] escapeDelimiterBuf>""];\n	""2"" [label=""$stack11 = lengthof $stack10""];\n	""3"" [label=""$stack12 = this.<org.apache.commons.csv.Lexer: char[] escapeDelimiterBuf>""];\n	""4"" [label=""$stack13 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""5"" [label=""$stack14 = 0""];\n	""6"" [label=""$stack14 = 1""];\n	""7"" [label=""$stack15 = this.<org.apache.commons.csv.Lexer: char[] escapeDelimiterBuf>""];\n	""8"" [label=""$stack16 = 2 * i""];\n	""9"" [label=""$stack17 = this.<org.apache.commons.csv.Lexer: char[] delimiter>""];\n	""10"" [label=""$stack18 = $stack17[i]""];\n	""11"" [label=""$stack19 = $stack15[$stack16]""];\n	""12"" [label=""$stack2 = this.<org.apache.commons.csv.Lexer: char[] escapeDelimiterBuf>""];\n	""13"" [label=""$stack20 = 2 * i""];\n	""14"" [label=""$stack21 = this.<org.apache.commons.csv.Lexer: char[] escapeDelimiterBuf>""];\n	""15"" [label=""$stack22 = $stack20 - 1""];\n	""16"" [label=""$stack23 = this.<org.apache.commons.csv.Lexer: int escape>""];\n	""17"" [label=""$stack24 = $stack21[$stack22]""];\n	""18"" [label=""$stack3 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""19"" [label=""$stack4 = this.<org.apache.commons.csv.Lexer: char[] escapeDelimiterBuf>""];\n	""20"" [label=""$stack5 = this.<org.apache.commons.csv.Lexer: char[] delimiter>""];\n	""21"" [label=""$stack6 = $stack5[0]""];\n	""22"" [label=""$stack7 = $stack4[0]""];\n	""23"" [label=""$stack8 = this.<org.apache.commons.csv.Lexer: char[] delimiter>""];\n	""24"" [label=""$stack9 = lengthof $stack8""];\n	""25"" [label=""goto""];\n	""26"" [label=""goto""];\n	""27"" [label=""i = 1""];\n	""28"" [label=""i = i + 1""];\n	""29"" [label=""i = virtualinvoke $stack13.<org.apache.commons.csv.ExtendedBufferedReader: int read(char[],int,int)>($stack12, 0, $stack11)""];\n	""30"" [label=""if $stack19 != $stack18""];\n	""31"" [label=""if $stack24 == $stack23""];\n	""32"" [label=""if $stack7 == $stack6""];\n	""33"" [label=""if i == -1""];\n	""34"" [label=""if i >= $stack9""];\n	""35"" [label=""return $stack14""];\n	""36"" [label=""return 0""];\n	""37"" [label=""return 0""];\n	""38"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""39"" [label=""virtualinvoke $stack3.<org.apache.commons.csv.ExtendedBufferedReader: int peek(char[])>($stack2)""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""30""[label=""cfg_next""];\n	""11"" -> ""9""[label=""cfg_next""];\n	""12"" -> ""39""[label=""cfg_next""];\n	""13"" -> ""15""[label=""cfg_next""];\n	""14"" -> ""13""[label=""cfg_next""];\n	""15"" -> ""17""[label=""cfg_next""];\n	""16"" -> ""31""[label=""cfg_next""];\n	""17"" -> ""16""[label=""cfg_next""];\n	""18"" -> ""12""[label=""cfg_next""];\n	""19"" -> ""22""[label=""cfg_next""];\n	""2"" -> ""29""[label=""cfg_next""];\n	""20"" -> ""21""[label=""cfg_next""];\n	""21"" -> ""32""[label=""cfg_next""];\n	""22"" -> ""20""[label=""cfg_next""];\n	""23"" -> ""24""[label=""cfg_next""];\n	""24"" -> ""34""[label=""cfg_next""];\n	""25"" -> ""23""[label=""cfg_goto""];\n	""26"" -> ""35""[label=""cfg_goto""];\n	""27"" -> ""23""[label=""cfg_next""];\n	""28"" -> ""25""[label=""cfg_next""];\n	""29"" -> ""33""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""30"" -> ""14""[label=""cfg_false""];\n	""30"" -> ""37""[label=""cfg_true""];\n	""31"" -> ""28""[label=""cfg_true""];\n	""31"" -> ""37""[label=""cfg_false""];\n	""32"" -> ""27""[label=""cfg_true""];\n	""32"" -> ""36""[label=""cfg_false""];\n	""33"" -> ""5""[label=""cfg_true""];\n	""33"" -> ""6""[label=""cfg_false""];\n	""34"" -> ""4""[label=""cfg_true""];\n	""34"" -> ""7""[label=""cfg_false""];\n	""38"" -> ""18""[label=""cfg_next""];\n	""39"" -> ""19""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""5"" -> ""35""[label=""cfg_next""];\n	""6"" -> ""26""[label=""cfg_next""];\n	""7"" -> ""8""[label=""cfg_next""];\n	""8"" -> ""11""[label=""cfg_next""];\n	""9"" -> ""10""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.isMetaChar(int),Method,No Comment,private boolean isMetaChar(final int ch) {\n    return ch == escape || ch == quoteChar || ch == commentStart;\n},boolean isMetaChar(int),"digraph cfg_isMetaChar {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.Lexer: int escape>""];\n	""2"" [label=""$stack3 = this.<org.apache.commons.csv.Lexer: int quoteChar>""];\n	""3"" [label=""$stack4 = this.<org.apache.commons.csv.Lexer: int commentStart>""];\n	""4"" [label=""$stack5 = 0""];\n	""5"" [label=""$stack5 = 1""];\n	""6"" [label=""ch := @parameter0: int""];\n	""7"" [label=""goto""];\n	""8"" [label=""if ch != $stack4""];\n	""9"" [label=""if ch == $stack2""];\n	""10"" [label=""if ch == $stack3""];\n	""11"" [label=""return $stack5""];\n	""12"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""9""[label=""cfg_next""];\n	""10"" -> ""3""[label=""cfg_false""];\n	""10"" -> ""5""[label=""cfg_true""];\n	""12"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""10""[label=""cfg_next""];\n	""3"" -> ""8""[label=""cfg_next""];\n	""4"" -> ""11""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n	""7"" -> ""11""[label=""cfg_goto""];\n	""8"" -> ""4""[label=""cfg_true""];\n	""8"" -> ""5""[label=""cfg_false""];\n	""9"" -> ""2""[label=""cfg_false""];\n	""9"" -> ""5""[label=""cfg_true""];\n}\n",private 
org.apache.commons.csv.Lexer.isQuoteChar(int),Method,No Comment,boolean isQuoteChar(final int ch) {\n    return ch == quoteChar;\n},boolean isQuoteChar(int),"digraph cfg_isQuoteChar {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.Lexer: int quoteChar>""];\n	""2"" [label=""$stack3 = 0""];\n	""3"" [label=""$stack3 = 1""];\n	""4"" [label=""ch := @parameter0: int""];\n	""5"" [label=""goto""];\n	""6"" [label=""if ch != $stack2""];\n	""7"" [label=""return $stack3""];\n	""8"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_goto""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""6"" -> ""3""[label=""cfg_false""];\n	""8"" -> ""4""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.isStartOfLine(int),Method,"* Tests if the current character represents the start of a line: a CR, LF, or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line.",boolean isStartOfLine(final int ch) {\n    return ch == Constants.LF || ch == Constants.CR || ch == Constants.UNDEFINED;\n},boolean isStartOfLine(int),"digraph cfg_isStartOfLine {\n	""1"" [label=""$stack2 = 0""];\n	""2"" [label=""$stack2 = 1""];\n	""3"" [label=""ch := @parameter0: int""];\n	""4"" [label=""goto""];\n	""5"" [label=""if ch != -2""];\n	""6"" [label=""if ch == 10""];\n	""7"" [label=""if ch == 13""];\n	""8"" [label=""return $stack2""];\n	""9"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""8""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""6""[label=""cfg_next""];\n	""4"" -> ""8""[label=""cfg_goto""];\n	""5"" -> ""1""[label=""cfg_true""];\n	""5"" -> ""2""[label=""cfg_false""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""6"" -> ""7""[label=""cfg_false""];\n	""7"" -> ""2""[label=""cfg_true""];\n	""7"" -> ""5""[label=""cfg_false""];\n	""9"" -> ""3""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.nextToken(Token),Method,"* Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token an existing Token object to reuse. The caller is responsible for initializing the Token.\n     * @return the next token found.\n     * @throws IOException  on stream access error.\n     * @throws CSVException Thrown on invalid input.","Token nextToken(final Token token) throws IOException {\n    // Get the last read char (required for empty line detection)\n    int lastChar = reader.getLastChar();\n    // read the next char and set eol\n    int c = reader.read();\n    // Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF - they are equivalent here.\n    boolean eol = readEndOfLine(c);\n    // empty line detection: eol AND (last char was EOL or beginning)\n    if (ignoreEmptyLines) {\n        while (eol && isStartOfLine(lastChar)) {\n            // Go on char ahead ...\n            lastChar = c;\n            c = reader.read();\n            eol = readEndOfLine(c);\n            // reached the end of the file without any content (empty line at the end)\n            if (isEndOfFile(c)) {\n                token.type = Token.Type.EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n        }\n    }\n    // Did we reach EOF during the last iteration already? EOF\n    if (isEndOfFile(lastChar) || !isLastTokenDelimiter && isEndOfFile(c)) {\n        token.type = Token.Type.EOF;\n        // don't set token.isReady here because no content\n        return token;\n    }\n    if (isStartOfLine(lastChar) && isCommentStart(c)) {\n        final String line = reader.readLine();\n        if (line == null) {\n            token.type = Token.Type.EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n        final String comment = line.trim();\n        token.content.append(comment);\n        token.type = Token.Type.COMMENT;\n        return token;\n    }\n    // Important: make sure a new char gets consumed in each iteration\n    while (token.type == Token.Type.INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (Character.isWhitespace((char) c) && !isDelimiter(c) && !eol) {\n                c = reader.read();\n                eol = readEndOfLine(c);\n            }\n        }\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(c)) {\n            // empty token return TOKEN("""")\n            token.type = Token.Type.TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD("""")\n            // noop: token.content.append("""");\n            token.type = Token.Type.EORECORD;\n        } else if (isQuoteChar(c)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(c)) {\n            // end of file return EOF()\n            // noop: token.content.append("""");\n            token.type = Token.Type.EOF;\n            // there is data at EOF\n            token.isReady = true;\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            parseSimpleToken(token, c);\n        }\n    }\n    return token;\n}",org.apache.commons.csv.Token nextToken(org.apache.commons.csv.Token),"digraph cfg_nextToken {\n	""1"" [label=""$stack10 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEndOfFile(int)>(lastChar)""];\n	""2"" [label=""$stack11 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EOF>""];\n	""3"" [label=""$stack12 = this.<org.apache.commons.csv.Lexer: boolean isLastTokenDelimiter>""];\n	""4"" [label=""$stack13 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isStartOfLine(int)>(lastChar)""];\n	""5"" [label=""$stack14 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type INVALID>""];\n	""6"" [label=""$stack15 = token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type>""];\n	""7"" [label=""$stack16 = this.<org.apache.commons.csv.Lexer: boolean ignoreSurroundingSpaces>""];\n	""8"" [label=""$stack17 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isDelimiter(int)>(c)""];\n	""9"" [label=""$stack18 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isQuoteChar(int)>(c)""];\n	""10"" [label=""$stack19 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEndOfFile(int)>(c)""];\n	""11"" [label=""$stack20 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EOF>""];\n	""12"" [label=""$stack21 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EORECORD>""];\n	""13"" [label=""$stack22 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type TOKEN>""];\n	""14"" [label=""$stack23 = (char) c""];\n	""15"" [label=""$stack24 = staticinvoke <java.lang.Character: boolean isWhitespace(char)>($stack23)""];\n	""16"" [label=""$stack25 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isDelimiter(int)>(c)""];\n	""17"" [label=""$stack26 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""18"" [label=""$stack27 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isCommentStart(int)>(c)""];\n	""19"" [label=""$stack28 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""20"" [label=""$stack29 = token.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""21"" [label=""$stack30 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type COMMENT>""];\n	""22"" [label=""$stack31 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EOF>""];\n	""23"" [label=""$stack32 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEndOfFile(int)>(c)""];\n	""24"" [label=""$stack33 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isStartOfLine(int)>(lastChar)""];\n	""25"" [label=""$stack34 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""26"" [label=""$stack35 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEndOfFile(int)>(c)""];\n	""27"" [label=""$stack36 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EOF>""];\n	""28"" [label=""$stack7 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""29"" [label=""$stack8 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""30"" [label=""$stack9 = this.<org.apache.commons.csv.Lexer: boolean ignoreEmptyLines>""];\n	""31"" [label=""c = virtualinvoke $stack26.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""32"" [label=""c = virtualinvoke $stack34.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""33"" [label=""c = virtualinvoke $stack8.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""34"" [label=""comment = virtualinvoke line.<java.lang.String: java.lang.String trim()>()""];\n	""35"" [label=""eol = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean readEndOfLine(int)>(c)""];\n	""36"" [label=""eol = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean readEndOfLine(int)>(c)""];\n	""37"" [label=""eol = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean readEndOfLine(int)>(c)""];\n	""38"" [label=""goto""];\n	""39"" [label=""goto""];\n	""40"" [label=""goto""];\n	""41"" [label=""goto""];\n	""42"" [label=""goto""];\n	""43"" [label=""goto""];\n	""44"" [label=""if $stack10 != 0""];\n	""45"" [label=""if $stack12 != 0""];\n	""46"" [label=""if $stack13 == 0""];\n	""47"" [label=""if $stack15 != $stack14""];\n	""48"" [label=""if $stack16 == 0""];\n	""49"" [label=""if $stack17 == 0""];\n	""50"" [label=""if $stack18 == 0""];\n	""51"" [label=""if $stack19 == 0""];\n	""52"" [label=""if $stack24 == 0""];\n	""53"" [label=""if $stack25 != 0""];\n	""54"" [label=""if $stack27 == 0""];\n	""55"" [label=""if $stack32 == 0""];\n	""56"" [label=""if $stack33 == 0""];\n	""57"" [label=""if $stack35 == 0""];\n	""58"" [label=""if $stack9 == 0""];\n	""59"" [label=""if eol != 0""];\n	""60"" [label=""if eol == 0""];\n	""61"" [label=""if eol == 0""];\n	""62"" [label=""if line != null""];\n	""63"" [label=""lastChar = c""];\n	""64"" [label=""lastChar = virtualinvoke $stack7.<org.apache.commons.csv.ExtendedBufferedReader: int getLastChar()>()""];\n	""65"" [label=""line = virtualinvoke $stack28.<org.apache.commons.csv.ExtendedBufferedReader: java.lang.String readLine()>()""];\n	""66"" [label=""return token""];\n	""67"" [label=""return token""];\n	""68"" [label=""return token""];\n	""69"" [label=""return token""];\n	""70"" [label=""return token""];\n	""71"" [label=""specialinvoke this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.Token parseEncapsulatedToken(org.apache.commons.csv.Token)>(token)""];\n	""72"" [label=""specialinvoke this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.Token parseSimpleToken(org.apache.commons.csv.Token,int)>(token, c)""];\n	""73"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""74"" [label=""token := @parameter0: org.apache.commons.csv.Token""];\n	""75"" [label=""token.<org.apache.commons.csv.Token: boolean isReady> = 1""];\n	""76"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack11""];\n	""77"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack20""];\n	""78"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack21""];\n	""79"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack22""];\n	""80"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack30""];\n	""81"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack31""];\n	""82"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack36""];\n	""83"" [label=""virtualinvoke $stack29.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(comment)""];\n	""1"" -> ""44""[label=""cfg_next""];\n	""10"" -> ""51""[label=""cfg_next""];\n	""11"" -> ""77""[label=""cfg_next""];\n	""12"" -> ""78""[label=""cfg_next""];\n	""13"" -> ""79""[label=""cfg_next""];\n	""14"" -> ""15""[label=""cfg_next""];\n	""15"" -> ""52""[label=""cfg_next""];\n	""16"" -> ""53""[label=""cfg_next""];\n	""17"" -> ""31""[label=""cfg_next""];\n	""18"" -> ""54""[label=""cfg_next""];\n	""19"" -> ""65""[label=""cfg_next""];\n	""2"" -> ""76""[label=""cfg_next""];\n	""20"" -> ""83""[label=""cfg_next""];\n	""21"" -> ""80""[label=""cfg_next""];\n	""22"" -> ""81""[label=""cfg_next""];\n	""23"" -> ""55""[label=""cfg_next""];\n	""24"" -> ""56""[label=""cfg_next""];\n	""25"" -> ""32""[label=""cfg_next""];\n	""26"" -> ""57""[label=""cfg_next""];\n	""27"" -> ""82""[label=""cfg_next""];\n	""28"" -> ""64""[label=""cfg_next""];\n	""29"" -> ""33""[label=""cfg_next""];\n	""3"" -> ""45""[label=""cfg_next""];\n	""30"" -> ""58""[label=""cfg_next""];\n	""31"" -> ""37""[label=""cfg_next""];\n	""32"" -> ""36""[label=""cfg_next""];\n	""33"" -> ""35""[label=""cfg_next""];\n	""34"" -> ""20""[label=""cfg_next""];\n	""35"" -> ""30""[label=""cfg_next""];\n	""36"" -> ""26""[label=""cfg_next""];\n	""37"" -> ""38""[label=""cfg_next""];\n	""38"" -> ""14""[label=""cfg_goto""];\n	""39"" -> ""6""[label=""cfg_goto""];\n	""4"" -> ""46""[label=""cfg_next""];\n	""40"" -> ""6""[label=""cfg_goto""];\n	""41"" -> ""6""[label=""cfg_goto""];\n	""42"" -> ""6""[label=""cfg_goto""];\n	""43"" -> ""6""[label=""cfg_goto""];\n	""44"" -> ""2""[label=""cfg_true""];\n	""44"" -> ""3""[label=""cfg_false""];\n	""45"" -> ""23""[label=""cfg_false""];\n	""45"" -> ""4""[label=""cfg_true""];\n	""46"" -> ""18""[label=""cfg_false""];\n	""46"" -> ""6""[label=""cfg_true""];\n	""47"" -> ""69""[label=""cfg_true""];\n	""47"" -> ""7""[label=""cfg_false""];\n	""48"" -> ""14""[label=""cfg_false""];\n	""48"" -> ""8""[label=""cfg_true""];\n	""49"" -> ""13""[label=""cfg_false""];\n	""49"" -> ""61""[label=""cfg_true""];\n	""5"" -> ""47""[label=""cfg_next""];\n	""50"" -> ""10""[label=""cfg_true""];\n	""50"" -> ""71""[label=""cfg_false""];\n	""51"" -> ""11""[label=""cfg_false""];\n	""51"" -> ""72""[label=""cfg_true""];\n	""52"" -> ""16""[label=""cfg_false""];\n	""52"" -> ""8""[label=""cfg_true""];\n	""53"" -> ""59""[label=""cfg_false""];\n	""53"" -> ""8""[label=""cfg_true""];\n	""54"" -> ""19""[label=""cfg_false""];\n	""54"" -> ""6""[label=""cfg_true""];\n	""55"" -> ""2""[label=""cfg_false""];\n	""55"" -> ""4""[label=""cfg_true""];\n	""56"" -> ""1""[label=""cfg_true""];\n	""56"" -> ""63""[label=""cfg_false""];\n	""57"" -> ""27""[label=""cfg_false""];\n	""57"" -> ""60""[label=""cfg_true""];\n	""58"" -> ""1""[label=""cfg_true""];\n	""58"" -> ""60""[label=""cfg_false""];\n	""59"" -> ""17""[label=""cfg_false""];\n	""59"" -> ""8""[label=""cfg_true""];\n	""6"" -> ""5""[label=""cfg_next""];\n	""60"" -> ""1""[label=""cfg_true""];\n	""60"" -> ""24""[label=""cfg_false""];\n	""61"" -> ""12""[label=""cfg_false""];\n	""61"" -> ""9""[label=""cfg_true""];\n	""62"" -> ""22""[label=""cfg_false""];\n	""62"" -> ""34""[label=""cfg_true""];\n	""63"" -> ""25""[label=""cfg_next""];\n	""64"" -> ""29""[label=""cfg_next""];\n	""65"" -> ""62""[label=""cfg_next""];\n	""7"" -> ""48""[label=""cfg_next""];\n	""71"" -> ""41""[label=""cfg_next""];\n	""72"" -> ""43""[label=""cfg_next""];\n	""73"" -> ""74""[label=""cfg_next""];\n	""74"" -> ""28""[label=""cfg_next""];\n	""75"" -> ""42""[label=""cfg_next""];\n	""76"" -> ""67""[label=""cfg_next""];\n	""77"" -> ""75""[label=""cfg_next""];\n	""78"" -> ""40""[label=""cfg_next""];\n	""79"" -> ""39""[label=""cfg_next""];\n	""8"" -> ""49""[label=""cfg_next""];\n	""80"" -> ""70""[label=""cfg_next""];\n	""81"" -> ""68""[label=""cfg_next""];\n	""82"" -> ""66""[label=""cfg_next""];\n	""83"" -> ""21""[label=""cfg_next""];\n	""9"" -> ""50""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.nullToDisabled(Character),Method,No Comment,private int nullToDisabled(final Character c) {\n    // Explicit unboxing\n    return c == null ? Constants.UNDEFINED : c.charValue();\n},int nullToDisabled(java.lang.Character),"digraph cfg_nullToDisabled {\n	""1"" [label=""$stack2 = -2""];\n	""2"" [label=""$stack2 = virtualinvoke c.<java.lang.Character: char charValue()>()""];\n	""3"" [label=""c := @parameter0: java.lang.Character""];\n	""4"" [label=""goto""];\n	""5"" [label=""if c != null""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""1""[label=""cfg_false""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""7"" -> ""3""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.Lexer.parseEncapsulatedToken(Token),Method,"* Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as """", '') or using escaping (as in \"", \'). Whitespaces before and after\n     * an encapsulated token is ignored. The token is finished when one of the following conditions becomes true:\n     * </p>\n     * <ul>\n     * <li>An unescaped encapsulator has been reached and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             Thrown when in an invalid state: EOF before closing encapsulator or invalid character before\n     *             delimiter or EOL.\n     * @throws CSVException Thrown on invalid input.","private Token parseEncapsulatedToken(final Token token) throws IOException {\n    token.isQuoted = true;\n    // Save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        if (isQuoteChar(c)) {\n            if (isQuoteChar(reader.peek())) {\n                // double or escaped encapsulator -> add single encapsulator to token\n                c = reader.read();\n                token.content.append((char) c);\n            } else {\n                // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                while (true) {\n                    c = reader.read();\n                    if (isDelimiter(c)) {\n                        token.type = Token.Type.TOKEN;\n                        return token;\n                    }\n                    if (isEndOfFile(c)) {\n                        token.type = Token.Type.EOF;\n                        // There is data at EOF\n                        token.isReady = true;\n                        return token;\n                    }\n                    if (readEndOfLine(c)) {\n                        token.type = Token.Type.EORECORD;\n                        return token;\n                    }\n                    if (trailingData) {\n                        token.content.append((char) c);\n                    } else if (!Character.isWhitespace((char) c)) {\n                        // error invalid char between token and next delimiter\n                        throw new CSVException(""Invalid character between encapsulated token and delimiter at line: %,d, position: %,d"", getCurrentLineNumber(), getCharacterPosition());\n                    }\n                }\n            }\n        } else if (isEscape(c)) {\n            appendNextEscapedCharacterToToken(token);\n        } else if (isEndOfFile(c)) {\n            if (lenientEof) {\n                token.type = Token.Type.EOF;\n                // There is data at EOF\n                token.isReady = true;\n                return token;\n            }\n            // error condition (end of file before end of token)\n            throw new CSVException(""(startline %,d) EOF reached before encapsulated token finished"", startLineNumber);\n        } else {\n            // consume character\n            token.content.append((char) c);\n        }\n    }\n}",org.apache.commons.csv.Token parseEncapsulatedToken(org.apache.commons.csv.Token),"digraph cfg_parseEncapsulatedToken {\n	""1"" [label=""$stack10 = token.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""2"" [label=""$stack11 = this.<org.apache.commons.csv.Lexer: boolean lenientEof>""];\n	""3"" [label=""$stack12 = newarray (java.lang.Object)[1]""];\n	""4"" [label=""$stack12[0] = $stack13""];\n	""5"" [label=""$stack13 = staticinvoke <java.lang.Long: java.lang.Long valueOf(long)>(startLineNumber)""];\n	""6"" [label=""$stack14 = new org.apache.commons.csv.CSVException""];\n	""7"" [label=""$stack15 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EOF>""];\n	""8"" [label=""$stack16 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""9"" [label=""$stack17 = virtualinvoke $stack16.<org.apache.commons.csv.ExtendedBufferedReader: int peek()>()""];\n	""10"" [label=""$stack18 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isQuoteChar(int)>($stack17)""];\n	""11"" [label=""$stack19 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""12"" [label=""$stack20 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isDelimiter(int)>(c)""];\n	""13"" [label=""$stack21 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEndOfFile(int)>(c)""];\n	""14"" [label=""$stack22 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean readEndOfLine(int)>(c)""];\n	""15"" [label=""$stack23 = this.<org.apache.commons.csv.Lexer: boolean trailingData>""];\n	""16"" [label=""$stack24 = (char) c""];\n	""17"" [label=""$stack25 = staticinvoke <java.lang.Character: boolean isWhitespace(char)>($stack24)""];\n	""18"" [label=""$stack26 = virtualinvoke this.<org.apache.commons.csv.Lexer: long getCurrentLineNumber()>()""];\n	""19"" [label=""$stack27 = newarray (java.lang.Object)[2]""];\n	""20"" [label=""$stack27[0] = $stack28""];\n	""21"" [label=""$stack27[1] = $stack30""];\n	""22"" [label=""$stack28 = staticinvoke <java.lang.Long: java.lang.Long valueOf(long)>($stack26)""];\n	""23"" [label=""$stack29 = virtualinvoke this.<org.apache.commons.csv.Lexer: long getCharacterPosition()>()""];\n	""24"" [label=""$stack30 = staticinvoke <java.lang.Long: java.lang.Long valueOf(long)>($stack29)""];\n	""25"" [label=""$stack31 = new org.apache.commons.csv.CSVException""];\n	""26"" [label=""$stack32 = (char) c""];\n	""27"" [label=""$stack33 = token.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""28"" [label=""$stack34 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EORECORD>""];\n	""29"" [label=""$stack35 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EOF>""];\n	""30"" [label=""$stack36 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type TOKEN>""];\n	""31"" [label=""$stack37 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""32"" [label=""$stack38 = (char) c""];\n	""33"" [label=""$stack39 = token.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""34"" [label=""$stack5 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""35"" [label=""$stack6 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isQuoteChar(int)>(c)""];\n	""36"" [label=""$stack7 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEscape(int)>(c)""];\n	""37"" [label=""$stack8 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEndOfFile(int)>(c)""];\n	""38"" [label=""$stack9 = (char) c""];\n	""39"" [label=""c = virtualinvoke $stack19.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""40"" [label=""c = virtualinvoke $stack37.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""41"" [label=""c = virtualinvoke $stack5.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""42"" [label=""goto""];\n	""43"" [label=""goto""];\n	""44"" [label=""goto""];\n	""45"" [label=""goto""];\n	""46"" [label=""if $stack11 == 0""];\n	""47"" [label=""if $stack18 == 0""];\n	""48"" [label=""if $stack20 == 0""];\n	""49"" [label=""if $stack21 == 0""];\n	""50"" [label=""if $stack22 == 0""];\n	""51"" [label=""if $stack23 == 0""];\n	""52"" [label=""if $stack25 != 0""];\n	""53"" [label=""if $stack6 == 0""];\n	""54"" [label=""if $stack7 == 0""];\n	""55"" [label=""if $stack8 == 0""];\n	""56"" [label=""return token""];\n	""57"" [label=""return token""];\n	""58"" [label=""return token""];\n	""59"" [label=""return token""];\n	""60"" [label=""specialinvoke $stack14.<org.apache.commons.csv.CSVException: void <init>(java.lang.String,java.lang.Object[])>(\""(startline %,d) EOF reached before encapsulated token finished\"", $stack12)""];\n	""61"" [label=""specialinvoke $stack31.<org.apache.commons.csv.CSVException: void <init>(java.lang.String,java.lang.Object[])>(\""Invalid character between encapsulated token and delimiter at line: %,d, position: %,d\"", $stack27)""];\n	""62"" [label=""specialinvoke this.<org.apache.commons.csv.Lexer: void appendNextEscapedCharacterToToken(org.apache.commons.csv.Token)>(token)""];\n	""63"" [label=""startLineNumber = virtualinvoke this.<org.apache.commons.csv.Lexer: long getCurrentLineNumber()>()""];\n	""64"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""65"" [label=""throw $stack14""];\n	""66"" [label=""throw $stack31""];\n	""67"" [label=""token := @parameter0: org.apache.commons.csv.Token""];\n	""68"" [label=""token.<org.apache.commons.csv.Token: boolean isQuoted> = 1""];\n	""69"" [label=""token.<org.apache.commons.csv.Token: boolean isReady> = 1""];\n	""70"" [label=""token.<org.apache.commons.csv.Token: boolean isReady> = 1""];\n	""71"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack15""];\n	""72"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack34""];\n	""73"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack35""];\n	""74"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack36""];\n	""75"" [label=""virtualinvoke $stack10.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack9)""];\n	""76"" [label=""virtualinvoke $stack33.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack32)""];\n	""77"" [label=""virtualinvoke $stack39.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack38)""];\n	""1"" -> ""38""[label=""cfg_next""];\n	""10"" -> ""47""[label=""cfg_next""];\n	""11"" -> ""39""[label=""cfg_next""];\n	""12"" -> ""48""[label=""cfg_next""];\n	""13"" -> ""49""[label=""cfg_next""];\n	""14"" -> ""50""[label=""cfg_next""];\n	""15"" -> ""51""[label=""cfg_next""];\n	""16"" -> ""17""[label=""cfg_next""];\n	""17"" -> ""52""[label=""cfg_next""];\n	""18"" -> ""22""[label=""cfg_next""];\n	""19"" -> ""18""[label=""cfg_next""];\n	""2"" -> ""46""[label=""cfg_next""];\n	""20"" -> ""23""[label=""cfg_next""];\n	""21"" -> ""61""[label=""cfg_next""];\n	""22"" -> ""20""[label=""cfg_next""];\n	""23"" -> ""24""[label=""cfg_next""];\n	""24"" -> ""21""[label=""cfg_next""];\n	""25"" -> ""19""[label=""cfg_next""];\n	""26"" -> ""76""[label=""cfg_next""];\n	""27"" -> ""26""[label=""cfg_next""];\n	""28"" -> ""72""[label=""cfg_next""];\n	""29"" -> ""73""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""30"" -> ""74""[label=""cfg_next""];\n	""31"" -> ""40""[label=""cfg_next""];\n	""32"" -> ""77""[label=""cfg_next""];\n	""33"" -> ""32""[label=""cfg_next""];\n	""34"" -> ""41""[label=""cfg_next""];\n	""35"" -> ""53""[label=""cfg_next""];\n	""36"" -> ""54""[label=""cfg_next""];\n	""37"" -> ""55""[label=""cfg_next""];\n	""38"" -> ""75""[label=""cfg_next""];\n	""39"" -> ""12""[label=""cfg_next""];\n	""4"" -> ""60""[label=""cfg_next""];\n	""40"" -> ""33""[label=""cfg_next""];\n	""41"" -> ""35""[label=""cfg_next""];\n	""42"" -> ""34""[label=""cfg_goto""];\n	""43"" -> ""11""[label=""cfg_goto""];\n	""44"" -> ""34""[label=""cfg_goto""];\n	""45"" -> ""34""[label=""cfg_goto""];\n	""46"" -> ""6""[label=""cfg_true""];\n	""46"" -> ""7""[label=""cfg_false""];\n	""47"" -> ""11""[label=""cfg_true""];\n	""47"" -> ""31""[label=""cfg_false""];\n	""48"" -> ""13""[label=""cfg_true""];\n	""48"" -> ""30""[label=""cfg_false""];\n	""49"" -> ""14""[label=""cfg_true""];\n	""49"" -> ""29""[label=""cfg_false""];\n	""5"" -> ""4""[label=""cfg_next""];\n	""50"" -> ""15""[label=""cfg_true""];\n	""50"" -> ""28""[label=""cfg_false""];\n	""51"" -> ""16""[label=""cfg_true""];\n	""51"" -> ""27""[label=""cfg_false""];\n	""52"" -> ""11""[label=""cfg_true""];\n	""52"" -> ""25""[label=""cfg_false""];\n	""53"" -> ""36""[label=""cfg_true""];\n	""53"" -> ""8""[label=""cfg_false""];\n	""54"" -> ""37""[label=""cfg_true""];\n	""54"" -> ""62""[label=""cfg_false""];\n	""55"" -> ""1""[label=""cfg_true""];\n	""55"" -> ""2""[label=""cfg_false""];\n	""6"" -> ""3""[label=""cfg_next""];\n	""60"" -> ""65""[label=""cfg_next""];\n	""61"" -> ""66""[label=""cfg_next""];\n	""62"" -> ""44""[label=""cfg_next""];\n	""63"" -> ""34""[label=""cfg_next""];\n	""64"" -> ""67""[label=""cfg_next""];\n	""67"" -> ""68""[label=""cfg_next""];\n	""68"" -> ""63""[label=""cfg_next""];\n	""69"" -> ""57""[label=""cfg_next""];\n	""7"" -> ""71""[label=""cfg_next""];\n	""70"" -> ""59""[label=""cfg_next""];\n	""71"" -> ""70""[label=""cfg_next""];\n	""72"" -> ""58""[label=""cfg_next""];\n	""73"" -> ""69""[label=""cfg_next""];\n	""74"" -> ""56""[label=""cfg_next""];\n	""75"" -> ""45""[label=""cfg_next""];\n	""76"" -> ""43""[label=""cfg_next""];\n	""77"" -> ""42""[label=""cfg_next""];\n	""8"" -> ""9""[label=""cfg_next""];\n	""9"" -> ""10""[label=""cfg_next""];\n}\n",private 
"org.apache.commons.csv.Lexer.parseSimpleToken(Token,int)",Method,"* Parses a simple token.\n     * <p>\n     * Simple tokens are tokens that are not surrounded by encapsulators. A simple token might contain escaped delimiters (as \, or \;). The token is finished\n     * when one of the following conditions becomes true:\n     * </p>\n     * <ul>\n     * <li>The end of line has been reached (EORECORD)</li>\n     * <li>The end of stream has been reached (EOF)</li>\n     * <li>An unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token the current token\n     * @param ch     the current character\n     * @return the filled token\n     * @throws IOException  on stream access error\n     * @throws CSVException Thrown on invalid input.","private Token parseSimpleToken(final Token token, final int ch) throws IOException {\n    // Faster to use while(true)+break than while(token.type == INVALID)\n    int cur = ch;\n    while (true) {\n        if (readEndOfLine(cur)) {\n            token.type = Token.Type.EORECORD;\n            break;\n        }\n        if (isEndOfFile(cur)) {\n            token.type = Token.Type.EOF;\n            // There is data at EOF\n            token.isReady = true;\n            break;\n        }\n        if (isDelimiter(cur)) {\n            token.type = Token.Type.TOKEN;\n            break;\n        }\n        // continue\n        if (isEscape(cur)) {\n            appendNextEscapedCharacterToToken(token);\n        } else {\n            token.content.append((char) cur);\n        }\n        // continue\n        cur = reader.read();\n    }\n    if (ignoreSurroundingSpaces) {\n        trimTrailingSpaces(token.content);\n    }\n    return token;\n}","org.apache.commons.csv.Token parseSimpleToken(org.apache.commons.csv.Token,int)","digraph cfg_parseSimpleToken {\n	""1"" [label=""$stack10 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""2"" [label=""$stack11 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type TOKEN>""];\n	""3"" [label=""$stack12 = this.<org.apache.commons.csv.Lexer: boolean ignoreSurroundingSpaces>""];\n	""4"" [label=""$stack13 = token.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""5"" [label=""$stack14 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EOF>""];\n	""6"" [label=""$stack15 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type EORECORD>""];\n	""7"" [label=""$stack4 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean readEndOfLine(int)>(cur)""];\n	""8"" [label=""$stack5 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEndOfFile(int)>(cur)""];\n	""9"" [label=""$stack6 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isDelimiter(int)>(cur)""];\n	""10"" [label=""$stack7 = virtualinvoke this.<org.apache.commons.csv.Lexer: boolean isEscape(int)>(cur)""];\n	""11"" [label=""$stack8 = (char) cur""];\n	""12"" [label=""$stack9 = token.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""13"" [label=""ch := @parameter1: int""];\n	""14"" [label=""cur = ch""];\n	""15"" [label=""cur = virtualinvoke $stack10.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""16"" [label=""goto""];\n	""17"" [label=""goto""];\n	""18"" [label=""goto""];\n	""19"" [label=""goto""];\n	""20"" [label=""goto""];\n	""21"" [label=""if $stack12 == 0""];\n	""22"" [label=""if $stack4 == 0""];\n	""23"" [label=""if $stack5 == 0""];\n	""24"" [label=""if $stack6 == 0""];\n	""25"" [label=""if $stack7 == 0""];\n	""26"" [label=""return token""];\n	""27"" [label=""specialinvoke this.<org.apache.commons.csv.Lexer: void appendNextEscapedCharacterToToken(org.apache.commons.csv.Token)>(token)""];\n	""28"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""29"" [label=""token := @parameter0: org.apache.commons.csv.Token""];\n	""30"" [label=""token.<org.apache.commons.csv.Token: boolean isReady> = 1""];\n	""31"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack11""];\n	""32"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack14""];\n	""33"" [label=""token.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack15""];\n	""34"" [label=""virtualinvoke $stack9.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack8)""];\n	""35"" [label=""virtualinvoke this.<org.apache.commons.csv.Lexer: void trimTrailingSpaces(java.lang.StringBuilder)>($stack13)""];\n	""1"" -> ""15""[label=""cfg_next""];\n	""10"" -> ""25""[label=""cfg_next""];\n	""11"" -> ""34""[label=""cfg_next""];\n	""12"" -> ""11""[label=""cfg_next""];\n	""13"" -> ""14""[label=""cfg_next""];\n	""14"" -> ""7""[label=""cfg_next""];\n	""15"" -> ""20""[label=""cfg_next""];\n	""16"" -> ""3""[label=""cfg_goto""];\n	""17"" -> ""3""[label=""cfg_goto""];\n	""18"" -> ""3""[label=""cfg_goto""];\n	""19"" -> ""1""[label=""cfg_goto""];\n	""2"" -> ""31""[label=""cfg_next""];\n	""20"" -> ""7""[label=""cfg_goto""];\n	""21"" -> ""26""[label=""cfg_true""];\n	""21"" -> ""4""[label=""cfg_false""];\n	""22"" -> ""6""[label=""cfg_false""];\n	""22"" -> ""8""[label=""cfg_true""];\n	""23"" -> ""5""[label=""cfg_false""];\n	""23"" -> ""9""[label=""cfg_true""];\n	""24"" -> ""10""[label=""cfg_true""];\n	""24"" -> ""2""[label=""cfg_false""];\n	""25"" -> ""12""[label=""cfg_true""];\n	""25"" -> ""27""[label=""cfg_false""];\n	""27"" -> ""19""[label=""cfg_next""];\n	""28"" -> ""29""[label=""cfg_next""];\n	""29"" -> ""13""[label=""cfg_next""];\n	""3"" -> ""21""[label=""cfg_next""];\n	""30"" -> ""17""[label=""cfg_next""];\n	""31"" -> ""18""[label=""cfg_next""];\n	""32"" -> ""30""[label=""cfg_next""];\n	""33"" -> ""16""[label=""cfg_next""];\n	""34"" -> ""1""[label=""cfg_next""];\n	""35"" -> ""26""[label=""cfg_next""];\n	""4"" -> ""35""[label=""cfg_next""];\n	""5"" -> ""32""[label=""cfg_next""];\n	""6"" -> ""33""[label=""cfg_next""];\n	""7"" -> ""22""[label=""cfg_next""];\n	""8"" -> ""23""[label=""cfg_next""];\n	""9"" -> ""24""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.Lexer.readEndOfLine(int),Method,"* Greedily accepts \n, \r and \r\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator",boolean readEndOfLine(final int ch) throws IOException {\n    // check if we have \r\n...\n    int cur = ch;\n    if (cur == Constants.CR && reader.peek() == Constants.LF) {\n        // note: does not change ch outside of this method!\n        cur = reader.read();\n        // Save the EOL state\n        if (firstEol == null) {\n            this.firstEol = Constants.CRLF;\n        }\n    }\n    // save EOL state here.\n    if (firstEol == null) {\n        if (cur == Constants.LF) {\n            this.firstEol = LF_STRING;\n        } else if (cur == Constants.CR) {\n            this.firstEol = CR_STRING;\n        }\n    }\n    return cur == Constants.LF || cur == Constants.CR;\n},boolean readEndOfLine(int),"digraph cfg_readEndOfLine {\n	""1"" [label=""$stack10 = this.<org.apache.commons.csv.Lexer: java.lang.String firstEol>""];\n	""2"" [label=""$stack3 = this.<org.apache.commons.csv.Lexer: java.lang.String firstEol>""];\n	""3"" [label=""$stack4 = 0""];\n	""4"" [label=""$stack4 = 1""];\n	""5"" [label=""$stack5 = <org.apache.commons.csv.Lexer: java.lang.String CR_STRING>""];\n	""6"" [label=""$stack6 = <org.apache.commons.csv.Lexer: java.lang.String LF_STRING>""];\n	""7"" [label=""$stack7 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""8"" [label=""$stack8 = virtualinvoke $stack7.<org.apache.commons.csv.ExtendedBufferedReader: int peek()>()""];\n	""9"" [label=""$stack9 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""10"" [label=""ch := @parameter0: int""];\n	""11"" [label=""cur = ch""];\n	""12"" [label=""cur = virtualinvoke $stack9.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""13"" [label=""goto""];\n	""14"" [label=""goto""];\n	""15"" [label=""if $stack10 != null""];\n	""16"" [label=""if $stack3 != null""];\n	""17"" [label=""if $stack8 != 10""];\n	""18"" [label=""if cur != 10""];\n	""19"" [label=""if cur != 13""];\n	""20"" [label=""if cur != 13""];\n	""21"" [label=""if cur != 13""];\n	""22"" [label=""if cur == 10""];\n	""23"" [label=""return $stack4""];\n	""24"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""25"" [label=""this.<org.apache.commons.csv.Lexer: java.lang.String firstEol> = \""\r\n\""""];\n	""26"" [label=""this.<org.apache.commons.csv.Lexer: java.lang.String firstEol> = $stack5""];\n	""27"" [label=""this.<org.apache.commons.csv.Lexer: java.lang.String firstEol> = $stack6""];\n	""1"" -> ""15""[label=""cfg_next""];\n	""10"" -> ""11""[label=""cfg_next""];\n	""11"" -> ""19""[label=""cfg_next""];\n	""12"" -> ""1""[label=""cfg_next""];\n	""13"" -> ""22""[label=""cfg_goto""];\n	""14"" -> ""23""[label=""cfg_goto""];\n	""15"" -> ""2""[label=""cfg_true""];\n	""15"" -> ""25""[label=""cfg_false""];\n	""16"" -> ""18""[label=""cfg_false""];\n	""16"" -> ""22""[label=""cfg_true""];\n	""17"" -> ""2""[label=""cfg_true""];\n	""17"" -> ""9""[label=""cfg_false""];\n	""18"" -> ""20""[label=""cfg_true""];\n	""18"" -> ""6""[label=""cfg_false""];\n	""19"" -> ""2""[label=""cfg_true""];\n	""19"" -> ""7""[label=""cfg_false""];\n	""2"" -> ""16""[label=""cfg_next""];\n	""20"" -> ""22""[label=""cfg_true""];\n	""20"" -> ""5""[label=""cfg_false""];\n	""21"" -> ""3""[label=""cfg_true""];\n	""21"" -> ""4""[label=""cfg_false""];\n	""22"" -> ""21""[label=""cfg_false""];\n	""22"" -> ""4""[label=""cfg_true""];\n	""24"" -> ""10""[label=""cfg_next""];\n	""25"" -> ""2""[label=""cfg_next""];\n	""26"" -> ""22""[label=""cfg_next""];\n	""27"" -> ""13""[label=""cfg_next""];\n	""3"" -> ""23""[label=""cfg_next""];\n	""4"" -> ""14""[label=""cfg_next""];\n	""5"" -> ""26""[label=""cfg_next""];\n	""6"" -> ""27""[label=""cfg_next""];\n	""7"" -> ""8""[label=""cfg_next""];\n	""8"" -> ""17""[label=""cfg_next""];\n	""9"" -> ""12""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Lexer.readEscape(),Method,"* Handle an escape sequence. The current character must be the escape character. On return, the next character is available by calling\n     * {@link ExtendedBufferedReader#getLastChar()} on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link IOUtils#EOF} if char following the escape is invalid.\n     * @throws IOException  if there is a problem reading the stream or the end of stream is detected: the escape character is not allowed at end of stream\n     * @throws CSVException Thrown on invalid input.","int readEscape() throws IOException {\n    // the escape char has just been read (normally a backslash)\n    final int ch = reader.read();\n    switch(ch) {\n        case 'r':\n            return Constants.CR;\n        case 'n':\n            return Constants.LF;\n        case 't':\n            return Constants.TAB;\n        case 'b':\n            return Constants.BACKSPACE;\n        case 'f':\n            return Constants.FF;\n        case Constants.CR:\n        case Constants.LF:\n        // TODO is this correct?\n        case Constants.FF:\n        // TODO is this correct? Do tabs need to be escaped?\n        case Constants.TAB:\n        case // TODO is this correct?\n        Constants.BACKSPACE:\n            return ch;\n        case EOF:\n            throw new CSVException(""EOF while processing escape sequence"");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return EOF;\n    }\n}",int readEscape(),"digraph cfg_readEscape {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader>""];\n	""2"" [label=""$stack3 = newarray (java.lang.Object)[0]""];\n	""3"" [label=""$stack4 = new org.apache.commons.csv.CSVException""];\n	""4"" [label=""$stack5 = specialinvoke this.<org.apache.commons.csv.Lexer: boolean isMetaChar(int)>(ch)""];\n	""5"" [label=""ch = virtualinvoke $stack2.<org.apache.commons.csv.ExtendedBufferedReader: int read()>()""];\n	""6"" [label=""if $stack5 == 0""];\n	""7"" [label=""return -1""];\n	""8"" [label=""return 10""];\n	""9"" [label=""return 12""];\n	""10"" [label=""return 13""];\n	""11"" [label=""return 8""];\n	""12"" [label=""return 9""];\n	""13"" [label=""return ch""];\n	""14"" [label=""return ch""];\n	""15"" [label=""specialinvoke $stack4.<org.apache.commons.csv.CSVException: void <init>(java.lang.String,java.lang.Object[])>(\""EOF while processing escape sequence\"", $stack3)""];\n	""16"" [label=""switch(ch) \{     case -1:     case 8:     case 9:     case 10:     case 12:     case 13:     case 98:     case 102:     case 110:     case 114:     case 116:     default:  \}""];\n	""17"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""18"" [label=""throw $stack4""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""15"" -> ""18""[label=""cfg_next""];\n	""16"" -> ""10""[label=""cfg_switch""];\n	""16"" -> ""11""[label=""cfg_switch""];\n	""16"" -> ""12""[label=""cfg_switch""];\n	""16"" -> ""13""[label=""cfg_switch""];\n	""16"" -> ""3""[label=""cfg_switch""];\n	""16"" -> ""4""[label=""cfg_switch""];\n	""16"" -> ""8""[label=""cfg_switch""];\n	""16"" -> ""9""[label=""cfg_switch""];\n	""17"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""15""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""16""[label=""cfg_next""];\n	""6"" -> ""14""[label=""cfg_false""];\n	""6"" -> ""7""[label=""cfg_true""];\n}\n",default
org.apache.commons.csv.Lexer.trimTrailingSpaces(StringBuilder),Method,No Comment,void trimTrailingSpaces(final StringBuilder buffer) {\n    int length = buffer.length();\n    while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n        length--;\n    }\n    if (length != buffer.length()) {\n        buffer.setLength(length);\n    }\n},void trimTrailingSpaces(java.lang.StringBuilder),"digraph cfg_trimTrailingSpaces {\n	""1"" [label=""$stack3 = virtualinvoke buffer.<java.lang.StringBuilder: int length()>()""];\n	""2"" [label=""$stack4 = length - 1""];\n	""3"" [label=""$stack5 = virtualinvoke buffer.<java.lang.StringBuilder: char charAt(int)>($stack4)""];\n	""4"" [label=""$stack6 = staticinvoke <java.lang.Character: boolean isWhitespace(char)>($stack5)""];\n	""5"" [label=""buffer := @parameter0: java.lang.StringBuilder""];\n	""6"" [label=""goto""];\n	""7"" [label=""if $stack6 == 0""];\n	""8"" [label=""if length <= 0""];\n	""9"" [label=""if length == $stack3""];\n	""10"" [label=""length = length + -1""];\n	""11"" [label=""length = virtualinvoke buffer.<java.lang.StringBuilder: int length()>()""];\n	""12"" [label=""return""];\n	""13"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""14"" [label=""virtualinvoke buffer.<java.lang.StringBuilder: void setLength(int)>(length)""];\n	""1"" -> ""9""[label=""cfg_next""];\n	""10"" -> ""6""[label=""cfg_next""];\n	""11"" -> ""8""[label=""cfg_next""];\n	""13"" -> ""5""[label=""cfg_next""];\n	""14"" -> ""12""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""7""[label=""cfg_next""];\n	""5"" -> ""11""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_goto""];\n	""7"" -> ""1""[label=""cfg_true""];\n	""7"" -> ""10""[label=""cfg_false""];\n	""8"" -> ""1""[label=""cfg_true""];\n	""8"" -> ""2""[label=""cfg_false""];\n	""9"" -> ""12""[label=""cfg_true""];\n	""9"" -> ""14""[label=""cfg_false""];\n}\n",default
"org.apache.commons.csv.Lexer.<init>(CSVFormat,ExtendedBufferedReader)",Constructor,No Comment,"Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n    this.reader = reader;\n    this.delimiter = format.getDelimiterCharArray();\n    this.escape = nullToDisabled(format.getEscapeCharacter());\n    this.quoteChar = nullToDisabled(format.getQuoteCharacter());\n    this.commentStart = nullToDisabled(format.getCommentMarker());\n    this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n    this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    this.lenientEof = format.getLenientEof();\n    this.trailingData = format.getTrailingData();\n    this.delimiterBuf = new char[delimiter.length - 1];\n    this.escapeDelimiterBuf = new char[2 * delimiter.length - 1];\n}","void <init>(org.apache.commons.csv.CSVFormat,org.apache.commons.csv.ExtendedBufferedReader)","digraph cfg_init {\n	""1"" [label=""$stack10 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: boolean getIgnoreSurroundingSpaces()>()""];\n	""2"" [label=""$stack11 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: boolean getIgnoreEmptyLines()>()""];\n	""3"" [label=""$stack12 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: boolean getLenientEof()>()""];\n	""4"" [label=""$stack13 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: boolean getTrailingData()>()""];\n	""5"" [label=""$stack14 = this.<org.apache.commons.csv.Lexer: char[] delimiter>""];\n	""6"" [label=""$stack15 = lengthof $stack14""];\n	""7"" [label=""$stack16 = $stack15 - 1""];\n	""8"" [label=""$stack17 = newarray (char)[$stack16]""];\n	""9"" [label=""$stack18 = this.<org.apache.commons.csv.Lexer: char[] delimiter>""];\n	""10"" [label=""$stack19 = lengthof $stack18""];\n	""11"" [label=""$stack20 = 2 * $stack19""];\n	""12"" [label=""$stack21 = $stack20 - 1""];\n	""13"" [label=""$stack22 = newarray (char)[$stack21]""];\n	""14"" [label=""$stack3 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: char[] getDelimiterCharArray()>()""];\n	""15"" [label=""$stack4 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: java.lang.Character getEscapeCharacter()>()""];\n	""16"" [label=""$stack5 = specialinvoke this.<org.apache.commons.csv.Lexer: int nullToDisabled(java.lang.Character)>($stack4)""];\n	""17"" [label=""$stack6 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: java.lang.Character getQuoteCharacter()>()""];\n	""18"" [label=""$stack7 = specialinvoke this.<org.apache.commons.csv.Lexer: int nullToDisabled(java.lang.Character)>($stack6)""];\n	""19"" [label=""$stack8 = virtualinvoke format.<org.apache.commons.csv.CSVFormat: java.lang.Character getCommentMarker()>()""];\n	""20"" [label=""$stack9 = specialinvoke this.<org.apache.commons.csv.Lexer: int nullToDisabled(java.lang.Character)>($stack8)""];\n	""21"" [label=""format := @parameter0: org.apache.commons.csv.CSVFormat""];\n	""22"" [label=""reader := @parameter1: org.apache.commons.csv.ExtendedBufferedReader""];\n	""23"" [label=""return""];\n	""24"" [label=""specialinvoke this.<java.lang.Object: void <init>()>()""];\n	""25"" [label=""this := @this: org.apache.commons.csv.Lexer""];\n	""26"" [label=""this.<org.apache.commons.csv.Lexer: boolean ignoreEmptyLines> = $stack11""];\n	""27"" [label=""this.<org.apache.commons.csv.Lexer: boolean ignoreSurroundingSpaces> = $stack10""];\n	""28"" [label=""this.<org.apache.commons.csv.Lexer: boolean lenientEof> = $stack12""];\n	""29"" [label=""this.<org.apache.commons.csv.Lexer: boolean trailingData> = $stack13""];\n	""30"" [label=""this.<org.apache.commons.csv.Lexer: char[] delimiter> = $stack3""];\n	""31"" [label=""this.<org.apache.commons.csv.Lexer: char[] delimiterBuf> = $stack17""];\n	""32"" [label=""this.<org.apache.commons.csv.Lexer: char[] escapeDelimiterBuf> = $stack22""];\n	""33"" [label=""this.<org.apache.commons.csv.Lexer: int commentStart> = $stack9""];\n	""34"" [label=""this.<org.apache.commons.csv.Lexer: int escape> = $stack5""];\n	""35"" [label=""this.<org.apache.commons.csv.Lexer: int quoteChar> = $stack7""];\n	""36"" [label=""this.<org.apache.commons.csv.Lexer: org.apache.commons.csv.ExtendedBufferedReader reader> = reader""];\n	""1"" -> ""27""[label=""cfg_next""];\n	""10"" -> ""11""[label=""cfg_next""];\n	""11"" -> ""12""[label=""cfg_next""];\n	""12"" -> ""13""[label=""cfg_next""];\n	""13"" -> ""32""[label=""cfg_next""];\n	""14"" -> ""30""[label=""cfg_next""];\n	""15"" -> ""16""[label=""cfg_next""];\n	""16"" -> ""34""[label=""cfg_next""];\n	""17"" -> ""18""[label=""cfg_next""];\n	""18"" -> ""35""[label=""cfg_next""];\n	""19"" -> ""20""[label=""cfg_next""];\n	""2"" -> ""26""[label=""cfg_next""];\n	""20"" -> ""33""[label=""cfg_next""];\n	""21"" -> ""22""[label=""cfg_next""];\n	""22"" -> ""24""[label=""cfg_next""];\n	""24"" -> ""36""[label=""cfg_next""];\n	""25"" -> ""21""[label=""cfg_next""];\n	""26"" -> ""3""[label=""cfg_next""];\n	""27"" -> ""2""[label=""cfg_next""];\n	""28"" -> ""4""[label=""cfg_next""];\n	""29"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""28""[label=""cfg_next""];\n	""30"" -> ""15""[label=""cfg_next""];\n	""31"" -> ""9""[label=""cfg_next""];\n	""32"" -> ""23""[label=""cfg_next""];\n	""33"" -> ""1""[label=""cfg_next""];\n	""34"" -> ""17""[label=""cfg_next""];\n	""35"" -> ""19""[label=""cfg_next""];\n	""36"" -> ""14""[label=""cfg_next""];\n	""4"" -> ""29""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""8""[label=""cfg_next""];\n	""8"" -> ""31""[label=""cfg_next""];\n	""9"" -> ""10""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Token.reset(),Method,No Comment,void reset() {\n    content.setLength(0);\n    type = INVALID;\n    isReady = false;\n    isQuoted = false;\n},void reset(),"digraph cfg_reset {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""2"" [label=""$stack2 = <org.apache.commons.csv.Token$Type: org.apache.commons.csv.Token$Type INVALID>""];\n	""3"" [label=""return""];\n	""4"" [label=""this := @this: org.apache.commons.csv.Token""];\n	""5"" [label=""this.<org.apache.commons.csv.Token: boolean isQuoted> = 0""];\n	""6"" [label=""this.<org.apache.commons.csv.Token: boolean isReady> = 0""];\n	""7"" [label=""this.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type> = $stack2""];\n	""8"" [label=""virtualinvoke $stack1.<java.lang.StringBuilder: void setLength(int)>(0)""];\n	""1"" -> ""8""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n	""6"" -> ""5""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n	""8"" -> ""2""[label=""cfg_next""];\n}\n",default
org.apache.commons.csv.Token.toString(),Method,* Eases IDE debugging.\n     *\n     * @return a string helpful for debugging.,"@Override\npublic String toString() {\n    return type.name() + "" ["" + content.toString() + ""]"";\n}",java.lang.String toString(),"digraph cfg_toString {\n	""1"" [label=""$stack1 = new java.lang.StringBuilder""];\n	""2"" [label=""$stack10 = virtualinvoke $stack9.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""3"" [label=""$stack2 = this.<org.apache.commons.csv.Token: org.apache.commons.csv.Token$Type type>""];\n	""4"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.Token$Type: java.lang.String name()>()""];\n	""5"" [label=""$stack4 = virtualinvoke $stack1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack3)""];\n	""6"" [label=""$stack5 = this.<org.apache.commons.csv.Token: java.lang.StringBuilder content>""];\n	""7"" [label=""$stack6 = virtualinvoke $stack5.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""8"" [label=""$stack7 = virtualinvoke $stack4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\"" [\"")""];\n	""9"" [label=""$stack8 = virtualinvoke $stack7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack6)""];\n	""10"" [label=""$stack9 = virtualinvoke $stack8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""]\"")""];\n	""11"" [label=""return $stack10""];\n	""12"" [label=""specialinvoke $stack1.<java.lang.StringBuilder: void <init>()>()""];\n	""13"" [label=""this := @this: org.apache.commons.csv.Token""];\n	""1"" -> ""12""[label=""cfg_next""];\n	""10"" -> ""2""[label=""cfg_next""];\n	""12"" -> ""3""[label=""cfg_next""];\n	""13"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""11""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""8""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""9""[label=""cfg_next""];\n	""8"" -> ""6""[label=""cfg_next""];\n	""9"" -> ""10""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVException.<init>(String,Object[])",Constructor,"* Constructs a new instance with a formatted message.\n     *\n     * @param format A {@link Formatter} format string.\n     * @param args   See {@link String#format(String, Object...)}.\n     * @throws IllegalFormatException See {@link String#format(String, Object...)}.","public CSVException(final String format, final Object... args) {\n    super(String.format(format, args));\n}","void <init>(java.lang.String,java.lang.Object[])","digraph cfg_init {\n	""1"" [label=""$stack3 = staticinvoke <java.lang.String: java.lang.String format(java.lang.String,java.lang.Object[])>(format, args)""];\n	""2"" [label=""args := @parameter1: java.lang.Object[]""];\n	""3"" [label=""format := @parameter0: java.lang.String""];\n	""4"" [label=""return""];\n	""5"" [label=""specialinvoke this.<java.io.IOException: void <init>(java.lang.String)>($stack3)""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVException""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""5"" -> ""4""[label=""cfg_next""];\n	""6"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.Constants.<init>(),Constructor,No instances.,private Constants() {\n    // noop\n},void <init>(),"digraph cfg_init {\n	""1"" [label=""return""];\n	""2"" [label=""specialinvoke this.<java.lang.Object: void <init>()>()""];\n	""3"" [label=""this := @this: org.apache.commons.csv.Constants""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVRecord.get(Enum),Method,* Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String,public String get(final Enum<?> e) {\n    return get(e == null ? null : e.name());\n},java.lang.String get(java.lang.Enum),"digraph cfg_get {\n	""1"" [label=""$stack2 = null""];\n	""2"" [label=""$stack2 = virtualinvoke e.<java.lang.Enum: java.lang.String name()>()""];\n	""3"" [label=""$stack3 = virtualinvoke this.<org.apache.commons.csv.CSVRecord: java.lang.String get(java.lang.String)>($stack2)""];\n	""4"" [label=""e := @parameter0: java.lang.Enum""];\n	""5"" [label=""goto""];\n	""6"" [label=""if e != null""];\n	""7"" [label=""return $stack3""];\n	""8"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""7""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_goto""];\n	""6"" -> ""1""[label=""cfg_false""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""8"" -> ""4""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.get(int),Method,* Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index,public String get(final int i) {\n    return values[i];\n},java.lang.String get(int),"digraph cfg_get {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""2"" [label=""$stack3 = $stack2[i]""];\n	""3"" [label=""i := @parameter0: int""];\n	""4"" [label=""return $stack3""];\n	""5"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""5"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.get(String),Method,"* Returns a value by name. If multiple instances of the header name exists, only the last occurrence is returned.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)","public String get(final String name) {\n    final Map<String, Integer> headerMap = getHeaderMapRaw();\n    if (headerMap == null) {\n        throw new IllegalStateException(""No header mapping was specified, the record values can't be accessed by name"");\n    }\n    final Integer index = headerMap.get(name);\n    if (index == null) {\n        throw new IllegalArgumentException(String.format(""Mapping for %s not found, expected one of %s"", name, headerMap.keySet()));\n    }\n    try {\n        // N.B. Explicit (un)boxing is intentional\n        return values[index.intValue()];\n    } catch (final ArrayIndexOutOfBoundsException e) {\n        throw new IllegalArgumentException(String.format(""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index, // N.B. Explicit (un)boxing is intentional\n        Integer.valueOf(values.length)));\n    }\n}",java.lang.String get(java.lang.String),"digraph cfg_get {\n	""1"" [label=""$stack10 = interfaceinvoke headerMap.<java.util.Map: java.util.Set keySet()>()""];\n	""2"" [label=""$stack11 = staticinvoke <java.lang.String: java.lang.String format(java.lang.String,java.lang.Object[])>(\""Mapping for %s not found, expected one of %s\"", $stack9)""];\n	""3"" [label=""$stack12 = new java.lang.IllegalArgumentException""];\n	""4"" [label=""$stack13 = new java.lang.IllegalStateException""];\n	""5"" [label=""$stack14 := @caughtexception""];\n	""6"" [label=""$stack15 = newarray (java.lang.Object)[3]""];\n	""7"" [label=""$stack15[0] = name""];\n	""8"" [label=""$stack15[1] = index""];\n	""9"" [label=""$stack15[2] = $stack18""];\n	""10"" [label=""$stack16 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""11"" [label=""$stack17 = lengthof $stack16""];\n	""12"" [label=""$stack18 = staticinvoke <java.lang.Integer: java.lang.Integer valueOf(int)>($stack17)""];\n	""13"" [label=""$stack19 = staticinvoke <java.lang.String: java.lang.String format(java.lang.String,java.lang.Object[])>(\""Index for header \'%s\' is %d but CSVRecord only has %d values!\"", $stack15)""];\n	""14"" [label=""$stack20 = new java.lang.IllegalArgumentException""];\n	""15"" [label=""$stack5 = interfaceinvoke headerMap.<java.util.Map: java.lang.Object get(java.lang.Object)>(name)""];\n	""16"" [label=""$stack6 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""17"" [label=""$stack7 = virtualinvoke index.<java.lang.Integer: int intValue()>()""];\n	""18"" [label=""$stack8 = $stack6[$stack7]""];\n	""19"" [label=""$stack9 = newarray (java.lang.Object)[2]""];\n	""20"" [label=""$stack9[0] = name""];\n	""21"" [label=""$stack9[1] = $stack10""];\n	""22"" [label=""e = $stack14""];\n	""23"" [label=""headerMap = specialinvoke this.<org.apache.commons.csv.CSVRecord: java.util.Map getHeaderMapRaw()>()""];\n	""24"" [label=""if headerMap != null""];\n	""25"" [label=""if index != null""];\n	""26"" [label=""index = (java.lang.Integer) $stack5""];\n	""27"" [label=""name := @parameter0: java.lang.String""];\n	""28"" [label=""return $stack8""];\n	""29"" [label=""specialinvoke $stack12.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack11)""];\n	""30"" [label=""specialinvoke $stack13.<java.lang.IllegalStateException: void <init>(java.lang.String)>(\""No header mapping was specified, the record values can\'t be accessed by name\"")""];\n	""31"" [label=""specialinvoke $stack20.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($stack19)""];\n	""32"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""33"" [label=""throw $stack12""];\n	""34"" [label=""throw $stack13""];\n	""35"" [label=""throw $stack20""];\n	""1"" -> ""21""[label=""cfg_next""];\n	""10"" -> ""11""[label=""cfg_next""];\n	""11"" -> ""12""[label=""cfg_next""];\n	""12"" -> ""9""[label=""cfg_next""];\n	""13"" -> ""31""[label=""cfg_next""];\n	""14"" -> ""6""[label=""cfg_next""];\n	""15"" -> ""26""[label=""cfg_next""];\n	""16"" -> ""17""[label=""cfg_next""];\n	""16"" -> ""5""[label=""cfg_except""];\n	""17"" -> ""18""[label=""cfg_next""];\n	""17"" -> ""5""[label=""cfg_except""];\n	""18"" -> ""28""[label=""cfg_next""];\n	""18"" -> ""5""[label=""cfg_except""];\n	""19"" -> ""20""[label=""cfg_next""];\n	""2"" -> ""29""[label=""cfg_next""];\n	""20"" -> ""1""[label=""cfg_next""];\n	""21"" -> ""2""[label=""cfg_next""];\n	""22"" -> ""14""[label=""cfg_next""];\n	""23"" -> ""24""[label=""cfg_next""];\n	""24"" -> ""15""[label=""cfg_true""];\n	""24"" -> ""4""[label=""cfg_false""];\n	""25"" -> ""16""[label=""cfg_true""];\n	""25"" -> ""3""[label=""cfg_false""];\n	""26"" -> ""25""[label=""cfg_next""];\n	""27"" -> ""23""[label=""cfg_next""];\n	""29"" -> ""33""[label=""cfg_next""];\n	""3"" -> ""19""[label=""cfg_next""];\n	""30"" -> ""34""[label=""cfg_next""];\n	""31"" -> ""35""[label=""cfg_next""];\n	""32"" -> ""27""[label=""cfg_next""];\n	""4"" -> ""30""[label=""cfg_next""];\n	""5"" -> ""22""[label=""cfg_next""];\n	""6"" -> ""7""[label=""cfg_next""];\n	""7"" -> ""8""[label=""cfg_next""];\n	""8"" -> ""10""[label=""cfg_next""];\n	""9"" -> ""13""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.getBytePosition(),Method,"* Returns the starting position of this record in the source stream, measured in bytes.\n     *\n     * @return the byte position of this record in the source stream.\n     * @since 1.13.0",public long getBytePosition() {\n    return bytePosition;\n},long getBytePosition(),"digraph cfg_getBytePosition {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: long bytePosition>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.getCharacterPosition(),Method,* Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.,public long getCharacterPosition() {\n    return characterPosition;\n},long getCharacterPosition(),"digraph cfg_getCharacterPosition {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: long characterPosition>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.getComment(),Method,"* Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.",public String getComment() {\n    return comment;\n},java.lang.String getComment(),"digraph cfg_getComment {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: java.lang.String comment>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.getHeaderMapRaw(),Method,No Comment,"private Map<String, Integer> getHeaderMapRaw() {\n    return parser == null ? null : parser.getHeaderMapRaw();\n}",java.util.Map getHeaderMapRaw(),"digraph cfg_getHeaderMapRaw {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: org.apache.commons.csv.CSVParser parser>""];\n	""2"" [label=""$stack2 = this.<org.apache.commons.csv.CSVRecord: org.apache.commons.csv.CSVParser parser>""];\n	""3"" [label=""$stack3 = null""];\n	""4"" [label=""$stack3 = virtualinvoke $stack2.<org.apache.commons.csv.CSVParser: java.util.Map getHeaderMapRaw()>()""];\n	""5"" [label=""goto""];\n	""6"" [label=""if $stack1 != null""];\n	""7"" [label=""return $stack3""];\n	""8"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""2"" -> ""4""[label=""cfg_next""];\n	""3"" -> ""5""[label=""cfg_next""];\n	""4"" -> ""7""[label=""cfg_next""];\n	""5"" -> ""7""[label=""cfg_goto""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""6"" -> ""3""[label=""cfg_false""];\n	""8"" -> ""1""[label=""cfg_next""];\n}\n",private 
org.apache.commons.csv.CSVRecord.getParser(),Method,* Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7,public CSVParser getParser() {\n    return parser;\n},org.apache.commons.csv.CSVParser getParser(),"digraph cfg_getParser {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: org.apache.commons.csv.CSVParser parser>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.getRecordNumber(),Method,"* Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>NOTE:</strong>If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()",public long getRecordNumber() {\n    return recordNumber;\n},long getRecordNumber(),"digraph cfg_getRecordNumber {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: long recordNumber>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.hasComment(),Method,"* Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3",public boolean hasComment() {\n    return comment != null;\n},boolean hasComment(),"digraph cfg_hasComment {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: java.lang.String comment>""];\n	""2"" [label=""$stack2 = 0""];\n	""3"" [label=""$stack2 = 1""];\n	""4"" [label=""goto""];\n	""5"" [label=""if $stack1 == null""];\n	""6"" [label=""return $stack2""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""6""[label=""cfg_goto""];\n	""5"" -> ""2""[label=""cfg_true""];\n	""5"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.isConsistent(),Method,"* Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not","public boolean isConsistent() {\n    final Map<String, Integer> headerMap = getHeaderMapRaw();\n    return headerMap == null || headerMap.size() == values.length;\n}",boolean isConsistent(),"digraph cfg_isConsistent {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""2"" [label=""$stack3 = lengthof $stack2""];\n	""3"" [label=""$stack4 = interfaceinvoke headerMap.<java.util.Map: int size()>()""];\n	""4"" [label=""$stack5 = 0""];\n	""5"" [label=""$stack5 = 1""];\n	""6"" [label=""goto""];\n	""7"" [label=""headerMap = specialinvoke this.<org.apache.commons.csv.CSVRecord: java.util.Map getHeaderMapRaw()>()""];\n	""8"" [label=""if $stack4 != $stack3""];\n	""9"" [label=""if headerMap == null""];\n	""10"" [label=""return $stack5""];\n	""11"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""11"" -> ""7""[label=""cfg_next""];\n	""2"" -> ""8""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""10""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""10""[label=""cfg_goto""];\n	""7"" -> ""9""[label=""cfg_next""];\n	""8"" -> ""4""[label=""cfg_true""];\n	""8"" -> ""5""[label=""cfg_false""];\n	""9"" -> ""3""[label=""cfg_false""];\n	""9"" -> ""5""[label=""cfg_true""];\n}\n",public 
org.apache.commons.csv.CSVRecord.isMapped(String),Method,"* Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.","public boolean isMapped(final String name) {\n    final Map<String, Integer> headerMap = getHeaderMapRaw();\n    return headerMap != null && headerMap.containsKey(name);\n}",boolean isMapped(java.lang.String),"digraph cfg_isMapped {\n	""1"" [label=""$stack3 = interfaceinvoke headerMap.<java.util.Map: boolean containsKey(java.lang.Object)>(name)""];\n	""2"" [label=""$stack4 = 0""];\n	""3"" [label=""$stack4 = 1""];\n	""4"" [label=""goto""];\n	""5"" [label=""headerMap = specialinvoke this.<org.apache.commons.csv.CSVRecord: java.util.Map getHeaderMapRaw()>()""];\n	""6"" [label=""if $stack3 == 0""];\n	""7"" [label=""if headerMap == null""];\n	""8"" [label=""name := @parameter0: java.lang.String""];\n	""9"" [label=""return $stack4""];\n	""10"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""6""[label=""cfg_next""];\n	""10"" -> ""8""[label=""cfg_next""];\n	""2"" -> ""9""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""9""[label=""cfg_goto""];\n	""5"" -> ""7""[label=""cfg_next""];\n	""6"" -> ""2""[label=""cfg_true""];\n	""6"" -> ""3""[label=""cfg_false""];\n	""7"" -> ""1""[label=""cfg_false""];\n	""7"" -> ""2""[label=""cfg_true""];\n	""8"" -> ""5""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.isSet(int),Method,* Checks whether a column with a given index has a value.\n     *\n     * @param index\n     *         a column index (0-based)\n     * @return whether a column with a given index has a value,public boolean isSet(final int index) {\n    return 0 <= index && index < values.length;\n},boolean isSet(int),"digraph cfg_isSet {\n	""1"" [label=""$stack2 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""2"" [label=""$stack3 = lengthof $stack2""];\n	""3"" [label=""$stack4 = 0""];\n	""4"" [label=""$stack4 = 1""];\n	""5"" [label=""goto""];\n	""6"" [label=""if 0 > index""];\n	""7"" [label=""if index >= $stack3""];\n	""8"" [label=""index := @parameter0: int""];\n	""9"" [label=""return $stack4""];\n	""10"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""10"" -> ""8""[label=""cfg_next""];\n	""2"" -> ""7""[label=""cfg_next""];\n	""3"" -> ""9""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""9""[label=""cfg_goto""];\n	""6"" -> ""1""[label=""cfg_false""];\n	""6"" -> ""3""[label=""cfg_true""];\n	""7"" -> ""3""[label=""cfg_true""];\n	""7"" -> ""4""[label=""cfg_false""];\n	""8"" -> ""6""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.isSet(String),Method,* Checks whether a given column is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped and has a value,public boolean isSet(final String name) {\n    // N.B. Explicit (un)boxing is intentional\n    return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n},boolean isSet(java.lang.String),"digraph cfg_isSet {\n	""1"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVRecord: boolean isMapped(java.lang.String)>(name)""];\n	""2"" [label=""$stack3 = specialinvoke this.<org.apache.commons.csv.CSVRecord: java.util.Map getHeaderMapRaw()>()""];\n	""3"" [label=""$stack4 = interfaceinvoke $stack3.<java.util.Map: java.lang.Object get(java.lang.Object)>(name)""];\n	""4"" [label=""$stack5 = (java.lang.Integer) $stack4""];\n	""5"" [label=""$stack6 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""6"" [label=""$stack7 = lengthof $stack6""];\n	""7"" [label=""$stack8 = virtualinvoke $stack5.<java.lang.Integer: int intValue()>()""];\n	""8"" [label=""$stack9 = 0""];\n	""9"" [label=""$stack9 = 1""];\n	""10"" [label=""goto""];\n	""11"" [label=""if $stack2 == 0""];\n	""12"" [label=""if $stack8 >= $stack7""];\n	""13"" [label=""name := @parameter0: java.lang.String""];\n	""14"" [label=""return $stack9""];\n	""15"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""11""[label=""cfg_next""];\n	""10"" -> ""14""[label=""cfg_goto""];\n	""11"" -> ""2""[label=""cfg_false""];\n	""11"" -> ""8""[label=""cfg_true""];\n	""12"" -> ""8""[label=""cfg_true""];\n	""12"" -> ""9""[label=""cfg_false""];\n	""13"" -> ""1""[label=""cfg_next""];\n	""15"" -> ""13""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""7""[label=""cfg_next""];\n	""5"" -> ""6""[label=""cfg_next""];\n	""6"" -> ""12""[label=""cfg_next""];\n	""7"" -> ""5""[label=""cfg_next""];\n	""8"" -> ""14""[label=""cfg_next""];\n	""9"" -> ""10""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.iterator(),Method,* Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.,@Override\npublic Iterator<String> iterator() {\n    return toList().iterator();\n},java.util.Iterator iterator(),"digraph cfg_iterator {\n	""1"" [label=""$stack1 = virtualinvoke this.<org.apache.commons.csv.CSVRecord: java.util.List toList()>()""];\n	""2"" [label=""$stack2 = interfaceinvoke $stack1.<java.util.List: java.util.Iterator iterator()>()""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.putIn(Map),Method,* Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0,"public <M extends Map<String, String>> M putIn(final M map) {\n    if (getHeaderMapRaw() == null) {\n        return map;\n    }\n    getHeaderMapRaw().forEach((key, value) -> {\n        if (value < values.length) {\n            map.put(key, values[value]);\n        }\n    });\n    return map;\n}",java.util.Map putIn(java.util.Map),"digraph cfg_putIn {\n	""1"" [label=""$stack2 = specialinvoke this.<org.apache.commons.csv.CSVRecord: java.util.Map getHeaderMapRaw()>()""];\n	""2"" [label=""$stack3 = dynamicinvoke \""accept\"" <java.util.function.BiConsumer (org.apache.commons.csv.CSVRecord,java.util.Map)>(this, map) <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>(methodtype: void __METHODTYPE__(java.lang.Object,java.lang.Object), methodhandle: \""REF_INVOKE_SPECIAL\"" <org.apache.commons.csv.CSVRecord: void lambda$putIn$0(java.util.Map,java.lang.String,java.lang.Integer)>, methodtype: void __METHODTYPE__(java.lang.String,java.lang.Integer))""];\n	""3"" [label=""$stack4 = specialinvoke this.<org.apache.commons.csv.CSVRecord: java.util.Map getHeaderMapRaw()>()""];\n	""4"" [label=""if $stack2 != null""];\n	""5"" [label=""interfaceinvoke $stack4.<java.util.Map: void forEach(java.util.function.BiConsumer)>($stack3)""];\n	""6"" [label=""map := @parameter0: java.util.Map""];\n	""7"" [label=""return map""];\n	""8"" [label=""return map""];\n	""9"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""4""[label=""cfg_next""];\n	""2"" -> ""5""[label=""cfg_next""];\n	""3"" -> ""2""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_true""];\n	""4"" -> ""7""[label=""cfg_false""];\n	""5"" -> ""8""[label=""cfg_next""];\n	""6"" -> ""1""[label=""cfg_next""];\n	""9"" -> ""6""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.size(),Method,* Returns the number of values in this record.\n     *\n     * @return the number of values.,public int size() {\n    return values.length;\n},int size(),"digraph cfg_size {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""2"" [label=""$stack2 = lengthof $stack1""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.stream(),Method,* Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0,public Stream<String> stream() {\n    return Stream.of(values);\n},java.util.stream.Stream stream(),"digraph cfg_stream {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""2"" [label=""$stack2 = staticinvoke <java.util.stream.Stream: java.util.stream.Stream of(java.lang.Object[])>($stack1)""];\n	""3"" [label=""return $stack2""];\n	""4"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""3""[label=""cfg_next""];\n	""4"" -> ""1""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.toList(),Method,* Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0,public List<String> toList() {\n    return stream().collect(Collectors.toList());\n},java.util.List toList(),"digraph cfg_toList {\n	""1"" [label=""$stack1 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>()""];\n	""2"" [label=""$stack2 = virtualinvoke this.<org.apache.commons.csv.CSVRecord: java.util.stream.Stream stream()>()""];\n	""3"" [label=""$stack3 = interfaceinvoke $stack2.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>($stack1)""];\n	""4"" [label=""$stack4 = (java.util.List) $stack3""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""3""[label=""cfg_next""];\n	""2"" -> ""1""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""6"" -> ""2""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.toMap(),Method,"* Copies this record into a new Map of header name to record value. If multiple instances of a header name exist,\n     * then only the last occurrence is mapped.\n     *\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers.","public Map<String, String> toMap() {\n    return putIn(new LinkedHashMap<>(values.length));\n}",java.util.Map toMap(),"digraph cfg_toMap {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""2"" [label=""$stack2 = lengthof $stack1""];\n	""3"" [label=""$stack3 = new java.util.LinkedHashMap""];\n	""4"" [label=""$stack4 = virtualinvoke this.<org.apache.commons.csv.CSVRecord: java.util.Map putIn(java.util.Map)>($stack3)""];\n	""5"" [label=""return $stack4""];\n	""6"" [label=""specialinvoke $stack3.<java.util.LinkedHashMap: void <init>(int)>($stack2)""];\n	""7"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""6"" -> ""4""[label=""cfg_next""];\n	""7"" -> ""3""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.toString(),Method,"* Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.","@Override\npublic String toString() {\n    return ""CSVRecord [comment='"" + comment + ""', recordNumber="" + recordNumber + "", values="" + Arrays.toString(values) + ""]"";\n}",java.lang.String toString(),"digraph cfg_toString {\n	""1"" [label=""$stack1 = new java.lang.StringBuilder""];\n	""2"" [label=""$stack10 = virtualinvoke $stack7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\"", values=\"")""];\n	""3"" [label=""$stack11 = virtualinvoke $stack10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack9)""];\n	""4"" [label=""$stack12 = virtualinvoke $stack11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""]\"")""];\n	""5"" [label=""$stack13 = virtualinvoke $stack12.<java.lang.StringBuilder: java.lang.String toString()>()""];\n	""6"" [label=""$stack2 = this.<org.apache.commons.csv.CSVRecord: java.lang.String comment>""];\n	""7"" [label=""$stack3 = virtualinvoke $stack1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""CSVRecord [comment=\'\"")""];\n	""8"" [label=""$stack4 = virtualinvoke $stack3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack2)""];\n	""9"" [label=""$stack5 = this.<org.apache.commons.csv.CSVRecord: long recordNumber>""];\n	""10"" [label=""$stack6 = virtualinvoke $stack4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(\""\', recordNumber=\"")""];\n	""11"" [label=""$stack7 = virtualinvoke $stack6.<java.lang.StringBuilder: java.lang.StringBuilder append(long)>($stack5)""];\n	""12"" [label=""$stack8 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""13"" [label=""$stack9 = staticinvoke <java.util.Arrays: java.lang.String toString(java.lang.Object[])>($stack8)""];\n	""14"" [label=""return $stack13""];\n	""15"" [label=""specialinvoke $stack1.<java.lang.StringBuilder: void <init>()>()""];\n	""16"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""15""[label=""cfg_next""];\n	""10"" -> ""9""[label=""cfg_next""];\n	""11"" -> ""2""[label=""cfg_next""];\n	""12"" -> ""13""[label=""cfg_next""];\n	""13"" -> ""3""[label=""cfg_next""];\n	""15"" -> ""7""[label=""cfg_next""];\n	""16"" -> ""1""[label=""cfg_next""];\n	""2"" -> ""12""[label=""cfg_next""];\n	""3"" -> ""4""[label=""cfg_next""];\n	""4"" -> ""5""[label=""cfg_next""];\n	""5"" -> ""14""[label=""cfg_next""];\n	""6"" -> ""8""[label=""cfg_next""];\n	""7"" -> ""6""[label=""cfg_next""];\n	""8"" -> ""10""[label=""cfg_next""];\n	""9"" -> ""11""[label=""cfg_next""];\n}\n",public 
org.apache.commons.csv.CSVRecord.values(),Method,* Gets the values for this record. This is not a copy.\n     *\n     * @return the values for this record.\n     * @since 1.10.0,public String[] values() {\n    return values;\n},java.lang.String[] values(),"digraph cfg_values {\n	""1"" [label=""$stack1 = this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values>""];\n	""2"" [label=""return $stack1""];\n	""3"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""1"" -> ""2""[label=""cfg_next""];\n	""3"" -> ""1""[label=""cfg_next""];\n}\n",public 
"org.apache.commons.csv.CSVRecord.<init>(CSVParser,String[],String,long,long,long)",Constructor,No Comment,"CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber, final long characterPosition, final long bytePosition) {\n    this.recordNumber = recordNumber;\n    this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n    this.parser = parser;\n    this.comment = comment;\n    this.characterPosition = characterPosition;\n    this.bytePosition = bytePosition;\n}","void <init>(org.apache.commons.csv.CSVParser,java.lang.String[],java.lang.String,long,long,long)","digraph cfg_init {\n	""1"" [label=""$stack10 = <org.apache.commons.csv.Constants: java.lang.String[] EMPTY_STRING_ARRAY>""];\n	""2"" [label=""$stack10 = values""];\n	""3"" [label=""bytePosition := @parameter5: long""];\n	""4"" [label=""characterPosition := @parameter4: long""];\n	""5"" [label=""comment := @parameter2: java.lang.String""];\n	""6"" [label=""goto""];\n	""7"" [label=""if values == null""];\n	""8"" [label=""parser := @parameter0: org.apache.commons.csv.CSVParser""];\n	""9"" [label=""recordNumber := @parameter3: long""];\n	""10"" [label=""return""];\n	""11"" [label=""specialinvoke this.<java.lang.Object: void <init>()>()""];\n	""12"" [label=""this := @this: org.apache.commons.csv.CSVRecord""];\n	""13"" [label=""this.<org.apache.commons.csv.CSVRecord: java.lang.String comment> = comment""];\n	""14"" [label=""this.<org.apache.commons.csv.CSVRecord: java.lang.String[] values> = $stack10""];\n	""15"" [label=""this.<org.apache.commons.csv.CSVRecord: long bytePosition> = bytePosition""];\n	""16"" [label=""this.<org.apache.commons.csv.CSVRecord: long characterPosition> = characterPosition""];\n	""17"" [label=""this.<org.apache.commons.csv.CSVRecord: long recordNumber> = recordNumber""];\n	""18"" [label=""this.<org.apache.commons.csv.CSVRecord: org.apache.commons.csv.CSVParser parser> = parser""];\n	""19"" [label=""values := @parameter1: java.lang.String[]""];\n	""1"" -> ""14""[label=""cfg_next""];\n	""11"" -> ""17""[label=""cfg_next""];\n	""12"" -> ""8""[label=""cfg_next""];\n	""13"" -> ""16""[label=""cfg_next""];\n	""14"" -> ""18""[label=""cfg_next""];\n	""15"" -> ""10""[label=""cfg_next""];\n	""16"" -> ""15""[label=""cfg_next""];\n	""17"" -> ""7""[label=""cfg_next""];\n	""18"" -> ""13""[label=""cfg_next""];\n	""19"" -> ""5""[label=""cfg_next""];\n	""2"" -> ""6""[label=""cfg_next""];\n	""3"" -> ""11""[label=""cfg_next""];\n	""4"" -> ""3""[label=""cfg_next""];\n	""5"" -> ""9""[label=""cfg_next""];\n	""6"" -> ""14""[label=""cfg_goto""];\n	""7"" -> ""1""[label=""cfg_true""];\n	""7"" -> ""2""[label=""cfg_false""];\n	""8"" -> ""19""[label=""cfg_next""];\n	""9"" -> ""4""[label=""cfg_next""];\n}\n",default
