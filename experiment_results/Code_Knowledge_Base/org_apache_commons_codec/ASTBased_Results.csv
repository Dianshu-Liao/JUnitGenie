"FEN","Type","Comment","Source Code","Return Type","Modifier","class_extends","implements"
"org.apache.commons.codec.CodecPolicy","Enum","* Defines encoding and decoding policies.
 *
 * @since 1.15","Enum do not obtain Source Code","No return type","public ","enum has no extends",""
"org.apache.commons.codec.CodecPolicy.STRICT","Enum Constant","* The strict policy. Data that causes a codec to fail should throw an exception.","STRICT","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.CodecPolicy.LENIENT","Enum Constant","* The lenient policy. Data that causes a codec to fail should not throw an exception.","LENIENT","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.BinaryDecoder","Interface","* Defines common decoding methods for byte array decoders.","Interface do not obtain Source Code","No return type","public ","org.apache.commons.codec.Decoder",""
"org.apache.commons.codec.BinaryDecoder.decode(byte[])","Abstract Method","* Decodes a byte array and returns the results as a byte array.
     *
     * @param source
     *            A byte array which has been encoded with the appropriate encoder
     * @return a byte array that contains decoded content
     * @throws DecoderException
     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.","byte[] decode(byte[] source) throws DecoderException;","byte[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.BinaryDecoder.decode(byte[]).source","Parameter_1","Belong to org.apache.commons.codec.BinaryDecoder.decode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.DecoderException","Class","* Thrown when there is a failure condition during the decoding process. This exception is thrown when a {@link Decoder}
 * encounters a decoding specific exception such as invalid data, or characters outside of the expected range.","Class do not obtain Source Code","No return type","public ","java.lang.Exception",""
"org.apache.commons.codec.DecoderException.serialVersionUID","Field","* Declares the Serial Version Uid.
     *
     * @see <a href=""https://c2.com/cgi/wiki?AlwaysDeclareSerialVersionUid"">Always Declare Serial Version Uid</a>","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.DecoderException.<init>()","Constructor","* Constructs a new exception with {@code null} as its detail message. The cause is not initialized, and may
     * subsequently be initialized by a call to {@link #initCause}.
     *
     * @since 1.4","public DecoderException() {
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.DecoderException.<init>(String)","Constructor","* Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently
     * be initialized by a call to {@link #initCause}.
     *
     * @param message
     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.","public DecoderException(final String message) {
    super(message);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.DecoderException.<init>(String).message","Parameter_1","Belong to org.apache.commons.codec.DecoderException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.DecoderException.<init>(String,Throwable)","Constructor","* Constructs a new exception with the specified detail message and cause.
     * <p>
     * Note that the detail message associated with {@code cause} is not automatically incorporated into this
     * exception's detail message.
     * </p>
     *
     * @param message
     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.
     * @param cause
     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}
     *            value is permitted, and indicates that the cause is nonexistent or unknown.
     * @since 1.4","public DecoderException(final String message, final Throwable cause) {
    super(message, cause);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.DecoderException.<init>(String,Throwable).message","Parameter_1","Belong to org.apache.commons.codec.DecoderException.<init>(String,Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.DecoderException.<init>(String,Throwable).cause","Parameter_2","Belong to org.apache.commons.codec.DecoderException.<init>(String,Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.DecoderException.<init>(Throwable)","Constructor","* Constructs a new exception with the specified cause and a detail message of {@code (cause==null ?
     * null : cause.toString())} (which typically contains the class and detail message of {@code cause}).
     * This constructor is useful for exceptions that are little more than wrappers for other throwables.
     *
     * @param cause
     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}
     *            value is permitted, and indicates that the cause is nonexistent or unknown.
     * @since 1.4","public DecoderException(final Throwable cause) {
    super(cause);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.DecoderException.<init>(Throwable).cause","Parameter_1","Belong to org.apache.commons.codec.DecoderException.<init>(Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.Utils","Class","* Utility methods for this package.
 *
 * <p>This class is immutable and thread-safe.</p>
 *
 * @since 1.4","Class do not obtain Source Code","No return type","final ","",""
"org.apache.commons.codec.net.Utils.RADIX","Field","* Radix used in encoding and decoding.","private static final int RADIX = 16;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.Utils.digit16(byte)","Method","* Returns the numeric value of the character {@code b} in radix 16.
     *
     * @param b
     *            The byte to be converted.
     * @return The numeric value represented by the character in radix 16.
     * @throws DecoderException
     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}","static int digit16(final byte b) throws DecoderException {
    final int i = Character.digit((char) b, RADIX);
    if (i == -1) {
        throw new DecoderException(""Invalid URL encoding: not a valid digit (radix "" + RADIX + ""): "" + b);
    }
    return i;
}","int","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.Utils.digit16(byte).b","Parameter_1","Belong to org.apache.commons.codec.net.Utils.digit16(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.Utils.hexDigit(int)","Method","* Returns the upper case hexadecimal digit of the lower 4 bits of the int.
     *
     * @param b the input int
     * @return the upper case hexadecimal digit of the lower 4 bits of the int.","static char hexDigit(final int b) {
    return Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
}","char","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.Utils.hexDigit(int).b","Parameter_1","Belong to org.apache.commons.codec.net.Utils.hexDigit(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec","Abstract Class","* Implements methods common to all codecs defined in RFC 1522.
 * <p>
 * <a href=""http://www.ietf.org/rfc/rfc1522.txt"">RFC 1522</a> describes techniques to allow the
 * encoding of non-ASCII text in various portions of a RFC 822 [2] message header, in a manner which
 * is unlikely to confuse existing message handling software.
 * </p>
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @see <a href=""http://www.ietf.org/rfc/rfc1522.txt"">MIME (Multipurpose Internet Mail Extensions) Part Two:
 *          Message Header Extensions for Non-ASCII Text</a>
 * @since 1.3","Abstract Class do not obtain Source Code","No return type","abstract ","",""
"org.apache.commons.codec.net.RFC1522Codec.SEP","Field","Separator.","protected static final char SEP = '?';","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.POSTFIX","Field","Prefix.","protected static final String POSTFIX = ""?="";","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.PREFIX","Field","Postfix.","protected static final String PREFIX = ""=?"";","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.charset","Field","* The default Charset used for string decoding and encoding.","protected final Charset charset;","No return type","protected , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.decodeText(String)","Method","* Applies an RFC 1522 compliant decoding scheme to the given string of text.
     * <p>
     * This method processes the ""encoded-word"" header common to all the RFC 1522 codecs and then invokes
     * {@link #doDecoding(byte[])}  method of a concrete class to perform the specific decoding.
     * </p>
     *
     * @param text
     *            a string to decode
     * @return A new decoded String or {@code null} if the input is {@code null}.
     * @throws DecoderException
     *             thrown if there is an error condition during the decoding process.
     * @throws UnsupportedEncodingException
     *             thrown if charset specified in the ""encoded-word"" header is not supported","protected String decodeText(final String text) throws DecoderException, UnsupportedEncodingException {
    if (text == null) {
        return null;
    }
    if (!text.startsWith(PREFIX) || !text.endsWith(POSTFIX)) {
        throw new DecoderException(""RFC 1522 violation: malformed encoded content"");
    }
    final int terminator = text.length() - 2;
    int from = 2;
    int to = text.indexOf(SEP, from);
    if (to == terminator) {
        throw new DecoderException(""RFC 1522 violation: charset token not found"");
    }
    final String charset = text.substring(from, to);
    if (charset.isEmpty()) {
        throw new DecoderException(""RFC 1522 violation: charset not specified"");
    }
    from = to + 1;
    to = text.indexOf(SEP, from);
    if (to == terminator) {
        throw new DecoderException(""RFC 1522 violation: encoding token not found"");
    }
    final String encoding = text.substring(from, to);
    if (!getEncoding().equalsIgnoreCase(encoding)) {
        throw new DecoderException(""This codec cannot decode "" + encoding + "" encoded content"");
    }
    from = to + 1;
    to = text.indexOf(SEP, from);
    byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));
    data = doDecoding(data);
    return new String(data, charset);
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.decodeText(String).text","Parameter_1","Belong to org.apache.commons.codec.net.RFC1522Codec.decodeText(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.doDecoding(byte[])","Abstract Method","* Decodes an array of bytes using the defined encoding scheme.
     *
     * @param bytes
     *            Data to be decoded
     * @return a byte array that contains decoded data
     * @throws DecoderException
     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.","protected abstract byte[] doDecoding(byte[] bytes) throws DecoderException;","byte[]","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.doDecoding(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.RFC1522Codec.doDecoding(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.doEncoding(byte[])","Abstract Method","* Encodes an array of bytes using the defined encoding scheme.
     *
     * @param bytes
     *            Data to be encoded
     * @return A byte array containing the encoded data
     * @throws EncoderException
     *             thrown if the Encoder encounters a failure condition during the encoding process.","protected abstract byte[] doEncoding(byte[] bytes) throws EncoderException;","byte[]","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.doEncoding(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.RFC1522Codec.doEncoding(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.encodeText(String,Charset)","Method","* Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.
     * <p>
     * This method constructs the ""encoded-word"" header common to all the RFC 1522 codecs and then invokes
     * {@link #doEncoding(byte[])}  method of a concrete class to perform the specific encoding.
     * </p>
     *
     * @param text
     *            a string to encode
     * @param charset
     *            a charset to be used
     * @return RFC 1522 compliant ""encoded-word""
     * @throws EncoderException
     *             thrown if there is an error condition during the Encoding process.
     * @see Charset","protected String encodeText(final String text, final Charset charset) throws EncoderException {
    if (text == null) {
        return null;
    }
    final StringBuilder buffer = new StringBuilder();
    buffer.append(PREFIX);
    buffer.append(charset);
    buffer.append(SEP);
    buffer.append(getEncoding());
    buffer.append(SEP);
    buffer.append(StringUtils.newStringUsAscii(doEncoding(text.getBytes(charset))));
    buffer.append(POSTFIX);
    return buffer.toString();
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.encodeText(String,Charset).text","Parameter_1","Belong to org.apache.commons.codec.net.RFC1522Codec.encodeText(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.encodeText(String,Charset).charset","Parameter_2","Belong to org.apache.commons.codec.net.RFC1522Codec.encodeText(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.encodeText(String,String)","Method","* Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.
     * <p>
     * This method constructs the ""encoded-word"" header common to all the RFC 1522 codecs and then invokes
     * {@link #doEncoding(byte[])}  method of a concrete class to perform the specific encoding.
     * </p>
     *
     * @param text
     *            a string to encode
     * @param charsetName
     *            the charset to use
     * @return RFC 1522 compliant ""encoded-word""
     * @throws EncoderException
     *             thrown if there is an error condition during the Encoding process.
     * @throws UnsupportedCharsetException
     *             if charset is not available
     * @see Charset","protected String encodeText(final String text, final String charsetName) throws EncoderException {
    if (text == null) {
        // Don't attempt charsetName conversion.
        return null;
    }
    return encodeText(text, Charset.forName(charsetName));
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.encodeText(String,String).text","Parameter_1","Belong to org.apache.commons.codec.net.RFC1522Codec.encodeText(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.encodeText(String,String).charsetName","Parameter_2","Belong to org.apache.commons.codec.net.RFC1522Codec.encodeText(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.getCharset()","Method","* Gets the default Charset name used for string decoding and encoding.
     *
     * @return the default Charset name
     * @since 1.7","public Charset getCharset() {
    return charset;
}","Charset","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.getDefaultCharset()","Method","* Gets the default Charset name used for string decoding and encoding.
     *
     * @return the default Charset name","public String getDefaultCharset() {
    return charset.name();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.getEncoding()","Abstract Method","* Returns the codec name (referred to as encoding in the RFC 1522).
     *
     * @return name of the codec.","protected abstract String getEncoding();","String","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.<init>(Charset)","Constructor","No Comment","RFC1522Codec(final Charset charset) {
    this.charset = Objects.requireNonNull(charset, ""charset"");
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.RFC1522Codec.<init>(Charset).charset","Parameter_1","Belong to org.apache.commons.codec.net.RFC1522Codec.<init>(Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec","Class","* Codec for the Quoted-Printable section of <a href=""http://www.ietf.org/rfc/rfc1521.txt"">RFC 1521</a>.
 * <p>
 * The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to
 * printable characters in the ASCII character set. It encodes the data in such a way that the resulting octets are
 * unlikely to be modified by mail transport. If the data being encoded are mostly ASCII text, the encoded form of the
 * data remains largely recognizable by humans. A body which is entirely ASCII may also be encoded in Quoted-Printable
 * to ensure the integrity of the data should the message pass through a character- translating, and/or line-wrapping
 * gateway.
 * </p>
 * <p>
 * Note:
 * </p>
 * <p>
 * Depending on the selected {@code strict} parameter, this class will implement a different set of rules of the
 * quoted-printable spec:
 * </p>
 * <ul>
 *   <li>{@code strict=false}: only rules #1 and #2 are implemented</li>
 *   <li>{@code strict=true}: all rules #1 through #5 are implemented</li>
 * </ul>
 * <p>
 * Originally, this class only supported the non-strict mode, but the codec in this partial form could already be used
 * for certain applications that do not require quoted-printable line formatting (rules #3, #4, #5), for instance
 * Q codec. The strict mode has been added in 1.10.
 * </p>
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @see <a href=""http://www.ietf.org/rfc/rfc1521.txt"">RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:
 *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>
 *
 * @since 1.3","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.BinaryEncoder;org.apache.commons.codec.BinaryDecoder;org.apache.commons.codec.StringEncoder;org.apache.commons.codec.StringDecoder"
"org.apache.commons.codec.net.QuotedPrintableCodec.PRINTABLE_CHARS","Field","* BitSet of printable characters as defined in RFC 1521.","private static final BitSet PRINTABLE_CHARS = new BitSet(256);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.ESCAPE_CHAR","Field","No Comment","private static final byte ESCAPE_CHAR = '=';","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.TAB","Field","No Comment","private static final byte TAB = 9;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.SPACE","Field","No Comment","private static final byte SPACE = 32;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.CR","Field","No Comment","private static final byte CR = 13;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.LF","Field","No Comment","private static final byte LF = 10;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.MIN_BYTES","Field","* Minimum length required for the byte arrays used by encodeQuotedPrintable method","private static final int MIN_BYTES = 3;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.SAFE_LENGTH","Field","* Safe line length for quoted printable encoded text.","private static final int SAFE_LENGTH = 73;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.charset","Field","* The default Charset used for string decoding and encoding.","private final Charset charset;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.strict","Field","* Indicates whether soft line breaks shall be used during encoding (rule #3-5).","private final boolean strict;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decodeQuotedPrintable(byte[])","Method","* Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted
     * back to their original representation.
     * <p>
     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as
     * defined in RFC 1521.
     * </p>
     *
     * @param bytes
     *            array of quoted-printable characters
     * @return array of original bytes
     * @throws DecoderException
     *             Thrown if quoted-printable decoding is unsuccessful","public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {
    if (bytes == null) {
        return null;
    }
    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    for (int i = 0; i < bytes.length; i++) {
        final int b = bytes[i];
        if (b == ESCAPE_CHAR) {
            try {
                // if the next octet is a CR we have found a soft line break
                if (bytes[++i] == CR) {
                    continue;
                }
                final int u = Utils.digit16(bytes[i]);
                final int l = Utils.digit16(bytes[++i]);
                buffer.write((char) ((u << 4) + l));
            } catch (final ArrayIndexOutOfBoundsException e) {
                throw new DecoderException(""Invalid quoted-printable encoding"", e);
            }
        } else if (b != CR && b != LF) {
            // every other octet is appended except for CR & LF
            buffer.write(b);
        }
    }
    return buffer.toByteArray();
}","byte[]","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decodeQuotedPrintable(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.decodeQuotedPrintable(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeByte(int,boolean,ByteArrayOutputStream)","Method","* Encodes a byte in the buffer.
     *
     * @param b
     *            byte to write
     * @param encode
     *            indicates whether the octet shall be encoded
     * @param buffer
     *            the buffer to write to
     * @return the number of bytes that have been written to the buffer","private static int encodeByte(final int b, final boolean encode, final ByteArrayOutputStream buffer) {
    if (encode) {
        return encodeQuotedPrintable(b, buffer);
    }
    buffer.write(b);
    return 1;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeByte(int,boolean,ByteArrayOutputStream).b","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeByte(int,boolean,ByteArrayOutputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeByte(int,boolean,ByteArrayOutputStream).encode","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeByte(int,boolean,ByteArrayOutputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeByte(int,boolean,ByteArrayOutputStream).buffer","Parameter_3","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeByte(int,boolean,ByteArrayOutputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[])","Method","* Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.
     * <p>
     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
     * RFC 1521 and is suitable for encoding binary data and unformatted text.
     * </p>
     *
     * @param printable
     *            bitset of characters deemed quoted-printable
     * @param bytes
     *            array of bytes to be encoded
     * @return array of bytes containing quoted-printable data","public static final byte[] encodeQuotedPrintable(final BitSet printable, final byte[] bytes) {
    return encodeQuotedPrintable(printable, bytes, false);
}","byte[]","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[]).printable","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[]).bytes","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[],boolean)","Method","* Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.
     * <p>
     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset
     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
     * RFC 1521 and is suitable for encoding binary data and unformatted text.
     * </p>
     *
     * @param printable
     *            bitset of characters deemed quoted-printable
     * @param bytes
     *            array of bytes to be encoded
     * @param strict
     *            if {@code true} the full ruleset is used, otherwise only rule #1 and rule #2
     * @return array of bytes containing quoted-printable data
     * @since 1.10","public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {
    if (bytes == null) {
        return null;
    }
    if (printable == null) {
        printable = PRINTABLE_CHARS;
    }
    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    final int bytesLength = bytes.length;
    if (strict) {
        if (bytesLength < MIN_BYTES) {
            return null;
        }
        int pos = 1;
        // encode up to buffer.length - 3, the last three octets will be treated
        // separately for simplification of note #3
        for (int i = 0; i < bytesLength - 3; i++) {
            final int b = getUnsignedOctet(i, bytes);
            if (pos < SAFE_LENGTH) {
                // up to this length it is safe to add any byte, encoded or not
                pos += encodeByte(b, !printable.get(b), buffer);
            } else {
                // rule #3: whitespace at the end of a line *must* be encoded
                encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);
                // rule #5: soft line break
                buffer.write(ESCAPE_CHAR);
                buffer.write(CR);
                buffer.write(LF);
                pos = 1;
            }
        }
        // rule #3: whitespace at the end of a line *must* be encoded
        // if we would do a soft break line after this octet, encode whitespace
        int b = getUnsignedOctet(bytesLength - 3, bytes);
        boolean encode = !printable.get(b) || isWhitespace(b) && pos > SAFE_LENGTH - 5;
        pos += encodeByte(b, encode, buffer);
        // note #3: '=' *must not* be the ultimate or penultimate character
        // simplification: if < 6 bytes left, do a soft line break as we may need
        //                 exactly 6 bytes space for the last 2 bytes
        if (pos > SAFE_LENGTH - 2) {
            buffer.write(ESCAPE_CHAR);
            buffer.write(CR);
            buffer.write(LF);
        }
        for (int i = bytesLength - 2; i < bytesLength; i++) {
            b = getUnsignedOctet(i, bytes);
            // rule #3: trailing whitespace shall be encoded
            encode = !printable.get(b) || i > bytesLength - 2 && isWhitespace(b);
            encodeByte(b, encode, buffer);
        }
    } else {
        for (final byte c : bytes) {
            int b = c;
            if (b < 0) {
                b = 256 + b;
            }
            if (printable.get(b)) {
                buffer.write(b);
            } else {
                encodeQuotedPrintable(b, buffer);
            }
        }
    }
    return buffer.toByteArray();
}","byte[]","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[],boolean).printable","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[],boolean).bytes","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[],boolean).strict","Parameter_3","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(BitSet,byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(int,ByteArrayOutputStream)","Method","* Encodes byte into its quoted-printable representation.
     *
     * @param b
     *            byte to encode
     * @param buffer
     *            the buffer to write to
     * @return The number of bytes written to the {@code buffer}","private static int encodeQuotedPrintable(final int b, final ByteArrayOutputStream buffer) {
    buffer.write(ESCAPE_CHAR);
    final char hex1 = Utils.hexDigit(b >> 4);
    final char hex2 = Utils.hexDigit(b);
    buffer.write(hex1);
    buffer.write(hex2);
    return 3;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(int,ByteArrayOutputStream).b","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(int,ByteArrayOutputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(int,ByteArrayOutputStream).buffer","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(int,ByteArrayOutputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.getUnsignedOctet(int,byte[])","Method","* Gets the byte at position {@code index} of the byte array and
     * make sure it is unsigned.
     *
     * @param index
     *            position in the array
     * @param bytes
     *            the byte array
     * @return the unsigned octet at position {@code index} from the array","private static int getUnsignedOctet(final int index, final byte[] bytes) {
    int b = bytes[index];
    if (b < 0) {
        b = 256 + b;
    }
    return b;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.getUnsignedOctet(int,byte[]).index","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.getUnsignedOctet(int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.getUnsignedOctet(int,byte[]).bytes","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.getUnsignedOctet(int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.isWhitespace(int)","Method","* Checks whether the given byte is whitespace.
     *
     * @param b
     *            byte to be checked
     * @return {@code true} if the byte is either a space or tab character","private static boolean isWhitespace(final int b) {
    return b == SPACE || b == TAB;
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.isWhitespace(int).b","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.isWhitespace(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(byte[])","Method","* Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted
     * back to their original representation.
     * <p>
     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as
     * defined in RFC 1521.
     * </p>
     *
     * @param bytes
     *            array of quoted-printable characters
     * @return array of original bytes
     * @throws DecoderException
     *             Thrown if quoted-printable decoding is unsuccessful","@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
    return decodeQuotedPrintable(bytes);
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.decode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(Object)","Method","* Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original
     * representation.
     *
     * @param obj
     *            quoted-printable object to convert into its original form
     * @return original object
     * @throws DecoderException
     *             Thrown if the argument is not a {@code String} or {@code byte[]}. Thrown if a failure
     *             condition is encountered during the decode process.","@Override
public Object decode(final Object obj) throws DecoderException {
    if (obj == null) {
        return null;
    }
    if (obj instanceof byte[]) {
        return decode((byte[]) obj);
    }
    if (obj instanceof String) {
        return decode((String) obj);
    }
    throw new DecoderException(""Objects of type "" + obj.getClass().getName() + "" cannot be quoted-printable decoded"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.decode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(String)","Method","* Decodes a quoted-printable string into its original form using the default string Charset. Escaped characters are
     * converted back to their original representation.
     *
     * @param sourceStr
     *            quoted-printable string to convert into its original form
     * @return original string
     * @throws DecoderException
     *             Thrown if quoted-printable decoding is unsuccessful. Thrown if Charset is not supported.
     * @see #getCharset()","@Override
public String decode(final String sourceStr) throws DecoderException {
    return this.decode(sourceStr, getCharset());
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(String).sourceStr","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.decode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,Charset)","Method","* Decodes a quoted-printable string into its original form using the specified string Charset. Escaped characters
     * are converted back to their original representation.
     *
     * @param sourceStr
     *            quoted-printable string to convert into its original form
     * @param sourceCharset
     *            the original string Charset
     * @return original string
     * @throws DecoderException
     *             Thrown if quoted-printable decoding is unsuccessful
     * @since 1.7","public String decode(final String sourceStr, final Charset sourceCharset) throws DecoderException {
    if (sourceStr == null) {
        return null;
    }
    return new String(this.decode(StringUtils.getBytesUsAscii(sourceStr)), sourceCharset);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,Charset).sourceStr","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,Charset).sourceCharset","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,String)","Method","* Decodes a quoted-printable string into its original form using the specified string Charset. Escaped characters
     * are converted back to their original representation.
     *
     * @param sourceStr
     *            quoted-printable string to convert into its original form
     * @param sourceCharset
     *            the original string Charset
     * @return original string
     * @throws DecoderException
     *             Thrown if quoted-printable decoding is unsuccessful
     * @throws UnsupportedEncodingException
     *             Thrown if Charset is not supported","public String decode(final String sourceStr, final String sourceCharset) throws DecoderException, UnsupportedEncodingException {
    if (sourceStr == null) {
        return null;
    }
    return new String(decode(StringUtils.getBytesUsAscii(sourceStr)), sourceCharset);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,String).sourceStr","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,String).sourceCharset","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.decode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(byte[])","Method","* Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.
     * <p>
     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset
     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
     * RFC 1521 and is suitable for encoding binary data and unformatted text.
     * </p>
     *
     * @param bytes
     *            array of bytes to be encoded
     * @return array of bytes containing quoted-printable data","@Override
public byte[] encode(final byte[] bytes) {
    return encodeQuotedPrintable(PRINTABLE_CHARS, bytes, strict);
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(Object)","Method","* Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.
     *
     * @param obj
     *            string to convert to a quoted-printable form
     * @return quoted-printable object
     * @throws EncoderException
     *             Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is
     *             unsuccessful","@Override
public Object encode(final Object obj) throws EncoderException {
    if (obj == null) {
        return null;
    }
    if (obj instanceof byte[]) {
        return encode((byte[]) obj);
    }
    if (obj instanceof String) {
        return encode((String) obj);
    }
    throw new EncoderException(""Objects of type "" + obj.getClass().getName() + "" cannot be quoted-printable encoded"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(String)","Method","* Encodes a string into its quoted-printable form using the default string Charset. Unsafe characters are escaped.
     * <p>
     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset
     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
     * RFC 1521 and is suitable for encoding binary data and unformatted text.
     * </p>
     *
     * @param sourceStr
     *            string to convert to quoted-printable form
     * @return quoted-printable string
     * @throws EncoderException
     *             Thrown if quoted-printable encoding is unsuccessful
     *
     * @see #getCharset()","@Override
public String encode(final String sourceStr) throws EncoderException {
    return encode(sourceStr, getCharset());
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(String).sourceStr","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,Charset)","Method","* Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.
     * <p>
     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset
     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
     * RFC 1521 and is suitable for encoding binary data and unformatted text.
     * </p>
     *
     * @param sourceStr
     *            string to convert to quoted-printable form
     * @param sourceCharset
     *            the Charset for sourceStr
     * @return quoted-printable string
     * @since 1.7","public String encode(final String sourceStr, final Charset sourceCharset) {
    if (sourceStr == null) {
        return null;
    }
    return StringUtils.newStringUsAscii(this.encode(sourceStr.getBytes(sourceCharset)));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,Charset).sourceStr","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,Charset).sourceCharset","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,String)","Method","* Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.
     * <p>
     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset
     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
     * RFC 1521 and is suitable for encoding binary data and unformatted text.
     * </p>
     *
     * @param sourceStr
     *            string to convert to quoted-printable form
     * @param sourceCharset
     *            the Charset for sourceStr
     * @return quoted-printable string
     * @throws UnsupportedEncodingException
     *             Thrown if the Charset is not supported","public String encode(final String sourceStr, final String sourceCharset) throws UnsupportedEncodingException {
    if (sourceStr == null) {
        return null;
    }
    return StringUtils.newStringUsAscii(encode(sourceStr.getBytes(sourceCharset)));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,String).sourceStr","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,String).sourceCharset","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.encode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.getCharset()","Method","* Gets the default Charset name used for string decoding and encoding.
     *
     * @return the default Charset name
     * @since 1.7","public Charset getCharset() {
    return this.charset;
}","Charset","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.getDefaultCharset()","Method","* Gets the default Charset name used for string decoding and encoding.
     *
     * @return the default Charset name","public String getDefaultCharset() {
    return this.charset.name();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>()","Constructor","* Default constructor, assumes default Charset of {@link StandardCharsets#UTF_8}","public QuotedPrintableCodec() {
    this(StandardCharsets.UTF_8, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>(boolean)","Constructor","* Constructor which allows for the selection of the strict mode.
     *
     * @param strict
     *            if {@code true}, soft line breaks will be used
     * @since 1.10","public QuotedPrintableCodec(final boolean strict) {
    this(StandardCharsets.UTF_8, strict);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>(boolean).strict","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.<init>(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>(Charset)","Constructor","* Constructor which allows for the selection of a default Charset.
     *
     * @param charset
     *            the default string Charset to use.
     * @since 1.7","public QuotedPrintableCodec(final Charset charset) {
    this(charset, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>(Charset).charset","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.<init>(Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>(Charset,boolean)","Constructor","* Constructor which allows for the selection of a default Charset and strict mode.
     *
     * @param charset
     *            the default string Charset to use.
     * @param strict
     *            if {@code true}, soft line breaks will be used
     * @since 1.10","public QuotedPrintableCodec(final Charset charset, final boolean strict) {
    this.charset = charset;
    this.strict = strict;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>(Charset,boolean).charset","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.<init>(Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>(Charset,boolean).strict","Parameter_2","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.<init>(Charset,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>(String)","Constructor","* Constructor which allows for the selection of a default Charset.
     *
     * @param charsetName
     *            the default string Charset to use.
     * @throws UnsupportedCharsetException
     *             If no support for the named Charset is available
     *             in this instance of the Java virtual machine
     * @throws IllegalArgumentException
     *             If the given charsetName is null
     * @throws IllegalCharsetNameException
     *             If the given Charset name is illegal
     *
     * @since 1.7 throws UnsupportedCharsetException if the named Charset is unavailable","public QuotedPrintableCodec(final String charsetName) throws IllegalCharsetNameException, IllegalArgumentException, UnsupportedCharsetException {
    this(Charset.forName(charsetName), false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QuotedPrintableCodec.<init>(String).charsetName","Parameter_1","Belong to org.apache.commons.codec.net.QuotedPrintableCodec.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec","Class","* Similar to the Quoted-Printable content-transfer-encoding defined in
 * <a href=""http://www.ietf.org/rfc/rfc1521.txt"">RFC 1521</a> and designed to allow text containing mostly ASCII
 * characters to be decipherable on an ASCII terminal without decoding.
 * <p>
 * <a href=""http://www.ietf.org/rfc/rfc1522.txt"">RFC 1522</a> describes techniques to allow the encoding of non-ASCII
 * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message
 * handling software.
 * </p>
 * <p>
 * This class is conditionally thread-safe.
 * The instance field for encoding blanks is mutable {@link #setEncodeBlanks(boolean)}
 * but is not volatile, and accesses are not synchronized.
 * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronization
 * is used to ensure safe publication of the value between threads, and must not invoke
 * {@link #setEncodeBlanks(boolean)} after initial setup.
 * </p>
 *
 * @see <a href=""http://www.ietf.org/rfc/rfc1522.txt"">MIME (Multipurpose Internet Mail Extensions) Part Two: Message
 *          Header Extensions for Non-ASCII Text</a>
 *
 * @since 1.3","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.net.RFC1522Codec","org.apache.commons.codec.StringEncoder;org.apache.commons.codec.StringDecoder"
"org.apache.commons.codec.net.QCodec.PRINTABLE_CHARS","Field","* BitSet of printable characters as defined in RFC 1522.","private static final BitSet PRINTABLE_CHARS = new BitSet(256);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.SPACE","Field","No Comment","private static final byte SPACE = 32;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.UNDERSCORE","Field","No Comment","private static final byte UNDERSCORE = 95;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encodeBlanks","Field","No Comment","private boolean encodeBlanks;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.decode(Object)","Method","* Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original
     * representation.
     *
     * @param obj
     *            quoted-printable object to convert into its original form
     * @return original object
     * @throws DecoderException
     *             Thrown if the argument is not a {@code String}. Thrown if a failure condition is encountered
     *             during the decode process.","@Override
public Object decode(final Object obj) throws DecoderException {
    if (obj == null) {
        return null;
    }
    if (obj instanceof String) {
        return decode((String) obj);
    }
    throw new DecoderException(""Objects of type "" + obj.getClass().getName() + "" cannot be decoded using Q codec"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.decode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.decode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.decode(String)","Method","* Decodes a quoted-printable string into its original form. Escaped characters are converted back to their original
     * representation.
     *
     * @param str
     *            quoted-printable string to convert into its original form
     * @return original string
     * @throws DecoderException
     *             A decoder exception is thrown if a failure condition is encountered during the decode process.","@Override
public String decode(final String str) throws DecoderException {
    try {
        return decodeText(str);
    } catch (final UnsupportedEncodingException e) {
        throw new DecoderException(e.getMessage(), e);
    }
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.decode(String).str","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.decode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.doDecoding(byte[])","Method","No Comment","@Override
protected byte[] doDecoding(final byte[] bytes) throws DecoderException {
    if (bytes == null) {
        return null;
    }
    boolean hasUnderscores = false;
    for (final byte b : bytes) {
        if (b == UNDERSCORE) {
            hasUnderscores = true;
            break;
        }
    }
    if (hasUnderscores) {
        final byte[] tmp = new byte[bytes.length];
        for (int i = 0; i < bytes.length; i++) {
            final byte b = bytes[i];
            if (b != UNDERSCORE) {
                tmp[i] = b;
            } else {
                tmp[i] = SPACE;
            }
        }
        return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
    }
    return QuotedPrintableCodec.decodeQuotedPrintable(bytes);
}","byte[]","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.doDecoding(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.doDecoding(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.doEncoding(byte[])","Method","No Comment","@Override
protected byte[] doEncoding(final byte[] bytes) {
    if (bytes == null) {
        return null;
    }
    final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
    if (this.encodeBlanks) {
        for (int i = 0; i < data.length; i++) {
            if (data[i] == SPACE) {
                data[i] = UNDERSCORE;
            }
        }
    }
    return data;
}","byte[]","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.doEncoding(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.doEncoding(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(Object)","Method","* Encodes an object into its quoted-printable form using the default Charset. Unsafe characters are escaped.
     *
     * @param obj
     *            object to convert to quoted-printable form
     * @return quoted-printable object
     * @throws EncoderException
     *             thrown if a failure condition is encountered during the encoding process.","@Override
public Object encode(final Object obj) throws EncoderException {
    if (obj == null) {
        return null;
    }
    if (obj instanceof String) {
        return encode((String) obj);
    }
    throw new EncoderException(""Objects of type "" + obj.getClass().getName() + "" cannot be encoded using Q codec"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(String)","Method","* Encodes a string into its quoted-printable form using the default Charset. Unsafe characters are escaped.
     *
     * @param sourceStr
     *            string to convert to quoted-printable form
     * @return quoted-printable string
     * @throws EncoderException
     *             thrown if a failure condition is encountered during the encoding process.","@Override
public String encode(final String sourceStr) throws EncoderException {
    return encode(sourceStr, getCharset());
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(String).sourceStr","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(String,Charset)","Method","* Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.
     *
     * @param sourceStr
     *            string to convert to quoted-printable form
     * @param sourceCharset
     *            the Charset for sourceStr
     * @return quoted-printable string
     * @throws EncoderException
     *             thrown if a failure condition is encountered during the encoding process.
     * @since 1.7","public String encode(final String sourceStr, final Charset sourceCharset) throws EncoderException {
    return encodeText(sourceStr, sourceCharset);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(String,Charset).sourceStr","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.encode(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(String,Charset).sourceCharset","Parameter_2","Belong to org.apache.commons.codec.net.QCodec.encode(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(String,String)","Method","* Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.
     *
     * @param sourceStr
     *            string to convert to quoted-printable form
     * @param sourceCharset
     *            the Charset for sourceStr
     * @return quoted-printable string
     * @throws EncoderException
     *             thrown if a failure condition is encountered during the encoding process.","public String encode(final String sourceStr, final String sourceCharset) throws EncoderException {
    try {
        return encodeText(sourceStr, sourceCharset);
    } catch (final UnsupportedCharsetException e) {
        throw new EncoderException(e.getMessage(), e);
    }
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(String,String).sourceStr","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.encode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.encode(String,String).sourceCharset","Parameter_2","Belong to org.apache.commons.codec.net.QCodec.encode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.getEncoding()","Method","No Comment","@Override
protected String getEncoding() {
    return ""Q"";
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.isEncodeBlanks()","Method","* Tests if optional transformation of SPACE characters is to be used
     *
     * @return {@code true} if SPACE characters are to be transformed, {@code false} otherwise","public boolean isEncodeBlanks() {
    return this.encodeBlanks;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.setEncodeBlanks(boolean)","Method","* Defines whether optional transformation of SPACE characters is to be used
     *
     * @param b
     *            {@code true} if SPACE characters are to be transformed, {@code false} otherwise","public void setEncodeBlanks(final boolean b) {
    this.encodeBlanks = b;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.setEncodeBlanks(boolean).b","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.setEncodeBlanks(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.<init>()","Constructor","* Default constructor.","public QCodec() {
    this(StandardCharsets.UTF_8);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.<init>(Charset)","Constructor","* Constructor which allows for the selection of a default Charset.
     *
     * @param charset
     *            the default string Charset to use.
     *
     * @see Charset
     * @since 1.7","public QCodec(final Charset charset) {
    super(charset);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.<init>(Charset).charset","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.<init>(Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.<init>(String)","Constructor","* Constructor which allows for the selection of a default Charset.
     *
     * @param charsetName
     *            the Charset to use.
     * @throws java.nio.charset.UnsupportedCharsetException
     *             If the named Charset is unavailable
     * @since 1.7 throws UnsupportedCharsetException if the named Charset is unavailable
     * @see Charset","public QCodec(final String charsetName) {
    this(Charset.forName(charsetName));
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.QCodec.<init>(String).charsetName","Parameter_1","Belong to org.apache.commons.codec.net.QCodec.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec","Class","* Implements the Percent-Encoding scheme, as described in HTTP 1.1 specification. For extensibility, an array of
 * special US-ASCII characters can be specified in order to perform proper URI encoding for the different parts
 * of the URI.
 * <p>
 * This class is immutable. It is also thread-safe besides using BitSet which is not thread-safe, but its public
 * interface only call the access
 * </p>
 *
 * @see <a href=""https://tools.ietf.org/html/rfc3986#section-2.1"">Percent-Encoding</a>
 * @since 1.12","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.BinaryEncoder;org.apache.commons.codec.BinaryDecoder"
"org.apache.commons.codec.net.PercentCodec.ESCAPE_CHAR","Field","* The escape character used by the Percent-Encoding in order to introduce an encoded character.","private static final byte ESCAPE_CHAR = '%';","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.alwaysEncodeChars","Field","* The bit set used to store the character that should be always encoded","private final BitSet alwaysEncodeChars = new BitSet();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.plusForSpace","Field","* The flag defining if the space character should be encoded as '+'","private final boolean plusForSpace;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.alwaysEncodeCharsMin","Field","* The minimum and maximum code of the bytes that is inserted in the bit set, used to prevent look-ups","private int alwaysEncodeCharsMin = Integer.MAX_VALUE, alwaysEncodeCharsMax = Integer.MIN_VALUE;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.alwaysEncodeCharsMax","Field","* The minimum and maximum code of the bytes that is inserted in the bit set, used to prevent look-ups","private int alwaysEncodeCharsMin = Integer.MAX_VALUE, alwaysEncodeCharsMax = Integer.MIN_VALUE;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.canEncode(byte)","Method","No Comment","private boolean canEncode(final byte c) {
    return !isAsciiChar(c) || inAlwaysEncodeCharsRange(c) && alwaysEncodeChars.get(c);
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.canEncode(byte).c","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.canEncode(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.containsSpace(byte[])","Method","No Comment","private boolean containsSpace(final byte[] bytes) {
    for (final byte b : bytes) {
        if (b == ' ') {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.containsSpace(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.containsSpace(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.decode(byte[])","Method","* Decodes bytes encoded with Percent-Encoding based on RFC 3986. The reverse process is performed in order to
     * decode the encoded characters to Unicode.","@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
    if (bytes == null) {
        return null;
    }
    final ByteBuffer buffer = ByteBuffer.allocate(expectedDecodingBytes(bytes));
    for (int i = 0; i < bytes.length; i++) {
        final byte b = bytes[i];
        if (b == ESCAPE_CHAR) {
            try {
                final int u = Utils.digit16(bytes[++i]);
                final int l = Utils.digit16(bytes[++i]);
                buffer.put((byte) ((u << 4) + l));
            } catch (final ArrayIndexOutOfBoundsException e) {
                throw new DecoderException(""Invalid percent decoding: "", e);
            }
        } else if (plusForSpace && b == '+') {
            buffer.put((byte) ' ');
        } else {
            buffer.put(b);
        }
    }
    return buffer.array();
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.decode(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.decode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.decode(Object)","Method","* Decodes a byte[] Object, whose bytes are encoded with Percent-Encoding.
     *
     * @param obj the object to decode
     * @return the decoding result byte[] as Object
     * @throws DecoderException if the object is not a byte array","@Override
public Object decode(final Object obj) throws DecoderException {
    if (obj == null) {
        return null;
    }
    if (obj instanceof byte[]) {
        return decode((byte[]) obj);
    }
    throw new DecoderException(""Objects of type "" + obj.getClass().getName() + "" cannot be Percent decoded"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.decode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.decode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.doEncode(byte[],int,boolean)","Method","No Comment","private byte[] doEncode(final byte[] bytes, final int expectedLength, final boolean willEncode) {
    final ByteBuffer buffer = ByteBuffer.allocate(expectedLength);
    for (final byte b : bytes) {
        if (willEncode && canEncode(b)) {
            byte bb = b;
            if (bb < 0) {
                bb = (byte) (256 + bb);
            }
            final char hex1 = Utils.hexDigit(bb >> 4);
            final char hex2 = Utils.hexDigit(bb);
            buffer.put(ESCAPE_CHAR);
            buffer.put((byte) hex1);
            buffer.put((byte) hex2);
        } else if (plusForSpace && b == ' ') {
            buffer.put((byte) '+');
        } else {
            buffer.put(b);
        }
    }
    return buffer.array();
}","byte[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.doEncode(byte[],int,boolean).bytes","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.doEncode(byte[],int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.doEncode(byte[],int,boolean).expectedLength","Parameter_2","Belong to org.apache.commons.codec.net.PercentCodec.doEncode(byte[],int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.doEncode(byte[],int,boolean).willEncode","Parameter_3","Belong to org.apache.commons.codec.net.PercentCodec.doEncode(byte[],int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.encode(byte[])","Method","* Percent-Encoding based on RFC 3986. The non US-ASCII characters are encoded, as well as the
     * US-ASCII characters that are configured to be always encoded.","@Override
public byte[] encode(final byte[] bytes) throws EncoderException {
    if (bytes == null) {
        return null;
    }
    final int expectedEncodingBytes = expectedEncodingBytes(bytes);
    final boolean willEncode = expectedEncodingBytes != bytes.length;
    if (willEncode || plusForSpace && containsSpace(bytes)) {
        return doEncode(bytes, expectedEncodingBytes, willEncode);
    }
    return bytes;
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.encode(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.encode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.encode(Object)","Method","* Encodes an object into using the Percent-Encoding. Only byte[] objects are accepted.
     *
     * @param obj the object to encode
     * @return the encoding result byte[] as Object
     * @throws EncoderException if the object is not a byte array","@Override
public Object encode(final Object obj) throws EncoderException {
    if (obj == null) {
        return null;
    }
    if (obj instanceof byte[]) {
        return encode((byte[]) obj);
    }
    throw new EncoderException(""Objects of type "" + obj.getClass().getName() + "" cannot be Percent encoded"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.expectedDecodingBytes(byte[])","Method","No Comment","private int expectedDecodingBytes(final byte[] bytes) {
    int byteCount = 0;
    for (int i = 0; i < bytes.length; ) {
        final byte b = bytes[i];
        i += b == ESCAPE_CHAR ? 3 : 1;
        byteCount++;
    }
    return byteCount;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.expectedDecodingBytes(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.expectedDecodingBytes(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.expectedEncodingBytes(byte[])","Method","No Comment","private int expectedEncodingBytes(final byte[] bytes) {
    int byteCount = 0;
    for (final byte b : bytes) {
        byteCount += canEncode(b) ? 3 : 1;
    }
    return byteCount;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.expectedEncodingBytes(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.expectedEncodingBytes(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.inAlwaysEncodeCharsRange(byte)","Method","No Comment","private boolean inAlwaysEncodeCharsRange(final byte c) {
    return c >= alwaysEncodeCharsMin && c <= alwaysEncodeCharsMax;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.inAlwaysEncodeCharsRange(byte).c","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.inAlwaysEncodeCharsRange(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.insertAlwaysEncodeChar(byte)","Method","* Inserts a single character into a BitSet and maintains the min and max of the characters of the
     * {@code BitSet alwaysEncodeChars} in order to avoid look-ups when a byte is out of this range.
     *
     * @param b the byte that is candidate for min and max limit","private void insertAlwaysEncodeChar(final byte b) {
    if (b < 0) {
        throw new IllegalArgumentException(""byte must be >= 0"");
    }
    this.alwaysEncodeChars.set(b);
    if (b < alwaysEncodeCharsMin) {
        alwaysEncodeCharsMin = b;
    }
    if (b > alwaysEncodeCharsMax) {
        alwaysEncodeCharsMax = b;
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.insertAlwaysEncodeChar(byte).b","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.insertAlwaysEncodeChar(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.insertAlwaysEncodeChars(byte[])","Method","* Inserts the byte array into a BitSet for faster lookup.
     *
     * @param alwaysEncodeCharsArray","private void insertAlwaysEncodeChars(final byte[] alwaysEncodeCharsArray) {
    if (alwaysEncodeCharsArray != null) {
        for (final byte b : alwaysEncodeCharsArray) {
            insertAlwaysEncodeChar(b);
        }
    }
    insertAlwaysEncodeChar(ESCAPE_CHAR);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.insertAlwaysEncodeChars(byte[]).alwaysEncodeCharsArray","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.insertAlwaysEncodeChars(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.isAsciiChar(byte)","Method","No Comment","private boolean isAsciiChar(final byte c) {
    return c >= 0;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.isAsciiChar(byte).c","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.isAsciiChar(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.<init>()","Constructor","* Constructs a Percent coded that will encode all the non US-ASCII characters using the Percent-Encoding
     * while it will not encode all the US-ASCII characters, except for character '%' that is used as escape
     * character for Percent-Encoding.","public PercentCodec() {
    this.plusForSpace = false;
    insertAlwaysEncodeChar(ESCAPE_CHAR);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.<init>(byte[],boolean)","Constructor","* Constructs a Percent codec by specifying the characters that belong to US-ASCII that should
     * always be encoded. The rest US-ASCII characters will not be encoded, except for character '%' that
     * is used as escape character for Percent-Encoding.
     *
     * @param alwaysEncodeChars the unsafe characters that should always be encoded
     * @param plusForSpace      the flag defining if the space character should be encoded as '+'","public PercentCodec(final byte[] alwaysEncodeChars, final boolean plusForSpace) {
    this.plusForSpace = plusForSpace;
    insertAlwaysEncodeChars(alwaysEncodeChars);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.<init>(byte[],boolean).alwaysEncodeChars","Parameter_1","Belong to org.apache.commons.codec.net.PercentCodec.<init>(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.PercentCodec.<init>(byte[],boolean).plusForSpace","Parameter_2","Belong to org.apache.commons.codec.net.PercentCodec.<init>(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec","Class","* Implements the 'www-form-urlencoded' encoding scheme, also misleadingly known as URL encoding.
 * <p>
 * This codec is meant to be a replacement for standard Java classes {@link java.net.URLEncoder} and
 * {@link java.net.URLDecoder} on older Java platforms, as these classes in Java versions below
 * 1.4 rely on the platform's default charset encoding.
 * </p>
 * <p>
 * This class is thread-safe as of 1.11
 * </p>
 *
 * @see <a href=""http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1"">Chapter 17.13.4 Form content types</a>
 *           of the <a href=""http://www.w3.org/TR/html4/"">HTML 4.01 Specification</a>
 *
 * @since 1.2","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.BinaryEncoder;org.apache.commons.codec.BinaryDecoder;org.apache.commons.codec.StringEncoder;org.apache.commons.codec.StringDecoder"
"org.apache.commons.codec.net.URLCodec.ESCAPE_CHAR","Field","* Release 1.5 made this field final.","protected static final byte ESCAPE_CHAR = '%';","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.WWW_FORM_URL","Field","* BitSet of www-form-url safe characters.
     * This is a copy of the internal BitSet which is now used for the conversion.
     * Changes to this field are ignored.
     * @deprecated 1.11 Will be removed in 2.0 (CODEC-230)","@Deprecated
protected static final BitSet WWW_FORM_URL;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.WWW_FORM_URL_SAFE","Field","No Comment","private static final BitSet WWW_FORM_URL_SAFE = new BitSet(256);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.charset","Field","* The default charset used for string decoding and encoding.
     *
     * @deprecated TODO: This field will be changed to a private final Charset in 2.0. (CODEC-126)","@Deprecated
protected volatile String // added volatile: see CODEC-232
charset;","No return type","protected , volatile ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decodeUrl(byte[])","Method","* Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted
     * back to their original representation.
     *
     * @param bytes
     *            array of URL safe characters
     * @return array of original bytes
     * @throws DecoderException
     *             Thrown if URL decoding is unsuccessful","public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {
    if (bytes == null) {
        return null;
    }
    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    for (int i = 0; i < bytes.length; i++) {
        final int b = bytes[i];
        if (b == '+') {
            buffer.write(' ');
        } else if (b == ESCAPE_CHAR) {
            try {
                final int u = Utils.digit16(bytes[++i]);
                final int l = Utils.digit16(bytes[++i]);
                buffer.write((char) ((u << 4) + l));
            } catch (final ArrayIndexOutOfBoundsException e) {
                throw new DecoderException(""Invalid URL encoding: "", e);
            }
        } else {
            buffer.write(b);
        }
    }
    return buffer.toByteArray();
}","byte[]","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decodeUrl(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.decodeUrl(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encodeUrl(BitSet,byte[])","Method","* Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.
     *
     * @param urlsafe
     *            bitset of characters deemed URL safe
     * @param bytes
     *            array of bytes to convert to URL safe characters
     * @return array of bytes containing URL safe characters","public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {
    if (bytes == null) {
        return null;
    }
    if (urlsafe == null) {
        urlsafe = WWW_FORM_URL_SAFE;
    }
    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    for (final byte c : bytes) {
        int b = c;
        if (b < 0) {
            b = 256 + b;
        }
        if (urlsafe.get(b)) {
            if (b == ' ') {
                b = '+';
            }
            buffer.write(b);
        } else {
            buffer.write(ESCAPE_CHAR);
            final char hex1 = Utils.hexDigit(b >> 4);
            final char hex2 = Utils.hexDigit(b);
            buffer.write(hex1);
            buffer.write(hex2);
        }
    }
    return buffer.toByteArray();
}","byte[]","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encodeUrl(BitSet,byte[]).urlsafe","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.encodeUrl(BitSet,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encodeUrl(BitSet,byte[]).bytes","Parameter_2","Belong to org.apache.commons.codec.net.URLCodec.encodeUrl(BitSet,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decode(byte[])","Method","* Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted
     * back to their original representation.
     *
     * @param bytes
     *            array of URL safe characters
     * @return array of original bytes
     * @throws DecoderException
     *             Thrown if URL decoding is unsuccessful","@Override
public byte[] decode(final byte[] bytes) throws DecoderException {
    return decodeUrl(bytes);
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decode(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.decode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decode(Object)","Method","* Decodes a URL safe object into its original form. Escaped characters are converted back to their original
     * representation.
     *
     * @param obj
     *            URL safe object to convert into its original form
     * @return original object
     * @throws DecoderException
     *             Thrown if the argument is not a {@code String} or {@code byte[]}. Thrown if a failure
     *             condition is encountered during the decode process.","@Override
public Object decode(final Object obj) throws DecoderException {
    if (obj == null) {
        return null;
    }
    if (obj instanceof byte[]) {
        return decode((byte[]) obj);
    }
    if (obj instanceof String) {
        return decode((String) obj);
    }
    throw new DecoderException(""Objects of type "" + obj.getClass().getName() + "" cannot be URL decoded"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.decode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decode(String)","Method","* Decodes a URL safe string into its original form using the default string charset. Escaped characters are
     * converted back to their original representation.
     *
     * @param str
     *            URL safe string to convert into its original form
     * @return original string
     * @throws DecoderException
     *             Thrown if URL decoding is unsuccessful
     * @see #getDefaultCharset()","@Override
public String decode(final String str) throws DecoderException {
    if (str == null) {
        return null;
    }
    try {
        return decode(str, getDefaultCharset());
    } catch (final UnsupportedEncodingException e) {
        throw new DecoderException(e.getMessage(), e);
    }
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decode(String).str","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.decode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decode(String,String)","Method","* Decodes a URL safe string into its original form using the specified encoding. Escaped characters are converted
     * back to their original representation.
     *
     * @param str
     *            URL safe string to convert into its original form
     * @param charsetName
     *            the original string charset
     * @return original string
     * @throws DecoderException
     *             Thrown if URL decoding is unsuccessful
     * @throws UnsupportedEncodingException
     *             Thrown if charset is not supported","public String decode(final String str, final String charsetName) throws DecoderException, UnsupportedEncodingException {
    if (str == null) {
        return null;
    }
    return new String(decode(StringUtils.getBytesUsAscii(str)), charsetName);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decode(String,String).str","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.decode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.decode(String,String).charsetName","Parameter_2","Belong to org.apache.commons.codec.net.URLCodec.decode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encode(byte[])","Method","* Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.
     *
     * @param bytes
     *            array of bytes to convert to URL safe characters
     * @return array of bytes containing URL safe characters","@Override
public byte[] encode(final byte[] bytes) {
    return encodeUrl(WWW_FORM_URL_SAFE, bytes);
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encode(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.encode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encode(Object)","Method","* Encodes an object into its URL safe form. Unsafe characters are escaped.
     *
     * @param obj
     *            string to convert to a URL safe form
     * @return URL safe object
     * @throws EncoderException
     *             Thrown if URL encoding is not applicable to objects of this type or if encoding is unsuccessful","@Override
public Object encode(final Object obj) throws EncoderException {
    if (obj == null) {
        return null;
    }
    if (obj instanceof byte[]) {
        return encode((byte[]) obj);
    }
    if (obj instanceof String) {
        return encode((String) obj);
    }
    throw new EncoderException(""Objects of type "" + obj.getClass().getName() + "" cannot be URL encoded"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encode(String)","Method","* Encodes a string into its URL safe form using the default string charset. Unsafe characters are escaped.
     *
     * @param str
     *            string to convert to a URL safe form
     * @return URL safe string
     * @throws EncoderException
     *             Thrown if URL encoding is unsuccessful
     *
     * @see #getDefaultCharset()","@Override
public String encode(final String str) throws EncoderException {
    if (str == null) {
        return null;
    }
    try {
        return encode(str, getDefaultCharset());
    } catch (final UnsupportedEncodingException e) {
        throw new EncoderException(e.getMessage(), e);
    }
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encode(String).str","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encode(String,String)","Method","* Encodes a string into its URL safe form using the specified string charset. Unsafe characters are escaped.
     *
     * @param str
     *            string to convert to a URL safe form
     * @param charsetName
     *            the charset for str
     * @return URL safe string
     * @throws UnsupportedEncodingException
     *             Thrown if charset is not supported","public String encode(final String str, final String charsetName) throws UnsupportedEncodingException {
    if (str == null) {
        return null;
    }
    return StringUtils.newStringUsAscii(encode(str.getBytes(charsetName)));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encode(String,String).str","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.encode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.encode(String,String).charsetName","Parameter_2","Belong to org.apache.commons.codec.net.URLCodec.encode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.getDefaultCharset()","Method","* The default charset used for string decoding and encoding.
     *
     * @return the default string charset.","public String getDefaultCharset() {
    return this.charset;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.getEncoding()","Method","* The {@code String} encoding used for decoding and encoding.
     *
     * @return the encoding.
     * @deprecated Use {@link #getDefaultCharset()}, will be removed in 2.0.","@Deprecated
public String getEncoding() {
    return this.charset;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.<init>()","Constructor","* Default constructor.","public URLCodec() {
    this(CharEncoding.UTF_8);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.<init>(String)","Constructor","* Constructor which allows for the selection of a default charset.
     *
     * @param charset the default string charset to use.","public URLCodec(final String charset) {
    this.charset = charset;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.URLCodec.<init>(String).charset","Parameter_1","Belong to org.apache.commons.codec.net.URLCodec.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec","Class","* Identical to the Base64 encoding defined by <a href=""http://www.ietf.org/rfc/rfc1521.txt"">RFC 1521</a>
 * and allows a character set to be specified.
 * <p>
 * <a href=""http://www.ietf.org/rfc/rfc1522.txt"">RFC 1522</a> describes techniques to allow the encoding of non-ASCII
 * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message
 * handling software.
 * </p>
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @see <a href=""http://www.ietf.org/rfc/rfc1522.txt"">MIME (Multipurpose Internet Mail Extensions) Part Two: Message
 *          Header Extensions for Non-ASCII Text</a>
 *
 * @since 1.3","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.net.RFC1522Codec","org.apache.commons.codec.StringEncoder;org.apache.commons.codec.StringDecoder"
"org.apache.commons.codec.net.BCodec.DECODING_POLICY_DEFAULT","Field","* The default decoding policy.","private static final CodecPolicy DECODING_POLICY_DEFAULT = CodecPolicy.LENIENT;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.decodingPolicy","Field","* If true then decoding should throw an exception for impossible combinations of bits at the
     * end of the byte input. The default is to decode as much of them as possible.","private final CodecPolicy decodingPolicy;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.decode(Object)","Method","* Decodes a Base64 object into its original form. Escaped characters are converted back to their original
     * representation.
     *
     * @param value
     *            Base64 object to convert into its original form
     * @return original object
     * @throws DecoderException
     *             Thrown if the argument is not a {@code String}. Thrown if a failure condition is encountered
     *             during the decode process.","@Override
public Object decode(final Object value) throws DecoderException {
    if (value == null) {
        return null;
    }
    if (value instanceof String) {
        return decode((String) value);
    }
    throw new DecoderException(""Objects of type "" + value.getClass().getName() + "" cannot be decoded using BCodec"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.decode(Object).value","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.decode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.decode(String)","Method","* Decodes a Base64 string into its original form. Escaped characters are converted back to their original
     * representation.
     *
     * @param value
     *            Base64 string to convert into its original form
     * @return original string
     * @throws DecoderException
     *             A decoder exception is thrown if a failure condition is encountered during the decode process.","@Override
public String decode(final String value) throws DecoderException {
    try {
        return decodeText(value);
    } catch (final UnsupportedEncodingException | IllegalArgumentException e) {
        throw new DecoderException(e.getMessage(), e);
    }
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.decode(String).value","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.decode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.doDecoding(byte[])","Method","No Comment","@Override
protected byte[] doDecoding(final byte[] bytes) {
    if (bytes == null) {
        return null;
    }
    return new Base64(0, BaseNCodec.getChunkSeparator(), false, decodingPolicy).decode(bytes);
}","byte[]","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.doDecoding(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.doDecoding(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.doEncoding(byte[])","Method","No Comment","@Override
protected byte[] doEncoding(final byte[] bytes) {
    if (bytes == null) {
        return null;
    }
    return Base64.encodeBase64(bytes);
}","byte[]","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.doEncoding(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.doEncoding(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(Object)","Method","* Encodes an object into its Base64 form using the default Charset. Unsafe characters are escaped.
     *
     * @param value
     *            object to convert to Base64 form
     * @return Base64 object
     * @throws EncoderException
     *             thrown if a failure condition is encountered during the encoding process.","@Override
public Object encode(final Object value) throws EncoderException {
    if (value == null) {
        return null;
    }
    if (value instanceof String) {
        return encode((String) value);
    }
    throw new EncoderException(""Objects of type "" + value.getClass().getName() + "" cannot be encoded using BCodec"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(Object).value","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(String)","Method","* Encodes a string into its Base64 form using the default Charset. Unsafe characters are escaped.
     *
     * @param strSource
     *            string to convert to Base64 form
     * @return Base64 string
     * @throws EncoderException
     *             thrown if a failure condition is encountered during the encoding process.","@Override
public String encode(final String strSource) throws EncoderException {
    return encode(strSource, getCharset());
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(String).strSource","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(String,Charset)","Method","* Encodes a string into its Base64 form using the specified Charset. Unsafe characters are escaped.
     *
     * @param strSource
     *            string to convert to Base64 form
     * @param sourceCharset
     *            the Charset for {@code value}
     * @return Base64 string
     * @throws EncoderException
     *             thrown if a failure condition is encountered during the encoding process.
     * @since 1.7","public String encode(final String strSource, final Charset sourceCharset) throws EncoderException {
    return encodeText(strSource, sourceCharset);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(String,Charset).strSource","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.encode(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(String,Charset).sourceCharset","Parameter_2","Belong to org.apache.commons.codec.net.BCodec.encode(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(String,String)","Method","* Encodes a string into its Base64 form using the specified Charset. Unsafe characters are escaped.
     *
     * @param strSource
     *            string to convert to Base64 form
     * @param sourceCharset
     *            the Charset for {@code value}
     * @return Base64 string
     * @throws EncoderException
     *             thrown if a failure condition is encountered during the encoding process.","public String encode(final String strSource, final String sourceCharset) throws EncoderException {
    try {
        return encodeText(strSource, sourceCharset);
    } catch (final UnsupportedCharsetException e) {
        throw new EncoderException(e.getMessage(), e);
    }
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(String,String).strSource","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.encode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.encode(String,String).sourceCharset","Parameter_2","Belong to org.apache.commons.codec.net.BCodec.encode(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.getEncoding()","Method","No Comment","@Override
protected String getEncoding() {
    return ""B"";
}","String","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.isStrictDecoding()","Method","* Returns true if decoding behavior is strict. Decoding will raise a
     * {@link DecoderException} if trailing bits are not part of a valid Base64 encoding.
     *
     * <p>The default is false for lenient encoding. Decoding will compose trailing bits
     * into 8-bit bytes and discard the remainder.
     *
     * @return true if using strict decoding
     * @since 1.15","public boolean isStrictDecoding() {
    return decodingPolicy == CodecPolicy.STRICT;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.<init>()","Constructor","* Default constructor.","public BCodec() {
    this(StandardCharsets.UTF_8);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.<init>(Charset)","Constructor","* Constructor which allows for the selection of a default Charset
     *
     * @param charset
     *            the default string Charset to use.
     *
     * @see Charset
     * @since 1.7","public BCodec(final Charset charset) {
    this(charset, DECODING_POLICY_DEFAULT);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.<init>(Charset).charset","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.<init>(Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.<init>(Charset,CodecPolicy)","Constructor","* Constructor which allows for the selection of a default Charset.
     *
     * @param charset
     *            the default string Charset to use.
     * @param decodingPolicy The decoding policy.
     * @see Charset
     * @since 1.15","public BCodec(final Charset charset, final CodecPolicy decodingPolicy) {
    super(charset);
    this.decodingPolicy = decodingPolicy;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.<init>(Charset,CodecPolicy).charset","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.<init>(Charset,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.<init>(Charset,CodecPolicy).decodingPolicy","Parameter_2","Belong to org.apache.commons.codec.net.BCodec.<init>(Charset,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.<init>(String)","Constructor","* Constructor which allows for the selection of a default Charset
     *
     * @param charsetName
     *            the default Charset to use.
     * @throws java.nio.charset.UnsupportedCharsetException
     *             If the named Charset is unavailable
     * @since 1.7 throws UnsupportedCharsetException if the named Charset is unavailable
     * @see Charset","public BCodec(final String charsetName) {
    this(Charset.forName(charsetName));
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.net.BCodec.<init>(String).charsetName","Parameter_1","Belong to org.apache.commons.codec.net.BCodec.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets","Class","* Charsets required of every implementation of the Java platform.
 *
 * From the Java documentation <a href=""https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard
 * charsets</a>:
 * <p>
 * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the
 * release documentation for your implementation to see if any other encodings are supported. Consult the release
 * documentation for your implementation to see if any other encodings are supported. </cite>
 * </p>
 *
 * <ul>
 * <li>{@code US-ASCII}<p>
 * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</p></li>
 * <li>{@code ISO-8859-1}<p>
 * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</p></li>
 * <li>{@code UTF-8}<p>
 * Eight-bit Unicode Transformation Format.</p></li>
 * <li>{@code UTF-16BE}<p>
 * Sixteen-bit Unicode Transformation Format, big-endian byte order.</p></li>
 * <li>{@code UTF-16LE}<p>
 * Sixteen-bit Unicode Transformation Format, little-endian byte order.</p></li>
 * <li>{@code UTF-16}<p>
 * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order
 * accepted on input, big-endian used on output.)</p></li>
 * </ul>
 *
 * This perhaps would best belong in the Commons Lang project. Even if a similar class is defined in Commons Lang, it is
 * not foreseen that Commons Codec would be made to depend on Commons Lang.
 *
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @see <a href=""https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>
 * @since 1.7","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.Charsets.ISO_8859_1","Field","* CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @deprecated Use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.
     * @see <a href=""https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>","@Deprecated
public static final Charset ISO_8859_1 = StandardCharsets.ISO_8859_1;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.US_ASCII","Field","* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @deprecated Use {@link java.nio.charset.StandardCharsets#US_ASCII} instead.
     * @see <a href=""https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>","@Deprecated
public static final Charset US_ASCII = StandardCharsets.US_ASCII;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.UTF_16","Field","* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark
     * (either order accepted on input, big-endian used on output)
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @deprecated Use {@link java.nio.charset.StandardCharsets#UTF_16} instead.
     * @see <a href=""https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>","@Deprecated
public static final Charset UTF_16 = StandardCharsets.UTF_16;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.UTF_16BE","Field","* Sixteen-bit Unicode Transformation Format, big-endian byte order.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @deprecated Use {@link java.nio.charset.StandardCharsets#UTF_16BE} instead.
     * @see <a href=""https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>","@Deprecated
public static final Charset UTF_16BE = StandardCharsets.UTF_16BE;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.UTF_16LE","Field","* Sixteen-bit Unicode Transformation Format, little-endian byte order.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @deprecated Use {@link java.nio.charset.StandardCharsets#UTF_16LE} instead.
     * @see <a href=""https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>","@Deprecated
public static final Charset UTF_16LE = StandardCharsets.UTF_16LE;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.UTF_8","Field","* Eight-bit Unicode Transformation Format.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @deprecated Use {@link java.nio.charset.StandardCharsets#UTF_8} instead.
     * @see <a href=""https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">Standard charsets</a>","@Deprecated
public static final Charset UTF_8 = StandardCharsets.UTF_8;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.toCharset(Charset)","Method","* Returns the given Charset or the default Charset if the given Charset is null.
     *
     * @param charset
     *            A charset or null.
     * @return the given Charset or the default Charset if the given Charset is null.","public static Charset toCharset(final Charset charset) {
    return charset == null ? Charset.defaultCharset() : charset;
}","Charset","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.toCharset(Charset).charset","Parameter_1","Belong to org.apache.commons.codec.Charsets.toCharset(Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.toCharset(String)","Method","* Returns a Charset for the named charset. If the name is null, return the default Charset.
     *
     * @param charset The name of the requested charset, may be null.
     * @return a Charset for the named charset
     * @throws java.nio.charset.UnsupportedCharsetException If the named charset is unavailable","public static Charset toCharset(final String charset) {
    return charset == null ? Charset.defaultCharset() : Charset.forName(charset);
}","Charset","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.toCharset(String).charset","Parameter_1","Belong to org.apache.commons.codec.Charsets.toCharset(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Charsets.<init>()","Constructor","* TODO Make private in 2.0.
     *
     * @deprecated TODO Make private in 2.0.","@Deprecated
public Charsets() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Decoder","Interface","* Provides the highest level of abstraction for Decoders.
 * <p>
 * This is the sister interface of {@link Encoder}. All Decoders implement this common generic interface.
 * Allows a user to pass a generic Object to any Decoder implementation in the codec package.
 * </p>
 * <p>
 * One of the two interfaces at the center of the codec package.
 * </p>","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.Decoder.decode(Object)","Abstract Method","* Decodes an ""encoded"" Object and returns a ""decoded"" Object. Note that the implementation of this interface will
     * try to cast the Object parameter to the specific type expected by a particular Decoder implementation. If a
     * {@link ClassCastException} occurs this decode method will throw a DecoderException.
     *
     * @param source
     *            the object to decode
     * @return a 'decoded"" object
     * @throws DecoderException
     *             a decoder exception can be thrown for any number of reasons. Some good candidates are that the
     *             parameter passed to this method is null, a param cannot be cast to the appropriate type for a
     *             specific encoder.","Object decode(Object source) throws DecoderException;","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Decoder.decode(Object).source","Parameter_1","Belong to org.apache.commons.codec.Decoder.decode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt","Class","* The libc crypt() ""$1$"" and Apache ""$apr1$"" MD5-based hash algorithm.
 * <p>
 * Based on the public domain (""beer-ware"") C implementation from Poul-Henning Kamp which was found at: <a
 * href=""http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/libcrypt/crypt-md5.c?rev=1.1;content-type=text%2Fplain"">
 * crypt-md5.c @ freebsd.org</a>
 * </p>
 * <p>
 * Source:
 * </p>
 * <pre>
 * $FreeBSD: src/lib/libcrypt/crypt-md5.c,v 1.1 1999/01/21 13:50:09 brandon Exp $
 * </pre>
 * <p>
 * Conversion to Kotlin and from there to Java in 2012.
 * </p>
 * <p>
 * The C style comments are from the original C code, the ones with ""//"" from the port.
 * </p>
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @since 1.7","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.digest.Md5Crypt.APR1_PREFIX","Field","The Identifier of the Apache variant.","static final String APR1_PREFIX = ""$apr1$"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.BLOCKSIZE","Field","The number of bytes of the final hash.","private static final int BLOCKSIZE = 16;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.MD5_PREFIX","Field","The Identifier of this crypt() variant.","static final String MD5_PREFIX = ""$1$"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.ROUNDS","Field","The number of rounds of the big loop.","private static final int ROUNDS = 1000;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[])","Method","* See {@link #apr1Crypt(byte[], String)} for details.
     * <p>
     * A salt is generated for you using {@link SecureRandom}; your own {@link Random} in
     * {@link #apr1Crypt(byte[], Random)}.
     * </p>
     *
     * @param keyBytes plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @return the hash value
     * @throws IllegalArgumentException when a {@link java.security.NoSuchAlgorithmException} is caught. *
     * @see #apr1Crypt(byte[], String)","public static String apr1Crypt(final byte[] keyBytes) {
    return apr1Crypt(keyBytes, APR1_PREFIX + B64.getRandomSalt(8));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[]).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],Random)","Method","* See {@link #apr1Crypt(byte[], String)} for details.
     * <p>
     * A salt is generated for you using the user provided {@link Random}.
     * </p>
     *
     * @param keyBytes plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @param random the instance of {@link Random} to use for generating the salt.
     *              Consider using {@link SecureRandom} for more secure salts.
     * @return the hash value
     * @throws IllegalArgumentException when a {@link java.security.NoSuchAlgorithmException} is caught. *
     * @see #apr1Crypt(byte[], String)
     * @since 1.12","public static String apr1Crypt(final byte[] keyBytes, final Random random) {
    return apr1Crypt(keyBytes, APR1_PREFIX + B64.getRandomSalt(8, random));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],Random).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],Random).random","Parameter_2","Belong to org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],String)","Method","* See {@link #apr1Crypt(String, String)} for details.
     * <p>
     * A salt is generated for you using {@link SecureRandom}
     * </p>
     *
     * @param keyBytes
     *            plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            An APR1 salt. The salt may be null, in which case a salt is generated for you using
     *            {@link SecureRandom}
     * @return the hash value
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String apr1Crypt(final byte[] keyBytes, String salt) {
    // to make the md5Crypt regex happy
    if (salt != null && !salt.startsWith(APR1_PREFIX)) {
        salt = APR1_PREFIX + salt;
    }
    return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],String).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(String)","Method","* See {@link #apr1Crypt(String, String)} for details.
     * <p>
     * A salt is generated for you using {@link SecureRandom}.
     * </p>
     *
     * @param keyBytes
     *            plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @return the hash value
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
     * @see #apr1Crypt(byte[], String)","public static String apr1Crypt(final String keyBytes) {
    return apr1Crypt(keyBytes.getBytes(StandardCharsets.UTF_8));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(String).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(String,String)","Method","* Generates an Apache htpasswd compatible ""$apr1$"" MD5 based hash value.
     * <p>
     * The algorithm is identical to the crypt(3) ""$1$"" one but produces different outputs due to the different salt
     * prefix.
     * </p>
     *
     * @param keyBytes
     *            plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            salt string including the prefix and optionally garbage at the end. The salt may be null, in which
     *            case a salt is generated for you using {@link SecureRandom}.
     * @return the hash value
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String apr1Crypt(final String keyBytes, final String salt) {
    return apr1Crypt(keyBytes.getBytes(StandardCharsets.UTF_8), salt);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(String,String).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(String,String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[])","Method","* Generates a libc6 crypt() compatible ""$1$"" hash value.
     * <p>
     * See {@link #md5Crypt(byte[], String)} for details.
     * </p>
     * <p>
     * A salt is generated for you using {@link SecureRandom}.
     * </p>
     * @param keyBytes
     *            plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @return the hash value
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
     * @see #md5Crypt(byte[], String)","public static String md5Crypt(final byte[] keyBytes) {
    return md5Crypt(keyBytes, MD5_PREFIX + B64.getRandomSalt(8));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[]).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],Random)","Method","* Generates a libc6 crypt() compatible ""$1$"" hash value.
     * <p>
     * See {@link #md5Crypt(byte[], String)} for details.
     * </p>
     * <p>
     * A salt is generated for you using the instance of {@link Random} you supply.
     * </p>
     * @param keyBytes
     *            plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @param random
     *            the instance of {@link Random} to use for generating the salt.
     *            Consider using {@link SecureRandom} for more secure salts.
     * @return the hash value
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
     * @see #md5Crypt(byte[], String)
     * @since 1.12","public static String md5Crypt(final byte[] keyBytes, final Random random) {
    return md5Crypt(keyBytes, MD5_PREFIX + B64.getRandomSalt(8, random));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],Random).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],Random).random","Parameter_2","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String)","Method","* Generates a libc crypt() compatible ""$1$"" MD5 based hash value.
     * <p>
     * See {@link Crypt#crypt(String, String)} for details. We use {@link SecureRandom} for seed generation by
     * default.
     * </p>
     *
     * @param keyBytes
     *            plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            salt string including the prefix and optionally garbage at the end. The salt may be null, in which
     *            case a salt is generated for you using {@link SecureRandom}.
     * @return the hash value
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String md5Crypt(final byte[] keyBytes, final String salt) {
    return md5Crypt(keyBytes, salt, MD5_PREFIX);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String)","Method","* Generates a libc6 crypt() ""$1$"" or Apache htpasswd ""$apr1$"" hash value.
     * <p>
     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details. We use
     * {@link SecureRandom by default}.
     * </p>
     *
     * @param keyBytes
     *            plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            real salt value without prefix or ""rounds="". The salt may be null, in which case a salt
     *            is generated for you using {@link SecureRandom}.
     * @param prefix
     *            The salt prefix {@value #APR1_PREFIX}, {@value #MD5_PREFIX}.
     * @return the hash value
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {
    return md5Crypt(keyBytes, salt, prefix, new SecureRandom());
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String).prefix","Parameter_3","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String,Random)","Method","* Generates a libc6 crypt() ""$1$"" or Apache htpasswd ""$apr1$"" hash value.
     * <p>
     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.
     * </p>
     *
     * @param keyBytes
     *            plaintext string to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            real salt value without prefix or ""rounds="". The salt may be null, in which case a salt
     *            is generated for you using {@link SecureRandom}.
     * @param prefix
     *            The salt prefix {@value #APR1_PREFIX}, {@value #MD5_PREFIX}.
     * @param random
     *            the instance of {@link Random} to use for generating the salt.
     *            Consider using {@link SecureRandom} for more secure salts.
     * @return the hash value
     * @throws IllegalArgumentException
     *             if the salt or prefix does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
     * @since 1.12","public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix, final Random random) {
    final int keyLen = keyBytes.length;
    // Extract the real salt from the given string which can be a complete hash string.
    final String saltString;
    if (salt == null) {
        saltString = B64.getRandomSalt(8, random);
    } else {
        Objects.requireNonNull(prefix, ""prefix"");
        if (prefix.length() < 3) {
            throw new IllegalArgumentException(""Invalid prefix value: "" + prefix);
        }
        if (prefix.charAt(0) != '$' && prefix.charAt(prefix.length() - 1) != '$') {
            throw new IllegalArgumentException(""Invalid prefix value: "" + prefix);
        }
        final Pattern p = Pattern.compile(""^"" + prefix.replace(""$"", ""\\$"") + ""([\\.\\/a-zA-Z0-9]{1,8}).*"");
        final Matcher m = p.matcher(salt);
        if (!m.find()) {
            throw new IllegalArgumentException(""Invalid salt value: "" + salt);
        }
        saltString = m.group(1);
    }
    final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8);
    final MessageDigest ctx = DigestUtils.getMd5Digest();
    /*
         * The password first, since that is what is most unknown
         */
    ctx.update(keyBytes);
    /*
         * Then our magic string
         */
    ctx.update(prefix.getBytes(StandardCharsets.UTF_8));
    /*
         * Then the raw salt
         */
    ctx.update(saltBytes);
    /*
         * Then just as many characters of the MD5(pw,salt,pw)
         */
    MessageDigest ctx1 = DigestUtils.getMd5Digest();
    ctx1.update(keyBytes);
    ctx1.update(saltBytes);
    ctx1.update(keyBytes);
    byte[] finalb = ctx1.digest();
    int ii = keyLen;
    while (ii > 0) {
        ctx.update(finalb, 0, Math.min(ii, 16));
        ii -= 16;
    }
    /*
         * Don't leave anything around in JVM they could use.
         */
    Arrays.fill(finalb, (byte) 0);
    /*
         * Then something really weird...
         */
    ii = keyLen;
    final int j = 0;
    while (ii > 0) {
        if ((ii & 1) == 1) {
            ctx.update(finalb[j]);
        } else {
            ctx.update(keyBytes[j]);
        }
        ii >>= 1;
    }
    /*
         * Now make the output string
         */
    final StringBuilder passwd = new StringBuilder(prefix + saltString + ""$"");
    finalb = ctx.digest();
    /*
         * and now, just to make sure things don't run too fast On a 60 Mhz Pentium this takes 34 milliseconds, so you
         * would need 30 seconds to build a 1000 entry dictionary...
         */
    for (int i = 0; i < ROUNDS; i++) {
        ctx1 = DigestUtils.getMd5Digest();
        if ((i & 1) != 0) {
            ctx1.update(keyBytes);
        } else {
            ctx1.update(finalb, 0, BLOCKSIZE);
        }
        if (i % 3 != 0) {
            ctx1.update(saltBytes);
        }
        if (i % 7 != 0) {
            ctx1.update(keyBytes);
        }
        if ((i & 1) != 0) {
            ctx1.update(finalb, 0, BLOCKSIZE);
        } else {
            ctx1.update(keyBytes);
        }
        finalb = ctx1.digest();
    }
    // The following was nearly identical to the Sha2Crypt code.
    // Again, the buflen is not really needed.
    // int buflen = MD5_PREFIX.length() - 1 + salt_string.length() + 1 + BLOCKSIZE + 1;
    B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);
    B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);
    B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);
    B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);
    B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);
    B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);
    /*
         * Don't leave anything around in JVM they could use.
         */
    // Is there a better way to do this with the JVM?
    ctx.reset();
    ctx1.reset();
    Arrays.fill(keyBytes, (byte) 0);
    Arrays.fill(saltBytes, (byte) 0);
    Arrays.fill(finalb, (byte) 0);
    return passwd.toString();
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String,Random).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String,Random).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String,Random).prefix","Parameter_3","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String,Random).random","Parameter_4","Belong to org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[],String,String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Md5Crypt.<init>()","Constructor","* TODO Make private in 2.0.
     *
     * @deprecated TODO Make private in 2.0.","@Deprecated
public Md5Crypt() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt","Class","* GNU libc crypt(3) compatible hash method.
 * <p>
 * See {@link #crypt(String, String)} for further details.
 * </p>
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @since 1.7","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.digest.Crypt.crypt(byte[])","Method","* Encrypts a password in a crypt(3) compatible way.
     * <p>
     * A random salt and the default algorithm (currently SHA-512) are used. See {@link #crypt(String, String)} for
     * details.
     * </p>
     * <p>
     * A salt is generated for you using {@link SecureRandom}.
     * </p>
     *
     * @param keyBytes
     *            plaintext password
     * @return hash value
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String crypt(final byte[] keyBytes) {
    return crypt(keyBytes, null);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.crypt(byte[]).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Crypt.crypt(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.crypt(byte[],String)","Method","* Encrypts a password in a crypt(3) compatible way.
     * <p>
     * If no salt is provided, a random salt and the default algorithm (currently SHA-512) will be used. See
     * {@link #crypt(String, String)} for details.
     * </p>
     *
     * @param keyBytes
     *            plaintext password
     * @param salt
     *            the salt, which is used to select the algorithm, see {@link #crypt(String, String)}
     *            The salt may be null,
     *            in which case the method delegates to {@link Sha2Crypt#sha512Crypt(byte[])}
     *
     * @return hash value
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String crypt(final byte[] keyBytes, final String salt) {
    if (salt == null) {
        return Sha2Crypt.sha512Crypt(keyBytes);
    }
    if (salt.startsWith(Sha2Crypt.SHA512_PREFIX)) {
        return Sha2Crypt.sha512Crypt(keyBytes, salt);
    }
    if (salt.startsWith(Sha2Crypt.SHA256_PREFIX)) {
        return Sha2Crypt.sha256Crypt(keyBytes, salt);
    }
    if (salt.startsWith(Md5Crypt.MD5_PREFIX)) {
        return Md5Crypt.md5Crypt(keyBytes, salt);
    }
    return UnixCrypt.crypt(keyBytes, salt);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.crypt(byte[],String).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Crypt.crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.crypt(byte[],String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Crypt.crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.crypt(String)","Method","* Calculates the digest using the strongest crypt(3) algorithm.
     * <p>
     * A random salt and the default algorithm (currently SHA-512) are used.
     * </p>
     * <p>
     * A salt is generated for you using {@link SecureRandom}.
     * </p>
     *
     * @see #crypt(String, String)
     * @param key
     *            plaintext password
     * @return hash value
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String crypt(final String key) {
    return crypt(key, null);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.crypt(String).key","Parameter_1","Belong to org.apache.commons.codec.digest.Crypt.crypt(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.crypt(String,String)","Method","* Encrypts a password in a crypt(3) compatible way.
     * <p>
     * The exact algorithm depends on the format of the salt string:
     * </p>
     * <ul>
     * <li>SHA-512 salts start with {@code $6$} and are up to 16 chars long.
     * <li>SHA-256 salts start with {@code $5$} and are up to 16 chars long
     * <li>MD5 salts start with {@code $1$} and are up to 8 chars long
     * <li>DES, the traditional UnixCrypt algorithm is used with only 2 chars
     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!
     * </ul>
     * <p>
     * The magic strings {@code ""$apr1$""} and {@code ""$2a$""} are not recognized by this method as its output should be
     * identical with that of the libc implementation.
     * </p>
     * <p>
     * The rest of the salt string is drawn from the set {@code [a-zA-Z0-9./]} and is cut at the maximum length or if a
     * {@code ""$""} sign is encountered. It is therefore valid to enter a complete hash value as salt to for example verify a
     * password with:
     * </p>
     * <pre>
     * storedPwd.equals(crypt(enteredPwd, storedPwd))
     * </pre>
     * <p>
     * The resulting string starts with the marker string ({@code $n$}), where n is the same as the input salt.
     * The salt is then appended, followed by a {@code ""$""} sign.
     * This is followed by the actual hash value.
     * For DES the string only contains the salt and actual hash.
     * The total length is dependent on the algorithm used:
     * </p>
     * <ul>
     * <li>SHA-512: 106 chars
     * <li>SHA-256: 63 chars
     * <li>MD5: 34 chars
     * <li>DES: 13 chars
     * </ul>
     * <p>
     * Example:
     * </p>
     * <pre>
     *      crypt(""secret"", ""$1$xxxx"") =&gt; ""$1$xxxx$aMkevjfEIpa35Bh3G4bAc.""
     *      crypt(""secret"", ""xx"") =&gt; ""xxWAum7tHdIUw""
     * </pre>
     * <p>
     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in
     * UTF-8 but for example in ISO-8859-1 where equal characters result in different byte values.
     * </p>
     *
     * @see ""The man page of the libc crypt (3) function.""
     * @param key
     *            plaintext password as entered by the used
     * @param salt
     *            real salt value without prefix or ""rounds="". The salt may be null, in which case a
     *            salt is generated for you using {@link SecureRandom}
     * @return hash value, i.e. encrypted password including the salt string
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *","public static String crypt(final String key, final String salt) {
    return crypt(key.getBytes(StandardCharsets.UTF_8), salt);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.crypt(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.Crypt.crypt(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.crypt(String,String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Crypt.crypt(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Crypt.<init>()","Constructor","* TODO Make private in 2.0.
     *
     * @deprecated TODO Make private in 2.0.","@Deprecated
public Crypt() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64","Class","* Base64-like method to convert binary bytes into ASCII chars.
 * <p>
 * TODO: Can Base64 be reused?
 * </p>
 * <p>
 * This class is immutable and thread-safe.
 * </p>","Class do not obtain Source Code","No return type","final ","",""
"org.apache.commons.codec.digest.B64.B64T_STRING","Field","* Table with characters for Base64 transformation.","static final String B64T_STRING = ""./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.B64T_ARRAY","Field","package access for testing","static final char[] B64T_ARRAY = B64T_STRING.toCharArray();","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder)","Method","* Base64 like conversion of bytes to ASCII chars.
     *
     * @param b2
     *            A byte from the result.
     * @param b1
     *            A byte from the result.
     * @param b0
     *            A byte from the result.
     * @param outLen
     *            The number of expected output chars.
     * @param buffer
     *            Where the output chars is appended to.","static void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen, final StringBuilder buffer) {
    // The bit masking is necessary because the JVM byte type is signed!
    int w = b2 << 16 & 0x00ffffff | b1 << 8 & 0x00ffff | b0 & 0xff;
    // It's effectively a ""for"" loop but kept to resemble the original C code.
    int n = outLen;
    while (n-- > 0) {
        buffer.append(B64T_ARRAY[w & 0x3f]);
        w >>= 6;
    }
}","void","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder).b2","Parameter_1","Belong to org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder).b1","Parameter_2","Belong to org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder).b0","Parameter_3","Belong to org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder).outLen","Parameter_4","Belong to org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder).buffer","Parameter_5","Belong to org.apache.commons.codec.digest.B64.b64from24bit(byte,byte,byte,int,StringBuilder)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.getRandomSalt(int)","Method","* Generates a string of random chars from the B64T set.
     * <p>
     * The salt is generated with {@link SecureRandom}.
     * </p>
     *
     * @param num Number of chars to generate.
     * @return a random salt {@link String}.","static String getRandomSalt(final int num) {
    return getRandomSalt(num, new SecureRandom());
}","String","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.getRandomSalt(int).num","Parameter_1","Belong to org.apache.commons.codec.digest.B64.getRandomSalt(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.getRandomSalt(int,Random)","Method","* Generates a string of random chars from the B64T set.
     * <p>
     * The salt is generated with the {@link Random} provided.
     * </p>
     *
     * @param num Number of chars to generate.
     * @param random an instance of {@link Random}.
     * @return a random salt {@link String}.","static String getRandomSalt(final int num, final Random random) {
    final StringBuilder saltString = new StringBuilder(num);
    for (int i = 1; i <= num; i++) {
        saltString.append(B64T_STRING.charAt(random.nextInt(B64T_STRING.length())));
    }
    return saltString.toString();
}","String","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.getRandomSalt(int,Random).num","Parameter_1","Belong to org.apache.commons.codec.digest.B64.getRandomSalt(int,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.B64.getRandomSalt(int,Random).random","Parameter_2","Belong to org.apache.commons.codec.digest.B64.getRandomSalt(int,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32","Class","* A pure-Java implementation of the CRC32 checksum that uses
 * the same polynomial as the built-in native CRC32.
 * <p>
 * This is to avoid the JNI overhead for certain uses of checksumming
 * where many small pieces of data are checksummed in succession.
 * </p>
 * <p>
 * The current version is ~10x to 1.8x as fast as Sun's native
 * java.util.zip.CRC32 in Java 1.6
 * </p>
 * <p>
 * Copied from Apache Hadoop 2.6.3.
 * The code agrees with the following file in the 2.6.3 tag:
 * https://gitbox.apache.org/repos/asf?p=hadoop.git;a=blob_plain;
 * f=hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/PureJavaCrc32.java;
 * hb=2120de588b92b9f22b1cc4188761d6a8c61aa778
 * </p>
 * <p>
 * This class is Not ThreadSafe
 * </p>
 *
 * @see java.util.zip.CRC32
 * @since 1.11","Class do not obtain Source Code","No return type","public ","","java.util.zip.Checksum"
"org.apache.commons.codec.digest.PureJavaCrc32.T","Field","@formatter:off","private static final int[] T = { /* T8_0 */
0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D, /* T8_1 */
0x00000000, 0x191B3141, 0x32366282, 0x2B2D53C3, 0x646CC504, 0x7D77F445, 0x565AA786, 0x4F4196C7, 0xC8D98A08, 0xD1C2BB49, 0xFAEFE88A, 0xE3F4D9CB, 0xACB54F0C, 0xB5AE7E4D, 0x9E832D8E, 0x87981CCF, 0x4AC21251, 0x53D92310, 0x78F470D3, 0x61EF4192, 0x2EAED755, 0x37B5E614, 0x1C98B5D7, 0x05838496, 0x821B9859, 0x9B00A918, 0xB02DFADB, 0xA936CB9A, 0xE6775D5D, 0xFF6C6C1C, 0xD4413FDF, 0xCD5A0E9E, 0x958424A2, 0x8C9F15E3, 0xA7B24620, 0xBEA97761, 0xF1E8E1A6, 0xE8F3D0E7, 0xC3DE8324, 0xDAC5B265, 0x5D5DAEAA, 0x44469FEB, 0x6F6BCC28, 0x7670FD69, 0x39316BAE, 0x202A5AEF, 0x0B07092C, 0x121C386D, 0xDF4636F3, 0xC65D07B2, 0xED705471, 0xF46B6530, 0xBB2AF3F7, 0xA231C2B6, 0x891C9175, 0x9007A034, 0x179FBCFB, 0x0E848DBA, 0x25A9DE79, 0x3CB2EF38, 0x73F379FF, 0x6AE848BE, 0x41C51B7D, 0x58DE2A3C, 0xF0794F05, 0xE9627E44, 0xC24F2D87, 0xDB541CC6, 0x94158A01, 0x8D0EBB40, 0xA623E883, 0xBF38D9C2, 0x38A0C50D, 0x21BBF44C, 0x0A96A78F, 0x138D96CE, 0x5CCC0009, 0x45D73148, 0x6EFA628B, 0x77E153CA, 0xBABB5D54, 0xA3A06C15, 0x888D3FD6, 0x91960E97, 0xDED79850, 0xC7CCA911, 0xECE1FAD2, 0xF5FACB93, 0x7262D75C, 0x6B79E61D, 0x4054B5DE, 0x594F849F, 0x160E1258, 0x0F152319, 0x243870DA, 0x3D23419B, 0x65FD6BA7, 0x7CE65AE6, 0x57CB0925, 0x4ED03864, 0x0191AEA3, 0x188A9FE2, 0x33A7CC21, 0x2ABCFD60, 0xAD24E1AF, 0xB43FD0EE, 0x9F12832D, 0x8609B26C, 0xC94824AB, 0xD05315EA, 0xFB7E4629, 0xE2657768, 0x2F3F79F6, 0x362448B7, 0x1D091B74, 0x04122A35, 0x4B53BCF2, 0x52488DB3, 0x7965DE70, 0x607EEF31, 0xE7E6F3FE, 0xFEFDC2BF, 0xD5D0917C, 0xCCCBA03D, 0x838A36FA, 0x9A9107BB, 0xB1BC5478, 0xA8A76539, 0x3B83984B, 0x2298A90A, 0x09B5FAC9, 0x10AECB88, 0x5FEF5D4F, 0x46F46C0E, 0x6DD93FCD, 0x74C20E8C, 0xF35A1243, 0xEA412302, 0xC16C70C1, 0xD8774180, 0x9736D747, 0x8E2DE606, 0xA500B5C5, 0xBC1B8484, 0x71418A1A, 0x685ABB5B, 0x4377E898, 0x5A6CD9D9, 0x152D4F1E, 0x0C367E5F, 0x271B2D9C, 0x3E001CDD, 0xB9980012, 0xA0833153, 0x8BAE6290, 0x92B553D1, 0xDDF4C516, 0xC4EFF457, 0xEFC2A794, 0xF6D996D5, 0xAE07BCE9, 0xB71C8DA8, 0x9C31DE6B, 0x852AEF2A, 0xCA6B79ED, 0xD37048AC, 0xF85D1B6F, 0xE1462A2E, 0x66DE36E1, 0x7FC507A0, 0x54E85463, 0x4DF36522, 0x02B2F3E5, 0x1BA9C2A4, 0x30849167, 0x299FA026, 0xE4C5AEB8, 0xFDDE9FF9, 0xD6F3CC3A, 0xCFE8FD7B, 0x80A96BBC, 0x99B25AFD, 0xB29F093E, 0xAB84387F, 0x2C1C24B0, 0x350715F1, 0x1E2A4632, 0x07317773, 0x4870E1B4, 0x516BD0F5, 0x7A468336, 0x635DB277, 0xCBFAD74E, 0xD2E1E60F, 0xF9CCB5CC, 0xE0D7848D, 0xAF96124A, 0xB68D230B, 0x9DA070C8, 0x84BB4189, 0x03235D46, 0x1A386C07, 0x31153FC4, 0x280E0E85, 0x674F9842, 0x7E54A903, 0x5579FAC0, 0x4C62CB81, 0x8138C51F, 0x9823F45E, 0xB30EA79D, 0xAA1596DC, 0xE554001B, 0xFC4F315A, 0xD7626299, 0xCE7953D8, 0x49E14F17, 0x50FA7E56, 0x7BD72D95, 0x62CC1CD4, 0x2D8D8A13, 0x3496BB52, 0x1FBBE891, 0x06A0D9D0, 0x5E7EF3EC, 0x4765C2AD, 0x6C48916E, 0x7553A02F, 0x3A1236E8, 0x230907A9, 0x0824546A, 0x113F652B, 0x96A779E4, 0x8FBC48A5, 0xA4911B66, 0xBD8A2A27, 0xF2CBBCE0, 0xEBD08DA1, 0xC0FDDE62, 0xD9E6EF23, 0x14BCE1BD, 0x0DA7D0FC, 0x268A833F, 0x3F91B27E, 0x70D024B9, 0x69CB15F8, 0x42E6463B, 0x5BFD777A, 0xDC656BB5, 0xC57E5AF4, 0xEE530937, 0xF7483876, 0xB809AEB1, 0xA1129FF0, 0x8A3FCC33, 0x9324FD72, /* T8_2 */
0x00000000, 0x01C26A37, 0x0384D46E, 0x0246BE59, 0x0709A8DC, 0x06CBC2EB, 0x048D7CB2, 0x054F1685, 0x0E1351B8, 0x0FD13B8F, 0x0D9785D6, 0x0C55EFE1, 0x091AF964, 0x08D89353, 0x0A9E2D0A, 0x0B5C473D, 0x1C26A370, 0x1DE4C947, 0x1FA2771E, 0x1E601D29, 0x1B2F0BAC, 0x1AED619B, 0x18ABDFC2, 0x1969B5F5, 0x1235F2C8, 0x13F798FF, 0x11B126A6, 0x10734C91, 0x153C5A14, 0x14FE3023, 0x16B88E7A, 0x177AE44D, 0x384D46E0, 0x398F2CD7, 0x3BC9928E, 0x3A0BF8B9, 0x3F44EE3C, 0x3E86840B, 0x3CC03A52, 0x3D025065, 0x365E1758, 0x379C7D6F, 0x35DAC336, 0x3418A901, 0x3157BF84, 0x3095D5B3, 0x32D36BEA, 0x331101DD, 0x246BE590, 0x25A98FA7, 0x27EF31FE, 0x262D5BC9, 0x23624D4C, 0x22A0277B, 0x20E69922, 0x2124F315, 0x2A78B428, 0x2BBADE1F, 0x29FC6046, 0x283E0A71, 0x2D711CF4, 0x2CB376C3, 0x2EF5C89A, 0x2F37A2AD, 0x709A8DC0, 0x7158E7F7, 0x731E59AE, 0x72DC3399, 0x7793251C, 0x76514F2B, 0x7417F172, 0x75D59B45, 0x7E89DC78, 0x7F4BB64F, 0x7D0D0816, 0x7CCF6221, 0x798074A4, 0x78421E93, 0x7A04A0CA, 0x7BC6CAFD, 0x6CBC2EB0, 0x6D7E4487, 0x6F38FADE, 0x6EFA90E9, 0x6BB5866C, 0x6A77EC5B, 0x68315202, 0x69F33835, 0x62AF7F08, 0x636D153F, 0x612BAB66, 0x60E9C151, 0x65A6D7D4, 0x6464BDE3, 0x662203BA, 0x67E0698D, 0x48D7CB20, 0x4915A117, 0x4B531F4E, 0x4A917579, 0x4FDE63FC, 0x4E1C09CB, 0x4C5AB792, 0x4D98DDA5, 0x46C49A98, 0x4706F0AF, 0x45404EF6, 0x448224C1, 0x41CD3244, 0x400F5873, 0x4249E62A, 0x438B8C1D, 0x54F16850, 0x55330267, 0x5775BC3E, 0x56B7D609, 0x53F8C08C, 0x523AAABB, 0x507C14E2, 0x51BE7ED5, 0x5AE239E8, 0x5B2053DF, 0x5966ED86, 0x58A487B1, 0x5DEB9134, 0x5C29FB03, 0x5E6F455A, 0x5FAD2F6D, 0xE1351B80, 0xE0F771B7, 0xE2B1CFEE, 0xE373A5D9, 0xE63CB35C, 0xE7FED96B, 0xE5B86732, 0xE47A0D05, 0xEF264A38, 0xEEE4200F, 0xECA29E56, 0xED60F461, 0xE82FE2E4, 0xE9ED88D3, 0xEBAB368A, 0xEA695CBD, 0xFD13B8F0, 0xFCD1D2C7, 0xFE976C9E, 0xFF5506A9, 0xFA1A102C, 0xFBD87A1B, 0xF99EC442, 0xF85CAE75, 0xF300E948, 0xF2C2837F, 0xF0843D26, 0xF1465711, 0xF4094194, 0xF5CB2BA3, 0xF78D95FA, 0xF64FFFCD, 0xD9785D60, 0xD8BA3757, 0xDAFC890E, 0xDB3EE339, 0xDE71F5BC, 0xDFB39F8B, 0xDDF521D2, 0xDC374BE5, 0xD76B0CD8, 0xD6A966EF, 0xD4EFD8B6, 0xD52DB281, 0xD062A404, 0xD1A0CE33, 0xD3E6706A, 0xD2241A5D, 0xC55EFE10, 0xC49C9427, 0xC6DA2A7E, 0xC7184049, 0xC25756CC, 0xC3953CFB, 0xC1D382A2, 0xC011E895, 0xCB4DAFA8, 0xCA8FC59F, 0xC8C97BC6, 0xC90B11F1, 0xCC440774, 0xCD866D43, 0xCFC0D31A, 0xCE02B92D, 0x91AF9640, 0x906DFC77, 0x922B422E, 0x93E92819, 0x96A63E9C, 0x976454AB, 0x9522EAF2, 0x94E080C5, 0x9FBCC7F8, 0x9E7EADCF, 0x9C381396, 0x9DFA79A1, 0x98B56F24, 0x99770513, 0x9B31BB4A, 0x9AF3D17D, 0x8D893530, 0x8C4B5F07, 0x8E0DE15E, 0x8FCF8B69, 0x8A809DEC, 0x8B42F7DB, 0x89044982, 0x88C623B5, 0x839A6488, 0x82580EBF, 0x801EB0E6, 0x81DCDAD1, 0x8493CC54, 0x8551A663, 0x8717183A, 0x86D5720D, 0xA9E2D0A0, 0xA820BA97, 0xAA6604CE, 0xABA46EF9, 0xAEEB787C, 0xAF29124B, 0xAD6FAC12, 0xACADC625, 0xA7F18118, 0xA633EB2F, 0xA4755576, 0xA5B73F41, 0xA0F829C4, 0xA13A43F3, 0xA37CFDAA, 0xA2BE979D, 0xB5C473D0, 0xB40619E7, 0xB640A7BE, 0xB782CD89, 0xB2CDDB0C, 0xB30FB13B, 0xB1490F62, 0xB08B6555, 0xBBD72268, 0xBA15485F, 0xB853F606, 0xB9919C31, 0xBCDE8AB4, 0xBD1CE083, 0xBF5A5EDA, 0xBE9834ED, /* T8_3 */
0x00000000, 0xB8BC6765, 0xAA09C88B, 0x12B5AFEE, 0x8F629757, 0x37DEF032, 0x256B5FDC, 0x9DD738B9, 0xC5B428EF, 0x7D084F8A, 0x6FBDE064, 0xD7018701, 0x4AD6BFB8, 0xF26AD8DD, 0xE0DF7733, 0x58631056, 0x5019579F, 0xE8A530FA, 0xFA109F14, 0x42ACF871, 0xDF7BC0C8, 0x67C7A7AD, 0x75720843, 0xCDCE6F26, 0x95AD7F70, 0x2D111815, 0x3FA4B7FB, 0x8718D09E, 0x1ACFE827, 0xA2738F42, 0xB0C620AC, 0x087A47C9, 0xA032AF3E, 0x188EC85B, 0x0A3B67B5, 0xB28700D0, 0x2F503869, 0x97EC5F0C, 0x8559F0E2, 0x3DE59787, 0x658687D1, 0xDD3AE0B4, 0xCF8F4F5A, 0x7733283F, 0xEAE41086, 0x525877E3, 0x40EDD80D, 0xF851BF68, 0xF02BF8A1, 0x48979FC4, 0x5A22302A, 0xE29E574F, 0x7F496FF6, 0xC7F50893, 0xD540A77D, 0x6DFCC018, 0x359FD04E, 0x8D23B72B, 0x9F9618C5, 0x272A7FA0, 0xBAFD4719, 0x0241207C, 0x10F48F92, 0xA848E8F7, 0x9B14583D, 0x23A83F58, 0x311D90B6, 0x89A1F7D3, 0x1476CF6A, 0xACCAA80F, 0xBE7F07E1, 0x06C36084, 0x5EA070D2, 0xE61C17B7, 0xF4A9B859, 0x4C15DF3C, 0xD1C2E785, 0x697E80E0, 0x7BCB2F0E, 0xC377486B, 0xCB0D0FA2, 0x73B168C7, 0x6104C729, 0xD9B8A04C, 0x446F98F5, 0xFCD3FF90, 0xEE66507E, 0x56DA371B, 0x0EB9274D, 0xB6054028, 0xA4B0EFC6, 0x1C0C88A3, 0x81DBB01A, 0x3967D77F, 0x2BD27891, 0x936E1FF4, 0x3B26F703, 0x839A9066, 0x912F3F88, 0x299358ED, 0xB4446054, 0x0CF80731, 0x1E4DA8DF, 0xA6F1CFBA, 0xFE92DFEC, 0x462EB889, 0x549B1767, 0xEC277002, 0x71F048BB, 0xC94C2FDE, 0xDBF98030, 0x6345E755, 0x6B3FA09C, 0xD383C7F9, 0xC1366817, 0x798A0F72, 0xE45D37CB, 0x5CE150AE, 0x4E54FF40, 0xF6E89825, 0xAE8B8873, 0x1637EF16, 0x048240F8, 0xBC3E279D, 0x21E91F24, 0x99557841, 0x8BE0D7AF, 0x335CB0CA, 0xED59B63B, 0x55E5D15E, 0x47507EB0, 0xFFEC19D5, 0x623B216C, 0xDA874609, 0xC832E9E7, 0x708E8E82, 0x28ED9ED4, 0x9051F9B1, 0x82E4565F, 0x3A58313A, 0xA78F0983, 0x1F336EE6, 0x0D86C108, 0xB53AA66D, 0xBD40E1A4, 0x05FC86C1, 0x1749292F, 0xAFF54E4A, 0x322276F3, 0x8A9E1196, 0x982BBE78, 0x2097D91D, 0x78F4C94B, 0xC048AE2E, 0xD2FD01C0, 0x6A4166A5, 0xF7965E1C, 0x4F2A3979, 0x5D9F9697, 0xE523F1F2, 0x4D6B1905, 0xF5D77E60, 0xE762D18E, 0x5FDEB6EB, 0xC2098E52, 0x7AB5E937, 0x680046D9, 0xD0BC21BC, 0x88DF31EA, 0x3063568F, 0x22D6F961, 0x9A6A9E04, 0x07BDA6BD, 0xBF01C1D8, 0xADB46E36, 0x15080953, 0x1D724E9A, 0xA5CE29FF, 0xB77B8611, 0x0FC7E174, 0x9210D9CD, 0x2AACBEA8, 0x38191146, 0x80A57623, 0xD8C66675, 0x607A0110, 0x72CFAEFE, 0xCA73C99B, 0x57A4F122, 0xEF189647, 0xFDAD39A9, 0x45115ECC, 0x764DEE06, 0xCEF18963, 0xDC44268D, 0x64F841E8, 0xF92F7951, 0x41931E34, 0x5326B1DA, 0xEB9AD6BF, 0xB3F9C6E9, 0x0B45A18C, 0x19F00E62, 0xA14C6907, 0x3C9B51BE, 0x842736DB, 0x96929935, 0x2E2EFE50, 0x2654B999, 0x9EE8DEFC, 0x8C5D7112, 0x34E11677, 0xA9362ECE, 0x118A49AB, 0x033FE645, 0xBB838120, 0xE3E09176, 0x5B5CF613, 0x49E959FD, 0xF1553E98, 0x6C820621, 0xD43E6144, 0xC68BCEAA, 0x7E37A9CF, 0xD67F4138, 0x6EC3265D, 0x7C7689B3, 0xC4CAEED6, 0x591DD66F, 0xE1A1B10A, 0xF3141EE4, 0x4BA87981, 0x13CB69D7, 0xAB770EB2, 0xB9C2A15C, 0x017EC639, 0x9CA9FE80, 0x241599E5, 0x36A0360B, 0x8E1C516E, 0x866616A7, 0x3EDA71C2, 0x2C6FDE2C, 0x94D3B949, 0x090481F0, 0xB1B8E695, 0xA30D497B, 0x1BB12E1E, 0x43D23E48, 0xFB6E592D, 0xE9DBF6C3, 0x516791A6, 0xCCB0A91F, 0x740CCE7A, 0x66B96194, 0xDE0506F1, /* T8_4 */
0x00000000, 0x3D6029B0, 0x7AC05360, 0x47A07AD0, 0xF580A6C0, 0xC8E08F70, 0x8F40F5A0, 0xB220DC10, 0x30704BC1, 0x0D106271, 0x4AB018A1, 0x77D03111, 0xC5F0ED01, 0xF890C4B1, 0xBF30BE61, 0x825097D1, 0x60E09782, 0x5D80BE32, 0x1A20C4E2, 0x2740ED52, 0x95603142, 0xA80018F2, 0xEFA06222, 0xD2C04B92, 0x5090DC43, 0x6DF0F5F3, 0x2A508F23, 0x1730A693, 0xA5107A83, 0x98705333, 0xDFD029E3, 0xE2B00053, 0xC1C12F04, 0xFCA106B4, 0xBB017C64, 0x866155D4, 0x344189C4, 0x0921A074, 0x4E81DAA4, 0x73E1F314, 0xF1B164C5, 0xCCD14D75, 0x8B7137A5, 0xB6111E15, 0x0431C205, 0x3951EBB5, 0x7EF19165, 0x4391B8D5, 0xA121B886, 0x9C419136, 0xDBE1EBE6, 0xE681C256, 0x54A11E46, 0x69C137F6, 0x2E614D26, 0x13016496, 0x9151F347, 0xAC31DAF7, 0xEB91A027, 0xD6F18997, 0x64D15587, 0x59B17C37, 0x1E1106E7, 0x23712F57, 0x58F35849, 0x659371F9, 0x22330B29, 0x1F532299, 0xAD73FE89, 0x9013D739, 0xD7B3ADE9, 0xEAD38459, 0x68831388, 0x55E33A38, 0x124340E8, 0x2F236958, 0x9D03B548, 0xA0639CF8, 0xE7C3E628, 0xDAA3CF98, 0x3813CFCB, 0x0573E67B, 0x42D39CAB, 0x7FB3B51B, 0xCD93690B, 0xF0F340BB, 0xB7533A6B, 0x8A3313DB, 0x0863840A, 0x3503ADBA, 0x72A3D76A, 0x4FC3FEDA, 0xFDE322CA, 0xC0830B7A, 0x872371AA, 0xBA43581A, 0x9932774D, 0xA4525EFD, 0xE3F2242D, 0xDE920D9D, 0x6CB2D18D, 0x51D2F83D, 0x167282ED, 0x2B12AB5D, 0xA9423C8C, 0x9422153C, 0xD3826FEC, 0xEEE2465C, 0x5CC29A4C, 0x61A2B3FC, 0x2602C92C, 0x1B62E09C, 0xF9D2E0CF, 0xC4B2C97F, 0x8312B3AF, 0xBE729A1F, 0x0C52460F, 0x31326FBF, 0x7692156F, 0x4BF23CDF, 0xC9A2AB0E, 0xF4C282BE, 0xB362F86E, 0x8E02D1DE, 0x3C220DCE, 0x0142247E, 0x46E25EAE, 0x7B82771E, 0xB1E6B092, 0x8C869922, 0xCB26E3F2, 0xF646CA42, 0x44661652, 0x79063FE2, 0x3EA64532, 0x03C66C82, 0x8196FB53, 0xBCF6D2E3, 0xFB56A833, 0xC6368183, 0x74165D93, 0x49767423, 0x0ED60EF3, 0x33B62743, 0xD1062710, 0xEC660EA0, 0xABC67470, 0x96A65DC0, 0x248681D0, 0x19E6A860, 0x5E46D2B0, 0x6326FB00, 0xE1766CD1, 0xDC164561, 0x9BB63FB1, 0xA6D61601, 0x14F6CA11, 0x2996E3A1, 0x6E369971, 0x5356B0C1, 0x70279F96, 0x4D47B626, 0x0AE7CCF6, 0x3787E546, 0x85A73956, 0xB8C710E6, 0xFF676A36, 0xC2074386, 0x4057D457, 0x7D37FDE7, 0x3A978737, 0x07F7AE87, 0xB5D77297, 0x88B75B27, 0xCF1721F7, 0xF2770847, 0x10C70814, 0x2DA721A4, 0x6A075B74, 0x576772C4, 0xE547AED4, 0xD8278764, 0x9F87FDB4, 0xA2E7D404, 0x20B743D5, 0x1DD76A65, 0x5A7710B5, 0x67173905, 0xD537E515, 0xE857CCA5, 0xAFF7B675, 0x92979FC5, 0xE915E8DB, 0xD475C16B, 0x93D5BBBB, 0xAEB5920B, 0x1C954E1B, 0x21F567AB, 0x66551D7B, 0x5B3534CB, 0xD965A31A, 0xE4058AAA, 0xA3A5F07A, 0x9EC5D9CA, 0x2CE505DA, 0x11852C6A, 0x562556BA, 0x6B457F0A, 0x89F57F59, 0xB49556E9, 0xF3352C39, 0xCE550589, 0x7C75D999, 0x4115F029, 0x06B58AF9, 0x3BD5A349, 0xB9853498, 0x84E51D28, 0xC34567F8, 0xFE254E48, 0x4C059258, 0x7165BBE8, 0x36C5C138, 0x0BA5E888, 0x28D4C7DF, 0x15B4EE6F, 0x521494BF, 0x6F74BD0F, 0xDD54611F, 0xE03448AF, 0xA794327F, 0x9AF41BCF, 0x18A48C1E, 0x25C4A5AE, 0x6264DF7E, 0x5F04F6CE, 0xED242ADE, 0xD044036E, 0x97E479BE, 0xAA84500E, 0x4834505D, 0x755479ED, 0x32F4033D, 0x0F942A8D, 0xBDB4F69D, 0x80D4DF2D, 0xC774A5FD, 0xFA148C4D, 0x78441B9C, 0x4524322C, 0x028448FC, 0x3FE4614C, 0x8DC4BD5C, 0xB0A494EC, 0xF704EE3C, 0xCA64C78C, /* T8_5 */
0x00000000, 0xCB5CD3A5, 0x4DC8A10B, 0x869472AE, 0x9B914216, 0x50CD91B3, 0xD659E31D, 0x1D0530B8, 0xEC53826D, 0x270F51C8, 0xA19B2366, 0x6AC7F0C3, 0x77C2C07B, 0xBC9E13DE, 0x3A0A6170, 0xF156B2D5, 0x03D6029B, 0xC88AD13E, 0x4E1EA390, 0x85427035, 0x9847408D, 0x531B9328, 0xD58FE186, 0x1ED33223, 0xEF8580F6, 0x24D95353, 0xA24D21FD, 0x6911F258, 0x7414C2E0, 0xBF481145, 0x39DC63EB, 0xF280B04E, 0x07AC0536, 0xCCF0D693, 0x4A64A43D, 0x81387798, 0x9C3D4720, 0x57619485, 0xD1F5E62B, 0x1AA9358E, 0xEBFF875B, 0x20A354FE, 0xA6372650, 0x6D6BF5F5, 0x706EC54D, 0xBB3216E8, 0x3DA66446, 0xF6FAB7E3, 0x047A07AD, 0xCF26D408, 0x49B2A6A6, 0x82EE7503, 0x9FEB45BB, 0x54B7961E, 0xD223E4B0, 0x197F3715, 0xE82985C0, 0x23755665, 0xA5E124CB, 0x6EBDF76E, 0x73B8C7D6, 0xB8E41473, 0x3E7066DD, 0xF52CB578, 0x0F580A6C, 0xC404D9C9, 0x4290AB67, 0x89CC78C2, 0x94C9487A, 0x5F959BDF, 0xD901E971, 0x125D3AD4, 0xE30B8801, 0x28575BA4, 0xAEC3290A, 0x659FFAAF, 0x789ACA17, 0xB3C619B2, 0x35526B1C, 0xFE0EB8B9, 0x0C8E08F7, 0xC7D2DB52, 0x4146A9FC, 0x8A1A7A59, 0x971F4AE1, 0x5C439944, 0xDAD7EBEA, 0x118B384F, 0xE0DD8A9A, 0x2B81593F, 0xAD152B91, 0x6649F834, 0x7B4CC88C, 0xB0101B29, 0x36846987, 0xFDD8BA22, 0x08F40F5A, 0xC3A8DCFF, 0x453CAE51, 0x8E607DF4, 0x93654D4C, 0x58399EE9, 0xDEADEC47, 0x15F13FE2, 0xE4A78D37, 0x2FFB5E92, 0xA96F2C3C, 0x6233FF99, 0x7F36CF21, 0xB46A1C84, 0x32FE6E2A, 0xF9A2BD8F, 0x0B220DC1, 0xC07EDE64, 0x46EAACCA, 0x8DB67F6F, 0x90B34FD7, 0x5BEF9C72, 0xDD7BEEDC, 0x16273D79, 0xE7718FAC, 0x2C2D5C09, 0xAAB92EA7, 0x61E5FD02, 0x7CE0CDBA, 0xB7BC1E1F, 0x31286CB1, 0xFA74BF14, 0x1EB014D8, 0xD5ECC77D, 0x5378B5D3, 0x98246676, 0x852156CE, 0x4E7D856B, 0xC8E9F7C5, 0x03B52460, 0xF2E396B5, 0x39BF4510, 0xBF2B37BE, 0x7477E41B, 0x6972D4A3, 0xA22E0706, 0x24BA75A8, 0xEFE6A60D, 0x1D661643, 0xD63AC5E6, 0x50AEB748, 0x9BF264ED, 0x86F75455, 0x4DAB87F0, 0xCB3FF55E, 0x006326FB, 0xF135942E, 0x3A69478B, 0xBCFD3525, 0x77A1E680, 0x6AA4D638, 0xA1F8059D, 0x276C7733, 0xEC30A496, 0x191C11EE, 0xD240C24B, 0x54D4B0E5, 0x9F886340, 0x828D53F8, 0x49D1805D, 0xCF45F2F3, 0x04192156, 0xF54F9383, 0x3E134026, 0xB8873288, 0x73DBE12D, 0x6EDED195, 0xA5820230, 0x2316709E, 0xE84AA33B, 0x1ACA1375, 0xD196C0D0, 0x5702B27E, 0x9C5E61DB, 0x815B5163, 0x4A0782C6, 0xCC93F068, 0x07CF23CD, 0xF6999118, 0x3DC542BD, 0xBB513013, 0x700DE3B6, 0x6D08D30E, 0xA65400AB, 0x20C07205, 0xEB9CA1A0, 0x11E81EB4, 0xDAB4CD11, 0x5C20BFBF, 0x977C6C1A, 0x8A795CA2, 0x41258F07, 0xC7B1FDA9, 0x0CED2E0C, 0xFDBB9CD9, 0x36E74F7C, 0xB0733DD2, 0x7B2FEE77, 0x662ADECF, 0xAD760D6A, 0x2BE27FC4, 0xE0BEAC61, 0x123E1C2F, 0xD962CF8A, 0x5FF6BD24, 0x94AA6E81, 0x89AF5E39, 0x42F38D9C, 0xC467FF32, 0x0F3B2C97, 0xFE6D9E42, 0x35314DE7, 0xB3A53F49, 0x78F9ECEC, 0x65FCDC54, 0xAEA00FF1, 0x28347D5F, 0xE368AEFA, 0x16441B82, 0xDD18C827, 0x5B8CBA89, 0x90D0692C, 0x8DD55994, 0x46898A31, 0xC01DF89F, 0x0B412B3A, 0xFA1799EF, 0x314B4A4A, 0xB7DF38E4, 0x7C83EB41, 0x6186DBF9, 0xAADA085C, 0x2C4E7AF2, 0xE712A957, 0x15921919, 0xDECECABC, 0x585AB812, 0x93066BB7, 0x8E035B0F, 0x455F88AA, 0xC3CBFA04, 0x089729A1, 0xF9C19B74, 0x329D48D1, 0xB4093A7F, 0x7F55E9DA, 0x6250D962, 0xA90C0AC7, 0x2F987869, 0xE4C4ABCC, /* T8_6 */
0x00000000, 0xA6770BB4, 0x979F1129, 0x31E81A9D, 0xF44F2413, 0x52382FA7, 0x63D0353A, 0xC5A73E8E, 0x33EF4E67, 0x959845D3, 0xA4705F4E, 0x020754FA, 0xC7A06A74, 0x61D761C0, 0x503F7B5D, 0xF64870E9, 0x67DE9CCE, 0xC1A9977A, 0xF0418DE7, 0x56368653, 0x9391B8DD, 0x35E6B369, 0x040EA9F4, 0xA279A240, 0x5431D2A9, 0xF246D91D, 0xC3AEC380, 0x65D9C834, 0xA07EF6BA, 0x0609FD0E, 0x37E1E793, 0x9196EC27, 0xCFBD399C, 0x69CA3228, 0x582228B5, 0xFE552301, 0x3BF21D8F, 0x9D85163B, 0xAC6D0CA6, 0x0A1A0712, 0xFC5277FB, 0x5A257C4F, 0x6BCD66D2, 0xCDBA6D66, 0x081D53E8, 0xAE6A585C, 0x9F8242C1, 0x39F54975, 0xA863A552, 0x0E14AEE6, 0x3FFCB47B, 0x998BBFCF, 0x5C2C8141, 0xFA5B8AF5, 0xCBB39068, 0x6DC49BDC, 0x9B8CEB35, 0x3DFBE081, 0x0C13FA1C, 0xAA64F1A8, 0x6FC3CF26, 0xC9B4C492, 0xF85CDE0F, 0x5E2BD5BB, 0x440B7579, 0xE27C7ECD, 0xD3946450, 0x75E36FE4, 0xB044516A, 0x16335ADE, 0x27DB4043, 0x81AC4BF7, 0x77E43B1E, 0xD19330AA, 0xE07B2A37, 0x460C2183, 0x83AB1F0D, 0x25DC14B9, 0x14340E24, 0xB2430590, 0x23D5E9B7, 0x85A2E203, 0xB44AF89E, 0x123DF32A, 0xD79ACDA4, 0x71EDC610, 0x4005DC8D, 0xE672D739, 0x103AA7D0, 0xB64DAC64, 0x87A5B6F9, 0x21D2BD4D, 0xE47583C3, 0x42028877, 0x73EA92EA, 0xD59D995E, 0x8BB64CE5, 0x2DC14751, 0x1C295DCC, 0xBA5E5678, 0x7FF968F6, 0xD98E6342, 0xE86679DF, 0x4E11726B, 0xB8590282, 0x1E2E0936, 0x2FC613AB, 0x89B1181F, 0x4C162691, 0xEA612D25, 0xDB8937B8, 0x7DFE3C0C, 0xEC68D02B, 0x4A1FDB9F, 0x7BF7C102, 0xDD80CAB6, 0x1827F438, 0xBE50FF8C, 0x8FB8E511, 0x29CFEEA5, 0xDF879E4C, 0x79F095F8, 0x48188F65, 0xEE6F84D1, 0x2BC8BA5F, 0x8DBFB1EB, 0xBC57AB76, 0x1A20A0C2, 0x8816EAF2, 0x2E61E146, 0x1F89FBDB, 0xB9FEF06F, 0x7C59CEE1, 0xDA2EC555, 0xEBC6DFC8, 0x4DB1D47C, 0xBBF9A495, 0x1D8EAF21, 0x2C66B5BC, 0x8A11BE08, 0x4FB68086, 0xE9C18B32, 0xD82991AF, 0x7E5E9A1B, 0xEFC8763C, 0x49BF7D88, 0x78576715, 0xDE206CA1, 0x1B87522F, 0xBDF0599B, 0x8C184306, 0x2A6F48B2, 0xDC27385B, 0x7A5033EF, 0x4BB82972, 0xEDCF22C6, 0x28681C48, 0x8E1F17FC, 0xBFF70D61, 0x198006D5, 0x47ABD36E, 0xE1DCD8DA, 0xD034C247, 0x7643C9F3, 0xB3E4F77D, 0x1593FCC9, 0x247BE654, 0x820CEDE0, 0x74449D09, 0xD23396BD, 0xE3DB8C20, 0x45AC8794, 0x800BB91A, 0x267CB2AE, 0x1794A833, 0xB1E3A387, 0x20754FA0, 0x86024414, 0xB7EA5E89, 0x119D553D, 0xD43A6BB3, 0x724D6007, 0x43A57A9A, 0xE5D2712E, 0x139A01C7, 0xB5ED0A73, 0x840510EE, 0x22721B5A, 0xE7D525D4, 0x41A22E60, 0x704A34FD, 0xD63D3F49, 0xCC1D9F8B, 0x6A6A943F, 0x5B828EA2, 0xFDF58516, 0x3852BB98, 0x9E25B02C, 0xAFCDAAB1, 0x09BAA105, 0xFFF2D1EC, 0x5985DA58, 0x686DC0C5, 0xCE1ACB71, 0x0BBDF5FF, 0xADCAFE4B, 0x9C22E4D6, 0x3A55EF62, 0xABC30345, 0x0DB408F1, 0x3C5C126C, 0x9A2B19D8, 0x5F8C2756, 0xF9FB2CE2, 0xC813367F, 0x6E643DCB, 0x982C4D22, 0x3E5B4696, 0x0FB35C0B, 0xA9C457BF, 0x6C636931, 0xCA146285, 0xFBFC7818, 0x5D8B73AC, 0x03A0A617, 0xA5D7ADA3, 0x943FB73E, 0x3248BC8A, 0xF7EF8204, 0x519889B0, 0x6070932D, 0xC6079899, 0x304FE870, 0x9638E3C4, 0xA7D0F959, 0x01A7F2ED, 0xC400CC63, 0x6277C7D7, 0x539FDD4A, 0xF5E8D6FE, 0x647E3AD9, 0xC209316D, 0xF3E12BF0, 0x55962044, 0x90311ECA, 0x3646157E, 0x07AE0FE3, 0xA1D90457, 0x579174BE, 0xF1E67F0A, 0xC00E6597, 0x66796E23, 0xA3DE50AD, 0x05A95B19, 0x34414184, 0x92364A30, /* T8_7 */
0x00000000, 0xCCAA009E, 0x4225077D, 0x8E8F07E3, 0x844A0EFA, 0x48E00E64, 0xC66F0987, 0x0AC50919, 0xD3E51BB5, 0x1F4F1B2B, 0x91C01CC8, 0x5D6A1C56, 0x57AF154F, 0x9B0515D1, 0x158A1232, 0xD92012AC, 0x7CBB312B, 0xB01131B5, 0x3E9E3656, 0xF23436C8, 0xF8F13FD1, 0x345B3F4F, 0xBAD438AC, 0x767E3832, 0xAF5E2A9E, 0x63F42A00, 0xED7B2DE3, 0x21D12D7D, 0x2B142464, 0xE7BE24FA, 0x69312319, 0xA59B2387, 0xF9766256, 0x35DC62C8, 0xBB53652B, 0x77F965B5, 0x7D3C6CAC, 0xB1966C32, 0x3F196BD1, 0xF3B36B4F, 0x2A9379E3, 0xE639797D, 0x68B67E9E, 0xA41C7E00, 0xAED97719, 0x62737787, 0xECFC7064, 0x205670FA, 0x85CD537D, 0x496753E3, 0xC7E85400, 0x0B42549E, 0x01875D87, 0xCD2D5D19, 0x43A25AFA, 0x8F085A64, 0x562848C8, 0x9A824856, 0x140D4FB5, 0xD8A74F2B, 0xD2624632, 0x1EC846AC, 0x9047414F, 0x5CED41D1, 0x299DC2ED, 0xE537C273, 0x6BB8C590, 0xA712C50E, 0xADD7CC17, 0x617DCC89, 0xEFF2CB6A, 0x2358CBF4, 0xFA78D958, 0x36D2D9C6, 0xB85DDE25, 0x74F7DEBB, 0x7E32D7A2, 0xB298D73C, 0x3C17D0DF, 0xF0BDD041, 0x5526F3C6, 0x998CF358, 0x1703F4BB, 0xDBA9F425, 0xD16CFD3C, 0x1DC6FDA2, 0x9349FA41, 0x5FE3FADF, 0x86C3E873, 0x4A69E8ED, 0xC4E6EF0E, 0x084CEF90, 0x0289E689, 0xCE23E617, 0x40ACE1F4, 0x8C06E16A, 0xD0EBA0BB, 0x1C41A025, 0x92CEA7C6, 0x5E64A758, 0x54A1AE41, 0x980BAEDF, 0x1684A93C, 0xDA2EA9A2, 0x030EBB0E, 0xCFA4BB90, 0x412BBC73, 0x8D81BCED, 0x8744B5F4, 0x4BEEB56A, 0xC561B289, 0x09CBB217, 0xAC509190, 0x60FA910E, 0xEE7596ED, 0x22DF9673, 0x281A9F6A, 0xE4B09FF4, 0x6A3F9817, 0xA6959889, 0x7FB58A25, 0xB31F8ABB, 0x3D908D58, 0xF13A8DC6, 0xFBFF84DF, 0x37558441, 0xB9DA83A2, 0x7570833C, 0x533B85DA, 0x9F918544, 0x111E82A7, 0xDDB48239, 0xD7718B20, 0x1BDB8BBE, 0x95548C5D, 0x59FE8CC3, 0x80DE9E6F, 0x4C749EF1, 0xC2FB9912, 0x0E51998C, 0x04949095, 0xC83E900B, 0x46B197E8, 0x8A1B9776, 0x2F80B4F1, 0xE32AB46F, 0x6DA5B38C, 0xA10FB312, 0xABCABA0B, 0x6760BA95, 0xE9EFBD76, 0x2545BDE8, 0xFC65AF44, 0x30CFAFDA, 0xBE40A839, 0x72EAA8A7, 0x782FA1BE, 0xB485A120, 0x3A0AA6C3, 0xF6A0A65D, 0xAA4DE78C, 0x66E7E712, 0xE868E0F1, 0x24C2E06F, 0x2E07E976, 0xE2ADE9E8, 0x6C22EE0B, 0xA088EE95, 0x79A8FC39, 0xB502FCA7, 0x3B8DFB44, 0xF727FBDA, 0xFDE2F2C3, 0x3148F25D, 0xBFC7F5BE, 0x736DF520, 0xD6F6D6A7, 0x1A5CD639, 0x94D3D1DA, 0x5879D144, 0x52BCD85D, 0x9E16D8C3, 0x1099DF20, 0xDC33DFBE, 0x0513CD12, 0xC9B9CD8C, 0x4736CA6F, 0x8B9CCAF1, 0x8159C3E8, 0x4DF3C376, 0xC37CC495, 0x0FD6C40B, 0x7AA64737, 0xB60C47A9, 0x3883404A, 0xF42940D4, 0xFEEC49CD, 0x32464953, 0xBCC94EB0, 0x70634E2E, 0xA9435C82, 0x65E95C1C, 0xEB665BFF, 0x27CC5B61, 0x2D095278, 0xE1A352E6, 0x6F2C5505, 0xA386559B, 0x061D761C, 0xCAB77682, 0x44387161, 0x889271FF, 0x825778E6, 0x4EFD7878, 0xC0727F9B, 0x0CD87F05, 0xD5F86DA9, 0x19526D37, 0x97DD6AD4, 0x5B776A4A, 0x51B26353, 0x9D1863CD, 0x1397642E, 0xDF3D64B0, 0x83D02561, 0x4F7A25FF, 0xC1F5221C, 0x0D5F2282, 0x079A2B9B, 0xCB302B05, 0x45BF2CE6, 0x89152C78, 0x50353ED4, 0x9C9F3E4A, 0x121039A9, 0xDEBA3937, 0xD47F302E, 0x18D530B0, 0x965A3753, 0x5AF037CD, 0xFF6B144A, 0x33C114D4, 0xBD4E1337, 0x71E413A9, 0x7B211AB0, 0xB78B1A2E, 0x39041DCD, 0xF5AE1D53, 0x2C8E0FFF, 0xE0240F61, 0x6EAB0882, 0xA201081C, 0xA8C40105, 0x646E019B, 0xEAE10678, 0x264B06E6 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.crc","Field","The current CRC value, bit-flipped","private int crc;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.getValue()","Method","No Comment","@Override
public long getValue() {
    return ~crc & 0xffffffffL;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.reset()","Method","No Comment","@Override
public void reset() {
    resetCrc();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.resetCrc()","Method","called by ctor, so must not be overrideable","private void resetCrc() {
    crc = 0xffffffff;
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.update(byte[],int,int)","Method","No Comment","@Override
public void update(final byte[] b, final int offset, final int len) {
    int localCrc = crc;
    final int remainder = len & 0x7;
    int i = offset;
    for (final int end = offset + len - remainder; i < end; i += 8) {
        final int x = localCrc ^ (b[i] << 24 >>> 24) + (b[i + 1] << 24 >>> 16) + (b[i + 2] << 24 >>> 8) + (b[i + 3] << 24);
        localCrc = T[(x << 24 >>> 24) + 0x700] ^ T[(x << 16 >>> 24) + 0x600] ^ T[(x << 8 >>> 24) + 0x500] ^ T[(x >>> 24) + 0x400] ^ T[(b[i + 4] << 24 >>> 24) + 0x300] ^ T[(b[i + 5] << 24 >>> 24) + 0x200] ^ T[(b[i + 6] << 24 >>> 24) + 0x100] ^ T[b[i + 7] << 24 >>> 24];
    }
    // loop unroll - duff's device style
    switch(remainder) {
        case 7:
            localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24];
        // falls-through
        case 6:
            localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24];
        // falls-through
        case 5:
            localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24];
        // falls-through
        case 4:
            localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24];
        // falls-through
        case 3:
            localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24];
        // falls-through
        case 2:
            localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24];
        // falls-through
        case 1:
            localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24];
        // falls-through
        default:
    }
    // Publish crc out to object
    crc = localCrc;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.update(byte[],int,int).b","Parameter_1","Belong to org.apache.commons.codec.digest.PureJavaCrc32.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.update(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.PureJavaCrc32.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.update(byte[],int,int).len","Parameter_3","Belong to org.apache.commons.codec.digest.PureJavaCrc32.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.update(int)","Method","No Comment","@Override
public final void update(final int b) {
    crc = crc >>> 8 ^ T[(crc ^ b) << 24 >>> 24];
}","void","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.update(int).b","Parameter_1","Belong to org.apache.commons.codec.digest.PureJavaCrc32.update(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32.<init>()","Constructor","Constructs a new PureJavaCrc32 object.","public PureJavaCrc32() {
    resetCrc();
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils","Class","* Simplifies common {@link javax.crypto.Mac} tasks. This class is immutable and thread-safe.
 * However the Mac may not be.
 * <p>
 * <strong>Note: Not all JCE implementations support all algorithms. If not supported, an IllegalArgumentException is
 * thrown.</strong>
 * </p>
 * <p>
 * Sample usage:
 * </p>
 * <pre>
 * import static HmacAlgorithms.*;
 * byte[] key = {1,2,3,4}; // don't use this actual key!
 * String valueToDigest = ""The quick brown fox jumps over the lazy dog"";
 * byte[] hmac = new HmacUtils(HMAC_SHA_224, key).hmac(valueToDigest);
 * // Mac re-use
 * HmacUtils hm1 = new HmacUtils(""HmacAlgoName"", key); // use a valid name here!
 * String hexPom = hm1.hmacHex(new File(""pom.xml""));
 * String hexNot = hm1.hmacHex(new File(""NOTICE.txt""));
 * </pre>
 * @since 1.10","Class do not obtain Source Code","No return type","public , final ","",""
"org.apache.commons.codec.digest.HmacUtils.STREAM_BUFFER_LENGTH","Field","No Comment","private static final int STREAM_BUFFER_LENGTH = 1024;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.mac","Field","No Comment","private final Mac mac;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacMd5(byte[])","Method","* Returns an initialized {@code Mac} for the HmacMD5 algorithm.
     * <p>
     * Every implementation of the Java platform is required to support this standard Mac algorithm.
     * </p>
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @return A Mac instance initialized with the given key.
     * @see Mac#getInstance(String)
     * @see Mac#init(Key)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_MD5, byte[])}","@Deprecated
public static Mac getHmacMd5(final byte[] key) {
    return getInitializedMac(HmacAlgorithms.HMAC_MD5, key);
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacMd5(byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.getHmacMd5(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacSha1(byte[])","Method","* Returns an initialized {@code Mac} for the HmacSHA1 algorithm.
     * <p>
     * Every implementation of the Java platform is required to support this standard Mac algorithm.
     * </p>
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @return A Mac instance initialized with the given key.
     * @see Mac#getInstance(String)
     * @see Mac#init(Key)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_1, byte[])}","@Deprecated
public static Mac getHmacSha1(final byte[] key) {
    return getInitializedMac(HmacAlgorithms.HMAC_SHA_1, key);
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacSha1(byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.getHmacSha1(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacSha256(byte[])","Method","* Returns an initialized {@code Mac} for the HmacSHA256 algorithm.
     * <p>
     * Every implementation of the Java platform is required to support this standard Mac algorithm.
     * </p>
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @return A Mac instance initialized with the given key.
     * @see Mac#getInstance(String)
     * @see Mac#init(Key)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_256, byte[])}","@Deprecated
public static Mac getHmacSha256(final byte[] key) {
    return getInitializedMac(HmacAlgorithms.HMAC_SHA_256, key);
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacSha256(byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.getHmacSha256(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacSha384(byte[])","Method","* Returns an initialized {@code Mac} for the HmacSHA384 algorithm.
     * <p>
     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.
     * </p>
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @return A Mac instance initialized with the given key.
     * @see Mac#getInstance(String)
     * @see Mac#init(Key)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_384, byte[])}","@Deprecated
public static Mac getHmacSha384(final byte[] key) {
    return getInitializedMac(HmacAlgorithms.HMAC_SHA_384, key);
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacSha384(byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.getHmacSha384(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacSha512(byte[])","Method","* Returns an initialized {@code Mac} for the HmacSHA512 algorithm.
     * <p>
     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.
     * </p>
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @return A Mac instance initialized with the given key.
     * @see Mac#getInstance(String)
     * @see Mac#init(Key)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_512, byte[])}","@Deprecated
public static Mac getHmacSha512(final byte[] key) {
    return getInitializedMac(HmacAlgorithms.HMAC_SHA_512, key);
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getHmacSha512(byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.getHmacSha512(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getInitializedMac(HmacAlgorithms,byte[])","Method","* Returns an initialized {@code Mac} for the given {@code algorithm}.
     *
     * @param algorithm
     *            the name of the algorithm requested. See
     *            <a href= ""https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA""
     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard
     *            algorithm names.
     * @param key
     *            The key for the keyed digest (must not be null)
     * @return A Mac instance initialized with the given key.
     * @see Mac#getInstance(String)
     * @see Mac#init(Key)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.","public static Mac getInitializedMac(final HmacAlgorithms algorithm, final byte[] key) {
    return getInitializedMac(algorithm.getName(), key);
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getInitializedMac(HmacAlgorithms,byte[]).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.getInitializedMac(HmacAlgorithms,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getInitializedMac(HmacAlgorithms,byte[]).key","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.getInitializedMac(HmacAlgorithms,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getInitializedMac(String,byte[])","Method","* Returns an initialized {@code Mac} for the given {@code algorithm}.
     *
     * @param algorithm
     *            the name of the algorithm requested. See
     *            <a href= ""https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA""
     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard
     *            algorithm names.
     * @param key
     *            The key for the keyed digest (must not be null)
     * @return A Mac instance initialized with the given key.
     * @see Mac#getInstance(String)
     * @see Mac#init(Key)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.","public static Mac getInitializedMac(final String algorithm, final byte[] key) {
    if (key == null) {
        throw new IllegalArgumentException(""Null key"");
    }
    try {
        final SecretKeySpec keySpec = new SecretKeySpec(key, algorithm);
        final Mac mac = Mac.getInstance(algorithm);
        mac.init(keySpec);
        return mac;
    } catch (final NoSuchAlgorithmException | InvalidKeyException e) {
        throw new IllegalArgumentException(e);
    }
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getInitializedMac(String,byte[]).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.getInitializedMac(String,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.getInitializedMac(String,byte[]).key","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.getInitializedMac(String,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],byte[])","Method","* Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacMD5 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmac(byte[])}","@Deprecated
public static byte[] hmacMd5(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],InputStream)","Method","* Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacMD5 MAC for the given key and value
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmac(InputStream)}","@Deprecated
public static byte[] hmacMd5(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5(String,String)","Method","* Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacMD5 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmac(String)}","@Deprecated
public static byte[] hmacMd5(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],byte[])","Method","* Returns a HmacMD5 Message Authentication Code (MAC) as a hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacMD5 MAC for the given key and value as a hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmacHex(byte[])}","@Deprecated
public static String hmacMd5Hex(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],InputStream)","Method","* Returns a HmacMD5 Message Authentication Code (MAC) as a hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacMD5 MAC for the given key and value as a hexadecimal string (lowercase)
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmacHex(InputStream)}","@Deprecated
public static String hmacMd5Hex(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(String,String)","Method","* Returns a HmacMD5 Message Authentication Code (MAC) as a hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacMD5 MAC for the given key and value as a hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmacHex(String)}","@Deprecated
public static String hmacMd5Hex(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],byte[])","Method","* Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA1 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmac(byte[])}","@Deprecated
public static byte[] hmacSha1(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],InputStream)","Method","* Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacSHA1 MAC for the given key and value
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmac(InputStream)}","@Deprecated
public static byte[] hmacSha1(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1(String,String)","Method","* Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA1 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmac(String)}","@Deprecated
public static byte[] hmacSha1(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],byte[])","Method","* Returns a HmacSHA1 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA1 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmacHex(byte[])}","@Deprecated
public static String hmacSha1Hex(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],InputStream)","Method","* Returns a HmacSHA1 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacSHA1 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmacHex(InputStream)}","@Deprecated
public static String hmacSha1Hex(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(String,String)","Method","* Returns a HmacSHA1 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA1 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmacHex(String)}","@Deprecated
public static String hmacSha1Hex(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],byte[])","Method","* Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA256 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmac(byte[])}","@Deprecated
public static byte[] hmacSha256(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],InputStream)","Method","* Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacSHA256 MAC for the given key and value
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmac(InputStream)}","@Deprecated
public static byte[] hmacSha256(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256(String,String)","Method","* Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA256 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmac(String)}","@Deprecated
public static byte[] hmacSha256(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],byte[])","Method","* Returns a HmacSHA256 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA256 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmacHex(byte[])}","@Deprecated
public static String hmacSha256Hex(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],InputStream)","Method","* Returns a HmacSHA256 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacSHA256 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmacHex(InputStream)}","@Deprecated
public static String hmacSha256Hex(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(String,String)","Method","* Returns a HmacSHA256 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA256 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmacHex(String)}","@Deprecated
public static String hmacSha256Hex(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],byte[])","Method","* Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA384 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmac(byte[])}","@Deprecated
public static byte[] hmacSha384(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],InputStream)","Method","* Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacSHA384 MAC for the given key and value
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmac(InputStream)}","@Deprecated
public static byte[] hmacSha384(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384(String,String)","Method","* Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA384 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmac(String)}","@Deprecated
public static byte[] hmacSha384(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],byte[])","Method","* Returns a HmacSHA384 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA384 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmacHex(byte[])}","@Deprecated
public static String hmacSha384Hex(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],InputStream)","Method","* Returns a HmacSHA384 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacSHA384 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmacHex(InputStream)}","@Deprecated
public static String hmacSha384Hex(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(String,String)","Method","* Returns a HmacSHA384 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA384 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmacHex(String)}","@Deprecated
public static String hmacSha384Hex(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],byte[])","Method","* Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA512 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmac(byte[])}","@Deprecated
public static byte[] hmacSha512(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],InputStream)","Method","* Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacSHA512 MAC for the given key and value
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmac(InputStream)}","@Deprecated
public static byte[] hmacSha512(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512(String,String)","Method","* Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA512 MAC for the given key and value
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmac(String)}","@Deprecated
public static byte[] hmacSha512(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],byte[])","Method","* Returns a HmacSHA512 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA512 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmacHex(byte[])}","@Deprecated
public static String hmacSha512Hex(final byte[] key, final byte[] valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],InputStream)","Method","* Returns a HmacSHA512 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return HmacSHA512 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmacHex(InputStream)}","@Deprecated
public static String hmacSha512Hex(final byte[] key, final InputStream valueToDigest) throws IOException {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],InputStream).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[],InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(String,String)","Method","* Returns a HmacSHA512 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.
     *
     * @param key
     *            The key for the keyed digest (must not be null)
     * @param valueToDigest
     *            The value (data) which should to digest (maybe empty or null)
     * @return HmacSHA512 MAC for the given key and value as hexadecimal string (lowercase)
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmacHex(String)}","@Deprecated
public static String hmacSha512Hex(final String key, final String valueToDigest) {
    return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(String,String).key","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(String,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.isAvailable(HmacAlgorithms)","Method","* Returns whether this algorithm is available
     *
     * @param name the name to check
     * @return whether this algorithm is available
     * @since 1.11","public static boolean isAvailable(final HmacAlgorithms name) {
    try {
        Mac.getInstance(name.getName());
        return true;
    } catch (final NoSuchAlgorithmException e) {
        return false;
    }
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.isAvailable(HmacAlgorithms).name","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.isAvailable(HmacAlgorithms)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.isAvailable(String)","Method","* Returns whether this algorithm is available
     *
     * @param name the name to check
     * @return whether this algorithm is available
     * @since 1.11","public static boolean isAvailable(final String name) {
    try {
        Mac.getInstance(name);
        return true;
    } catch (final NoSuchAlgorithmException e) {
        return false;
    }
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.isAvailable(String).name","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.isAvailable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,byte[])","Method","* Resets and then updates the given {@link Mac} with the value.
     *
     * @param mac
     *            the initialized {@link Mac} to update
     * @param valueToDigest
     *            the value to update the {@link Mac} with (maybe null or empty)
     * @return the updated {@link Mac}
     * @throws IllegalStateException
     *             if the Mac was not initialized","public static Mac updateHmac(final Mac mac, final byte[] valueToDigest) {
    mac.reset();
    mac.update(valueToDigest);
    return mac;
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,byte[]).mac","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,InputStream)","Method","* Resets and then updates the given {@link Mac} with the value.
     *
     * @param mac
     *            the initialized {@link Mac} to update
     * @param valueToDigest
     *            the value to update the {@link Mac} with
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return the updated {@link Mac}
     * @throws IOException
     *             If an I/O error occurs.
     * @throws IllegalStateException
     *             If the Mac was not initialized","public static Mac updateHmac(final Mac mac, final InputStream valueToDigest) throws IOException {
    mac.reset();
    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];
    int read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);
    while (read > -1) {
        mac.update(buffer, 0, read);
        read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);
    }
    return mac;
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,InputStream).mac","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,InputStream).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,String)","Method","* Resets and then updates the given {@link Mac} with the value.
     *
     * @param mac
     *            the initialized {@link Mac} to update
     * @param valueToDigest
     *            the value to update the {@link Mac} with (maybe null or empty)
     * @return the updated {@link Mac}
     * @throws IllegalStateException
     *             if the Mac was not initialized","public static Mac updateHmac(final Mac mac, final String valueToDigest) {
    mac.reset();
    mac.update(StringUtils.getBytesUtf8(valueToDigest));
    return mac;
}","Mac","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,String).mac","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.updateHmac(Mac,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(byte[])","Method","* Returns the digest for the input data.
     *
     * @param valueToDigest the input to use
     * @return the digest as a byte[]
     * @since 1.11","public byte[] hmac(final byte[] valueToDigest) {
    return mac.doFinal(valueToDigest);
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(byte[]).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmac(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(ByteBuffer)","Method","* Returns the digest for the input data.
     *
     * @param valueToDigest the input to use
     * @return the digest as a byte[]
     * @since 1.11","public byte[] hmac(final ByteBuffer valueToDigest) {
    mac.update(valueToDigest);
    return mac.doFinal();
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(ByteBuffer).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmac(ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(File)","Method","* Returns the digest for the file.
     *
     * @param valueToDigest the file to use
     * @return the digest
     * @throws IOException
     *             If an I/O error occurs.
     * @since 1.11","public byte[] hmac(final File valueToDigest) throws IOException {
    try (BufferedInputStream stream = new BufferedInputStream(new FileInputStream(valueToDigest))) {
        return hmac(stream);
    }
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(File).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmac(File)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(InputStream)","Method","* Returns the digest for the stream.
     *
     * @param valueToDigest
     *            the data to use
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return the digest
     * @throws IOException
     *             If an I/O error occurs.
     * @since 1.11","public byte[] hmac(final InputStream valueToDigest) throws IOException {
    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];
    int read;
    while ((read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {
        mac.update(buffer, 0, read);
    }
    return mac.doFinal();
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(InputStream).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmac(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(String)","Method","* Returns the digest for the input data.
     *
     * @param valueToDigest the input to use, treated as UTF-8
     * @return the digest as a byte[]
     * @since 1.11","public byte[] hmac(final String valueToDigest) {
    return mac.doFinal(StringUtils.getBytesUtf8(valueToDigest));
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmac(String).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmac(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(byte[])","Method","* Returns the digest for the input data.
     *
     * @param valueToDigest the input to use
     * @return the digest as a hexadecimal String
     * @since 1.11","public String hmacHex(final byte[] valueToDigest) {
    return Hex.encodeHexString(hmac(valueToDigest));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(byte[]).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacHex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(ByteBuffer)","Method","* Returns the digest for the input data.
     *
     * @param valueToDigest the input to use
     * @return the digest as a hexadecimal String
     * @since 1.11","public String hmacHex(final ByteBuffer valueToDigest) {
    return Hex.encodeHexString(hmac(valueToDigest));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(ByteBuffer).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacHex(ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(File)","Method","* Returns the digest for the file.
     *
     * @param valueToDigest the file to use
     * @return the digest as a hexadecimal String
     * @throws IOException
     *             If an I/O error occurs.
     * @since 1.11","public String hmacHex(final File valueToDigest) throws IOException {
    return Hex.encodeHexString(hmac(valueToDigest));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(File).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacHex(File)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(InputStream)","Method","* Returns the digest for the stream.
     *
     * @param valueToDigest
     *            the data to use
     *            <p>
     *            The InputStream must not be null and will not be closed
     *            </p>
     * @return the digest as a hexadecimal String
     * @throws IOException
     *             If an I/O error occurs.
     * @since 1.11","public String hmacHex(final InputStream valueToDigest) throws IOException {
    return Hex.encodeHexString(hmac(valueToDigest));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(InputStream).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacHex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(String)","Method","* Returns the digest for the input data.
     *
     * @param valueToDigest the input to use, treated as UTF-8
     * @return the digest as a hexadecimal String
     * @since 1.11","public String hmacHex(final String valueToDigest) {
    return Hex.encodeHexString(hmac(valueToDigest));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.hmacHex(String).valueToDigest","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.hmacHex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>()","Constructor","* Preserves binary compatibility only.
     * As for previous versions does not provide useful behavior
     * @deprecated since 1.11; only useful to preserve binary compatibility","@Deprecated
public HmacUtils() {
    this(null);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,byte[])","Constructor","* Creates an instance using the provided algorithm type.
     *
     * @param algorithm to use.
     * @param key the key to use
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @since 1.11","public HmacUtils(final HmacAlgorithms algorithm, final byte[] key) {
    this(algorithm.getName(), key);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,byte[]).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,byte[]).key","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,String)","Constructor","* Creates an instance using the provided algorithm type.
     *
     * @param algorithm to use
     * @param  key the key to use
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @since 1.11","public HmacUtils(final HmacAlgorithms algorithm, final String key) {
    this(algorithm.getName(), StringUtils.getBytesUtf8(key));
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,String).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,String).key","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.<init>(HmacAlgorithms,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(Mac)","Constructor","No Comment","private HmacUtils(final Mac mac) {
    this.mac = mac;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(Mac).mac","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.<init>(Mac)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(String,byte[])","Constructor","* Creates an instance using the provided algorithm type.
     *
     * @param algorithm to use
     * @param  key the key to use
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @since 1.11","public HmacUtils(final String algorithm, final byte[] key) {
    this(getInitializedMac(algorithm, key));
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(String,byte[]).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.<init>(String,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(String,byte[]).key","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.<init>(String,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(String,String)","Constructor","* Creates an instance using the provided algorithm type.
     *
     * @param algorithm to use
     * @param  key the key to use
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.
     * @since 1.11","public HmacUtils(final String algorithm, final String key) {
    this(algorithm, StringUtils.getBytesUtf8(key));
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(String,String).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.HmacUtils.<init>(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacUtils.<init>(String,String).key","Parameter_2","Belong to org.apache.commons.codec.digest.HmacUtils.<init>(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt","Class","* Unix crypt(3) algorithm implementation.
 * <p>
 * This class only implements the traditional 56 bit DES based algorithm. Please use Crypt.crypt() for a method
 * that distinguishes between all the algorithms supported in the current glibc's crypt().
 * </p>
 * <p>
 * The Java implementation was taken from the JetSpeed Portal project (see
 * org.apache.jetspeed.services.security.ldap.UnixCrypt).
 * </p>
 * <p>
 * This class is slightly incompatible if the given salt contains characters that are not part of the allowed range
 * [a-zA-Z0-9./].
 * </p>
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @since 1.7","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.digest.UnixCrypt.CRYPT_SALT_REGEX","Field","No Comment","private static final String CRYPT_SALT_REGEX = ""^["" + B64.B64T_STRING + ""]{2,}$"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.CRYPT_SALT_PATTERN","Field","No Comment","private static final Pattern CRYPT_SALT_PATTERN = Pattern.compile(CRYPT_SALT_REGEX);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.CON_SALT","Field","No Comment","private static final int[] CON_SALT = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 0 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.COV2CHAR","Field","No Comment","private static final int[] COV2CHAR = { 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.SHIFT2","Field","No Comment","private static final boolean[] SHIFT2 = { false, false, true, true, true, true, true, true, false, true, true, true, true, true, true, false };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.SKB","Field","No Comment","private static final int[][] SKB = { { 0, 16, 0x20000000, 0x20000010, 0x10000, 0x10010, 0x20010000, 0x20010010, 2048, 2064, 0x20000800, 0x20000810, 0x10800, 0x10810, 0x20010800, 0x20010810, 32, 48, 0x20000020, 0x20000030, 0x10020, 0x10030, 0x20010020, 0x20010030, 2080, 2096, 0x20000820, 0x20000830, 0x10820, 0x10830, 0x20010820, 0x20010830, 0x80000, 0x80010, 0x20080000, 0x20080010, 0x90000, 0x90010, 0x20090000, 0x20090010, 0x80800, 0x80810, 0x20080800, 0x20080810, 0x90800, 0x90810, 0x20090800, 0x20090810, 0x80020, 0x80030, 0x20080020, 0x20080030, 0x90020, 0x90030, 0x20090020, 0x20090030, 0x80820, 0x80830, 0x20080820, 0x20080830, 0x90820, 0x90830, 0x20090820, 0x20090830 }, { 0, 0x2000000, 8192, 0x2002000, 0x200000, 0x2200000, 0x202000, 0x2202000, 4, 0x2000004, 8196, 0x2002004, 0x200004, 0x2200004, 0x202004, 0x2202004, 1024, 0x2000400, 9216, 0x2002400, 0x200400, 0x2200400, 0x202400, 0x2202400, 1028, 0x2000404, 9220, 0x2002404, 0x200404, 0x2200404, 0x202404, 0x2202404, 0x10000000, 0x12000000, 0x10002000, 0x12002000, 0x10200000, 0x12200000, 0x10202000, 0x12202000, 0x10000004, 0x12000004, 0x10002004, 0x12002004, 0x10200004, 0x12200004, 0x10202004, 0x12202004, 0x10000400, 0x12000400, 0x10002400, 0x12002400, 0x10200400, 0x12200400, 0x10202400, 0x12202400, 0x10000404, 0x12000404, 0x10002404, 0x12002404, 0x10200404, 0x12200404, 0x10202404, 0x12202404 }, { 0, 1, 0x40000, 0x40001, 0x1000000, 0x1000001, 0x1040000, 0x1040001, 2, 3, 0x40002, 0x40003, 0x1000002, 0x1000003, 0x1040002, 0x1040003, 512, 513, 0x40200, 0x40201, 0x1000200, 0x1000201, 0x1040200, 0x1040201, 514, 515, 0x40202, 0x40203, 0x1000202, 0x1000203, 0x1040202, 0x1040203, 0x8000000, 0x8000001, 0x8040000, 0x8040001, 0x9000000, 0x9000001, 0x9040000, 0x9040001, 0x8000002, 0x8000003, 0x8040002, 0x8040003, 0x9000002, 0x9000003, 0x9040002, 0x9040003, 0x8000200, 0x8000201, 0x8040200, 0x8040201, 0x9000200, 0x9000201, 0x9040200, 0x9040201, 0x8000202, 0x8000203, 0x8040202, 0x8040203, 0x9000202, 0x9000203, 0x9040202, 0x9040203 }, { 0, 0x100000, 256, 0x100100, 8, 0x100008, 264, 0x100108, 4096, 0x101000, 4352, 0x101100, 4104, 0x101008, 4360, 0x101108, 0x4000000, 0x4100000, 0x4000100, 0x4100100, 0x4000008, 0x4100008, 0x4000108, 0x4100108, 0x4001000, 0x4101000, 0x4001100, 0x4101100, 0x4001008, 0x4101008, 0x4001108, 0x4101108, 0x20000, 0x120000, 0x20100, 0x120100, 0x20008, 0x120008, 0x20108, 0x120108, 0x21000, 0x121000, 0x21100, 0x121100, 0x21008, 0x121008, 0x21108, 0x121108, 0x4020000, 0x4120000, 0x4020100, 0x4120100, 0x4020008, 0x4120008, 0x4020108, 0x4120108, 0x4021000, 0x4121000, 0x4021100, 0x4121100, 0x4021008, 0x4121008, 0x4021108, 0x4121108 }, { 0, 0x10000000, 0x10000, 0x10010000, 4, 0x10000004, 0x10004, 0x10010004, 0x20000000, 0x30000000, 0x20010000, 0x30010000, 0x20000004, 0x30000004, 0x20010004, 0x30010004, 0x100000, 0x10100000, 0x110000, 0x10110000, 0x100004, 0x10100004, 0x110004, 0x10110004, 0x20100000, 0x30100000, 0x20110000, 0x30110000, 0x20100004, 0x30100004, 0x20110004, 0x30110004, 4096, 0x10001000, 0x11000, 0x10011000, 4100, 0x10001004, 0x11004, 0x10011004, 0x20001000, 0x30001000, 0x20011000, 0x30011000, 0x20001004, 0x30001004, 0x20011004, 0x30011004, 0x101000, 0x10101000, 0x111000, 0x10111000, 0x101004, 0x10101004, 0x111004, 0x10111004, 0x20101000, 0x30101000, 0x20111000, 0x30111000, 0x20101004, 0x30101004, 0x20111004, 0x30111004 }, { 0, 0x8000000, 8, 0x8000008, 1024, 0x8000400, 1032, 0x8000408, 0x20000, 0x8020000, 0x20008, 0x8020008, 0x20400, 0x8020400, 0x20408, 0x8020408, 1, 0x8000001, 9, 0x8000009, 1025, 0x8000401, 1033, 0x8000409, 0x20001, 0x8020001, 0x20009, 0x8020009, 0x20401, 0x8020401, 0x20409, 0x8020409, 0x2000000, 0xa000000, 0x2000008, 0xa000008, 0x2000400, 0xa000400, 0x2000408, 0xa000408, 0x2020000, 0xa020000, 0x2020008, 0xa020008, 0x2020400, 0xa020400, 0x2020408, 0xa020408, 0x2000001, 0xa000001, 0x2000009, 0xa000009, 0x2000401, 0xa000401, 0x2000409, 0xa000409, 0x2020001, 0xa020001, 0x2020009, 0xa020009, 0x2020401, 0xa020401, 0x2020409, 0xa020409 }, { 0, 256, 0x80000, 0x80100, 0x1000000, 0x1000100, 0x1080000, 0x1080100, 16, 272, 0x80010, 0x80110, 0x1000010, 0x1000110, 0x1080010, 0x1080110, 0x200000, 0x200100, 0x280000, 0x280100, 0x1200000, 0x1200100, 0x1280000, 0x1280100, 0x200010, 0x200110, 0x280010, 0x280110, 0x1200010, 0x1200110, 0x1280010, 0x1280110, 512, 768, 0x80200, 0x80300, 0x1000200, 0x1000300, 0x1080200, 0x1080300, 528, 784, 0x80210, 0x80310, 0x1000210, 0x1000310, 0x1080210, 0x1080310, 0x200200, 0x200300, 0x280200, 0x280300, 0x1200200, 0x1200300, 0x1280200, 0x1280300, 0x200210, 0x200310, 0x280210, 0x280310, 0x1200210, 0x1200310, 0x1280210, 0x1280310 }, { 0, 0x4000000, 0x40000, 0x4040000, 2, 0x4000002, 0x40002, 0x4040002, 8192, 0x4002000, 0x42000, 0x4042000, 8194, 0x4002002, 0x42002, 0x4042002, 32, 0x4000020, 0x40020, 0x4040020, 34, 0x4000022, 0x40022, 0x4040022, 8224, 0x4002020, 0x42020, 0x4042020, 8226, 0x4002022, 0x42022, 0x4042022, 2048, 0x4000800, 0x40800, 0x4040800, 2050, 0x4000802, 0x40802, 0x4040802, 10240, 0x4002800, 0x42800, 0x4042800, 10242, 0x4002802, 0x42802, 0x4042802, 2080, 0x4000820, 0x40820, 0x4040820, 2082, 0x4000822, 0x40822, 0x4040822, 10272, 0x4002820, 0x42820, 0x4042820, 10274, 0x4002822, 0x42822, 0x4042822 } };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.SPTRANS","Field","No Comment","private static final int[][] SPTRANS = { { 0x820200, 0x20000, 0x80800000, 0x80820200, 0x800000, 0x80020200, 0x80020000, 0x80800000, 0x80020200, 0x820200, 0x820000, 0x80000200, 0x80800200, 0x800000, 0, 0x80020000, 0x20000, 0x80000000, 0x800200, 0x20200, 0x80820200, 0x820000, 0x80000200, 0x800200, 0x80000000, 512, 0x20200, 0x80820000, 512, 0x80800200, 0x80820000, 0, 0, 0x80820200, 0x800200, 0x80020000, 0x820200, 0x20000, 0x80000200, 0x800200, 0x80820000, 512, 0x20200, 0x80800000, 0x80020200, 0x80000000, 0x80800000, 0x820000, 0x80820200, 0x20200, 0x820000, 0x80800200, 0x800000, 0x80000200, 0x80020000, 0, 0x20000, 0x800000, 0x80800200, 0x820200, 0x80000000, 0x80820000, 512, 0x80020200 }, { 0x10042004, 0, 0x42000, 0x10040000, 0x10000004, 8196, 0x10002000, 0x42000, 8192, 0x10040004, 4, 0x10002000, 0x40004, 0x10042000, 0x10040000, 4, 0x40000, 0x10002004, 0x10040004, 8192, 0x42004, 0x10000000, 0, 0x40004, 0x10002004, 0x42004, 0x10042000, 0x10000004, 0x10000000, 0x40000, 8196, 0x10042004, 0x40004, 0x10042000, 0x10002000, 0x42004, 0x10042004, 0x40004, 0x10000004, 0, 0x10000000, 8196, 0x40000, 0x10040004, 8192, 0x10000000, 0x42004, 0x10002004, 0x10042000, 8192, 0, 0x10000004, 4, 0x10042004, 0x42000, 0x10040000, 0x10040004, 0x40000, 8196, 0x10002000, 0x10002004, 4, 0x10040000, 0x42000 }, { 0x41000000, 0x1010040, 64, 0x41000040, 0x40010000, 0x1000000, 0x41000040, 0x10040, 0x1000040, 0x10000, 0x1010000, 0x40000000, 0x41010040, 0x40000040, 0x40000000, 0x41010000, 0, 0x40010000, 0x1010040, 64, 0x40000040, 0x41010040, 0x10000, 0x41000000, 0x41010000, 0x1000040, 0x40010040, 0x1010000, 0x10040, 0, 0x1000000, 0x40010040, 0x1010040, 64, 0x40000000, 0x10000, 0x40000040, 0x40010000, 0x1010000, 0x41000040, 0, 0x1010040, 0x10040, 0x41010000, 0x40010000, 0x1000000, 0x41010040, 0x40000000, 0x40010040, 0x41000000, 0x1000000, 0x41010040, 0x10000, 0x1000040, 0x41000040, 0x10040, 0x1000040, 0, 0x41010000, 0x40000040, 0x41000000, 0x40010040, 64, 0x1010000 }, { 0x100402, 0x4000400, 2, 0x4100402, 0, 0x4100000, 0x4000402, 0x100002, 0x4100400, 0x4000002, 0x4000000, 1026, 0x4000002, 0x100402, 0x100000, 0x4000000, 0x4100002, 0x100400, 1024, 2, 0x100400, 0x4000402, 0x4100000, 1024, 1026, 0, 0x100002, 0x4100400, 0x4000400, 0x4100002, 0x4100402, 0x100000, 0x4100002, 1026, 0x100000, 0x4000002, 0x100400, 0x4000400, 2, 0x4100000, 0x4000402, 0, 1024, 0x100002, 0, 0x4100002, 0x4100400, 1024, 0x4000000, 0x4100402, 0x100402, 0x100000, 0x4100402, 2, 0x4000400, 0x100402, 0x100002, 0x100400, 0x4100000, 0x4000402, 1026, 0x4000000, 0x4000002, 0x4100400 }, { 0x2000000, 16384, 256, 0x2004108, 0x2004008, 0x2000100, 16648, 0x2004000, 16384, 8, 0x2000008, 16640, 0x2000108, 0x2004008, 0x2004100, 0, 16640, 0x2000000, 16392, 264, 0x2000100, 16648, 0, 0x2000008, 8, 0x2000108, 0x2004108, 16392, 0x2004000, 256, 264, 0x2004100, 0x2004100, 0x2000108, 16392, 0x2004000, 16384, 8, 0x2000008, 0x2000100, 0x2000000, 16640, 0x2004108, 0, 16648, 0x2000000, 256, 16392, 0x2000108, 256, 0, 0x2004108, 0x2004008, 0x2004100, 264, 16384, 16640, 0x2004008, 0x2000100, 264, 8, 16648, 0x2004000, 0x2000008 }, { 0x20000010, 0x80010, 0, 0x20080800, 0x80010, 2048, 0x20000810, 0x80000, 2064, 0x20080810, 0x80800, 0x20000000, 0x20000800, 0x20000010, 0x20080000, 0x80810, 0x80000, 0x20000810, 0x20080010, 0, 2048, 16, 0x20080800, 0x20080010, 0x20080810, 0x20080000, 0x20000000, 2064, 16, 0x80800, 0x80810, 0x20000800, 2064, 0x20000000, 0x20000800, 0x80810, 0x20080800, 0x80010, 0, 0x20000800, 0x20000000, 2048, 0x20080010, 0x80000, 0x80010, 0x20080810, 0x80800, 16, 0x20080810, 0x80800, 0x80000, 0x20000810, 0x20000010, 0x20080000, 0x80810, 0, 2048, 0x20000010, 0x20000810, 0x20080800, 0x20080000, 2064, 16, 0x20080010 }, { 4096, 128, 0x400080, 0x400001, 0x401081, 4097, 4224, 0, 0x400000, 0x400081, 129, 0x401000, 1, 0x401080, 0x401000, 129, 0x400081, 4096, 4097, 0x401081, 0, 0x400080, 0x400001, 4224, 0x401001, 4225, 0x401080, 1, 4225, 0x401001, 128, 0x400000, 4225, 0x401000, 0x401001, 129, 4096, 128, 0x400000, 0x401001, 0x400081, 4225, 4224, 0, 128, 0x400001, 1, 0x400080, 0, 0x400081, 0x400080, 4224, 129, 4096, 0x401081, 0x400000, 0x401080, 1, 4097, 0x401081, 0x400001, 0x401080, 0x401000, 4097 }, { 0x8200020, 0x8208000, 32800, 0, 0x8008000, 0x200020, 0x8200000, 0x8208020, 32, 0x8000000, 0x208000, 32800, 0x208020, 0x8008020, 0x8000020, 0x8200000, 32768, 0x208020, 0x200020, 0x8008000, 0x8208020, 0x8000020, 0, 0x208000, 0x8000000, 0x200000, 0x8008020, 0x8200020, 0x200000, 32768, 0x8208000, 32, 0x200000, 32768, 0x8000020, 0x8208020, 32800, 0x8000000, 0, 0x208000, 0x8200020, 0x8008020, 0x8008000, 0x200020, 0x8208000, 32, 0x200020, 0x8008000, 0x8208020, 0x200000, 0x8200000, 0x8000020, 0x208000, 32800, 0x8008020, 0x8200000, 32, 0x8208000, 0x208020, 0, 0x8000000, 0x8200020, 32768, 0x208020 } };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.body(int[],int,int)","Method","No Comment","private static int[] body(final int[] schedule, final int eSwap0, final int eSwap1) {
    int left = 0;
    int right = 0;
    int t = 0;
    for (int j = 0; j < 25; j++) {
        for (int i = 0; i < 32; i += 4) {
            left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);
            right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);
        }
        t = left;
        left = right;
        right = t;
    }
    t = right;
    right = left >>> 1 | left << 31;
    left = t >>> 1 | t << 31;
    final int[] results = new int[2];
    permOp(right, left, 1, 0x55555555, results);
    right = results[0];
    left = results[1];
    permOp(left, right, 8, 0xff00ff, results);
    left = results[0];
    right = results[1];
    permOp(right, left, 2, 0x33333333, results);
    right = results[0];
    left = results[1];
    permOp(left, right, 16, 65535, results);
    left = results[0];
    right = results[1];
    permOp(right, left, 4, 0xf0f0f0f, results);
    right = results[0];
    left = results[1];
    final int[] out = new int[2];
    out[0] = left;
    out[1] = right;
    return out;
}","int[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.body(int[],int,int).schedule","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.body(int[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.body(int[],int,int).eSwap0","Parameter_2","Belong to org.apache.commons.codec.digest.UnixCrypt.body(int[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.body(int[],int,int).eSwap1","Parameter_3","Belong to org.apache.commons.codec.digest.UnixCrypt.body(int[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.byteToUnsigned(byte)","Method","No Comment","private static int byteToUnsigned(final byte b) {
    return b & 0xff;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.byteToUnsigned(byte).b","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.byteToUnsigned(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(byte[])","Method","* Generates a crypt(3) compatible hash using the DES algorithm.
     * <p>
     * A salt is generated for you using {@link SecureRandom}.
     * </p>
     *
     * @param original
     *            plaintext password
     * @return a 13 character string starting with the salt string","public static String crypt(final byte[] original) {
    return crypt(original, null);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(byte[]).original","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.crypt(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(byte[],String)","Method","* Generates a crypt(3) compatible hash using the DES algorithm.
     * <p>
     * Using unspecified characters as salt results incompatible hash values.
     * </p>
     *
     * @param original
     *            plaintext password
     * @param salt
     *            a two character string drawn from [a-zA-Z0-9./]. The salt may be null, in which case a salt is
     *            generated for you using {@link B64#getRandomSalt(int)}.
     * @return a 13 character string starting with the salt string
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern","public static String crypt(final byte[] original, String salt) {
    if (salt == null) {
        salt = B64.getRandomSalt(2);
    } else if (!CRYPT_SALT_PATTERN.matcher(salt).matches()) {
        throw new IllegalArgumentException(""Invalid salt value: "" + salt);
    }
    final StringBuilder buffer = new StringBuilder(""             "");
    final char charZero = salt.charAt(0);
    final char charOne = salt.charAt(1);
    buffer.setCharAt(0, charZero);
    buffer.setCharAt(1, charOne);
    final int eSwap0 = CON_SALT[charZero];
    final int eSwap1 = CON_SALT[charOne] << 4;
    final byte[] key = new byte[8];
    Arrays.fill(key, (byte) 0);
    final int originalLength = original.length;
    for (int i = 0; i < key.length && i < originalLength; i++) {
        final int iChar = original[i];
        key[i] = (byte) (iChar << 1);
    }
    final int[] schedule = desSetKey(key);
    final int[] out = body(schedule, eSwap0, eSwap1);
    final byte[] b = new byte[9];
    intToFourBytes(out[0], b, 0);
    intToFourBytes(out[1], b, 4);
    b[8] = 0;
    int i = 2;
    int y = 0;
    int u = 128;
    for (; i < 13; i++) {
        int j = 0;
        int c = 0;
        for (; j < 6; j++) {
            c <<= 1;
            if ((b[y] & u) != 0) {
                c |= 0x1;
            }
            u >>>= 1;
            if (u == 0) {
                y++;
                u = 128;
            }
            buffer.setCharAt(i, (char) COV2CHAR[c]);
        }
    }
    return buffer.toString();
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(byte[],String).original","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(byte[],String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.UnixCrypt.crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(String)","Method","* Generates a crypt(3) compatible hash using the DES algorithm.
     * <p>
     * A salt is generated for you using {@link SecureRandom}.
     * </p>
     *
     * @param original
     *            plaintext password
     * @return a 13 character string starting with the salt string","public static String crypt(final String original) {
    return crypt(original.getBytes(StandardCharsets.UTF_8));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(String).original","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.crypt(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(String,String)","Method","* Generates a crypt(3) compatible hash using the DES algorithm.
     *
     * @param original
     *            plaintext password
     * @param salt
     *            a two character string drawn from [a-zA-Z0-9./]. The salt may be null, in which case a salt is
     *            generated for you using {@link SecureRandom}.
     * @return a 13 character string starting with the salt string
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern","public static String crypt(final String original, final String salt) {
    return crypt(original.getBytes(StandardCharsets.UTF_8), salt);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(String,String).original","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.crypt(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.crypt(String,String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.UnixCrypt.crypt(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[])","Method","No Comment","private static int dEncrypt(int el, final int r, final int s, final int e0, final int e1, final int[] sArr) {
    int v = r ^ r >>> 16;
    int u = v & e0;
    v &= e1;
    u = u ^ u << 16 ^ r ^ sArr[s];
    int t = v ^ v << 16 ^ r ^ sArr[s + 1];
    t = t >>> 4 | t << 28;
    el ^= SPTRANS[1][t & 0x3f] | SPTRANS[3][t >>> 8 & 0x3f] | SPTRANS[5][t >>> 16 & 0x3f] | SPTRANS[7][t >>> 24 & 0x3f] | SPTRANS[0][u & 0x3f] | SPTRANS[2][u >>> 8 & 0x3f] | SPTRANS[4][u >>> 16 & 0x3f] | SPTRANS[6][u >>> 24 & 0x3f];
    return el;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[]).el","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[]).r","Parameter_2","Belong to org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[]).s","Parameter_3","Belong to org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[]).e0","Parameter_4","Belong to org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[]).e1","Parameter_5","Belong to org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[]).sArr","Parameter_6","Belong to org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int,int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.desSetKey(byte[])","Method","No Comment","private static int[] desSetKey(final byte[] key) {
    final int[] schedule = new int[32];
    int c = fourBytesToInt(key, 0);
    int d = fourBytesToInt(key, 4);
    final int[] results = new int[2];
    permOp(d, c, 4, 0xf0f0f0f, results);
    d = results[0];
    c = results[1];
    c = hPermOp(c, -2, 0xcccc0000);
    d = hPermOp(d, -2, 0xcccc0000);
    permOp(d, c, 1, 0x55555555, results);
    d = results[0];
    c = results[1];
    permOp(c, d, 8, 0xff00ff, results);
    c = results[0];
    d = results[1];
    permOp(d, c, 1, 0x55555555, results);
    d = results[0];
    c = results[1];
    d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;
    c &= 0xfffffff;
    int j = 0;
    for (int i = 0; i < 16; i++) {
        if (SHIFT2[i]) {
            c = c >>> 2 | c << 26;
            d = d >>> 2 | d << 26;
        } else {
            c = c >>> 1 | c << 27;
            d = d >>> 1 | d << 27;
        }
        c &= 0xfffffff;
        d &= 0xfffffff;
        int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] | SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] | SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];
        final int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] | SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];
        schedule[j++] = t << 16 | s & 0xffff;
        s = s >>> 16 | t & 0xffff0000;
        s = s << 4 | s >>> 28;
        schedule[j++] = s;
    }
    return schedule;
}","int[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.desSetKey(byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.desSetKey(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.fourBytesToInt(byte[],int)","Method","No Comment","private static int fourBytesToInt(final byte[] b, int offset) {
    int value = byteToUnsigned(b[offset++]);
    value |= byteToUnsigned(b[offset++]) << 8;
    value |= byteToUnsigned(b[offset++]) << 16;
    value |= byteToUnsigned(b[offset++]) << 24;
    return value;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.fourBytesToInt(byte[],int).b","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.fourBytesToInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.fourBytesToInt(byte[],int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.UnixCrypt.fourBytesToInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.hPermOp(int,int,int)","Method","No Comment","private static int hPermOp(final int a, final int n, final int m) {
    final int t = (a << 16 - n ^ a) & m;
    return a ^ t ^ t >>> 16 - n;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.hPermOp(int,int,int).a","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.hPermOp(int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.hPermOp(int,int,int).n","Parameter_2","Belong to org.apache.commons.codec.digest.UnixCrypt.hPermOp(int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.hPermOp(int,int,int).m","Parameter_3","Belong to org.apache.commons.codec.digest.UnixCrypt.hPermOp(int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.intToFourBytes(int,byte[],int)","Method","No Comment","private static void intToFourBytes(final int iValue, final byte[] b, int offset) {
    b[offset++] = (byte) (iValue & 0xff);
    b[offset++] = (byte) (iValue >>> 8 & 0xff);
    b[offset++] = (byte) (iValue >>> 16 & 0xff);
    b[offset++] = (byte) (iValue >>> 24 & 0xff);
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.intToFourBytes(int,byte[],int).iValue","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.intToFourBytes(int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.intToFourBytes(int,byte[],int).b","Parameter_2","Belong to org.apache.commons.codec.digest.UnixCrypt.intToFourBytes(int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.intToFourBytes(int,byte[],int).offset","Parameter_3","Belong to org.apache.commons.codec.digest.UnixCrypt.intToFourBytes(int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[])","Method","No Comment","private static void permOp(int a, int b, final int n, final int m, final int[] results) {
    final int t = (a >>> n ^ b) & m;
    a ^= t << n;
    b ^= t;
    results[0] = a;
    results[1] = b;
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[]).a","Parameter_1","Belong to org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[]).b","Parameter_2","Belong to org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[]).n","Parameter_3","Belong to org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[]).m","Parameter_4","Belong to org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[]).results","Parameter_5","Belong to org.apache.commons.codec.digest.UnixCrypt.permOp(int,int,int,int,int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.UnixCrypt.<init>()","Constructor","* TODO Make private in 2.0.
     *
     * @deprecated TODO Make private in 2.0.","@Deprecated
public UnixCrypt() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3","Class","* Implements the Blake3 algorithm providing a {@linkplain #initHash() hash function} with extensible output (XOF), a
 * {@linkplain #initKeyedHash(byte[]) keyed hash function} (MAC, PRF), and a
 * {@linkplain #initKeyDerivationFunction(byte[]) key derivation function} (KDF). Blake3 has a 128-bit security level
 * and a default output length of 256 bits (32 bytes) which can extended up to 2<sup>64</sup> bytes.
 * <h2>Hashing</h2>
 * <p>Hash mode calculates the same output hash given the same input bytes and can be used as both a message digest and
 * and extensible output function.</p>
 * <pre>{@code
 *      Blake3 hasher = Blake3.initHash();
 *      hasher.update(""Hello, world!"".getBytes(StandardCharsets.UTF_8));
 *      byte[] hash = new byte[32];
 *      hasher.doFinalize(hash);
 * }</pre>
 * <h2>Keyed Hashing</h2>
 * <p>Keyed hashes take a 32-byte secret key and calculates a message authentication code on some input bytes. These
 * also work as pseudo-random functions (PRFs) with extensible output similar to the extensible hash output. Note that
 * Blake3 keyed hashes have the same performance as plain hashes; the key is used in initialization in place of a
 * standard initialization vector used for plain hashing.</p>
 * <pre>{@code
 *      SecureRandom random = SecureRandom.getInstanceStrong();
 *      byte[] key = new byte[32];
 *      random.nextBytes(key);
 *      Blake3 hasher = Blake3.initKeyedHash(key);
 *      hasher.update(""Hello, Alice!"".getBytes(StandardCharsets.UTF_8));
 *      byte[] mac = new byte[32];
 *      hasher.doFinalize(mac);
 * }</pre>
 * <h2>Key Derivation</h2>
 * <p>A specific hash mode for deriving session keys and other derived keys in a unique key derivation context
 * identified by some sequence of bytes. These context strings should be unique but do not need to be kept secret.
 * Additional input data is hashed for key material which can be finalized to derive subkeys.</p>
 * <pre>{@code
 *      String context = ""org.apache.commons.codec.digest.Blake3Example"";
 *      byte[] sharedSecret = ...;
 *      byte[] senderId = ...;
 *      byte[] recipientId = ...;
 *      Blake3 kdf = Blake3.initKeyDerivationFunction(context.getBytes(StandardCharsets.UTF_8));
 *      kdf.update(sharedSecret);
 *      kdf.update(senderId);
 *      kdf.update(recipientId);
 *      byte[] txKey = new byte[32];
 *      byte[] rxKey = new byte[32];
 *      kdf.doFinalize(txKey);
 *      kdf.doFinalize(rxKey);
 * }</pre>
 * <p>
 * Adapted from the ISC-licensed O(1) Cryptography library by Matt Sicker and ported from the reference public domain
 * implementation by Jack O'Connor.
 * </p>
 *
 * @see <a href=""https://github.com/BLAKE3-team/BLAKE3"">BLAKE3 hash function</a>
 * @since 1.16","Class do not obtain Source Code","No return type","public , final ","",""
"org.apache.commons.codec.digest.Blake3.BLOCK_LEN","Field","No Comment","private static final int BLOCK_LEN = 64;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.BLOCK_INTS","Field","No Comment","private static final int BLOCK_INTS = BLOCK_LEN / Integer.BYTES;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.KEY_LEN","Field","No Comment","private static final int KEY_LEN = 32;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.KEY_INTS","Field","No Comment","private static final int KEY_INTS = KEY_LEN / Integer.BYTES;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.OUT_LEN","Field","No Comment","private static final int OUT_LEN = 32;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.CHUNK_LEN","Field","No Comment","private static final int CHUNK_LEN = 1024;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.CHAINING_VALUE_INTS","Field","No Comment","private static final int CHAINING_VALUE_INTS = 8;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.IV","Field","* Standard hash key used for plain hashes; same initialization vector as Blake2s.","private static final int[] IV = { 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.CHUNK_START","Field","domain flags","private static final int CHUNK_START = 1;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.CHUNK_END","Field","No Comment","private static final int CHUNK_END = 1 << 1;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.PARENT","Field","No Comment","private static final int PARENT = 1 << 2;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ROOT","Field","No Comment","private static final int ROOT = 1 << 3;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.KEYED_HASH","Field","No Comment","private static final int KEYED_HASH = 1 << 4;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.DERIVE_KEY_CONTEXT","Field","No Comment","private static final int DERIVE_KEY_CONTEXT = 1 << 5;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.DERIVE_KEY_MATERIAL","Field","No Comment","private static final int DERIVE_KEY_MATERIAL = 1 << 6;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.MSG_SCHEDULE","Field","@formatter:off","private static final byte[][] MSG_SCHEDULE = { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }, { 2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8 }, { 3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1 }, { 10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6 }, { 12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4 }, { 9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7 }, { 11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13 } };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.engineState","Field","No Comment","private final EngineState engineState;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.checkBufferArgs(byte[],int,int)","Method","No Comment","private static void checkBufferArgs(final byte[] buffer, final int offset, final int length) {
    Objects.requireNonNull(buffer);
    if (offset < 0) {
        throw new IndexOutOfBoundsException(""Offset must be non-negative"");
    }
    if (length < 0) {
        throw new IndexOutOfBoundsException(""Length must be non-negative"");
    }
    final int bufferLength = buffer.length;
    if (offset > bufferLength - length) {
        throw new IndexOutOfBoundsException(""Offset "" + offset + "" and length "" + length + "" out of bounds with buffer length "" + bufferLength);
    }
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.checkBufferArgs(byte[],int,int).buffer","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.checkBufferArgs(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.checkBufferArgs(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.checkBufferArgs(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.checkBufferArgs(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.checkBufferArgs(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int)","Method","No Comment","private static int[] compress(final int[] chainingValue, final int[] blockWords, final int blockLength, final long counter, final int flags) {
    final int[] state = Arrays.copyOf(chainingValue, BLOCK_INTS);
    System.arraycopy(IV, 0, state, 8, 4);
    state[12] = (int) counter;
    state[13] = (int) (counter >> Integer.SIZE);
    state[14] = blockLength;
    state[15] = flags;
    for (int i = 0; i < 7; i++) {
        final byte[] schedule = MSG_SCHEDULE[i];
        round(state, blockWords, schedule);
    }
    for (int i = 0; i < state.length / 2; i++) {
        state[i] ^= state[i + 8];
        state[i + 8] ^= chainingValue[i];
    }
    return state;
}","int[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int).chainingValue","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int).blockWords","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int).blockLength","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int).counter","Parameter_4","Belong to org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int).flags","Parameter_5","Belong to org.apache.commons.codec.digest.Blake3.compress(int[],int[],int,long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int)","Method","* The mixing function, G, which mixes either a column or a diagonal.","private static void g(final int[] state, final int a, final int b, final int c, final int d, final int mx, final int my) {
    state[a] += state[b] + mx;
    state[d] = Integer.rotateRight(state[d] ^ state[a], 16);
    state[c] += state[d];
    state[b] = Integer.rotateRight(state[b] ^ state[c], 12);
    state[a] += state[b] + my;
    state[d] = Integer.rotateRight(state[d] ^ state[a], 8);
    state[c] += state[d];
    state[b] = Integer.rotateRight(state[b] ^ state[c], 7);
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int).state","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int).a","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int).b","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int).c","Parameter_4","Belong to org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int).d","Parameter_5","Belong to org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int).mx","Parameter_6","Belong to org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int).my","Parameter_7","Belong to org.apache.commons.codec.digest.Blake3.g(int[],int,int,int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.hash(byte[])","Method","* Calculates the Blake3 hash of the provided data.
     *
     * @param data source array to absorb data from
     * @return 32-byte hash squeezed from the provided data
     * @throws NullPointerException if data is null","public static byte[] hash(final byte[] data) {
    return Blake3.initHash().update(data).doFinalize(OUT_LEN);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.hash(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.hash(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.initHash()","Method","* Constructs a fresh Blake3 hash function. The instance returned functions as an arbitrary length message digest.
     *
     * @return fresh Blake3 instance in hashed mode","public static Blake3 initHash() {
    return new Blake3(IV, 0);
}","Blake3","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.initKeyDerivationFunction(byte[])","Method","* Constructs a fresh Blake3 key derivation function using the provided key derivation context byte string.
     * The instance returned functions as a key-derivation function which can further absorb additional context data
     * before squeezing derived key data.
     *
     * @param kdfContext a globally unique key-derivation context byte string to separate key derivation contexts from each other
     * @return fresh Blake3 instance in key derivation mode
     * @throws NullPointerException if kdfContext is null","public static Blake3 initKeyDerivationFunction(final byte[] kdfContext) {
    Objects.requireNonNull(kdfContext);
    final EngineState kdf = new EngineState(IV, DERIVE_KEY_CONTEXT);
    kdf.inputData(kdfContext, 0, kdfContext.length);
    final byte[] key = new byte[KEY_LEN];
    kdf.outputHash(key, 0, key.length);
    return new Blake3(unpackInts(key, KEY_INTS), DERIVE_KEY_MATERIAL);
}","Blake3","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.initKeyDerivationFunction(byte[]).kdfContext","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.initKeyDerivationFunction(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.initKeyedHash(byte[])","Method","* Constructs a fresh Blake3 keyed hash function. The instance returned functions as a pseudorandom function (PRF) or as a
     * message authentication code (MAC).
     *
     * @param key 32-byte secret key
     * @return fresh Blake3 instance in keyed mode using the provided key
     * @throws NullPointerException     if key is null
     * @throws IllegalArgumentException if key is not 32 bytes","public static Blake3 initKeyedHash(final byte[] key) {
    Objects.requireNonNull(key);
    if (key.length != KEY_LEN) {
        throw new IllegalArgumentException(""Blake3 keys must be 32 bytes"");
    }
    return new Blake3(unpackInts(key, KEY_INTS), KEYED_HASH);
}","Blake3","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.initKeyedHash(byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.initKeyedHash(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.keyedHash(byte[],byte[])","Method","* Calculates the Blake3 keyed hash (MAC) of the provided data.
     *
     * @param key  32-byte secret key
     * @param data source array to absorb data from
     * @return 32-byte mac squeezed from the provided data
     * @throws NullPointerException if key or data are null","public static byte[] keyedHash(final byte[] key, final byte[] data) {
    return Blake3.initKeyedHash(key).update(data).doFinalize(OUT_LEN);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.keyedHash(byte[],byte[]).key","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.keyedHash(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.keyedHash(byte[],byte[]).data","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.keyedHash(byte[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.packInt(int,byte[],int,int)","Method","No Comment","private static void packInt(final int value, final byte[] dst, final int off, final int len) {
    for (int i = 0; i < len; i++) {
        dst[off + i] = (byte) (value >>> i * Byte.SIZE);
    }
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.packInt(int,byte[],int,int).value","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.packInt(int,byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.packInt(int,byte[],int,int).dst","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.packInt(int,byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.packInt(int,byte[],int,int).off","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.packInt(int,byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.packInt(int,byte[],int,int).len","Parameter_4","Belong to org.apache.commons.codec.digest.Blake3.packInt(int,byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentChainingValue(int[],int[],int[],int)","Method","No Comment","private static int[] parentChainingValue(final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {
    return parentOutput(leftChildCV, rightChildCV, key, flags).chainingValue();
}","int[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentChainingValue(int[],int[],int[],int).leftChildCV","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.parentChainingValue(int[],int[],int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentChainingValue(int[],int[],int[],int).rightChildCV","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.parentChainingValue(int[],int[],int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentChainingValue(int[],int[],int[],int).key","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.parentChainingValue(int[],int[],int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentChainingValue(int[],int[],int[],int).flags","Parameter_4","Belong to org.apache.commons.codec.digest.Blake3.parentChainingValue(int[],int[],int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentOutput(int[],int[],int[],int)","Method","No Comment","private static Output parentOutput(final int[] leftChildCV, final int[] rightChildCV, final int[] key, final int flags) {
    final int[] blockWords = Arrays.copyOf(leftChildCV, BLOCK_INTS);
    System.arraycopy(rightChildCV, 0, blockWords, 8, CHAINING_VALUE_INTS);
    return new Output(key.clone(), blockWords, 0, BLOCK_LEN, flags | PARENT);
}","Output","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentOutput(int[],int[],int[],int).leftChildCV","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.parentOutput(int[],int[],int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentOutput(int[],int[],int[],int).rightChildCV","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.parentOutput(int[],int[],int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentOutput(int[],int[],int[],int).key","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.parentOutput(int[],int[],int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.parentOutput(int[],int[],int[],int).flags","Parameter_4","Belong to org.apache.commons.codec.digest.Blake3.parentOutput(int[],int[],int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.round(int[],int[],byte[])","Method","No Comment","private static void round(final int[] state, final int[] msg, final byte[] schedule) {
    // Mix the columns.
    g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);
    g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);
    g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);
    g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);
    // Mix the diagonals.
    g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);
    g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);
    g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);
    g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.round(int[],int[],byte[]).state","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.round(int[],int[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.round(int[],int[],byte[]).msg","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.round(int[],int[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.round(int[],int[],byte[]).schedule","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.round(int[],int[],byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.unpackInt(byte[],int)","Method","No Comment","private static int unpackInt(final byte[] buf, final int off) {
    return buf[off] & 0xFF | (buf[off + 1] & 0xFF) << 8 | (buf[off + 2] & 0xFF) << 16 | (buf[off + 3] & 0xFF) << 24;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.unpackInt(byte[],int).buf","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.unpackInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.unpackInt(byte[],int).off","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.unpackInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.unpackInts(byte[],int)","Method","No Comment","private static int[] unpackInts(final byte[] buf, final int nrInts) {
    final int[] values = new int[nrInts];
    for (int i = 0, off = 0; i < nrInts; i++, off += Integer.BYTES) {
        values[i] = unpackInt(buf, off);
    }
    return values;
}","int[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.unpackInts(byte[],int).buf","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.unpackInts(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.unpackInts(byte[],int).nrInts","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.unpackInts(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.doFinalize(byte[])","Method","* Finalizes hash output data that depends on the sequence of updated bytes preceding this invocation and any
     * previously finalized bytes. Note that this can finalize up to 2<sup>64</sup> bytes per instance.
     *
     * @param out destination array to finalize bytes into
     * @return {@code this} instance.
     * @throws NullPointerException if out is null","public Blake3 doFinalize(final byte[] out) {
    return doFinalize(out, 0, out.length);
}","Blake3","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.doFinalize(byte[]).out","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.doFinalize(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.doFinalize(byte[],int,int)","Method","* Finalizes an arbitrary number of bytes into the provided output array that depends on the sequence of previously
     * updated and finalized bytes. Note that this can finalize up to 2<sup>64</sup> bytes per instance.
     *
     * @param out    destination array to finalize bytes into
     * @param offset where in the array to begin writing bytes to
     * @param length number of bytes to finalize
     * @return {@code this} instance.
     * @throws NullPointerException      if out is null
     * @throws IndexOutOfBoundsException if offset or length are negative or if offset + length is greater than the
     *                                   length of the provided array","public Blake3 doFinalize(final byte[] out, final int offset, final int length) {
    checkBufferArgs(out, offset, length);
    engineState.outputHash(out, offset, length);
    return this;
}","Blake3","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.doFinalize(byte[],int,int).out","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.doFinalize(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.doFinalize(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.doFinalize(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.doFinalize(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.doFinalize(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.doFinalize(int)","Method","* Squeezes and returns an arbitrary number of bytes dependent on the sequence of previously absorbed and squeezed bytes.
     *
     * @param nrBytes number of bytes to finalize
     * @return requested number of finalized bytes
     * @throws IllegalArgumentException if nrBytes is negative","public byte[] doFinalize(final int nrBytes) {
    if (nrBytes < 0) {
        throw new IllegalArgumentException(""Requested bytes must be non-negative"");
    }
    final byte[] hash = new byte[nrBytes];
    doFinalize(hash);
    return hash;
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.doFinalize(int).nrBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.doFinalize(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.reset()","Method","* Resets this instance back to its initial state when it was first constructed.
     * @return {@code this} instance.","public Blake3 reset() {
    engineState.reset();
    return this;
}","Blake3","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.update(byte[])","Method","* Updates this hash state using the provided bytes.
     *
     * @param in source array to update data from
     * @return {@code this} instance.
     * @throws NullPointerException if in is null","public Blake3 update(final byte[] in) {
    return update(in, 0, in.length);
}","Blake3","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.update(byte[]).in","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.update(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.update(byte[],int,int)","Method","* Updates this hash state using the provided bytes at an offset.
     *
     * @param in     source array to update data from
     * @param offset where in the array to begin reading bytes
     * @param length number of bytes to update
     * @return {@code this} instance.
     * @throws NullPointerException      if in is null
     * @throws IndexOutOfBoundsException if offset or length are negative or if offset + length is greater than the
     *                                   length of the provided array","public Blake3 update(final byte[] in, final int offset, final int length) {
    checkBufferArgs(in, offset, length);
    engineState.inputData(in, offset, length);
    return this;
}","Blake3","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.update(byte[],int,int).in","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.update(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.update(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.<init>(int[],int)","Constructor","No Comment","private Blake3(final int[] key, final int flags) {
    engineState = new EngineState(key, flags);
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.<init>(int[],int).key","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.<init>(int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.<init>(int[],int).flags","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.<init>(int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState","Class","No Comment","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.digest.Blake3$ChunkState.chainingValue","Field","No Comment","private int[] chainingValue;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.chunkCounter","Field","No Comment","private final long chunkCounter;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.flags","Field","No Comment","private final int flags;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.block","Field","No Comment","private final byte[] block = new byte[BLOCK_LEN];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.blockLength","Field","No Comment","private int blockLength;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.blocksCompressed","Field","No Comment","private int blocksCompressed;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.length()","Method","No Comment","private int length() {
    return BLOCK_LEN * blocksCompressed + blockLength;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.output()","Method","No Comment","private Output output() {
    final int[] blockWords = unpackInts(block, BLOCK_INTS);
    final int outputFlags = flags | startFlag() | CHUNK_END;
    return new Output(chainingValue, blockWords, chunkCounter, blockLength, outputFlags);
}","Output","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.startFlag()","Method","No Comment","private int startFlag() {
    return blocksCompressed == 0 ? CHUNK_START : 0;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.update(byte[],int,int)","Method","No Comment","private void update(final byte[] input, int offset, int length) {
    while (length > 0) {
        if (blockLength == BLOCK_LEN) {
            // If the block buffer is full, compress it and clear it. More
            // input is coming, so this compression is not CHUNK_END.
            final int[] blockWords = unpackInts(block, BLOCK_INTS);
            chainingValue = Arrays.copyOf(compress(chainingValue, blockWords, BLOCK_LEN, chunkCounter, flags | startFlag()), CHAINING_VALUE_INTS);
            blocksCompressed++;
            blockLength = 0;
            Arrays.fill(block, (byte) 0);
        }
        final int want = BLOCK_LEN - blockLength;
        final int take = Math.min(want, length);
        System.arraycopy(input, offset, block, blockLength, take);
        blockLength += take;
        offset += take;
        length -= take;
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.update(byte[],int,int).input","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3$ChunkState.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.update(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3$ChunkState.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.update(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3$ChunkState.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.<init>(int[],long,int)","Constructor","No Comment","private ChunkState(final int[] key, final long chunkCounter, final int flags) {
    chainingValue = key;
    this.chunkCounter = chunkCounter;
    this.flags = flags;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.<init>(int[],long,int).key","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3$ChunkState.<init>(int[],long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.<init>(int[],long,int).chunkCounter","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3$ChunkState.<init>(int[],long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$ChunkState.<init>(int[],long,int).flags","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3$ChunkState.<init>(int[],long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState","Class","No Comment","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.digest.Blake3$EngineState.key","Field","No Comment","private final int[] key;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.flags","Field","No Comment","private final int flags;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.cvStack","Field","be much lower.","private final int[][] cvStack = new int[54][];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.stackLen","Field","No Comment","private int stackLen;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.state","Field","No Comment","private ChunkState state;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.addChunkCV(int[],long)","Method","Section 5.1.2 of the BLAKE3 spec explains this algorithm in more detail.","private void addChunkCV(final int[] firstCV, final long totalChunks) {
    // This chunk might complete some subtrees. For each completed subtree,
    // its left child will be the current top entry in the CV stack, and
    // its right child will be the current value of `newCV`. Pop each left
    // child off the stack, merge it with `newCV`, and overwrite `newCV`
    // with the result. After all these merges, push the final value of
    // `newCV` onto the stack. The number of completed subtrees is given
    // by the number of trailing 0-bits in the new total number of chunks.
    int[] newCV = firstCV;
    long chunkCounter = totalChunks;
    while ((chunkCounter & 1) == 0) {
        newCV = parentChainingValue(popCV(), newCV, key, flags);
        chunkCounter >>= 1;
    }
    pushCV(newCV);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.addChunkCV(int[],long).firstCV","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3$EngineState.addChunkCV(int[],long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.addChunkCV(int[],long).totalChunks","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3$EngineState.addChunkCV(int[],long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.inputData(byte[],int,int)","Method","No Comment","private void inputData(final byte[] in, int offset, int length) {
    while (length > 0) {
        // If the current chunk is complete, finalize it and reset the
        // chunk state. More input is coming, so this chunk is not ROOT.
        if (state.length() == CHUNK_LEN) {
            final int[] chunkCV = state.output().chainingValue();
            final long totalChunks = state.chunkCounter + 1;
            addChunkCV(chunkCV, totalChunks);
            state = new ChunkState(key, totalChunks, flags);
        }
        // Compress input bytes into the current chunk state.
        final int want = CHUNK_LEN - state.length();
        final int take = Math.min(want, length);
        state.update(in, offset, take);
        offset += take;
        length -= take;
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.inputData(byte[],int,int).in","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3$EngineState.inputData(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.inputData(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3$EngineState.inputData(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.inputData(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3$EngineState.inputData(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.outputHash(byte[],int,int)","Method","No Comment","private void outputHash(final byte[] out, final int offset, final int length) {
    // Starting with the Output from the current chunk, compute all the
    // parent chaining values along the right edge of the tree, until we
    // have the root Output.
    Output output = state.output();
    int parentNodesRemaining = stackLen;
    while (parentNodesRemaining-- > 0) {
        final int[] parentCV = cvStack[parentNodesRemaining];
        output = parentOutput(parentCV, output.chainingValue(), key, flags);
    }
    output.rootOutputBytes(out, offset, length);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.outputHash(byte[],int,int).out","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3$EngineState.outputHash(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.outputHash(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3$EngineState.outputHash(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.outputHash(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3$EngineState.outputHash(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.popCV()","Method","No Comment","private int[] popCV() {
    return cvStack[--stackLen];
}","int[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.pushCV(int[])","Method","No Comment","private void pushCV(final int[] cv) {
    cvStack[stackLen++] = cv;
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.pushCV(int[]).cv","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3$EngineState.pushCV(int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.reset()","Method","No Comment","private void reset() {
    stackLen = 0;
    Arrays.fill(cvStack, null);
    state = new ChunkState(key, 0, flags);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.<init>(int[],int)","Constructor","No Comment","private EngineState(final int[] key, final int flags) {
    this.key = key;
    this.flags = flags;
    state = new ChunkState(key, 0, flags);
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.<init>(int[],int).key","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3$EngineState.<init>(int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$EngineState.<init>(int[],int).flags","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3$EngineState.<init>(int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output","Class","* Represents the state just prior to either producing an eight word chaining value or any number of output bytes
     * when the ROOT flag is set.","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.digest.Blake3$Output.inputChainingValue","Field","No Comment","private final int[] inputChainingValue;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.blockWords","Field","No Comment","private final int[] blockWords;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.counter","Field","No Comment","private final long counter;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.blockLength","Field","No Comment","private final int blockLength;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.flags","Field","No Comment","private final int flags;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.chainingValue()","Method","No Comment","private int[] chainingValue() {
    return Arrays.copyOf(compress(inputChainingValue, blockWords, blockLength, counter, flags), CHAINING_VALUE_INTS);
}","int[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.rootOutputBytes(byte[],int,int)","Method","No Comment","private void rootOutputBytes(final byte[] out, int offset, int length) {
    int outputBlockCounter = 0;
    while (length > 0) {
        int chunkLength = Math.min(OUT_LEN * 2, length);
        length -= chunkLength;
        final int[] words = compress(inputChainingValue, blockWords, blockLength, outputBlockCounter++, flags | ROOT);
        int wordCounter = 0;
        while (chunkLength > 0) {
            final int wordLength = Math.min(Integer.BYTES, chunkLength);
            packInt(words[wordCounter++], out, offset, wordLength);
            offset += wordLength;
            chunkLength -= wordLength;
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.rootOutputBytes(byte[],int,int).out","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3$Output.rootOutputBytes(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.rootOutputBytes(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3$Output.rootOutputBytes(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.rootOutputBytes(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3$Output.rootOutputBytes(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int)","Constructor","No Comment","private Output(final int[] inputChainingValue, final int[] blockWords, final long counter, final int blockLength, final int flags) {
    this.inputChainingValue = inputChainingValue;
    this.blockWords = blockWords;
    this.counter = counter;
    this.blockLength = blockLength;
    this.flags = flags;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int).inputChainingValue","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int).blockWords","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int).counter","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int).blockLength","Parameter_4","Belong to org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int).flags","Parameter_5","Belong to org.apache.commons.codec.digest.Blake3$Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState","Class","No Comment","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.digest.Blake3.ChunkState.chainingValue","Field","No Comment","private int[] chainingValue;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.chunkCounter","Field","No Comment","private final long chunkCounter;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.flags","Field","No Comment","private final int flags;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.block","Field","No Comment","private final byte[] block = new byte[BLOCK_LEN];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.blockLength","Field","No Comment","private int blockLength;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.blocksCompressed","Field","No Comment","private int blocksCompressed;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.length()","Method","No Comment","private int length() {
    return BLOCK_LEN * blocksCompressed + blockLength;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.output()","Method","No Comment","private Output output() {
    final int[] blockWords = unpackInts(block, BLOCK_INTS);
    final int outputFlags = flags | startFlag() | CHUNK_END;
    return new Output(chainingValue, blockWords, chunkCounter, blockLength, outputFlags);
}","Output","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.startFlag()","Method","No Comment","private int startFlag() {
    return blocksCompressed == 0 ? CHUNK_START : 0;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.update(byte[],int,int)","Method","No Comment","private void update(final byte[] input, int offset, int length) {
    while (length > 0) {
        if (blockLength == BLOCK_LEN) {
            // If the block buffer is full, compress it and clear it. More
            // input is coming, so this compression is not CHUNK_END.
            final int[] blockWords = unpackInts(block, BLOCK_INTS);
            chainingValue = Arrays.copyOf(compress(chainingValue, blockWords, BLOCK_LEN, chunkCounter, flags | startFlag()), CHAINING_VALUE_INTS);
            blocksCompressed++;
            blockLength = 0;
            Arrays.fill(block, (byte) 0);
        }
        final int want = BLOCK_LEN - blockLength;
        final int take = Math.min(want, length);
        System.arraycopy(input, offset, block, blockLength, take);
        blockLength += take;
        offset += take;
        length -= take;
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.update(byte[],int,int).input","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.ChunkState.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.update(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.ChunkState.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.update(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.ChunkState.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.<init>(int[],long,int)","Constructor","No Comment","private ChunkState(final int[] key, final long chunkCounter, final int flags) {
    chainingValue = key;
    this.chunkCounter = chunkCounter;
    this.flags = flags;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.<init>(int[],long,int).key","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.ChunkState.<init>(int[],long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.<init>(int[],long,int).chunkCounter","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.ChunkState.<init>(int[],long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.ChunkState.<init>(int[],long,int).flags","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.ChunkState.<init>(int[],long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState","Class","No Comment","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.digest.Blake3.EngineState.key","Field","No Comment","private final int[] key;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.flags","Field","No Comment","private final int flags;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.cvStack","Field","be much lower.","private final int[][] cvStack = new int[54][];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.stackLen","Field","No Comment","private int stackLen;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.state","Field","No Comment","private ChunkState state;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.addChunkCV(int[],long)","Method","Section 5.1.2 of the BLAKE3 spec explains this algorithm in more detail.","private void addChunkCV(final int[] firstCV, final long totalChunks) {
    // This chunk might complete some subtrees. For each completed subtree,
    // its left child will be the current top entry in the CV stack, and
    // its right child will be the current value of `newCV`. Pop each left
    // child off the stack, merge it with `newCV`, and overwrite `newCV`
    // with the result. After all these merges, push the final value of
    // `newCV` onto the stack. The number of completed subtrees is given
    // by the number of trailing 0-bits in the new total number of chunks.
    int[] newCV = firstCV;
    long chunkCounter = totalChunks;
    while ((chunkCounter & 1) == 0) {
        newCV = parentChainingValue(popCV(), newCV, key, flags);
        chunkCounter >>= 1;
    }
    pushCV(newCV);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.addChunkCV(int[],long).firstCV","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.EngineState.addChunkCV(int[],long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.addChunkCV(int[],long).totalChunks","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.EngineState.addChunkCV(int[],long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.inputData(byte[],int,int)","Method","No Comment","private void inputData(final byte[] in, int offset, int length) {
    while (length > 0) {
        // If the current chunk is complete, finalize it and reset the
        // chunk state. More input is coming, so this chunk is not ROOT.
        if (state.length() == CHUNK_LEN) {
            final int[] chunkCV = state.output().chainingValue();
            final long totalChunks = state.chunkCounter + 1;
            addChunkCV(chunkCV, totalChunks);
            state = new ChunkState(key, totalChunks, flags);
        }
        // Compress input bytes into the current chunk state.
        final int want = CHUNK_LEN - state.length();
        final int take = Math.min(want, length);
        state.update(in, offset, take);
        offset += take;
        length -= take;
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.inputData(byte[],int,int).in","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.EngineState.inputData(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.inputData(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.EngineState.inputData(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.inputData(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.EngineState.inputData(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.outputHash(byte[],int,int)","Method","No Comment","private void outputHash(final byte[] out, final int offset, final int length) {
    // Starting with the Output from the current chunk, compute all the
    // parent chaining values along the right edge of the tree, until we
    // have the root Output.
    Output output = state.output();
    int parentNodesRemaining = stackLen;
    while (parentNodesRemaining-- > 0) {
        final int[] parentCV = cvStack[parentNodesRemaining];
        output = parentOutput(parentCV, output.chainingValue(), key, flags);
    }
    output.rootOutputBytes(out, offset, length);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.outputHash(byte[],int,int).out","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.EngineState.outputHash(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.outputHash(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.EngineState.outputHash(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.outputHash(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.EngineState.outputHash(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.popCV()","Method","No Comment","private int[] popCV() {
    return cvStack[--stackLen];
}","int[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.pushCV(int[])","Method","No Comment","private void pushCV(final int[] cv) {
    cvStack[stackLen++] = cv;
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.pushCV(int[]).cv","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.EngineState.pushCV(int[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.reset()","Method","No Comment","private void reset() {
    stackLen = 0;
    Arrays.fill(cvStack, null);
    state = new ChunkState(key, 0, flags);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.<init>(int[],int)","Constructor","No Comment","private EngineState(final int[] key, final int flags) {
    this.key = key;
    this.flags = flags;
    state = new ChunkState(key, 0, flags);
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.<init>(int[],int).key","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.EngineState.<init>(int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.EngineState.<init>(int[],int).flags","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.EngineState.<init>(int[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output","Class","* Represents the state just prior to either producing an eight word chaining value or any number of output bytes
     * when the ROOT flag is set.","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.digest.Blake3.Output.inputChainingValue","Field","No Comment","private final int[] inputChainingValue;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.blockWords","Field","No Comment","private final int[] blockWords;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.counter","Field","No Comment","private final long counter;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.blockLength","Field","No Comment","private final int blockLength;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.flags","Field","No Comment","private final int flags;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.chainingValue()","Method","No Comment","private int[] chainingValue() {
    return Arrays.copyOf(compress(inputChainingValue, blockWords, blockLength, counter, flags), CHAINING_VALUE_INTS);
}","int[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.rootOutputBytes(byte[],int,int)","Method","No Comment","private void rootOutputBytes(final byte[] out, int offset, int length) {
    int outputBlockCounter = 0;
    while (length > 0) {
        int chunkLength = Math.min(OUT_LEN * 2, length);
        length -= chunkLength;
        final int[] words = compress(inputChainingValue, blockWords, blockLength, outputBlockCounter++, flags | ROOT);
        int wordCounter = 0;
        while (chunkLength > 0) {
            final int wordLength = Math.min(Integer.BYTES, chunkLength);
            packInt(words[wordCounter++], out, offset, wordLength);
            offset += wordLength;
            chunkLength -= wordLength;
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.rootOutputBytes(byte[],int,int).out","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.Output.rootOutputBytes(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.rootOutputBytes(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.Output.rootOutputBytes(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.rootOutputBytes(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.Output.rootOutputBytes(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int)","Constructor","No Comment","private Output(final int[] inputChainingValue, final int[] blockWords, final long counter, final int blockLength, final int flags) {
    this.inputChainingValue = inputChainingValue;
    this.blockWords = blockWords;
    this.counter = counter;
    this.blockLength = blockLength;
    this.flags = flags;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int).inputChainingValue","Parameter_1","Belong to org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int).blockWords","Parameter_2","Belong to org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int).counter","Parameter_3","Belong to org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int).blockLength","Parameter_4","Belong to org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int).flags","Parameter_5","Belong to org.apache.commons.codec.digest.Blake3.Output.<init>(int[],int[],long,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms","Class","* Standard {@link MessageDigest} algorithm names from the <cite>Java Cryptography Architecture Standard Algorithm Name
 * Documentation</cite>.
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 * <ul>
 * <li>Java 8 and up: SHA-224.</li>
 * <li>Java 9 and up: SHA3-224, SHA3-256, SHA3-384, SHA3-512.</li>
 * </ul>
 *
 * @see <a href=""https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest"">
 *      Java 8 Cryptography Architecture Standard Algorithm Name Documentation</a>
 * @see <a href=""https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#messagedigest-algorithms"">
 *      Java 11 Cryptography Architecture Standard Algorithm Name Documentation</a>
 * @see <a href=""https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#messagedigest-algorithms"">
 *      Java 17 Cryptography Architecture Standard Algorithm Name Documentation</a>
 * @see <a href=""https://docs.oracle.com/en/java/javase/21/docs/specs/security/standard-names.html#messagedigest-algorithms"">
 *      Java 21 Cryptography Architecture Standard Algorithm Name Documentation</a>
 *
 * @see <a href=""https://dx.doi.org/10.6028/NIST.FIPS.180-4"">FIPS PUB 180-4</a>
 * @see <a href=""https://dx.doi.org/10.6028/NIST.FIPS.202"">FIPS PUB 202</a>
 * @since 1.7","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.digest.MessageDigestAlgorithms.MD2","Field","* The MD2 message digest algorithm defined in RFC 1319.","public static final String MD2 = ""MD2"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.MD5","Field","* The MD5 message digest algorithm defined in RFC 1321.","public static final String MD5 = ""MD5"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_1","Field","* The SHA-1 hash algorithm defined in the FIPS PUB 180-2.","public static final String SHA_1 = ""SHA-1"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224","Field","* The SHA-224 hash algorithm defined in the FIPS PUB 180-3.
     * <p>
     * Present in Oracle Java 8.
     * </p>
     *
     * @since 1.11","public static final String SHA_224 = ""SHA-224"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_256","Field","* The SHA-256 hash algorithm defined in the FIPS PUB 180-2.","public static final String SHA_256 = ""SHA-256"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_384","Field","* The SHA-384 hash algorithm defined in the FIPS PUB 180-2.","public static final String SHA_384 = ""SHA-384"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_512","Field","* The SHA-512 hash algorithm defined in the FIPS PUB 180-2.","public static final String SHA_512 = ""SHA-512"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_512_224","Field","* The SHA-512 hash algorithm defined in the FIPS PUB 180-4.
     * <p>
     * Included starting in Oracle Java 9.
     * </p>
     *
     * @since 1.14","public static final String SHA_512_224 = ""SHA-512/224"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_512_256","Field","* The SHA-512 hash algorithm defined in the FIPS PUB 180-4.
     * <p>
     * Included starting in Oracle Java 9.
     * </p>
     *
     * @since 1.14","public static final String SHA_512_256 = ""SHA-512/256"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA3_224","Field","* The SHA3-224 hash algorithm defined in the FIPS PUB 202.
     * <p>
     * Included starting in Oracle Java 9.
     * </p>
     *
     * @since 1.11","public static final String SHA3_224 = ""SHA3-224"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA3_256","Field","* The SHA3-256 hash algorithm defined in the FIPS PUB 202.
     * <p>
     * Included starting in Oracle Java 9.
     * </p>
     *
     * @since 1.11","public static final String SHA3_256 = ""SHA3-256"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA3_384","Field","* The SHA3-384 hash algorithm defined in the FIPS PUB 202.
     * <p>
     * Included starting in Oracle Java 9.
     * </p>
     *
     * @since 1.11","public static final String SHA3_384 = ""SHA3-384"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA3_512","Field","* The SHA3-512 hash algorithm defined in the FIPS PUB 202.
     * <p>
     * Included starting in Oracle Java 9.
     * </p>
     *
     * @since 1.11","public static final String SHA3_512 = ""SHA3-512"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.values()","Method","* Gets all constant values defined in this class.
     *
     * @return all constant values defined in this class.
     * @since 1.11","public static String[] values() {
    // Do not use a constant array here as that can be changed externally by accident or design
    return new String[] { MD2, MD5, SHA_1, SHA_224, SHA_256, SHA_384, SHA_512, SHA_512_224, SHA_512_256, SHA3_224, SHA3_256, SHA3_384, SHA3_512 };
}","String[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MessageDigestAlgorithms.<init>()","Constructor","No Comment","private MessageDigestAlgorithms() {
    // cannot be instantiated.
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3","Class","* Implements the MurmurHash3 32-bit and 128-bit hash functions.
 *
 * <p>
 * MurmurHash is a non-cryptographic hash function suitable for general hash-based lookup. The name comes from two basic
 * operations, multiply (MU) and rotate (R), used in its inner loop. Unlike cryptographic hash functions, it is not
 * specifically designed to be difficult to reverse by an adversary, making it unsuitable for cryptographic purposes.
 * </p>
 *
 * <p>
 * This contains a Java port of the 32-bit hash function {@code MurmurHash3_x86_32} and the 128-bit hash function
 * {@code MurmurHash3_x64_128} from Austin Appleby's original {@code c++} code in SMHasher.
 * </p>
 *
 * <p>
 * This is public domain code with no copyrights. From home page of
 * <a href=""https://github.com/aappleby/smhasher"">SMHasher</a>:
 * </p>
 *
 * <blockquote> ""All MurmurHash versions are public domain software, and the author disclaims all copyright to their
 * code."" </blockquote>
 *
 * <p>
 * Original adaption from Apache Hive. That adaption contains a {@code hash64} method that is not part of the original
 * MurmurHash3 code. It is not recommended to use these methods. They will be removed in a future release. To obtain a
 * 64-bit hash use half of the bits from the {@code hash128x64} methods using the input data converted to bytes.
 * </p>
 *
 * @see <a href=""https://en.wikipedia.org/wiki/MurmurHash"">MurmurHash</a>
 * @see <a href=""https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp""> Original MurmurHash3 c++
 *      code</a>
 * @see <a href=
 *      ""https://github.com/apache/hive/blob/master/storage-api/src/java/org/apache/hive/common/util/Murmur3.java"">
 *      Apache Hive Murmer3</a>
 * @since 1.13","Class do not obtain Source Code","No return type","public , final ","",""
"org.apache.commons.codec.digest.MurmurHash3.NULL_HASHCODE","Field","* A random number to use for a hash code.
     *
     * @deprecated This is not used internally and will be removed in a future release.","@Deprecated
public static final long NULL_HASHCODE = 2862933555777941757L;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.DEFAULT_SEED","Field","* A default seed to use for the murmur hash algorithm.
     * Has the value {@code 104729}.","public static final int DEFAULT_SEED = 104729;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.C1_32","Field","Constants for 32-bit variant","private static final int C1_32 = 0xcc9e2d51;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.C2_32","Field","No Comment","private static final int C2_32 = 0x1b873593;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.R1_32","Field","No Comment","private static final int R1_32 = 15;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.R2_32","Field","No Comment","private static final int R2_32 = 13;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.M_32","Field","No Comment","private static final int M_32 = 5;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.N_32","Field","No Comment","private static final int N_32 = 0xe6546b64;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.C1","Field","Constants for 128-bit variant","private static final long C1 = 0x87c37b91114253d5L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.C2","Field","No Comment","private static final long C2 = 0x4cf5ad432745937fL;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.R1","Field","No Comment","private static final int R1 = 31;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.R2","Field","No Comment","private static final int R2 = 27;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.R3","Field","No Comment","private static final int R3 = 33;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.M","Field","No Comment","private static final int M = 5;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.N1","Field","No Comment","private static final int N1 = 0x52dce729;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.N2","Field","No Comment","private static final int N2 = 0x38495ab5;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.fmix32(int)","Method","* Performs the final avalanche mix step of the 32-bit hash function {@code MurmurHash3_x86_32}.
     *
     * @param hash The current hash
     * @return The final hash","private static int fmix32(int hash) {
    hash ^= hash >>> 16;
    hash *= 0x85ebca6b;
    hash ^= hash >>> 13;
    hash *= 0xc2b2ae35;
    hash ^= hash >>> 16;
    return hash;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.fmix32(int).hash","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.fmix32(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.fmix64(long)","Method","* Performs the final avalanche mix step of the 64-bit hash function {@code MurmurHash3_x64_128}.
     *
     * @param hash The current hash
     * @return The final hash","private static long fmix64(long hash) {
    hash ^= hash >>> 33;
    hash *= 0xff51afd7ed558ccdL;
    hash ^= hash >>> 33;
    hash *= 0xc4ceb9fe1a85ec53L;
    hash ^= hash >>> 33;
    return hash;
}","long","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.fmix64(long).hash","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.fmix64(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.getLittleEndianInt(byte[],int)","Method","* Gets the little-endian int from 4 bytes starting at the specified index.
     *
     * @param data The data
     * @param index The index
     * @return The little-endian int","private static int getLittleEndianInt(final byte[] data, final int index) {
    return data[index] & 0xff | (data[index + 1] & 0xff) << 8 | (data[index + 2] & 0xff) << 16 | (data[index + 3] & 0xff) << 24;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.getLittleEndianInt(byte[],int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.getLittleEndianInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.getLittleEndianInt(byte[],int).index","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.getLittleEndianInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.getLittleEndianLong(byte[],int)","Method","* Gets the little-endian long from 8 bytes starting at the specified index.
     *
     * @param data The data
     * @param index The index
     * @return The little-endian long","private static long getLittleEndianLong(final byte[] data, final int index) {
    return (long) data[index] & 0xff | ((long) data[index + 1] & 0xff) << 8 | ((long) data[index + 2] & 0xff) << 16 | ((long) data[index + 3] & 0xff) << 24 | ((long) data[index + 4] & 0xff) << 32 | ((long) data[index + 5] & 0xff) << 40 | ((long) data[index + 6] & 0xff) << 48 | ((long) data[index + 7] & 0xff) << 56;
}","long","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.getLittleEndianLong(byte[],int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.getLittleEndianLong(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.getLittleEndianLong(byte[],int).index","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.getLittleEndianLong(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128(byte[])","Method","* Generates 128-bit hash from the byte array with a default seed.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash128(data, offset, data.length, seed);
     * </pre>
     *
     * <p>Note: The sign extension bug in {@link #hash128(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.</p>
     *
     * @param data The input byte array
     * @return The 128-bit hash (2 longs)
     * @see #hash128(byte[], int, int, int)","public static long[] hash128(final byte[] data) {
    return hash128(data, 0, data.length, DEFAULT_SEED);
}","long[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128(byte[],int,int,int)","Method","* Generates 128-bit hash from the byte array with the given offset, length and seed.
     *
     * <p>This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}
     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>
     *
     * <p>This implementation contains a sign-extension bug in the seed initialization.
     * This manifests if the seed is negative.</p>
     *
     * @param data The input byte array
     * @param offset The first element of array
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 128-bit hash (2 longs)
     * @deprecated Use {@link #hash128x64(byte[], int, int, int)}. This corrects the seed initialization.","@Deprecated
public static long[] hash128(final byte[] data, final int offset, final int length, final int seed) {
    // ************
    // Note: This deliberately fails to apply masking using 0xffffffffL to the seed
    // to maintain behavioral compatibility with the original version.
    // The implicit conversion to a long will extend a negative sign
    // bit through the upper 32-bits of the long seed. These should be zero.
    // ************
    return hash128x64Internal(data, offset, length, seed);
}","long[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128(byte[],int,int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128(byte[],int,int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128(byte[],int,int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128(byte[],int,int,int).seed","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128(String)","Method","* Generates 128-bit hash from a string with a default seed.
     * <p>
     * Before 1.14 the string was converted using default encoding.
     * Since 1.14 the string is converted to bytes using UTF-8 encoding.
     * </p>
     * <p>
     * This is a helper method that will produce the same result as:
     * </p>
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);
     * int hash = MurmurHash3.hash128(bytes, offset, bytes.length, seed);
     * </pre>
     *
     * <p>Note: The sign extension bug in {@link #hash128(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.</p>
     *
     * @param data The input String
     * @return The 128-bit hash (2 longs)
     * @see #hash128(byte[], int, int, int)
     * @deprecated Use {@link #hash128x64(byte[])} using the bytes returned from
     * {@link String#getBytes(java.nio.charset.Charset)}.","@Deprecated
public static long[] hash128(final String data) {
    final byte[] bytes = StringUtils.getBytesUtf8(data);
    return hash128(bytes, 0, bytes.length, DEFAULT_SEED);
}","long[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[])","Method","* Generates 128-bit hash from the byte array with a seed of zero.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int seed = 0;
     * int hash = MurmurHash3.hash128x64(data, offset, data.length, seed);
     * </pre>
     *
     * @param data The input byte array
     * @return The 128-bit hash (2 longs)
     * @see #hash128x64(byte[], int, int, int)
     * @since 1.14","public static long[] hash128x64(final byte[] data) {
    return hash128x64(data, 0, data.length, 0);
}","long[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[],int,int,int)","Method","* Generates 128-bit hash from the byte array with the given offset, length and seed.
     *
     * <p>This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}
     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>
     *
     * @param data The input byte array
     * @param offset The first element of array
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 128-bit hash (2 longs)
     * @since 1.14","public static long[] hash128x64(final byte[] data, final int offset, final int length, final int seed) {
    // Use an unsigned 32-bit integer as the seed
    return hash128x64Internal(data, offset, length, seed & 0xffffffffL);
}","long[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[],int,int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[],int,int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[],int,int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[],int,int,int).seed","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[],int,int,long)","Method","* Generates 128-bit hash from the byte array with the given offset, length and seed.
     *
     * <p>This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}
     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>
     *
     * @param data The input byte array
     * @param offset The first element of array
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 128-bit hash (2 longs)","private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {
    long h1 = seed;
    long h2 = seed;
    final int nblocks = length >> 4;
    // body
    for (int i = 0; i < nblocks; i++) {
        final int index = offset + (i << 4);
        long k1 = getLittleEndianLong(data, index);
        long k2 = getLittleEndianLong(data, index + 8);
        // mix functions for k1
        k1 *= C1;
        k1 = Long.rotateLeft(k1, R1);
        k1 *= C2;
        h1 ^= k1;
        h1 = Long.rotateLeft(h1, R2);
        h1 += h2;
        h1 = h1 * M + N1;
        // mix functions for k2
        k2 *= C2;
        k2 = Long.rotateLeft(k2, R3);
        k2 *= C1;
        h2 ^= k2;
        h2 = Long.rotateLeft(h2, R1);
        h2 += h1;
        h2 = h2 * M + N2;
    }
    // tail
    long k1 = 0;
    long k2 = 0;
    final int index = offset + (nblocks << 4);
    switch(offset + length - index) {
        case 15:
            k2 ^= ((long) data[index + 14] & 0xff) << 48;
        // falls-through
        case 14:
            k2 ^= ((long) data[index + 13] & 0xff) << 40;
        // falls-through
        case 13:
            k2 ^= ((long) data[index + 12] & 0xff) << 32;
        // falls-through
        case 12:
            k2 ^= ((long) data[index + 11] & 0xff) << 24;
        // falls-through
        case 11:
            k2 ^= ((long) data[index + 10] & 0xff) << 16;
        // falls-through
        case 10:
            k2 ^= ((long) data[index + 9] & 0xff) << 8;
        // falls-through
        case 9:
            k2 ^= data[index + 8] & 0xff;
            k2 *= C2;
            k2 = Long.rotateLeft(k2, R3);
            k2 *= C1;
            h2 ^= k2;
        // falls-through
        case 8:
            k1 ^= ((long) data[index + 7] & 0xff) << 56;
        // falls-through
        case 7:
            k1 ^= ((long) data[index + 6] & 0xff) << 48;
        // falls-through
        case 6:
            k1 ^= ((long) data[index + 5] & 0xff) << 40;
        // falls-through
        case 5:
            k1 ^= ((long) data[index + 4] & 0xff) << 32;
        // falls-through
        case 4:
            k1 ^= ((long) data[index + 3] & 0xff) << 24;
        // falls-through
        case 3:
            k1 ^= ((long) data[index + 2] & 0xff) << 16;
        // falls-through
        case 2:
            k1 ^= ((long) data[index + 1] & 0xff) << 8;
        // falls-through
        case 1:
            k1 ^= data[index] & 0xff;
            k1 *= C1;
            k1 = Long.rotateLeft(k1, R1);
            k1 *= C2;
            h1 ^= k1;
    }
    // finalization
    h1 ^= length;
    h2 ^= length;
    h1 += h2;
    h2 += h1;
    h1 = fmix64(h1);
    h2 = fmix64(h2);
    h1 += h2;
    h2 += h1;
    return new long[] { h1, h2 };
}","long[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[],int,int,long).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[],int,int,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[],int,int,long).offset","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[],int,int,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[],int,int,long).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[],int,int,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[],int,int,long).seed","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[],int,int,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[])","Method","* Generates 32-bit hash from the byte array with a default seed.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash32(data, offset, data.length, seed);
     * </pre>
     *
     * <p>This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.</p>
     *
     * @param data The input byte array
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int, int)
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.","@Deprecated
public static int hash32(final byte[] data) {
    return hash32(data, 0, data.length, DEFAULT_SEED);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int)","Method","* Generates 32-bit hash from the byte array with the given length and a default seed.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash32(data, offset, length, seed);
     * </pre>
     *
     * <p>This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.</p>
     *
     * @param data The input byte array
     * @param length The length of array
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int, int)
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.","@Deprecated
public static int hash32(final byte[] data, final int length) {
    return hash32(data, length, DEFAULT_SEED);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int).length","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int)","Method","* Generates 32-bit hash from the byte array with the given length and seed. This is a
     * helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int hash = MurmurHash3.hash32(data, offset, length, seed);
     * </pre>
     *
     * <p>This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.</p>
     *
     * @param data The input byte array
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int, int)
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.","@Deprecated
public static int hash32(final byte[] data, final int length, final int seed) {
    return hash32(data, 0, length, seed);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int).length","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int).seed","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int,int)","Method","* Generates 32-bit hash from the byte array with the given offset, length and seed.
     *
     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>
     *
     * <p>This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.</p>
     *
     * @param data The input byte array
     * @param offset The offset of data
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.","@Deprecated
public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
    int hash = seed;
    final int nblocks = length >> 2;
    // body
    for (int i = 0; i < nblocks; i++) {
        final int index = offset + (i << 2);
        final int k = getLittleEndianInt(data, index);
        hash = mix32(k, hash);
    }
    // tail
    // Note: This fails to apply masking using 0xff to the 3 remaining bytes.
    final int index = offset + (nblocks << 2);
    int k1 = 0;
    switch(offset + length - index) {
        case 3:
            k1 ^= data[index + 2] << 16;
        // falls-through
        case 2:
            k1 ^= data[index + 1] << 8;
        // falls-through
        case 1:
            k1 ^= data[index];
            // mix functions
            k1 *= C1_32;
            k1 = Integer.rotateLeft(k1, R1_32);
            k1 *= C2_32;
            hash ^= k1;
    }
    hash ^= length;
    return fmix32(hash);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int,int).seed","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long)","Method","* Generates 32-bit hash from a long with a default seed value.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(8)
     *                                            .putLong(data)
     *                                            .array(), offset, 8, seed);
     * </pre>
     *
     * @param data The long to hash
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)","public static int hash32(final long data) {
    return hash32(data, DEFAULT_SEED);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,int)","Method","* Generates 32-bit hash from a long with the given seed.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(8)
     *                                            .putLong(data)
     *                                            .array(), offset, 8, seed);
     * </pre>
     *
     * @param data The long to hash
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)","public static int hash32(final long data, final int seed) {
    int hash = seed;
    final long r0 = Long.reverseBytes(data);
    hash = mix32((int) r0, hash);
    hash = mix32((int) (r0 >>> 32), hash);
    hash ^= Long.BYTES;
    return fmix32(hash);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,int).seed","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,long)","Method","* Generates 32-bit hash from two longs with a default seed value.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(16)
     *                                            .putLong(data1)
     *                                            .putLong(data2)
     *                                            .array(), offset, 16, seed);
     * </pre>
     *
     * @param data1 The first long to hash
     * @param data2 The second long to hash
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)","public static int hash32(final long data1, final long data2) {
    return hash32(data1, data2, DEFAULT_SEED);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,long).data1","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,long).data2","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(long,long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,long,int)","Method","* Generates 32-bit hash from two longs with the given seed.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(16)
     *                                            .putLong(data1)
     *                                            .putLong(data2)
     *                                            .array(), offset, 16, seed);
     * </pre>
     *
     * @param data1 The first long to hash
     * @param data2 The second long to hash
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)","public static int hash32(final long data1, final long data2, final int seed) {
    int hash = seed;
    final long r0 = Long.reverseBytes(data1);
    final long r1 = Long.reverseBytes(data2);
    hash = mix32((int) r0, hash);
    hash = mix32((int) (r0 >>> 32), hash);
    hash = mix32((int) r1, hash);
    hash = mix32((int) (r1 >>> 32), hash);
    hash ^= Long.BYTES * 2;
    return fmix32(hash);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,long,int).data1","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(long,long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,long,int).data2","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(long,long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(long,long,int).seed","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(long,long,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(String)","Method","* Generates 32-bit hash from a string with a default seed.
     * <p>
     * Before 1.14 the string was converted using default encoding.
     * Since 1.14 the string is converted to bytes using UTF-8 encoding.
     * </p>
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);
     * int hash = MurmurHash3.hash32(bytes, offset, bytes.length, seed);
     * </pre>
     *
     * <p>This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.</p>
     *
     * @param data The input string
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int, int)
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)} with the bytes returned from
     * {@link String#getBytes(java.nio.charset.Charset)}. This corrects the processing of trailing bytes.","@Deprecated
public static int hash32(final String data) {
    final byte[] bytes = StringUtils.getBytesUtf8(data);
    return hash32(bytes, 0, bytes.length, DEFAULT_SEED);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[])","Method","* Generates 32-bit hash from the byte array with a seed of zero.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int offset = 0;
     * int seed = 0;
     * int hash = MurmurHash3.hash32x86(data, offset, data.length, seed);
     * </pre>
     *
     * @param data The input byte array
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)
     * @since 1.14","public static int hash32x86(final byte[] data) {
    return hash32x86(data, 0, data.length, 0);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[],int,int,int)","Method","* Generates 32-bit hash from the byte array with the given offset, length and seed.
     *
     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>
     *
     * @param data The input byte array
     * @param offset The offset of data
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @since 1.14","public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
    int hash = seed;
    final int nblocks = length >> 2;
    // body
    for (int i = 0; i < nblocks; i++) {
        final int index = offset + (i << 2);
        final int k = getLittleEndianInt(data, index);
        hash = mix32(k, hash);
    }
    // tail
    final int index = offset + (nblocks << 2);
    int k1 = 0;
    switch(offset + length - index) {
        case 3:
            k1 ^= (data[index + 2] & 0xff) << 16;
        // falls-through
        case 2:
            // falls-through
            k1 ^= (data[index + 1] & 0xff) << 8;
        // falls-through
        case 1:
            k1 ^= data[index] & 0xff;
            // mix functions
            k1 *= C1_32;
            k1 = Integer.rotateLeft(k1, R1_32);
            k1 *= C2_32;
            hash ^= k1;
    }
    hash ^= length;
    return fmix32(hash);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[],int,int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[],int,int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[],int,int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[],int,int,int).seed","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[])","Method","* Generates 64-bit hash from a byte array with a default seed.
     *
     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>
     *
     * <p>This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data.
     * This method will be removed in a future release.</p>
     *
     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.</p>
     *
     * <p>This is a helper method that will produce the same result as:</p>
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(data, offset, data.length, seed);
     * </pre>
     *
     * @param data The input byte array
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[])}.","@Deprecated
public static long hash64(final byte[] data) {
    return hash64(data, 0, data.length, DEFAULT_SEED);
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int)","Method","* Generates 64-bit hash from a byte array with the given offset and length and a default seed.
     *
     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>
     *
     * <p>This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data.
     * This method will be removed in a future release.</p>
     *
     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.</p>
     *
     * <p>This is a helper method that will produce the same result as:</p>
     *
     * <pre>
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(data, offset, length, seed);
     * </pre>
     *
     * @param data The input byte array
     * @param offset The offset of data
     * @param length The length of array
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[], int, int, int)}.","@Deprecated
public static long hash64(final byte[] data, final int offset, final int length) {
    return hash64(data, offset, length, DEFAULT_SEED);
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int,int)","Method","* Generates 64-bit hash from a byte array with the given offset, length and seed.
     *
     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>
     *
     * <p>This is a Murmur3-like 64-bit variant.
     * This method will be removed in a future release.</p>
     *
     * <p>This implementation contains a sign-extension bug in the seed initialization.
     * This manifests if the seed is negative.</p>
     *
     * <p>This algorithm processes 8 bytes chunks of data in a manner similar to the 16 byte chunks
     * of data processed in the MurmurHash3 {@code MurmurHash3_x64_128} method. However the hash
     * is not mixed with a hash chunk from the next 8 bytes of data. The method will not return
     * the same value as the first or second 64-bits of the function
     * {@link #hash128(byte[], int, int, int)}.</p>
     *
     * <p>Use of this method is not advised. Use the first long returned from
     * {@link #hash128x64(byte[], int, int, int)}.</p>
     *
     * @param data The input byte array
     * @param offset The offset of data
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 64-bit hash
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[], int, int, int)}.","@Deprecated
public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
    // Note: This fails to apply masking using 0xffffffffL to the seed.
    long hash = seed;
    final int nblocks = length >> 3;
    // body
    for (int i = 0; i < nblocks; i++) {
        final int index = offset + (i << 3);
        long k = getLittleEndianLong(data, index);
        // mix functions
        k *= C1;
        k = Long.rotateLeft(k, R1);
        k *= C2;
        hash ^= k;
        hash = Long.rotateLeft(hash, R2) * M + N1;
    }
    // tail
    long k1 = 0;
    final int index = offset + (nblocks << 3);
    switch(offset + length - index) {
        case 7:
            k1 ^= ((long) data[index + 6] & 0xff) << 48;
        // falls-through
        case 6:
            k1 ^= ((long) data[index + 5] & 0xff) << 40;
        // falls-through
        case 5:
            k1 ^= ((long) data[index + 4] & 0xff) << 32;
        // falls-through
        case 4:
            k1 ^= ((long) data[index + 3] & 0xff) << 24;
        // falls-through
        case 3:
            k1 ^= ((long) data[index + 2] & 0xff) << 16;
        // falls-through
        case 2:
            k1 ^= ((long) data[index + 1] & 0xff) << 8;
        // falls-through
        case 1:
            k1 ^= (long) data[index] & 0xff;
            k1 *= C1;
            k1 = Long.rotateLeft(k1, R1);
            k1 *= C2;
            hash ^= k1;
    }
    // finalization
    hash ^= length;
    return fmix64(hash);
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int,int).seed","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(byte[],int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(int)","Method","* Generates 64-bit hash from an int with a default seed.
     *
     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>
     *
     * <p>This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code int}.
     * This method will be removed in a future release.</p>
     *
     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.</p>
     *
     * <p>This is a helper method that will produce the same result as:</p>
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(4)
     *                                          .putInt(data)
     *                                          .array(), offset, 4, seed);
     * </pre>
     *
     * @param data The int to hash
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code int}.","@Deprecated
public static long hash64(final int data) {
    long k1 = Integer.reverseBytes(data) & -1L >>> 32;
    long hash = DEFAULT_SEED;
    k1 *= C1;
    k1 = Long.rotateLeft(k1, R1);
    k1 *= C2;
    hash ^= k1;
    // finalization
    hash ^= Integer.BYTES;
    return fmix64(hash);
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(long)","Method","* Generates 64-bit hash from a long with a default seed.
     *
     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>
     *
     * <p>This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code long}.
     * This method will be removed in a future release.</p>
     *
     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.</p>
     *
     * <p>This is a helper method that will produce the same result as:</p>
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(8)
     *                                          .putLong(data)
     *                                          .array(), offset, 8, seed);
     * </pre>
     *
     * @param data The long to hash
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code long}.","@Deprecated
public static long hash64(final long data) {
    long hash = DEFAULT_SEED;
    long k = Long.reverseBytes(data);
    // mix functions
    k *= C1;
    k = Long.rotateLeft(k, R1);
    k *= C2;
    hash ^= k;
    hash = Long.rotateLeft(hash, R2) * M + N1;
    // finalization
    hash ^= Long.BYTES;
    return fmix64(hash);
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(long).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(short)","Method","* Generates 64-bit hash from a short with a default seed.
     *
     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>
     *
     * <p>This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code short}.
     * This method will be removed in a future release.</p>
     *
     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.</p>
     *
     * <p>This is a helper method that will produce the same result as:</p>
     *
     * <pre>
     * int offset = 0;
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(2)
     *                                          .putShort(data)
     *                                          .array(), offset, 2, seed);
     * </pre>
     *
     * @param data The short to hash
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code short}.","@Deprecated
public static long hash64(final short data) {
    long hash = DEFAULT_SEED;
    long k1 = 0;
    k1 ^= ((long) data & 0xff) << 8;
    k1 ^= (long) ((data & 0xFF00) >> 8) & 0xff;
    k1 *= C1;
    k1 = Long.rotateLeft(k1, R1);
    k1 *= C2;
    hash ^= k1;
    // finalization
    hash ^= Short.BYTES;
    return fmix64(hash);
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.hash64(short).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.hash64(short)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.mix32(int,int)","Method","* Performs the intermediate mix step of the 32-bit hash function {@code MurmurHash3_x86_32}.
     *
     * @param k The data to add to the hash
     * @param hash The current hash
     * @return The new hash","private static int mix32(int k, int hash) {
    k *= C1_32;
    k = Integer.rotateLeft(k, R1_32);
    k *= C2_32;
    hash ^= k;
    return Integer.rotateLeft(hash, R2_32) * M_32 + N_32;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.mix32(int,int).k","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.mix32(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.mix32(int,int).hash","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.mix32(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.<init>()","Constructor","No instance methods.","private MurmurHash3() {
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32","Class","* Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new
     * hash computed.
     *
     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>
     *
     * <p>This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.</p>
     *
     * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes.","Class do not obtain Source Code","No return type","public , static ","org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86",""
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.finalise(int,int,byte[],int)","Method","* {@inheritDoc}
         *
         * <p>This implementation contains a sign-extension bug in the finalization step of
         * any bytes left over from dividing the length by 4. This manifests if any of these
         * bytes are negative.<p>
         *
         * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes.","@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
    int result = hash;
    // Note: This fails to apply masking using 0xff to the 3 remaining bytes.
    int k1 = 0;
    switch(unprocessedLength) {
        case 3:
            k1 ^= unprocessed[2] << 16;
        // falls-through
        case 2:
            k1 ^= unprocessed[1] << 8;
        // falls-through
        case 1:
            k1 ^= unprocessed[0];
            // mix functions
            k1 *= C1_32;
            k1 = Integer.rotateLeft(k1, R1_32);
            k1 *= C2_32;
            result ^= k1;
    }
    // finalization
    result ^= totalLen;
    return fmix32(result);
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.finalise(int,int,byte[],int).hash","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.finalise(int,int,byte[],int).unprocessedLength","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.finalise(int,int,byte[],int).unprocessed","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.finalise(int,int,byte[],int).totalLen","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32.<init>()","Constructor","* Constructs a new instance.","public IncrementalHash32() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86","Class","* Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new
     * hash computed.
     *
     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>
     *
     * @since 1.14","Class do not obtain Source Code","No return type","public , static ","",""
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.BLOCK_SIZE","Field","The size of byte blocks that are processed together.","private static final int BLOCK_SIZE = 4;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.unprocessed","Field","Up to 3 unprocessed bytes from input data.","private final byte[] unprocessed = new byte[3];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.unprocessedLength","Field","The number of unprocessed bytes in the tail data.","private int unprocessedLength;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.totalLen","Field","The total number of input bytes added since the start.","private int totalLen;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.hash","Field","* The current running hash.
         * This must be finalized to generate the 32-bit hash value.","private int hash;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Method","* Combines the bytes using an Or operation ({@code | } in a little-endian representation
         * of a 32-bit integer; byte 1 will be the least significant byte, byte 4 the most
         * significant.
         *
         * @param b1 The first byte
         * @param b2 The second byte
         * @param b3 The third byte
         * @param b4 The fourth byte
         * @return The 32-bit integer","private static int orBytes(final byte b1, final byte b2, final byte b3, final byte b4) {
    return b1 & 0xff | (b2 & 0xff) << 8 | (b3 & 0xff) << 16 | (b4 & 0xff) << 24;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.orBytes(byte,byte,byte,byte).b1","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.orBytes(byte,byte,byte,byte).b2","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.orBytes(byte,byte,byte,byte).b3","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.orBytes(byte,byte,byte,byte).b4","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.add(byte[],int,int)","Method","* Adds the byte array to the current incremental hash.
         *
         * @param data The input byte array
         * @param offset The offset of data
         * @param length The length of array","public final void add(final byte[] data, final int offset, final int length) {
    if (length <= 0) {
        // Nothing to add
        return;
    }
    totalLen += length;
    // Process the bytes in blocks of 4.
    // New bytes must be added to any current unprocessed bytes,
    // then processed in blocks of 4 and the remaining bytes saved:
    //
    //    |--|---------------------------|--|
    // unprocessed
    //                main block
    //                                remaining
    // Check if the unprocessed bytes and new bytes can fill a block of 4.
    // Make this overflow safe in the event that length is Integer.MAX_VALUE.
    // Equivalent to: (unprocessedLength + length < BLOCK_SIZE)
    if (unprocessedLength + length - BLOCK_SIZE < 0) {
        // Not enough so add to the unprocessed bytes
        System.arraycopy(data, offset, unprocessed, unprocessedLength, length);
        unprocessedLength += length;
        return;
    }
    // Combine unprocessed bytes with new bytes.
    final int newOffset;
    final int newLength;
    if (unprocessedLength > 0) {
        int k = -1;
        switch(unprocessedLength) {
            case 1:
                k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]);
                break;
            case 2:
                k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]);
                break;
            case 3:
                k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]);
                break;
            default:
                throw new IllegalStateException(""Unprocessed length should be 1, 2, or 3: "" + unprocessedLength);
        }
        hash = mix32(k, hash);
        // Update the offset and length
        final int consumed = BLOCK_SIZE - unprocessedLength;
        newOffset = offset + consumed;
        newLength = length - consumed;
    } else {
        newOffset = offset;
        newLength = length;
    }
    // Main processing of blocks of 4 bytes
    final int nblocks = newLength >> 2;
    for (int i = 0; i < nblocks; i++) {
        final int index = newOffset + (i << 2);
        final int k = getLittleEndianInt(data, index);
        hash = mix32(k, hash);
    }
    // Save left-over unprocessed bytes
    final int consumed = nblocks << 2;
    unprocessedLength = newLength - consumed;
    if (unprocessedLength != 0) {
        System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength);
    }
}","void","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.add(byte[],int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.add(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.add(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.add(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.add(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.add(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.end()","Method","* Generates the 32-bit hash value. Repeat calls to this method with no additional data
         * will generate the same hash value.
         *
         * @return The 32-bit hash","public final int end() {
    // Allow calling end() again after adding no data to return the same result.
    return finalise(hash, unprocessedLength, unprocessed, totalLen);
}","int","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.finalise(int,int,byte[],int)","Method","* Finalizes the running hash to the output 32-bit hash by processing remaining bytes
         * and performing final mixing.
         *
         * @param hash The running hash
         * @param unprocessedLength The number of unprocessed bytes in the tail data.
         * @param unprocessed Up to 3 unprocessed bytes from input data.
         * @param totalLen The total number of input bytes added since the start.
         * @return The 32-bit hash","int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
    int result = hash;
    int k1 = 0;
    switch(unprocessedLength) {
        case 3:
            k1 ^= (unprocessed[2] & 0xff) << 16;
        // falls-through
        case 2:
            k1 ^= (unprocessed[1] & 0xff) << 8;
        // falls-through
        case 1:
            k1 ^= unprocessed[0] & 0xff;
            // mix functions
            k1 *= C1_32;
            k1 = Integer.rotateLeft(k1, R1_32);
            k1 *= C2_32;
            result ^= k1;
    }
    // finalization
    result ^= totalLen;
    return fmix32(result);
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.finalise(int,int,byte[],int).hash","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.finalise(int,int,byte[],int).unprocessedLength","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.finalise(int,int,byte[],int).unprocessed","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.finalise(int,int,byte[],int).totalLen","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.start(int)","Method","* Starts a new incremental hash.
         *
         * @param seed The initial seed value","public final void start(final int seed) {
    // Reset
    unprocessedLength = totalLen = 0;
    this.hash = seed;
}","void","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.start(int).seed","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.start(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3$IncrementalHash32x86.<init>()","Constructor","* Constructs a new instance.","public IncrementalHash32x86() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32","Class","* Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new
     * hash computed.
     *
     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>
     *
     * <p>This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.</p>
     *
     * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes.","Class do not obtain Source Code","No return type","public , static ","org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86",""
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.finalise(int,int,byte[],int)","Method","* {@inheritDoc}
         *
         * <p>This implementation contains a sign-extension bug in the finalization step of
         * any bytes left over from dividing the length by 4. This manifests if any of these
         * bytes are negative.<p>
         *
         * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes.","@Override
@Deprecated
int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
    int result = hash;
    // Note: This fails to apply masking using 0xff to the 3 remaining bytes.
    int k1 = 0;
    switch(unprocessedLength) {
        case 3:
            k1 ^= unprocessed[2] << 16;
        // falls-through
        case 2:
            k1 ^= unprocessed[1] << 8;
        // falls-through
        case 1:
            k1 ^= unprocessed[0];
            // mix functions
            k1 *= C1_32;
            k1 = Integer.rotateLeft(k1, R1_32);
            k1 *= C2_32;
            result ^= k1;
    }
    // finalization
    result ^= totalLen;
    return fmix32(result);
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.finalise(int,int,byte[],int).hash","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.finalise(int,int,byte[],int).unprocessedLength","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.finalise(int,int,byte[],int).unprocessed","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.finalise(int,int,byte[],int).totalLen","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32.<init>()","Constructor","* Constructs a new instance.","public IncrementalHash32() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86","Class","* Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new
     * hash computed.
     *
     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>
     *
     * @since 1.14","Class do not obtain Source Code","No return type","public , static ","",""
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.BLOCK_SIZE","Field","The size of byte blocks that are processed together.","private static final int BLOCK_SIZE = 4;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.unprocessed","Field","Up to 3 unprocessed bytes from input data.","private final byte[] unprocessed = new byte[3];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.unprocessedLength","Field","The number of unprocessed bytes in the tail data.","private int unprocessedLength;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.totalLen","Field","The total number of input bytes added since the start.","private int totalLen;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.hash","Field","* The current running hash.
         * This must be finalized to generate the 32-bit hash value.","private int hash;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Method","* Combines the bytes using an Or operation ({@code | } in a little-endian representation
         * of a 32-bit integer; byte 1 will be the least significant byte, byte 4 the most
         * significant.
         *
         * @param b1 The first byte
         * @param b2 The second byte
         * @param b3 The third byte
         * @param b4 The fourth byte
         * @return The 32-bit integer","private static int orBytes(final byte b1, final byte b2, final byte b3, final byte b4) {
    return b1 & 0xff | (b2 & 0xff) << 8 | (b3 & 0xff) << 16 | (b4 & 0xff) << 24;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte,byte,byte,byte).b1","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte,byte,byte,byte).b2","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte,byte,byte,byte).b3","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte,byte,byte,byte).b4","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte,byte,byte,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[],int,int)","Method","* Adds the byte array to the current incremental hash.
         *
         * @param data The input byte array
         * @param offset The offset of data
         * @param length The length of array","public final void add(final byte[] data, final int offset, final int length) {
    if (length <= 0) {
        // Nothing to add
        return;
    }
    totalLen += length;
    // Process the bytes in blocks of 4.
    // New bytes must be added to any current unprocessed bytes,
    // then processed in blocks of 4 and the remaining bytes saved:
    //
    //    |--|---------------------------|--|
    // unprocessed
    //                main block
    //                                remaining
    // Check if the unprocessed bytes and new bytes can fill a block of 4.
    // Make this overflow safe in the event that length is Integer.MAX_VALUE.
    // Equivalent to: (unprocessedLength + length < BLOCK_SIZE)
    if (unprocessedLength + length - BLOCK_SIZE < 0) {
        // Not enough so add to the unprocessed bytes
        System.arraycopy(data, offset, unprocessed, unprocessedLength, length);
        unprocessedLength += length;
        return;
    }
    // Combine unprocessed bytes with new bytes.
    final int newOffset;
    final int newLength;
    if (unprocessedLength > 0) {
        int k = -1;
        switch(unprocessedLength) {
            case 1:
                k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]);
                break;
            case 2:
                k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]);
                break;
            case 3:
                k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]);
                break;
            default:
                throw new IllegalStateException(""Unprocessed length should be 1, 2, or 3: "" + unprocessedLength);
        }
        hash = mix32(k, hash);
        // Update the offset and length
        final int consumed = BLOCK_SIZE - unprocessedLength;
        newOffset = offset + consumed;
        newLength = length - consumed;
    } else {
        newOffset = offset;
        newLength = length;
    }
    // Main processing of blocks of 4 bytes
    final int nblocks = newLength >> 2;
    for (int i = 0; i < nblocks; i++) {
        final int index = newOffset + (i << 2);
        final int k = getLittleEndianInt(data, index);
        hash = mix32(k, hash);
    }
    // Save left-over unprocessed bytes
    final int consumed = nblocks << 2;
    unprocessedLength = newLength - consumed;
    if (unprocessedLength != 0) {
        System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength);
    }
}","void","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[],int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.end()","Method","* Generates the 32-bit hash value. Repeat calls to this method with no additional data
         * will generate the same hash value.
         *
         * @return The 32-bit hash","public final int end() {
    // Allow calling end() again after adding no data to return the same result.
    return finalise(hash, unprocessedLength, unprocessed, totalLen);
}","int","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int,int,byte[],int)","Method","* Finalizes the running hash to the output 32-bit hash by processing remaining bytes
         * and performing final mixing.
         *
         * @param hash The running hash
         * @param unprocessedLength The number of unprocessed bytes in the tail data.
         * @param unprocessed Up to 3 unprocessed bytes from input data.
         * @param totalLen The total number of input bytes added since the start.
         * @return The 32-bit hash","int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
    int result = hash;
    int k1 = 0;
    switch(unprocessedLength) {
        case 3:
            k1 ^= (unprocessed[2] & 0xff) << 16;
        // falls-through
        case 2:
            k1 ^= (unprocessed[1] & 0xff) << 8;
        // falls-through
        case 1:
            k1 ^= unprocessed[0] & 0xff;
            // mix functions
            k1 *= C1_32;
            k1 = Integer.rotateLeft(k1, R1_32);
            k1 *= C2_32;
            result ^= k1;
    }
    // finalization
    result ^= totalLen;
    return fmix32(result);
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int,int,byte[],int).hash","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int,int,byte[],int).unprocessedLength","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int,int,byte[],int).unprocessed","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int,int,byte[],int).totalLen","Parameter_4","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int,int,byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.start(int)","Method","* Starts a new incremental hash.
         *
         * @param seed The initial seed value","public final void start(final int seed) {
    // Reset
    unprocessedLength = totalLen = 0;
    this.hash = seed;
}","void","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.start(int).seed","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.start(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.<init>()","Constructor","* Constructs a new instance.","public IncrementalHash32x86() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils","Class","* Operations to simplify common {@link java.security.MessageDigest} tasks. This class is immutable and thread-safe. However the MessageDigest instances it
 * creates generally won't be.
 * <p>
 * The {@link MessageDigestAlgorithms} class provides constants for standard digest algorithms that can be used with the {@link #getDigest(String)} method and
 * other methods that require the Digest algorithm name.
 * </p>
 * <p>
 * Note: The class has shorthand methods for all the algorithms present as standard in Java 6. This approach requires lots of methods for each algorithm, and
 * quickly becomes unwieldy. The following code works with all algorithms:
 * </p>
 *
 * <pre>
 * import static org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224;
 * ...
 * byte [] digest = new DigestUtils(SHA_224).digest(dataToDigest);
 * String hdigest = new DigestUtils(SHA_224).digestAsHex(new File(""pom.xml""));
 * </pre>
 *
 * @see MessageDigestAlgorithms","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.digest.DigestUtils.BUFFER_SIZE","Field","* Package-private for tests.","static final int BUFFER_SIZE = 1024;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.messageDigest","Field","No Comment","private final MessageDigest messageDigest;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,byte[])","Method","* Reads through a byte array and returns the digest for the data. Provided for symmetry with other methods.
     *
     * @param messageDigest The MessageDigest to use (for example MD5)
     * @param data          Data to digest
     * @return the digest
     * @since 1.11","public static byte[] digest(final MessageDigest messageDigest, final byte[] data) {
    return messageDigest.digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,byte[]).messageDigest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,byte[]).data","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,ByteBuffer)","Method","* Reads through a ByteBuffer and returns the digest for the data
     *
     * @param messageDigest The MessageDigest to use (for example MD5)
     * @param data          Data to digest
     * @return the digest
     * @since 1.11","public static byte[] digest(final MessageDigest messageDigest, final ByteBuffer data) {
    messageDigest.update(data);
    return messageDigest.digest();
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,ByteBuffer).messageDigest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,ByteBuffer).data","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,File)","Method","* Reads through a File and returns the digest for the data
     *
     * @param messageDigest The MessageDigest to use (for example MD5)
     * @param data          Data to digest
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.11","public static byte[] digest(final MessageDigest messageDigest, final File data) throws IOException {
    return updateDigest(messageDigest, data).digest();
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,File).messageDigest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,File)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,File).data","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,File)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,InputStream)","Method","* Reads through an InputStream and returns the digest for the data
     *
     * @param messageDigest The MessageDigest to use (for example MD5)
     * @param data          Data to digest
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.11 (was private)","public static byte[] digest(final MessageDigest messageDigest, final InputStream data) throws IOException {
    return updateDigest(messageDigest, data).digest();
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,InputStream).messageDigest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,InputStream).data","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,Path,OpenOption[])","Method","* Reads through a File and returns the digest for the data
     *
     * @param messageDigest The MessageDigest to use (for example MD5)
     * @param data          Data to digest
     * @param options       options How to open the file
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.14","public static byte[] digest(final MessageDigest messageDigest, final Path data, final OpenOption... options) throws IOException {
    return updateDigest(messageDigest, data, options).digest();
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,Path,OpenOption[]).messageDigest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,Path,OpenOption[]).data","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,Path,OpenOption[]).options","Parameter_3","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,RandomAccessFile)","Method","* Reads through a RandomAccessFile using non-blocking-io (NIO) and returns the digest for the data
     *
     * @param messageDigest The MessageDigest to use (for example MD5)
     * @param data          Data to digest
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.14","public static byte[] digest(final MessageDigest messageDigest, final RandomAccessFile data) throws IOException {
    return updateDigest(messageDigest, data).digest();
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,RandomAccessFile).messageDigest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,RandomAccessFile)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,RandomAccessFile).data","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.digest(MessageDigest,RandomAccessFile)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getDigest(String)","Method","* Gets a {@code MessageDigest} for the given {@code algorithm}.
     *
     * @param algorithm the name of the algorithm requested. See
     *                  <a href=""https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA"">Appendix A in the Java
     *                  Cryptography Architecture Reference Guide</a> for information about standard algorithm names.
     * @return A digest instance.
     * @see MessageDigest#getInstance(String)
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.","public static MessageDigest getDigest(final String algorithm) {
    try {
        return getMessageDigest(algorithm);
    } catch (final NoSuchAlgorithmException e) {
        throw new IllegalArgumentException(e);
    }
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getDigest(String).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.getDigest(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getDigest(String,MessageDigest)","Method","* Gets a {@code MessageDigest} for the given {@code algorithm} or a default if there is a problem getting the algorithm.
     *
     * @param algorithm            the name of the algorithm requested. See
     *                             <a href=""https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA""> Appendix A in the Java
     *                             Cryptography Architecture Reference Guide</a> for information about standard algorithm names.
     * @param defaultMessageDigest The default MessageDigest.
     * @return A digest instance.
     * @see MessageDigest#getInstance(String)
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.
     * @since 1.11","public static MessageDigest getDigest(final String algorithm, final MessageDigest defaultMessageDigest) {
    try {
        return getMessageDigest(algorithm);
    } catch (final Exception e) {
        return defaultMessageDigest;
    }
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getDigest(String,MessageDigest).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.getDigest(String,MessageDigest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getDigest(String,MessageDigest).defaultMessageDigest","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.getDigest(String,MessageDigest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getMd2Digest()","Method","* Gets an MD2 MessageDigest.
     *
     * @return An MD2 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD2 is a built-in algorithm
     * @see MessageDigestAlgorithms#MD2
     * @since 1.7","public static MessageDigest getMd2Digest() {
    return getDigest(MessageDigestAlgorithms.MD2);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getMd5Digest()","Method","* Gets an MD5 MessageDigest.
     *
     * @return An MD5 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD5 is a built-in algorithm
     * @see MessageDigestAlgorithms#MD5","public static MessageDigest getMd5Digest() {
    return getDigest(MessageDigestAlgorithms.MD5);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getMessageDigest(String)","Method","* Gets a {@code MessageDigest} for the given {@code algorithm}.
     *
     * @param algorithm the name of the algorithm requested. See
     *                  <a href=""https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA""> Appendix A in the Java
     *                  Cryptography Architecture Reference Guide</a> for information about standard algorithm names.
     * @return A digest instance.
     * @see MessageDigest#getInstance(String)
     * @throws NoSuchAlgorithmException if no Provider supports a MessageDigestSpi implementation for the specified algorithm.","private static MessageDigest getMessageDigest(final String algorithm) throws NoSuchAlgorithmException {
    return MessageDigest.getInstance(algorithm);
}","MessageDigest","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getMessageDigest(String).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.getMessageDigest(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha1Digest()","Method","* Gets an SHA-1 digest.
     *
     * @return An SHA-1 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-1 is a built-in algorithm
     * @see MessageDigestAlgorithms#SHA_1
     * @since 1.7","public static MessageDigest getSha1Digest() {
    return getDigest(MessageDigestAlgorithms.SHA_1);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha256Digest()","Method","* Gets an SHA-256 digest.
     *
     * @return An SHA-256 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-256 is a built-in algorithm
     * @see MessageDigestAlgorithms#SHA_256","public static MessageDigest getSha256Digest() {
    return getDigest(MessageDigestAlgorithms.SHA_256);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha3_224Digest()","Method","* Gets an SHA3-224 digest.
     *
     * @return An SHA3-224 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.
     * @see MessageDigestAlgorithms#SHA3_224
     * @since 1.12","public static MessageDigest getSha3_224Digest() {
    return getDigest(MessageDigestAlgorithms.SHA3_224);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha3_256Digest()","Method","* Returns an SHA3-256 digest.
     *
     * @return An SHA3-256 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.
     * @see MessageDigestAlgorithms#SHA3_256
     * @since 1.12","public static MessageDigest getSha3_256Digest() {
    return getDigest(MessageDigestAlgorithms.SHA3_256);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha3_384Digest()","Method","* Gets an SHA3-384 digest.
     *
     * @return An SHA3-384 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.
     * @see MessageDigestAlgorithms#SHA3_384
     * @since 1.12","public static MessageDigest getSha3_384Digest() {
    return getDigest(MessageDigestAlgorithms.SHA3_384);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha3_512Digest()","Method","* Gets an SHA3-512 digest.
     *
     * @return An SHA3-512 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.
     * @see MessageDigestAlgorithms#SHA3_512
     * @since 1.12","public static MessageDigest getSha3_512Digest() {
    return getDigest(MessageDigestAlgorithms.SHA3_512);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha384Digest()","Method","* Gets an SHA-384 digest.
     *
     * @return An SHA-384 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-384 is a built-in algorithm
     * @see MessageDigestAlgorithms#SHA_384","public static MessageDigest getSha384Digest() {
    return getDigest(MessageDigestAlgorithms.SHA_384);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha512_224Digest()","Method","* Gets an SHA-512/224 digest.
     *
     * @return An SHA-512/224 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.
     * @see MessageDigestAlgorithms#SHA_512_224","public static MessageDigest getSha512_224Digest() {
    return getDigest(MessageDigestAlgorithms.SHA_512_224);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha512_256Digest()","Method","* Gets an SHA-512/256 digest.
     *
     * @return An SHA-512/256 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.
     * @see MessageDigestAlgorithms#SHA_512_224","public static MessageDigest getSha512_256Digest() {
    return getDigest(MessageDigestAlgorithms.SHA_512_256);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getSha512Digest()","Method","* Gets an SHA-512 digest.
     *
     * @return An SHA-512 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-512 is a built-in algorithm
     * @see MessageDigestAlgorithms#SHA_512","public static MessageDigest getSha512Digest() {
    return getDigest(MessageDigestAlgorithms.SHA_512);
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getShaDigest()","Method","* Gets an SHA-1 digest.
     *
     * @return An SHA-1 digest instance.
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught
     * @deprecated (1.11) Use {@link #getSha1Digest()}","@Deprecated
public static MessageDigest getShaDigest() {
    return getSha1Digest();
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.isAvailable(String)","Method","* Test whether the algorithm is supported.
     *
     * @param messageDigestAlgorithm the algorithm name
     * @return {@code true} if the algorithm can be found
     * @since 1.11","public static boolean isAvailable(final String messageDigestAlgorithm) {
    return getDigest(messageDigestAlgorithm, null) != null;
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.isAvailable(String).messageDigestAlgorithm","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.isAvailable(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2(byte[])","Method","* Calculates the MD2 digest and returns the value as a 16 element {@code byte[]}.
     *
     * @param data Data to digest
     * @return MD2 digest
     * @since 1.7","public static byte[] md2(final byte[] data) {
    return getMd2Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md2(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2(InputStream)","Method","* Calculates the MD2 digest and returns the value as a 16 element {@code byte[]}.
     *
     * @param data Data to digest
     * @return MD2 digest
     * @throws IOException On error reading from the stream
     * @since 1.7","public static byte[] md2(final InputStream data) throws IOException {
    return digest(getMd2Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md2(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2(String)","Method","* Calculates the MD2 digest and returns the value as a 16 element {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return MD2 digest
     * @since 1.7","public static byte[] md2(final String data) {
    return md2(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md2(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2Hex(byte[])","Method","* Calculates the MD2 digest and returns the value as a 32 character hexadecimal string.
     *
     * @param data Data to digest
     * @return MD2 digest as a hexadecimal string
     * @since 1.7","public static String md2Hex(final byte[] data) {
    return Hex.encodeHexString(md2(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md2Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2Hex(InputStream)","Method","* Calculates the MD2 digest and returns the value as a 32 character hexadecimal string.
     *
     * @param data Data to digest
     * @return MD2 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.7","public static String md2Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(md2(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md2Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2Hex(String)","Method","* Calculates the MD2 digest and returns the value as a 32 character hexadecimal string.
     *
     * @param data Data to digest
     * @return MD2 digest as a hexadecimal string
     * @since 1.7","public static String md2Hex(final String data) {
    return Hex.encodeHexString(md2(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md2Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md2Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5(byte[])","Method","* Calculates the MD5 digest and returns the value as a 16 element {@code byte[]}.
     *
     * @param data Data to digest
     * @return MD5 digest","public static byte[] md5(final byte[] data) {
    return getMd5Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md5(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5(InputStream)","Method","* Calculates the MD5 digest and returns the value as a 16 element {@code byte[]}.
     *
     * @param data Data to digest
     * @return MD5 digest
     * @throws IOException On error reading from the stream
     * @since 1.4","public static byte[] md5(final InputStream data) throws IOException {
    return digest(getMd5Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md5(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5(String)","Method","* Calculates the MD5 digest and returns the value as a 16 element {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return MD5 digest","public static byte[] md5(final String data) {
    return md5(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md5(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5Hex(byte[])","Method","* Calculates the MD5 digest and returns the value as a 32 character hexadecimal string.
     *
     * @param data Data to digest
     * @return MD5 digest as a hexadecimal string","public static String md5Hex(final byte[] data) {
    return Hex.encodeHexString(md5(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md5Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5Hex(InputStream)","Method","* Calculates the MD5 digest and returns the value as a 32 character hexadecimal string.
     *
     * @param data Data to digest
     * @return MD5 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.4","public static String md5Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(md5(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md5Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5Hex(String)","Method","* Calculates the MD5 digest and returns the value as a 32 character hexadecimal string.
     *
     * @param data Data to digest
     * @return MD5 digest as a hexadecimal string","public static String md5Hex(final String data) {
    return Hex.encodeHexString(md5(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.md5Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.md5Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha(byte[])","Method","* Calculates the SHA-1 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-1 digest
     * @deprecated (1.11) Use {@link #sha1(byte[])}","@Deprecated
public static byte[] sha(final byte[] data) {
    return sha1(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha(InputStream)","Method","* Calculates the SHA-1 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-1 digest
     * @throws IOException On error reading from the stream
     * @since 1.4
     * @deprecated (1.11) Use {@link #sha1(InputStream)}","@Deprecated
public static byte[] sha(final InputStream data) throws IOException {
    return sha1(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha(String)","Method","* Calculates the SHA-1 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-1 digest
     * @deprecated (1.11) Use {@link #sha1(String)}","@Deprecated
public static byte[] sha(final String data) {
    return sha1(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1(byte[])","Method","* Calculates the SHA-1 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-1 digest
     * @since 1.7","public static byte[] sha1(final byte[] data) {
    return getSha1Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha1(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1(InputStream)","Method","* Calculates the SHA-1 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-1 digest
     * @throws IOException On error reading from the stream
     * @since 1.7","public static byte[] sha1(final InputStream data) throws IOException {
    return digest(getSha1Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha1(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1(String)","Method","* Calculates the SHA-1 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA-1 digest","public static byte[] sha1(final String data) {
    return sha1(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha1(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1Hex(byte[])","Method","* Calculates the SHA-1 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-1 digest as a hexadecimal string
     * @since 1.7","public static String sha1Hex(final byte[] data) {
    return Hex.encodeHexString(sha1(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha1Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1Hex(InputStream)","Method","* Calculates the SHA-1 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-1 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.7","public static String sha1Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha1(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha1Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1Hex(String)","Method","* Calculates the SHA-1 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-1 digest as a hexadecimal string
     * @since 1.7","public static String sha1Hex(final String data) {
    return Hex.encodeHexString(sha1(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha1Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha1Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256(byte[])","Method","* Calculates the SHA-256 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-256 digest
     * @since 1.4","public static byte[] sha256(final byte[] data) {
    return getSha256Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha256(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256(InputStream)","Method","* Calculates the SHA-256 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-256 digest
     * @throws IOException On error reading from the stream
     * @since 1.4","public static byte[] sha256(final InputStream data) throws IOException {
    return digest(getSha256Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha256(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256(String)","Method","* Calculates the SHA-256 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA-256 digest
     * @since 1.4","public static byte[] sha256(final String data) {
    return sha256(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha256(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256Hex(byte[])","Method","* Calculates the SHA-256 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-256 digest as a hexadecimal string
     * @since 1.4","public static String sha256Hex(final byte[] data) {
    return Hex.encodeHexString(sha256(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha256Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256Hex(InputStream)","Method","* Calculates the SHA-256 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-256 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.4","public static String sha256Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha256(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha256Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256Hex(String)","Method","* Calculates the SHA-256 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-256 digest as a hexadecimal string
     * @since 1.4","public static String sha256Hex(final String data) {
    return Hex.encodeHexString(sha256(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha256Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha256Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224(byte[])","Method","* Calculates the SHA3-224 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA3-224 digest
     * @since 1.12","public static byte[] sha3_224(final byte[] data) {
    return getSha3_224Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_224(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224(InputStream)","Method","* Calculates the SHA3-224 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA3-224 digest
     * @throws IOException On error reading from the stream
     * @since 1.12","public static byte[] sha3_224(final InputStream data) throws IOException {
    return digest(getSha3_224Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_224(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224(String)","Method","* Calculates the SHA3-224 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA3-224 digest
     * @since 1.12","public static byte[] sha3_224(final String data) {
    return sha3_224(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_224(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(byte[])","Method","* Calculates the SHA3-224 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-224 digest as a hexadecimal string
     * @since 1.12","public static String sha3_224Hex(final byte[] data) {
    return Hex.encodeHexString(sha3_224(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(InputStream)","Method","* Calculates the SHA3-224 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-224 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.12","public static String sha3_224Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha3_224(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(String)","Method","* Calculates the SHA3-224 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-224 digest as a hexadecimal string
     * @since 1.12","public static String sha3_224Hex(final String data) {
    return Hex.encodeHexString(sha3_224(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256(byte[])","Method","* Calculates the SHA3-256 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA3-256 digest
     * @since 1.12","public static byte[] sha3_256(final byte[] data) {
    return getSha3_256Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_256(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256(InputStream)","Method","* Calculates the SHA3-256 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA3-256 digest
     * @throws IOException On error reading from the stream
     * @since 1.12","public static byte[] sha3_256(final InputStream data) throws IOException {
    return digest(getSha3_256Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_256(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256(String)","Method","* Calculates the SHA3-256 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA3-256 digest
     * @since 1.12","public static byte[] sha3_256(final String data) {
    return sha3_256(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_256(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(byte[])","Method","* Calculates the SHA3-256 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-256 digest as a hexadecimal string
     * @since 1.12","public static String sha3_256Hex(final byte[] data) {
    return Hex.encodeHexString(sha3_256(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(InputStream)","Method","* Calculates the SHA3-256 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-256 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.12","public static String sha3_256Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha3_256(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(String)","Method","* Calculates the SHA3-256 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-256 digest as a hexadecimal string
     * @since 1.12","public static String sha3_256Hex(final String data) {
    return Hex.encodeHexString(sha3_256(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384(byte[])","Method","* Calculates the SHA3-384 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA3-384 digest
     * @since 1.12","public static byte[] sha3_384(final byte[] data) {
    return getSha3_384Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_384(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384(InputStream)","Method","* Calculates the SHA3-384 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA3-384 digest
     * @throws IOException On error reading from the stream
     * @since 1.12","public static byte[] sha3_384(final InputStream data) throws IOException {
    return digest(getSha3_384Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_384(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384(String)","Method","* Calculates the SHA3-384 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA3-384 digest
     * @since 1.12","public static byte[] sha3_384(final String data) {
    return sha3_384(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_384(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(byte[])","Method","* Calculates the SHA3-384 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-384 digest as a hexadecimal string
     * @since 1.12","public static String sha3_384Hex(final byte[] data) {
    return Hex.encodeHexString(sha3_384(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(InputStream)","Method","* Calculates the SHA3-384 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-384 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.12","public static String sha3_384Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha3_384(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(String)","Method","* Calculates the SHA3-384 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-384 digest as a hexadecimal string
     * @since 1.12","public static String sha3_384Hex(final String data) {
    return Hex.encodeHexString(sha3_384(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512(byte[])","Method","* Calculates the SHA3-512 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA3-512 digest
     * @since 1.12","public static byte[] sha3_512(final byte[] data) {
    return getSha3_512Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_512(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512(InputStream)","Method","* Calculates the SHA3-512 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA3-512 digest
     * @throws IOException On error reading from the stream
     * @since 1.12","public static byte[] sha3_512(final InputStream data) throws IOException {
    return digest(getSha3_512Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_512(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512(String)","Method","* Calculates the SHA3-512 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA3-512 digest
     * @since 1.12","public static byte[] sha3_512(final String data) {
    return sha3_512(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_512(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(byte[])","Method","* Calculates the SHA3-512 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-512 digest as a hexadecimal string
     * @since 1.12","public static String sha3_512Hex(final byte[] data) {
    return Hex.encodeHexString(sha3_512(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(InputStream)","Method","* Calculates the SHA3-512 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-512 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.12","public static String sha3_512Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha3_512(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(String)","Method","* Calculates the SHA3-512 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA3-512 digest as a hexadecimal string
     * @since 1.12","public static String sha3_512Hex(final String data) {
    return Hex.encodeHexString(sha3_512(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384(byte[])","Method","* Calculates the SHA-384 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-384 digest
     * @since 1.4","public static byte[] sha384(final byte[] data) {
    return getSha384Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha384(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384(InputStream)","Method","* Calculates the SHA-384 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-384 digest
     * @throws IOException On error reading from the stream
     * @since 1.4","public static byte[] sha384(final InputStream data) throws IOException {
    return digest(getSha384Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha384(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384(String)","Method","* Calculates the SHA-384 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA-384 digest
     * @since 1.4","public static byte[] sha384(final String data) {
    return sha384(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha384(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384Hex(byte[])","Method","* Calculates the SHA-384 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-384 digest as a hexadecimal string
     * @since 1.4","public static String sha384Hex(final byte[] data) {
    return Hex.encodeHexString(sha384(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha384Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384Hex(InputStream)","Method","* Calculates the SHA-384 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-384 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.4","public static String sha384Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha384(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha384Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384Hex(String)","Method","* Calculates the SHA-384 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-384 digest as a hexadecimal string
     * @since 1.4","public static String sha384Hex(final String data) {
    return Hex.encodeHexString(sha384(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha384Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha384Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512(byte[])","Method","* Calculates the SHA-512 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-512 digest
     * @since 1.4","public static byte[] sha512(final byte[] data) {
    return getSha512Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512(InputStream)","Method","* Calculates the SHA-512 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-512 digest
     * @throws IOException On error reading from the stream
     * @since 1.4","public static byte[] sha512(final InputStream data) throws IOException {
    return digest(getSha512Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512(String)","Method","* Calculates the SHA-512 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA-512 digest
     * @since 1.4","public static byte[] sha512(final String data) {
    return sha512(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224(byte[])","Method","* Calculates the SHA-512/224 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-512/224 digest
     * @since 1.14","public static byte[] sha512_224(final byte[] data) {
    return getSha512_224Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_224(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224(InputStream)","Method","* Calculates the SHA-512/224 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-512/224 digest
     * @throws IOException On error reading from the stream
     * @since 1.14","public static byte[] sha512_224(final InputStream data) throws IOException {
    return digest(getSha512_224Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_224(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224(String)","Method","* Calculates the SHA-512/224 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA-512/224 digest
     * @since 1.14","public static byte[] sha512_224(final String data) {
    return sha512_224(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_224(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(byte[])","Method","* Calculates the SHA-512/224 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-512/224 digest as a hexadecimal string
     * @since 1.14","public static String sha512_224Hex(final byte[] data) {
    return Hex.encodeHexString(sha512_224(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(InputStream)","Method","* Calculates the SHA-512/224 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-512/224 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.14","public static String sha512_224Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha512_224(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(String)","Method","* Calculates the SHA-512/224 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-512/224 digest as a hexadecimal string
     * @since 1.14","public static String sha512_224Hex(final String data) {
    return Hex.encodeHexString(sha512_224(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256(byte[])","Method","* Calculates the SHA-512/256 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-512/256 digest
     * @since 1.14","public static byte[] sha512_256(final byte[] data) {
    return getSha512_256Digest().digest(data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_256(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256(InputStream)","Method","* Calculates the SHA-512/256 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest
     * @return SHA-512/256 digest
     * @throws IOException On error reading from the stream
     * @since 1.14","public static byte[] sha512_256(final InputStream data) throws IOException {
    return digest(getSha512_256Digest(), data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_256(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256(String)","Method","* Calculates the SHA-512/256 digest and returns the value as a {@code byte[]}.
     *
     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return SHA-512/224 digest
     * @since 1.14","public static byte[] sha512_256(final String data) {
    return sha512_256(StringUtils.getBytesUtf8(data));
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_256(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(byte[])","Method","* Calculates the SHA-512/256 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-512/256 digest as a hexadecimal string
     * @since 1.14","public static String sha512_256Hex(final byte[] data) {
    return Hex.encodeHexString(sha512_256(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(InputStream)","Method","* Calculates the SHA-512/256 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-512/256 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.14","public static String sha512_256Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha512_256(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(String)","Method","* Calculates the SHA-512/256 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-512/256 digest as a hexadecimal string
     * @since 1.14","public static String sha512_256Hex(final String data) {
    return Hex.encodeHexString(sha512_256(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512Hex(byte[])","Method","* Calculates the SHA-512 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-512 digest as a hexadecimal string
     * @since 1.4","public static String sha512Hex(final byte[] data) {
    return Hex.encodeHexString(sha512(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512Hex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512Hex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512Hex(InputStream)","Method","* Calculates the SHA-512 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-512 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.4","public static String sha512Hex(final InputStream data) throws IOException {
    return Hex.encodeHexString(sha512(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512Hex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512Hex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512Hex(String)","Method","* Calculates the SHA-512 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-512 digest as a hexadecimal string
     * @since 1.4","public static String sha512Hex(final String data) {
    return Hex.encodeHexString(sha512(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.sha512Hex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.sha512Hex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.shaHex(byte[])","Method","* Calculates the SHA-1 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-1 digest as a hexadecimal string
     * @deprecated (1.11) Use {@link #sha1Hex(byte[])}","@Deprecated
public static String shaHex(final byte[] data) {
    return sha1Hex(data);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.shaHex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.shaHex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.shaHex(InputStream)","Method","* Calculates the SHA-1 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-1 digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.4
     * @deprecated (1.11) Use {@link #sha1Hex(InputStream)}","@Deprecated
public static String shaHex(final InputStream data) throws IOException {
    return sha1Hex(data);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.shaHex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.shaHex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.shaHex(String)","Method","* Calculates the SHA-1 digest and returns the value as a hexadecimal string.
     *
     * @param data Data to digest
     * @return SHA-1 digest as a hexadecimal string
     * @deprecated (1.11) Use {@link #sha1Hex(String)}","@Deprecated
public static String shaHex(final String data) {
    return sha1Hex(data);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.shaHex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.shaHex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,byte[])","Method","* Updates the given {@link MessageDigest}.
     *
     * @param messageDigest the {@link MessageDigest} to update
     * @param valueToDigest the value to update the {@link MessageDigest} with
     * @return the updated {@link MessageDigest}
     * @since 1.7","public static MessageDigest updateDigest(final MessageDigest messageDigest, final byte[] valueToDigest) {
    messageDigest.update(valueToDigest);
    return messageDigest;
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,byte[]).messageDigest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,byte[]).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,ByteBuffer)","Method","* Updates the given {@link MessageDigest}.
     *
     * @param messageDigest the {@link MessageDigest} to update
     * @param valueToDigest the value to update the {@link MessageDigest} with
     * @return the updated {@link MessageDigest}
     * @since 1.11","public static MessageDigest updateDigest(final MessageDigest messageDigest, final ByteBuffer valueToDigest) {
    messageDigest.update(valueToDigest);
    return messageDigest;
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,ByteBuffer).messageDigest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,ByteBuffer).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,File)","Method","* Reads through a File and updates the digest for the data
     *
     * @param digest The MessageDigest to use (for example MD5)
     * @param data   Data to digest
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.11","public static MessageDigest updateDigest(final MessageDigest digest, final File data) throws IOException {
    try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(data))) {
        return updateDigest(digest, inputStream);
    }
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,File).digest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,File)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,File).data","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,File)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,FileChannel)","Method","* Reads through a RandomAccessFile and updates the digest for the data using non-blocking-io (NIO).
     *
     * TODO Decide if this should be public.
     *
     * @param digest The MessageDigest to use (for example MD5)
     * @param data   Data to digest
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.14","private static MessageDigest updateDigest(final MessageDigest digest, final FileChannel data) throws IOException {
    final ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);
    while (data.read(buffer) > 0) {
        buffer.flip();
        digest.update(buffer);
        buffer.clear();
    }
    return digest;
}","MessageDigest","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,FileChannel).digest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,FileChannel)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,FileChannel).data","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,FileChannel)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,InputStream)","Method","* Reads through an InputStream and updates the digest for the data
     *
     * @param digest      The MessageDigest to use (for example MD5)
     * @param inputStream Data to digest
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.8","public static MessageDigest updateDigest(final MessageDigest digest, final InputStream inputStream) throws IOException {
    final byte[] buffer = new byte[BUFFER_SIZE];
    int read = inputStream.read(buffer, 0, BUFFER_SIZE);
    while (read > -1) {
        digest.update(buffer, 0, read);
        read = inputStream.read(buffer, 0, BUFFER_SIZE);
    }
    return digest;
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,InputStream).digest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,InputStream).inputStream","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,Path,OpenOption[])","Method","* Reads through a Path and updates the digest for the data
     *
     * @param digest  The MessageDigest to use (for example MD5)
     * @param path    Data to digest
     * @param options options How to open the file
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.14","public static MessageDigest updateDigest(final MessageDigest digest, final Path path, final OpenOption... options) throws IOException {
    try (BufferedInputStream inputStream = new BufferedInputStream(Files.newInputStream(path, options))) {
        return updateDigest(digest, inputStream);
    }
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,Path,OpenOption[]).digest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,Path,OpenOption[]).path","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,Path,OpenOption[]).options","Parameter_3","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,RandomAccessFile)","Method","* Reads through a RandomAccessFile and updates the digest for the data using non-blocking-io (NIO)
     *
     * @param digest The MessageDigest to use (for example MD5)
     * @param data   Data to digest
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.14","// Closing RandomAccessFile closes the channel.
@SuppressWarnings(""resource"")
public static MessageDigest updateDigest(final MessageDigest digest, final RandomAccessFile data) throws IOException {
    return updateDigest(digest, data.getChannel());
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,RandomAccessFile).digest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,RandomAccessFile)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,RandomAccessFile).data","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,RandomAccessFile)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,String)","Method","* Updates the given {@link MessageDigest} from a String (converted to bytes using UTF-8).
     * <p>
     * To update the digest using a different charset for the conversion, convert the String to a byte array using
     * {@link String#getBytes(java.nio.charset.Charset)} and pass that to the {@link DigestUtils#updateDigest(MessageDigest, byte[])} method
     *
     * @param messageDigest the {@link MessageDigest} to update
     * @param valueToDigest the value to update the {@link MessageDigest} with; converted to bytes using {@link StringUtils#getBytesUtf8(String)}
     * @return the updated {@link MessageDigest}
     * @since 1.7","public static MessageDigest updateDigest(final MessageDigest messageDigest, final String valueToDigest) {
    messageDigest.update(StringUtils.getBytesUtf8(valueToDigest));
    return messageDigest;
}","MessageDigest","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,String).messageDigest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,String).valueToDigest","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.updateDigest(MessageDigest,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(byte[])","Method","* Reads through a byte array and returns the digest for the data.
     *
     * @param data Data to digest
     * @return the digest
     * @since 1.11","public byte[] digest(final byte[] data) {
    return updateDigest(messageDigest, data).digest();
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(ByteBuffer)","Method","* Reads through a ByteBuffer and returns the digest for the data
     *
     * @param data Data to digest
     * @return the digest
     * @since 1.11","public byte[] digest(final ByteBuffer data) {
    return updateDigest(messageDigest, data).digest();
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(ByteBuffer).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(File)","Method","* Reads through a File and returns the digest for the data
     *
     * @param data Data to digest
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.11","public byte[] digest(final File data) throws IOException {
    return updateDigest(messageDigest, data).digest();
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(File).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(File)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(InputStream)","Method","* Reads through an InputStream and returns the digest for the data
     *
     * @param data Data to digest
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.11","public byte[] digest(final InputStream data) throws IOException {
    return updateDigest(messageDigest, data).digest();
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(Path,OpenOption[])","Method","* Reads through a File and returns the digest for the data
     *
     * @param data    Data to digest
     * @param options options How to open the file
     * @return the digest
     * @throws IOException On error reading from the stream
     * @since 1.14","public byte[] digest(final Path data, final OpenOption... options) throws IOException {
    return updateDigest(messageDigest, data, options).digest();
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(Path,OpenOption[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(Path,OpenOption[]).options","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.digest(Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(String)","Method","* Reads through a byte array and returns the digest for the data.
     *
     * @param data Data to digest treated as UTF-8 string
     * @return the digest
     * @since 1.11","public byte[] digest(final String data) {
    return updateDigest(messageDigest, data).digest();
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digest(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digest(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(byte[])","Method","* Reads through a byte array and returns the digest for the data.
     *
     * @param data Data to digest
     * @return the digest as a hexadecimal string
     * @since 1.11","public String digestAsHex(final byte[] data) {
    return Hex.encodeHexString(digest(data));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digestAsHex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(ByteBuffer)","Method","* Reads through a ByteBuffer and returns the digest for the data
     *
     * @param data Data to digest
     * @return the digest as a hexadecimal string
     * @since 1.11","public String digestAsHex(final ByteBuffer data) {
    return Hex.encodeHexString(digest(data));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(ByteBuffer).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digestAsHex(ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(File)","Method","* Reads through a File and returns the digest for the data
     *
     * @param data Data to digest
     * @return the digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.11","public String digestAsHex(final File data) throws IOException {
    return Hex.encodeHexString(digest(data));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(File).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digestAsHex(File)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(InputStream)","Method","* Reads through an InputStream and returns the digest for the data
     *
     * @param data Data to digest
     * @return the digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.11","public String digestAsHex(final InputStream data) throws IOException {
    return Hex.encodeHexString(digest(data));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(InputStream).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digestAsHex(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(Path,OpenOption[])","Method","* Reads through a File and returns the digest for the data
     *
     * @param data    Data to digest
     * @param options options How to open the file
     * @return the digest as a hexadecimal string
     * @throws IOException On error reading from the stream
     * @since 1.11","public String digestAsHex(final Path data, final OpenOption... options) throws IOException {
    return Hex.encodeHexString(digest(data, options));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(Path,OpenOption[]).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digestAsHex(Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(Path,OpenOption[]).options","Parameter_2","Belong to org.apache.commons.codec.digest.DigestUtils.digestAsHex(Path,OpenOption[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(String)","Method","* Reads through a byte array and returns the digest for the data.
     *
     * @param data Data to digest treated as UTF-8 string
     * @return the digest as a hexadecimal string
     * @since 1.11","public String digestAsHex(final String data) {
    return Hex.encodeHexString(digest(data));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.digestAsHex(String).data","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.digestAsHex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.getMessageDigest()","Method","* Returns the message digest instance.
     *
     * @return the message digest instance
     * @since 1.11","public MessageDigest getMessageDigest() {
    return messageDigest;
}","MessageDigest","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.<init>()","Constructor","* Preserves binary compatibility only. As for previous versions does not provide useful behavior
     *
     * @deprecated since 1.11; only useful to preserve binary compatibility","@Deprecated
public DigestUtils() {
    this.messageDigest = null;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.<init>(MessageDigest)","Constructor","* Creates an instance using the provided {@link MessageDigest} parameter.
     *
     * This can then be used to create digests using methods such as {@link #digest(byte[])} and {@link #digestAsHex(File)}.
     *
     * @param digest the {@link MessageDigest} to use
     * @since 1.11","public DigestUtils(final MessageDigest digest) {
    this.messageDigest = digest;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.<init>(MessageDigest).digest","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.<init>(MessageDigest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.<init>(String)","Constructor","* Creates an instance using the provided {@link MessageDigest} parameter.
     *
     * This can then be used to create digests using methods such as {@link #digest(byte[])} and {@link #digestAsHex(File)}.
     *
     * @param name the name of the {@link MessageDigest} to use
     * @see #getDigest(String)
     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.
     * @since 1.11","public DigestUtils(final String name) {
    this(getDigest(name));
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.DigestUtils.<init>(String).name","Parameter_1","Belong to org.apache.commons.codec.digest.DigestUtils.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2","Class","* Implements the MurmurHash2 32-bit and 64-bit hash functions.
 *
 * <p>MurmurHash is a non-cryptographic hash function suitable for general
 * hash-based lookup. The name comes from two basic operations, multiply (MU)
 * and rotate (R), used in its inner loop. Unlike cryptographic hash functions,
 * it is not specifically designed to be difficult to reverse by an adversary,
 * making it unsuitable for cryptographic purposes.</p>
 *
 * <p>This contains a Java port of the 32-bit hash function {@code MurmurHash2}
 * and the 64-bit hash function {@code MurmurHash64A} from Austin Appleby's
 * original {@code c++} code in SMHasher.</p>
 *
 * <p>This is a re-implementation of the original C code plus some additional
 * features.</p>
 *
 * <p>This is public domain code with no copyrights. From home page of
 * <a href=""https://github.com/aappleby/smhasher"">SMHasher</a>:</p>
 *
 * <blockquote>
 * ""All MurmurHash versions are public domain software, and the author
 * disclaims all copyright to their code.""
 * </blockquote>
 *
 * @see <a href=""https://en.wikipedia.org/wiki/MurmurHash"">MurmurHash</a>
 * @see <a href=""https://github.com/aappleby/smhasher/blob/master/src/MurmurHash2.cpp"">
 *   Original MurmurHash2 c++ code</a>
 * @since 1.13","Class do not obtain Source Code","No return type","public , final ","",""
"org.apache.commons.codec.digest.MurmurHash2.M32","Field","Constants for 32-bit variant","private static final int M32 = 0x5bd1e995;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.R32","Field","No Comment","private static final int R32 = 24;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.M64","Field","Constants for 64-bit variant","private static final long M64 = 0xc6a4a7935bd1e995L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.R64","Field","No Comment","private static final int R64 = 47;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.getLittleEndianInt(byte[],int)","Method","* Gets the little-endian int from 4 bytes starting at the specified index.
     *
     * @param data The data
     * @param index The index
     * @return The little-endian int","private static int getLittleEndianInt(final byte[] data, final int index) {
    return data[index] & 0xff | (data[index + 1] & 0xff) << 8 | (data[index + 2] & 0xff) << 16 | (data[index + 3] & 0xff) << 24;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.getLittleEndianInt(byte[],int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.getLittleEndianInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.getLittleEndianInt(byte[],int).index","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash2.getLittleEndianInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.getLittleEndianLong(byte[],int)","Method","* Gets the little-endian long from 8 bytes starting at the specified index.
     *
     * @param data The data
     * @param index The index
     * @return The little-endian long","private static long getLittleEndianLong(final byte[] data, final int index) {
    return (long) data[index] & 0xff | ((long) data[index + 1] & 0xff) << 8 | ((long) data[index + 2] & 0xff) << 16 | ((long) data[index + 3] & 0xff) << 24 | ((long) data[index + 4] & 0xff) << 32 | ((long) data[index + 5] & 0xff) << 40 | ((long) data[index + 6] & 0xff) << 48 | ((long) data[index + 7] & 0xff) << 56;
}","long","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.getLittleEndianLong(byte[],int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.getLittleEndianLong(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.getLittleEndianLong(byte[],int).index","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash2.getLittleEndianLong(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int)","Method","* Generates a 32-bit hash from byte array with the given length and a default seed value.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int seed = 0x9747b28c;
     * int hash = MurmurHash2.hash32(data, length, seed);
     * </pre>
     *
     * @param data The input byte array
     * @param length The length of the array
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int)","public static int hash32(final byte[] data, final int length) {
    return hash32(data, length, 0x9747b28c);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int).length","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int,int)","Method","* Generates a 32-bit hash from byte array with the given length and seed.
     *
     * @param data The input byte array
     * @param length The length of the array
     * @param seed The initial seed value
     * @return The 32-bit hash","public static int hash32(final byte[] data, final int length, final int seed) {
    // Initialize the hash to a random value
    int h = seed ^ length;
    // Mix 4 bytes at a time into the hash
    final int nblocks = length >> 2;
    // body
    for (int i = 0; i < nblocks; i++) {
        final int index = i << 2;
        int k = getLittleEndianInt(data, index);
        k *= M32;
        k ^= k >>> R32;
        k *= M32;
        h *= M32;
        h ^= k;
    }
    // Handle the last few bytes of the input array
    final int index = nblocks << 2;
    switch(length - index) {
        case 3:
            h ^= (data[index + 2] & 0xff) << 16;
        // falls-through
        case 2:
            h ^= (data[index + 1] & 0xff) << 8;
        // falls-through
        case 1:
            h ^= data[index] & 0xff;
            h *= M32;
    }
    // Do a few final mixes of the hash to ensure the last few
    // bytes are well-incorporated.
    h ^= h >>> 13;
    h *= M32;
    h ^= h >>> 15;
    return h;
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int,int).length","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int,int).seed","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash2.hash32(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(String)","Method","* Generates a 32-bit hash from a string with a default seed.
     * <p>
     * Before 1.14 the string was converted using default encoding.
     * Since 1.14 the string is converted to bytes using UTF-8 encoding.
     * </p>
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int seed = 0x9747b28c;
     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);
     * int hash = MurmurHash2.hash32(bytes, bytes.length, seed);
     * </pre>
     *
     * @param text The input string
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int)","public static int hash32(final String text) {
    final byte[] bytes = StringUtils.getBytesUtf8(text);
    return hash32(bytes, bytes.length);
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(String).text","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.hash32(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(String,int,int)","Method","* Generates a 32-bit hash from a substring with a default seed value.
     * The string is converted to bytes using the default encoding.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int seed = 0x9747b28c;
     * byte[] bytes = text.substring(from, from + length).getBytes(StandardCharsets.UTF_8);
     * int hash = MurmurHash2.hash32(bytes, bytes.length, seed);
     * </pre>
     *
     * @param text The input string
     * @param from The starting index
     * @param length The length of the substring
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int)","public static int hash32(final String text, final int from, final int length) {
    return hash32(text.substring(from, from + length));
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(String,int,int).text","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.hash32(String,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(String,int,int).from","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash2.hash32(String,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash32(String,int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash2.hash32(String,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int)","Method","* Generates a 64-bit hash from byte array with given length and a default seed value.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int seed = 0xe17a1465;
     * int hash = MurmurHash2.hash64(data, length, seed);
     * </pre>
     *
     * @param data The input byte array
     * @param length The length of the array
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int)","public static long hash64(final byte[] data, final int length) {
    return hash64(data, length, 0xe17a1465);
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int).length","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int,int)","Method","* Generates a 64-bit hash from byte array of the given length and seed.
     *
     * @param data The input byte array
     * @param length The length of the array
     * @param seed The initial seed value
     * @return The 64-bit hash of the given array","public static long hash64(final byte[] data, final int length, final int seed) {
    long h = seed & 0xffffffffL ^ length * M64;
    final int nblocks = length >> 3;
    // body
    for (int i = 0; i < nblocks; i++) {
        final int index = i << 3;
        long k = getLittleEndianLong(data, index);
        k *= M64;
        k ^= k >>> R64;
        k *= M64;
        h ^= k;
        h *= M64;
    }
    final int index = nblocks << 3;
    switch(length - index) {
        case 7:
            h ^= ((long) data[index + 6] & 0xff) << 48;
        // falls-through
        case 6:
            h ^= ((long) data[index + 5] & 0xff) << 40;
        // falls-through
        case 5:
            h ^= ((long) data[index + 4] & 0xff) << 32;
        // falls-through
        case 4:
            h ^= ((long) data[index + 3] & 0xff) << 24;
        // falls-through
        case 3:
            h ^= ((long) data[index + 2] & 0xff) << 16;
        // falls-through
        case 2:
            h ^= ((long) data[index + 1] & 0xff) << 8;
        // falls-through
        case 1:
            h ^= (long) data[index] & 0xff;
            h *= M64;
    }
    h ^= h >>> R64;
    h *= M64;
    h ^= h >>> R64;
    return h;
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int,int).data","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int,int).length","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int,int).seed","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash2.hash64(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(String)","Method","* Generates a 64-bit hash from a string with a default seed.
     * <p>
     * Before 1.14 the string was converted using default encoding.
     * Since 1.14 the string is converted to bytes using UTF-8 encoding.
     * </p>
     * <p>
     * This is a helper method that will produce the same result as:
     * </p>
     *
     * <pre>
     * int seed = 0xe17a1465;
     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);
     * int hash = MurmurHash2.hash64(bytes, bytes.length, seed);
     * </pre>
     *
     * @param text The input string
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int)","public static long hash64(final String text) {
    final byte[] bytes = StringUtils.getBytesUtf8(text);
    return hash64(bytes, bytes.length);
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(String).text","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.hash64(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(String,int,int)","Method","* Generates a 64-bit hash from a substring with a default seed value.
     * The string is converted to bytes using the default encoding.
     * This is a helper method that will produce the same result as:
     *
     * <pre>
     * int seed = 0xe17a1465;
     * byte[] bytes = text.substring(from, from + length).getBytes(StandardCharsets.UTF_8);
     * int hash = MurmurHash2.hash64(bytes, bytes.length, seed);
     * </pre>
     *
     * @param text The input string
     * @param from The starting index
     * @param length The length of the substring
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int)","public static long hash64(final String text, final int from, final int length) {
    return hash64(text.substring(from, from + length));
}","long","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(String,int,int).text","Parameter_1","Belong to org.apache.commons.codec.digest.MurmurHash2.hash64(String,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(String,int,int).from","Parameter_2","Belong to org.apache.commons.codec.digest.MurmurHash2.hash64(String,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.hash64(String,int,int).length","Parameter_3","Belong to org.apache.commons.codec.digest.MurmurHash2.hash64(String,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.MurmurHash2.<init>()","Constructor","No instance methods.","private MurmurHash2() {
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C","Class","* A pure-Java implementation of the CRC32 checksum that uses the CRC32-C polynomial, the same polynomial used by iSCSI and implemented on many Intel chipsets
 * supporting SSE 4.2.
 *
 * <p>
 * Copied from Apache Hadoop 2.3.6: https://gitbox.apache.org/repos/asf?p=hadoop.git;a=blob_plain;
 * f=hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/PureJavaCrc32C.java; hb=2120de588b92b9f22b1cc4188761d6a8c61aa778
 * </p>
 * <p>
 * This class is Not ThreadSafe
 * </p>
 *
 * @since 1.11","Class do not obtain Source Code","No return type","public ","","java.util.zip.Checksum"
"org.apache.commons.codec.digest.PureJavaCrc32C.T8_0_START","Field","No Comment","private static final int T8_0_START = 0 * 256;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.T8_1_START","Field","No Comment","private static final int T8_1_START = 1 * 256;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.T8_2_START","Field","No Comment","private static final int T8_2_START = 2 * 256;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.T8_3_START","Field","No Comment","private static final int T8_3_START = 3 * 256;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.T8_4_START","Field","No Comment","private static final int T8_4_START = 4 * 256;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.T8_5_START","Field","No Comment","private static final int T8_5_START = 5 * 256;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.T8_6_START","Field","No Comment","private static final int T8_6_START = 6 * 256;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.T8_7_START","Field","No Comment","private static final int T8_7_START = 7 * 256;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.T","Field","@formatter:off","private static final int[] T = { /* T8_0 */
0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4, 0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB, 0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B, 0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24, 0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B, 0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384, 0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54, 0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B, 0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A, 0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35, 0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5, 0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA, 0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45, 0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A, 0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A, 0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595, 0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48, 0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957, 0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687, 0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198, 0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927, 0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38, 0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8, 0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7, 0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096, 0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789, 0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859, 0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46, 0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9, 0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6, 0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36, 0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829, 0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C, 0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93, 0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043, 0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C, 0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3, 0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC, 0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C, 0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033, 0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652, 0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D, 0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D, 0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982, 0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D, 0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622, 0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2, 0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED, 0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530, 0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F, 0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF, 0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0, 0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F, 0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540, 0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90, 0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F, 0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1, 0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E, 0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E, 0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351, /* T8_1 */
0x00000000, 0x13A29877, 0x274530EE, 0x34E7A899, 0x4E8A61DC, 0x5D28F9AB, 0x69CF5132, 0x7A6DC945, 0x9D14C3B8, 0x8EB65BCF, 0xBA51F356, 0xA9F36B21, 0xD39EA264, 0xC03C3A13, 0xF4DB928A, 0xE7790AFD, 0x3FC5F181, 0x2C6769F6, 0x1880C16F, 0x0B225918, 0x714F905D, 0x62ED082A, 0x560AA0B3, 0x45A838C4, 0xA2D13239, 0xB173AA4E, 0x859402D7, 0x96369AA0, 0xEC5B53E5, 0xFFF9CB92, 0xCB1E630B, 0xD8BCFB7C, 0x7F8BE302, 0x6C297B75, 0x58CED3EC, 0x4B6C4B9B, 0x310182DE, 0x22A31AA9, 0x1644B230, 0x05E62A47, 0xE29F20BA, 0xF13DB8CD, 0xC5DA1054, 0xD6788823, 0xAC154166, 0xBFB7D911, 0x8B507188, 0x98F2E9FF, 0x404E1283, 0x53EC8AF4, 0x670B226D, 0x74A9BA1A, 0x0EC4735F, 0x1D66EB28, 0x298143B1, 0x3A23DBC6, 0xDD5AD13B, 0xCEF8494C, 0xFA1FE1D5, 0xE9BD79A2, 0x93D0B0E7, 0x80722890, 0xB4958009, 0xA737187E, 0xFF17C604, 0xECB55E73, 0xD852F6EA, 0xCBF06E9D, 0xB19DA7D8, 0xA23F3FAF, 0x96D89736, 0x857A0F41, 0x620305BC, 0x71A19DCB, 0x45463552, 0x56E4AD25, 0x2C896460, 0x3F2BFC17, 0x0BCC548E, 0x186ECCF9, 0xC0D23785, 0xD370AFF2, 0xE797076B, 0xF4359F1C, 0x8E585659, 0x9DFACE2E, 0xA91D66B7, 0xBABFFEC0, 0x5DC6F43D, 0x4E646C4A, 0x7A83C4D3, 0x69215CA4, 0x134C95E1, 0x00EE0D96, 0x3409A50F, 0x27AB3D78, 0x809C2506, 0x933EBD71, 0xA7D915E8, 0xB47B8D9F, 0xCE1644DA, 0xDDB4DCAD, 0xE9537434, 0xFAF1EC43, 0x1D88E6BE, 0x0E2A7EC9, 0x3ACDD650, 0x296F4E27, 0x53028762, 0x40A01F15, 0x7447B78C, 0x67E52FFB, 0xBF59D487, 0xACFB4CF0, 0x981CE469, 0x8BBE7C1E, 0xF1D3B55B, 0xE2712D2C, 0xD69685B5, 0xC5341DC2, 0x224D173F, 0x31EF8F48, 0x050827D1, 0x16AABFA6, 0x6CC776E3, 0x7F65EE94, 0x4B82460D, 0x5820DE7A, 0xFBC3FAF9, 0xE861628E, 0xDC86CA17, 0xCF245260, 0xB5499B25, 0xA6EB0352, 0x920CABCB, 0x81AE33BC, 0x66D73941, 0x7575A136, 0x419209AF, 0x523091D8, 0x285D589D, 0x3BFFC0EA, 0x0F186873, 0x1CBAF004, 0xC4060B78, 0xD7A4930F, 0xE3433B96, 0xF0E1A3E1, 0x8A8C6AA4, 0x992EF2D3, 0xADC95A4A, 0xBE6BC23D, 0x5912C8C0, 0x4AB050B7, 0x7E57F82E, 0x6DF56059, 0x1798A91C, 0x043A316B, 0x30DD99F2, 0x237F0185, 0x844819FB, 0x97EA818C, 0xA30D2915, 0xB0AFB162, 0xCAC27827, 0xD960E050, 0xED8748C9, 0xFE25D0BE, 0x195CDA43, 0x0AFE4234, 0x3E19EAAD, 0x2DBB72DA, 0x57D6BB9F, 0x447423E8, 0x70938B71, 0x63311306, 0xBB8DE87A, 0xA82F700D, 0x9CC8D894, 0x8F6A40E3, 0xF50789A6, 0xE6A511D1, 0xD242B948, 0xC1E0213F, 0x26992BC2, 0x353BB3B5, 0x01DC1B2C, 0x127E835B, 0x68134A1E, 0x7BB1D269, 0x4F567AF0, 0x5CF4E287, 0x04D43CFD, 0x1776A48A, 0x23910C13, 0x30339464, 0x4A5E5D21, 0x59FCC556, 0x6D1B6DCF, 0x7EB9F5B8, 0x99C0FF45, 0x8A626732, 0xBE85CFAB, 0xAD2757DC, 0xD74A9E99, 0xC4E806EE, 0xF00FAE77, 0xE3AD3600, 0x3B11CD7C, 0x28B3550B, 0x1C54FD92, 0x0FF665E5, 0x759BACA0, 0x663934D7, 0x52DE9C4E, 0x417C0439, 0xA6050EC4, 0xB5A796B3, 0x81403E2A, 0x92E2A65D, 0xE88F6F18, 0xFB2DF76F, 0xCFCA5FF6, 0xDC68C781, 0x7B5FDFFF, 0x68FD4788, 0x5C1AEF11, 0x4FB87766, 0x35D5BE23, 0x26772654, 0x12908ECD, 0x013216BA, 0xE64B1C47, 0xF5E98430, 0xC10E2CA9, 0xD2ACB4DE, 0xA8C17D9B, 0xBB63E5EC, 0x8F844D75, 0x9C26D502, 0x449A2E7E, 0x5738B609, 0x63DF1E90, 0x707D86E7, 0x0A104FA2, 0x19B2D7D5, 0x2D557F4C, 0x3EF7E73B, 0xD98EEDC6, 0xCA2C75B1, 0xFECBDD28, 0xED69455F, 0x97048C1A, 0x84A6146D, 0xB041BCF4, 0xA3E32483, /* T8_2 */
0x00000000, 0xA541927E, 0x4F6F520D, 0xEA2EC073, 0x9EDEA41A, 0x3B9F3664, 0xD1B1F617, 0x74F06469, 0x38513EC5, 0x9D10ACBB, 0x773E6CC8, 0xD27FFEB6, 0xA68F9ADF, 0x03CE08A1, 0xE9E0C8D2, 0x4CA15AAC, 0x70A27D8A, 0xD5E3EFF4, 0x3FCD2F87, 0x9A8CBDF9, 0xEE7CD990, 0x4B3D4BEE, 0xA1138B9D, 0x045219E3, 0x48F3434F, 0xEDB2D131, 0x079C1142, 0xA2DD833C, 0xD62DE755, 0x736C752B, 0x9942B558, 0x3C032726, 0xE144FB14, 0x4405696A, 0xAE2BA919, 0x0B6A3B67, 0x7F9A5F0E, 0xDADBCD70, 0x30F50D03, 0x95B49F7D, 0xD915C5D1, 0x7C5457AF, 0x967A97DC, 0x333B05A2, 0x47CB61CB, 0xE28AF3B5, 0x08A433C6, 0xADE5A1B8, 0x91E6869E, 0x34A714E0, 0xDE89D493, 0x7BC846ED, 0x0F382284, 0xAA79B0FA, 0x40577089, 0xE516E2F7, 0xA9B7B85B, 0x0CF62A25, 0xE6D8EA56, 0x43997828, 0x37691C41, 0x92288E3F, 0x78064E4C, 0xDD47DC32, 0xC76580D9, 0x622412A7, 0x880AD2D4, 0x2D4B40AA, 0x59BB24C3, 0xFCFAB6BD, 0x16D476CE, 0xB395E4B0, 0xFF34BE1C, 0x5A752C62, 0xB05BEC11, 0x151A7E6F, 0x61EA1A06, 0xC4AB8878, 0x2E85480B, 0x8BC4DA75, 0xB7C7FD53, 0x12866F2D, 0xF8A8AF5E, 0x5DE93D20, 0x29195949, 0x8C58CB37, 0x66760B44, 0xC337993A, 0x8F96C396, 0x2AD751E8, 0xC0F9919B, 0x65B803E5, 0x1148678C, 0xB409F5F2, 0x5E273581, 0xFB66A7FF, 0x26217BCD, 0x8360E9B3, 0x694E29C0, 0xCC0FBBBE, 0xB8FFDFD7, 0x1DBE4DA9, 0xF7908DDA, 0x52D11FA4, 0x1E704508, 0xBB31D776, 0x511F1705, 0xF45E857B, 0x80AEE112, 0x25EF736C, 0xCFC1B31F, 0x6A802161, 0x56830647, 0xF3C29439, 0x19EC544A, 0xBCADC634, 0xC85DA25D, 0x6D1C3023, 0x8732F050, 0x2273622E, 0x6ED23882, 0xCB93AAFC, 0x21BD6A8F, 0x84FCF8F1, 0xF00C9C98, 0x554D0EE6, 0xBF63CE95, 0x1A225CEB, 0x8B277743, 0x2E66E53D, 0xC448254E, 0x6109B730, 0x15F9D359, 0xB0B84127, 0x5A968154, 0xFFD7132A, 0xB3764986, 0x1637DBF8, 0xFC191B8B, 0x595889F5, 0x2DA8ED9C, 0x88E97FE2, 0x62C7BF91, 0xC7862DEF, 0xFB850AC9, 0x5EC498B7, 0xB4EA58C4, 0x11ABCABA, 0x655BAED3, 0xC01A3CAD, 0x2A34FCDE, 0x8F756EA0, 0xC3D4340C, 0x6695A672, 0x8CBB6601, 0x29FAF47F, 0x5D0A9016, 0xF84B0268, 0x1265C21B, 0xB7245065, 0x6A638C57, 0xCF221E29, 0x250CDE5A, 0x804D4C24, 0xF4BD284D, 0x51FCBA33, 0xBBD27A40, 0x1E93E83E, 0x5232B292, 0xF77320EC, 0x1D5DE09F, 0xB81C72E1, 0xCCEC1688, 0x69AD84F6, 0x83834485, 0x26C2D6FB, 0x1AC1F1DD, 0xBF8063A3, 0x55AEA3D0, 0xF0EF31AE, 0x841F55C7, 0x215EC7B9, 0xCB7007CA, 0x6E3195B4, 0x2290CF18, 0x87D15D66, 0x6DFF9D15, 0xC8BE0F6B, 0xBC4E6B02, 0x190FF97C, 0xF321390F, 0x5660AB71, 0x4C42F79A, 0xE90365E4, 0x032DA597, 0xA66C37E9, 0xD29C5380, 0x77DDC1FE, 0x9DF3018D, 0x38B293F3, 0x7413C95F, 0xD1525B21, 0x3B7C9B52, 0x9E3D092C, 0xEACD6D45, 0x4F8CFF3B, 0xA5A23F48, 0x00E3AD36, 0x3CE08A10, 0x99A1186E, 0x738FD81D, 0xD6CE4A63, 0xA23E2E0A, 0x077FBC74, 0xED517C07, 0x4810EE79, 0x04B1B4D5, 0xA1F026AB, 0x4BDEE6D8, 0xEE9F74A6, 0x9A6F10CF, 0x3F2E82B1, 0xD50042C2, 0x7041D0BC, 0xAD060C8E, 0x08479EF0, 0xE2695E83, 0x4728CCFD, 0x33D8A894, 0x96993AEA, 0x7CB7FA99, 0xD9F668E7, 0x9557324B, 0x3016A035, 0xDA386046, 0x7F79F238, 0x0B899651, 0xAEC8042F, 0x44E6C45C, 0xE1A75622, 0xDDA47104, 0x78E5E37A, 0x92CB2309, 0x378AB177, 0x437AD51E, 0xE63B4760, 0x0C158713, 0xA954156D, 0xE5F54FC1, 0x40B4DDBF, 0xAA9A1DCC, 0x0FDB8FB2, 0x7B2BEBDB, 0xDE6A79A5, 0x3444B9D6, 0x91052BA8, /* T8_3 */
0x00000000, 0xDD45AAB8, 0xBF672381, 0x62228939, 0x7B2231F3, 0xA6679B4B, 0xC4451272, 0x1900B8CA, 0xF64463E6, 0x2B01C95E, 0x49234067, 0x9466EADF, 0x8D665215, 0x5023F8AD, 0x32017194, 0xEF44DB2C, 0xE964B13D, 0x34211B85, 0x560392BC, 0x8B463804, 0x924680CE, 0x4F032A76, 0x2D21A34F, 0xF06409F7, 0x1F20D2DB, 0xC2657863, 0xA047F15A, 0x7D025BE2, 0x6402E328, 0xB9474990, 0xDB65C0A9, 0x06206A11, 0xD725148B, 0x0A60BE33, 0x6842370A, 0xB5079DB2, 0xAC072578, 0x71428FC0, 0x136006F9, 0xCE25AC41, 0x2161776D, 0xFC24DDD5, 0x9E0654EC, 0x4343FE54, 0x5A43469E, 0x8706EC26, 0xE524651F, 0x3861CFA7, 0x3E41A5B6, 0xE3040F0E, 0x81268637, 0x5C632C8F, 0x45639445, 0x98263EFD, 0xFA04B7C4, 0x27411D7C, 0xC805C650, 0x15406CE8, 0x7762E5D1, 0xAA274F69, 0xB327F7A3, 0x6E625D1B, 0x0C40D422, 0xD1057E9A, 0xABA65FE7, 0x76E3F55F, 0x14C17C66, 0xC984D6DE, 0xD0846E14, 0x0DC1C4AC, 0x6FE34D95, 0xB2A6E72D, 0x5DE23C01, 0x80A796B9, 0xE2851F80, 0x3FC0B538, 0x26C00DF2, 0xFB85A74A, 0x99A72E73, 0x44E284CB, 0x42C2EEDA, 0x9F874462, 0xFDA5CD5B, 0x20E067E3, 0x39E0DF29, 0xE4A57591, 0x8687FCA8, 0x5BC25610, 0xB4868D3C, 0x69C32784, 0x0BE1AEBD, 0xD6A40405, 0xCFA4BCCF, 0x12E11677, 0x70C39F4E, 0xAD8635F6, 0x7C834B6C, 0xA1C6E1D4, 0xC3E468ED, 0x1EA1C255, 0x07A17A9F, 0xDAE4D027, 0xB8C6591E, 0x6583F3A6, 0x8AC7288A, 0x57828232, 0x35A00B0B, 0xE8E5A1B3, 0xF1E51979, 0x2CA0B3C1, 0x4E823AF8, 0x93C79040, 0x95E7FA51, 0x48A250E9, 0x2A80D9D0, 0xF7C57368, 0xEEC5CBA2, 0x3380611A, 0x51A2E823, 0x8CE7429B, 0x63A399B7, 0xBEE6330F, 0xDCC4BA36, 0x0181108E, 0x1881A844, 0xC5C402FC, 0xA7E68BC5, 0x7AA3217D, 0x52A0C93F, 0x8FE56387, 0xEDC7EABE, 0x30824006, 0x2982F8CC, 0xF4C75274, 0x96E5DB4D, 0x4BA071F5, 0xA4E4AAD9, 0x79A10061, 0x1B838958, 0xC6C623E0, 0xDFC69B2A, 0x02833192, 0x60A1B8AB, 0xBDE41213, 0xBBC47802, 0x6681D2BA, 0x04A35B83, 0xD9E6F13B, 0xC0E649F1, 0x1DA3E349, 0x7F816A70, 0xA2C4C0C8, 0x4D801BE4, 0x90C5B15C, 0xF2E73865, 0x2FA292DD, 0x36A22A17, 0xEBE780AF, 0x89C50996, 0x5480A32E, 0x8585DDB4, 0x58C0770C, 0x3AE2FE35, 0xE7A7548D, 0xFEA7EC47, 0x23E246FF, 0x41C0CFC6, 0x9C85657E, 0x73C1BE52, 0xAE8414EA, 0xCCA69DD3, 0x11E3376B, 0x08E38FA1, 0xD5A62519, 0xB784AC20, 0x6AC10698, 0x6CE16C89, 0xB1A4C631, 0xD3864F08, 0x0EC3E5B0, 0x17C35D7A, 0xCA86F7C2, 0xA8A47EFB, 0x75E1D443, 0x9AA50F6F, 0x47E0A5D7, 0x25C22CEE, 0xF8878656, 0xE1873E9C, 0x3CC29424, 0x5EE01D1D, 0x83A5B7A5, 0xF90696D8, 0x24433C60, 0x4661B559, 0x9B241FE1, 0x8224A72B, 0x5F610D93, 0x3D4384AA, 0xE0062E12, 0x0F42F53E, 0xD2075F86, 0xB025D6BF, 0x6D607C07, 0x7460C4CD, 0xA9256E75, 0xCB07E74C, 0x16424DF4, 0x106227E5, 0xCD278D5D, 0xAF050464, 0x7240AEDC, 0x6B401616, 0xB605BCAE, 0xD4273597, 0x09629F2F, 0xE6264403, 0x3B63EEBB, 0x59416782, 0x8404CD3A, 0x9D0475F0, 0x4041DF48, 0x22635671, 0xFF26FCC9, 0x2E238253, 0xF36628EB, 0x9144A1D2, 0x4C010B6A, 0x5501B3A0, 0x88441918, 0xEA669021, 0x37233A99, 0xD867E1B5, 0x05224B0D, 0x6700C234, 0xBA45688C, 0xA345D046, 0x7E007AFE, 0x1C22F3C7, 0xC167597F, 0xC747336E, 0x1A0299D6, 0x782010EF, 0xA565BA57, 0xBC65029D, 0x6120A825, 0x0302211C, 0xDE478BA4, 0x31035088, 0xEC46FA30, 0x8E647309, 0x5321D9B1, 0x4A21617B, 0x9764CBC3, 0xF54642FA, 0x2803E842, /* T8_4 */
0x00000000, 0x38116FAC, 0x7022DF58, 0x4833B0F4, 0xE045BEB0, 0xD854D11C, 0x906761E8, 0xA8760E44, 0xC5670B91, 0xFD76643D, 0xB545D4C9, 0x8D54BB65, 0x2522B521, 0x1D33DA8D, 0x55006A79, 0x6D1105D5, 0x8F2261D3, 0xB7330E7F, 0xFF00BE8B, 0xC711D127, 0x6F67DF63, 0x5776B0CF, 0x1F45003B, 0x27546F97, 0x4A456A42, 0x725405EE, 0x3A67B51A, 0x0276DAB6, 0xAA00D4F2, 0x9211BB5E, 0xDA220BAA, 0xE2336406, 0x1BA8B557, 0x23B9DAFB, 0x6B8A6A0F, 0x539B05A3, 0xFBED0BE7, 0xC3FC644B, 0x8BCFD4BF, 0xB3DEBB13, 0xDECFBEC6, 0xE6DED16A, 0xAEED619E, 0x96FC0E32, 0x3E8A0076, 0x069B6FDA, 0x4EA8DF2E, 0x76B9B082, 0x948AD484, 0xAC9BBB28, 0xE4A80BDC, 0xDCB96470, 0x74CF6A34, 0x4CDE0598, 0x04EDB56C, 0x3CFCDAC0, 0x51EDDF15, 0x69FCB0B9, 0x21CF004D, 0x19DE6FE1, 0xB1A861A5, 0x89B90E09, 0xC18ABEFD, 0xF99BD151, 0x37516AAE, 0x0F400502, 0x4773B5F6, 0x7F62DA5A, 0xD714D41E, 0xEF05BBB2, 0xA7360B46, 0x9F2764EA, 0xF236613F, 0xCA270E93, 0x8214BE67, 0xBA05D1CB, 0x1273DF8F, 0x2A62B023, 0x625100D7, 0x5A406F7B, 0xB8730B7D, 0x806264D1, 0xC851D425, 0xF040BB89, 0x5836B5CD, 0x6027DA61, 0x28146A95, 0x10050539, 0x7D1400EC, 0x45056F40, 0x0D36DFB4, 0x3527B018, 0x9D51BE5C, 0xA540D1F0, 0xED736104, 0xD5620EA8, 0x2CF9DFF9, 0x14E8B055, 0x5CDB00A1, 0x64CA6F0D, 0xCCBC6149, 0xF4AD0EE5, 0xBC9EBE11, 0x848FD1BD, 0xE99ED468, 0xD18FBBC4, 0x99BC0B30, 0xA1AD649C, 0x09DB6AD8, 0x31CA0574, 0x79F9B580, 0x41E8DA2C, 0xA3DBBE2A, 0x9BCAD186, 0xD3F96172, 0xEBE80EDE, 0x439E009A, 0x7B8F6F36, 0x33BCDFC2, 0x0BADB06E, 0x66BCB5BB, 0x5EADDA17, 0x169E6AE3, 0x2E8F054F, 0x86F90B0B, 0xBEE864A7, 0xF6DBD453, 0xCECABBFF, 0x6EA2D55C, 0x56B3BAF0, 0x1E800A04, 0x269165A8, 0x8EE76BEC, 0xB6F60440, 0xFEC5B4B4, 0xC6D4DB18, 0xABC5DECD, 0x93D4B161, 0xDBE70195, 0xE3F66E39, 0x4B80607D, 0x73910FD1, 0x3BA2BF25, 0x03B3D089, 0xE180B48F, 0xD991DB23, 0x91A26BD7, 0xA9B3047B, 0x01C50A3F, 0x39D46593, 0x71E7D567, 0x49F6BACB, 0x24E7BF1E, 0x1CF6D0B2, 0x54C56046, 0x6CD40FEA, 0xC4A201AE, 0xFCB36E02, 0xB480DEF6, 0x8C91B15A, 0x750A600B, 0x4D1B0FA7, 0x0528BF53, 0x3D39D0FF, 0x954FDEBB, 0xAD5EB117, 0xE56D01E3, 0xDD7C6E4F, 0xB06D6B9A, 0x887C0436, 0xC04FB4C2, 0xF85EDB6E, 0x5028D52A, 0x6839BA86, 0x200A0A72, 0x181B65DE, 0xFA2801D8, 0xC2396E74, 0x8A0ADE80, 0xB21BB12C, 0x1A6DBF68, 0x227CD0C4, 0x6A4F6030, 0x525E0F9C, 0x3F4F0A49, 0x075E65E5, 0x4F6DD511, 0x777CBABD, 0xDF0AB4F9, 0xE71BDB55, 0xAF286BA1, 0x9739040D, 0x59F3BFF2, 0x61E2D05E, 0x29D160AA, 0x11C00F06, 0xB9B60142, 0x81A76EEE, 0xC994DE1A, 0xF185B1B6, 0x9C94B463, 0xA485DBCF, 0xECB66B3B, 0xD4A70497, 0x7CD10AD3, 0x44C0657F, 0x0CF3D58B, 0x34E2BA27, 0xD6D1DE21, 0xEEC0B18D, 0xA6F30179, 0x9EE26ED5, 0x36946091, 0x0E850F3D, 0x46B6BFC9, 0x7EA7D065, 0x13B6D5B0, 0x2BA7BA1C, 0x63940AE8, 0x5B856544, 0xF3F36B00, 0xCBE204AC, 0x83D1B458, 0xBBC0DBF4, 0x425B0AA5, 0x7A4A6509, 0x3279D5FD, 0x0A68BA51, 0xA21EB415, 0x9A0FDBB9, 0xD23C6B4D, 0xEA2D04E1, 0x873C0134, 0xBF2D6E98, 0xF71EDE6C, 0xCF0FB1C0, 0x6779BF84, 0x5F68D028, 0x175B60DC, 0x2F4A0F70, 0xCD796B76, 0xF56804DA, 0xBD5BB42E, 0x854ADB82, 0x2D3CD5C6, 0x152DBA6A, 0x5D1E0A9E, 0x650F6532, 0x081E60E7, 0x300F0F4B, 0x783CBFBF, 0x402DD013, 0xE85BDE57, 0xD04AB1FB, 0x9879010F, 0xA0686EA3, /* T8_5 */
0x00000000, 0xEF306B19, 0xDB8CA0C3, 0x34BCCBDA, 0xB2F53777, 0x5DC55C6E, 0x697997B4, 0x8649FCAD, 0x6006181F, 0x8F367306, 0xBB8AB8DC, 0x54BAD3C5, 0xD2F32F68, 0x3DC34471, 0x097F8FAB, 0xE64FE4B2, 0xC00C303E, 0x2F3C5B27, 0x1B8090FD, 0xF4B0FBE4, 0x72F90749, 0x9DC96C50, 0xA975A78A, 0x4645CC93, 0xA00A2821, 0x4F3A4338, 0x7B8688E2, 0x94B6E3FB, 0x12FF1F56, 0xFDCF744F, 0xC973BF95, 0x2643D48C, 0x85F4168D, 0x6AC47D94, 0x5E78B64E, 0xB148DD57, 0x370121FA, 0xD8314AE3, 0xEC8D8139, 0x03BDEA20, 0xE5F20E92, 0x0AC2658B, 0x3E7EAE51, 0xD14EC548, 0x570739E5, 0xB83752FC, 0x8C8B9926, 0x63BBF23F, 0x45F826B3, 0xAAC84DAA, 0x9E748670, 0x7144ED69, 0xF70D11C4, 0x183D7ADD, 0x2C81B107, 0xC3B1DA1E, 0x25FE3EAC, 0xCACE55B5, 0xFE729E6F, 0x1142F576, 0x970B09DB, 0x783B62C2, 0x4C87A918, 0xA3B7C201, 0x0E045BEB, 0xE13430F2, 0xD588FB28, 0x3AB89031, 0xBCF16C9C, 0x53C10785, 0x677DCC5F, 0x884DA746, 0x6E0243F4, 0x813228ED, 0xB58EE337, 0x5ABE882E, 0xDCF77483, 0x33C71F9A, 0x077BD440, 0xE84BBF59, 0xCE086BD5, 0x213800CC, 0x1584CB16, 0xFAB4A00F, 0x7CFD5CA2, 0x93CD37BB, 0xA771FC61, 0x48419778, 0xAE0E73CA, 0x413E18D3, 0x7582D309, 0x9AB2B810, 0x1CFB44BD, 0xF3CB2FA4, 0xC777E47E, 0x28478F67, 0x8BF04D66, 0x64C0267F, 0x507CEDA5, 0xBF4C86BC, 0x39057A11, 0xD6351108, 0xE289DAD2, 0x0DB9B1CB, 0xEBF65579, 0x04C63E60, 0x307AF5BA, 0xDF4A9EA3, 0x5903620E, 0xB6330917, 0x828FC2CD, 0x6DBFA9D4, 0x4BFC7D58, 0xA4CC1641, 0x9070DD9B, 0x7F40B682, 0xF9094A2F, 0x16392136, 0x2285EAEC, 0xCDB581F5, 0x2BFA6547, 0xC4CA0E5E, 0xF076C584, 0x1F46AE9D, 0x990F5230, 0x763F3929, 0x4283F2F3, 0xADB399EA, 0x1C08B7D6, 0xF338DCCF, 0xC7841715, 0x28B47C0C, 0xAEFD80A1, 0x41CDEBB8, 0x75712062, 0x9A414B7B, 0x7C0EAFC9, 0x933EC4D0, 0xA7820F0A, 0x48B26413, 0xCEFB98BE, 0x21CBF3A7, 0x1577387D, 0xFA475364, 0xDC0487E8, 0x3334ECF1, 0x0788272B, 0xE8B84C32, 0x6EF1B09F, 0x81C1DB86, 0xB57D105C, 0x5A4D7B45, 0xBC029FF7, 0x5332F4EE, 0x678E3F34, 0x88BE542D, 0x0EF7A880, 0xE1C7C399, 0xD57B0843, 0x3A4B635A, 0x99FCA15B, 0x76CCCA42, 0x42700198, 0xAD406A81, 0x2B09962C, 0xC439FD35, 0xF08536EF, 0x1FB55DF6, 0xF9FAB944, 0x16CAD25D, 0x22761987, 0xCD46729E, 0x4B0F8E33, 0xA43FE52A, 0x90832EF0, 0x7FB345E9, 0x59F09165, 0xB6C0FA7C, 0x827C31A6, 0x6D4C5ABF, 0xEB05A612, 0x0435CD0B, 0x308906D1, 0xDFB96DC8, 0x39F6897A, 0xD6C6E263, 0xE27A29B9, 0x0D4A42A0, 0x8B03BE0D, 0x6433D514, 0x508F1ECE, 0xBFBF75D7, 0x120CEC3D, 0xFD3C8724, 0xC9804CFE, 0x26B027E7, 0xA0F9DB4A, 0x4FC9B053, 0x7B757B89, 0x94451090, 0x720AF422, 0x9D3A9F3B, 0xA98654E1, 0x46B63FF8, 0xC0FFC355, 0x2FCFA84C, 0x1B736396, 0xF443088F, 0xD200DC03, 0x3D30B71A, 0x098C7CC0, 0xE6BC17D9, 0x60F5EB74, 0x8FC5806D, 0xBB794BB7, 0x544920AE, 0xB206C41C, 0x5D36AF05, 0x698A64DF, 0x86BA0FC6, 0x00F3F36B, 0xEFC39872, 0xDB7F53A8, 0x344F38B1, 0x97F8FAB0, 0x78C891A9, 0x4C745A73, 0xA344316A, 0x250DCDC7, 0xCA3DA6DE, 0xFE816D04, 0x11B1061D, 0xF7FEE2AF, 0x18CE89B6, 0x2C72426C, 0xC3422975, 0x450BD5D8, 0xAA3BBEC1, 0x9E87751B, 0x71B71E02, 0x57F4CA8E, 0xB8C4A197, 0x8C786A4D, 0x63480154, 0xE501FDF9, 0x0A3196E0, 0x3E8D5D3A, 0xD1BD3623, 0x37F2D291, 0xD8C2B988, 0xEC7E7252, 0x034E194B, 0x8507E5E6, 0x6A378EFF, 0x5E8B4525, 0xB1BB2E3C, /* T8_6 */
0x00000000, 0x68032CC8, 0xD0065990, 0xB8057558, 0xA5E0C5D1, 0xCDE3E919, 0x75E69C41, 0x1DE5B089, 0x4E2DFD53, 0x262ED19B, 0x9E2BA4C3, 0xF628880B, 0xEBCD3882, 0x83CE144A, 0x3BCB6112, 0x53C84DDA, 0x9C5BFAA6, 0xF458D66E, 0x4C5DA336, 0x245E8FFE, 0x39BB3F77, 0x51B813BF, 0xE9BD66E7, 0x81BE4A2F, 0xD27607F5, 0xBA752B3D, 0x02705E65, 0x6A7372AD, 0x7796C224, 0x1F95EEEC, 0xA7909BB4, 0xCF93B77C, 0x3D5B83BD, 0x5558AF75, 0xED5DDA2D, 0x855EF6E5, 0x98BB466C, 0xF0B86AA4, 0x48BD1FFC, 0x20BE3334, 0x73767EEE, 0x1B755226, 0xA370277E, 0xCB730BB6, 0xD696BB3F, 0xBE9597F7, 0x0690E2AF, 0x6E93CE67, 0xA100791B, 0xC90355D3, 0x7106208B, 0x19050C43, 0x04E0BCCA, 0x6CE39002, 0xD4E6E55A, 0xBCE5C992, 0xEF2D8448, 0x872EA880, 0x3F2BDDD8, 0x5728F110, 0x4ACD4199, 0x22CE6D51, 0x9ACB1809, 0xF2C834C1, 0x7AB7077A, 0x12B42BB2, 0xAAB15EEA, 0xC2B27222, 0xDF57C2AB, 0xB754EE63, 0x0F519B3B, 0x6752B7F3, 0x349AFA29, 0x5C99D6E1, 0xE49CA3B9, 0x8C9F8F71, 0x917A3FF8, 0xF9791330, 0x417C6668, 0x297F4AA0, 0xE6ECFDDC, 0x8EEFD114, 0x36EAA44C, 0x5EE98884, 0x430C380D, 0x2B0F14C5, 0x930A619D, 0xFB094D55, 0xA8C1008F, 0xC0C22C47, 0x78C7591F, 0x10C475D7, 0x0D21C55E, 0x6522E996, 0xDD279CCE, 0xB524B006, 0x47EC84C7, 0x2FEFA80F, 0x97EADD57, 0xFFE9F19F, 0xE20C4116, 0x8A0F6DDE, 0x320A1886, 0x5A09344E, 0x09C17994, 0x61C2555C, 0xD9C72004, 0xB1C40CCC, 0xAC21BC45, 0xC422908D, 0x7C27E5D5, 0x1424C91D, 0xDBB77E61, 0xB3B452A9, 0x0BB127F1, 0x63B20B39, 0x7E57BBB0, 0x16549778, 0xAE51E220, 0xC652CEE8, 0x959A8332, 0xFD99AFFA, 0x459CDAA2, 0x2D9FF66A, 0x307A46E3, 0x58796A2B, 0xE07C1F73, 0x887F33BB, 0xF56E0EF4, 0x9D6D223C, 0x25685764, 0x4D6B7BAC, 0x508ECB25, 0x388DE7ED, 0x808892B5, 0xE88BBE7D, 0xBB43F3A7, 0xD340DF6F, 0x6B45AA37, 0x034686FF, 0x1EA33676, 0x76A01ABE, 0xCEA56FE6, 0xA6A6432E, 0x6935F452, 0x0136D89A, 0xB933ADC2, 0xD130810A, 0xCCD53183, 0xA4D61D4B, 0x1CD36813, 0x74D044DB, 0x27180901, 0x4F1B25C9, 0xF71E5091, 0x9F1D7C59, 0x82F8CCD0, 0xEAFBE018, 0x52FE9540, 0x3AFDB988, 0xC8358D49, 0xA036A181, 0x1833D4D9, 0x7030F811, 0x6DD54898, 0x05D66450, 0xBDD31108, 0xD5D03DC0, 0x8618701A, 0xEE1B5CD2, 0x561E298A, 0x3E1D0542, 0x23F8B5CB, 0x4BFB9903, 0xF3FEEC5B, 0x9BFDC093, 0x546E77EF, 0x3C6D5B27, 0x84682E7F, 0xEC6B02B7, 0xF18EB23E, 0x998D9EF6, 0x2188EBAE, 0x498BC766, 0x1A438ABC, 0x7240A674, 0xCA45D32C, 0xA246FFE4, 0xBFA34F6D, 0xD7A063A5, 0x6FA516FD, 0x07A63A35, 0x8FD9098E, 0xE7DA2546, 0x5FDF501E, 0x37DC7CD6, 0x2A39CC5F, 0x423AE097, 0xFA3F95CF, 0x923CB907, 0xC1F4F4DD, 0xA9F7D815, 0x11F2AD4D, 0x79F18185, 0x6414310C, 0x0C171DC4, 0xB412689C, 0xDC114454, 0x1382F328, 0x7B81DFE0, 0xC384AAB8, 0xAB878670, 0xB66236F9, 0xDE611A31, 0x66646F69, 0x0E6743A1, 0x5DAF0E7B, 0x35AC22B3, 0x8DA957EB, 0xE5AA7B23, 0xF84FCBAA, 0x904CE762, 0x2849923A, 0x404ABEF2, 0xB2828A33, 0xDA81A6FB, 0x6284D3A3, 0x0A87FF6B, 0x17624FE2, 0x7F61632A, 0xC7641672, 0xAF673ABA, 0xFCAF7760, 0x94AC5BA8, 0x2CA92EF0, 0x44AA0238, 0x594FB2B1, 0x314C9E79, 0x8949EB21, 0xE14AC7E9, 0x2ED97095, 0x46DA5C5D, 0xFEDF2905, 0x96DC05CD, 0x8B39B544, 0xE33A998C, 0x5B3FECD4, 0x333CC01C, 0x60F48DC6, 0x08F7A10E, 0xB0F2D456, 0xD8F1F89E, 0xC5144817, 0xAD1764DF, 0x15121187, 0x7D113D4F, /* T8_7 */
0x00000000, 0x493C7D27, 0x9278FA4E, 0xDB448769, 0x211D826D, 0x6821FF4A, 0xB3657823, 0xFA590504, 0x423B04DA, 0x0B0779FD, 0xD043FE94, 0x997F83B3, 0x632686B7, 0x2A1AFB90, 0xF15E7CF9, 0xB86201DE, 0x847609B4, 0xCD4A7493, 0x160EF3FA, 0x5F328EDD, 0xA56B8BD9, 0xEC57F6FE, 0x37137197, 0x7E2F0CB0, 0xC64D0D6E, 0x8F717049, 0x5435F720, 0x1D098A07, 0xE7508F03, 0xAE6CF224, 0x7528754D, 0x3C14086A, 0x0D006599, 0x443C18BE, 0x9F789FD7, 0xD644E2F0, 0x2C1DE7F4, 0x65219AD3, 0xBE651DBA, 0xF759609D, 0x4F3B6143, 0x06071C64, 0xDD439B0D, 0x947FE62A, 0x6E26E32E, 0x271A9E09, 0xFC5E1960, 0xB5626447, 0x89766C2D, 0xC04A110A, 0x1B0E9663, 0x5232EB44, 0xA86BEE40, 0xE1579367, 0x3A13140E, 0x732F6929, 0xCB4D68F7, 0x827115D0, 0x593592B9, 0x1009EF9E, 0xEA50EA9A, 0xA36C97BD, 0x782810D4, 0x31146DF3, 0x1A00CB32, 0x533CB615, 0x8878317C, 0xC1444C5B, 0x3B1D495F, 0x72213478, 0xA965B311, 0xE059CE36, 0x583BCFE8, 0x1107B2CF, 0xCA4335A6, 0x837F4881, 0x79264D85, 0x301A30A2, 0xEB5EB7CB, 0xA262CAEC, 0x9E76C286, 0xD74ABFA1, 0x0C0E38C8, 0x453245EF, 0xBF6B40EB, 0xF6573DCC, 0x2D13BAA5, 0x642FC782, 0xDC4DC65C, 0x9571BB7B, 0x4E353C12, 0x07094135, 0xFD504431, 0xB46C3916, 0x6F28BE7F, 0x2614C358, 0x1700AEAB, 0x5E3CD38C, 0x857854E5, 0xCC4429C2, 0x361D2CC6, 0x7F2151E1, 0xA465D688, 0xED59ABAF, 0x553BAA71, 0x1C07D756, 0xC743503F, 0x8E7F2D18, 0x7426281C, 0x3D1A553B, 0xE65ED252, 0xAF62AF75, 0x9376A71F, 0xDA4ADA38, 0x010E5D51, 0x48322076, 0xB26B2572, 0xFB575855, 0x2013DF3C, 0x692FA21B, 0xD14DA3C5, 0x9871DEE2, 0x4335598B, 0x0A0924AC, 0xF05021A8, 0xB96C5C8F, 0x6228DBE6, 0x2B14A6C1, 0x34019664, 0x7D3DEB43, 0xA6796C2A, 0xEF45110D, 0x151C1409, 0x5C20692E, 0x8764EE47, 0xCE589360, 0x763A92BE, 0x3F06EF99, 0xE44268F0, 0xAD7E15D7, 0x572710D3, 0x1E1B6DF4, 0xC55FEA9D, 0x8C6397BA, 0xB0779FD0, 0xF94BE2F7, 0x220F659E, 0x6B3318B9, 0x916A1DBD, 0xD856609A, 0x0312E7F3, 0x4A2E9AD4, 0xF24C9B0A, 0xBB70E62D, 0x60346144, 0x29081C63, 0xD3511967, 0x9A6D6440, 0x4129E329, 0x08159E0E, 0x3901F3FD, 0x703D8EDA, 0xAB7909B3, 0xE2457494, 0x181C7190, 0x51200CB7, 0x8A648BDE, 0xC358F6F9, 0x7B3AF727, 0x32068A00, 0xE9420D69, 0xA07E704E, 0x5A27754A, 0x131B086D, 0xC85F8F04, 0x8163F223, 0xBD77FA49, 0xF44B876E, 0x2F0F0007, 0x66337D20, 0x9C6A7824, 0xD5560503, 0x0E12826A, 0x472EFF4D, 0xFF4CFE93, 0xB67083B4, 0x6D3404DD, 0x240879FA, 0xDE517CFE, 0x976D01D9, 0x4C2986B0, 0x0515FB97, 0x2E015D56, 0x673D2071, 0xBC79A718, 0xF545DA3F, 0x0F1CDF3B, 0x4620A21C, 0x9D642575, 0xD4585852, 0x6C3A598C, 0x250624AB, 0xFE42A3C2, 0xB77EDEE5, 0x4D27DBE1, 0x041BA6C6, 0xDF5F21AF, 0x96635C88, 0xAA7754E2, 0xE34B29C5, 0x380FAEAC, 0x7133D38B, 0x8B6AD68F, 0xC256ABA8, 0x19122CC1, 0x502E51E6, 0xE84C5038, 0xA1702D1F, 0x7A34AA76, 0x3308D751, 0xC951D255, 0x806DAF72, 0x5B29281B, 0x1215553C, 0x230138CF, 0x6A3D45E8, 0xB179C281, 0xF845BFA6, 0x021CBAA2, 0x4B20C785, 0x906440EC, 0xD9583DCB, 0x613A3C15, 0x28064132, 0xF342C65B, 0xBA7EBB7C, 0x4027BE78, 0x091BC35F, 0xD25F4436, 0x9B633911, 0xA777317B, 0xEE4B4C5C, 0x350FCB35, 0x7C33B612, 0x866AB316, 0xCF56CE31, 0x14124958, 0x5D2E347F, 0xE54C35A1, 0xAC704886, 0x7734CFEF, 0x3E08B2C8, 0xC451B7CC, 0x8D6DCAEB, 0x56294D82, 0x1F1530A5 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.crc","Field","The current CRC value, bit-flipped","private int crc;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.getValue()","Method","No Comment","@Override
public long getValue() {
    final long ret = crc;
    return ~ret & 0xffffffffL;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.reset()","Method","No Comment","@Override
public void reset() {
    crc = 0xffffffff;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.update(byte[],int,int)","Method","No Comment","@Override
public void update(final byte[] b, int off, int len) {
    int localCrc = crc;
    while (len > 7) {
        final int c0 = (b[off + 0] ^ localCrc) & 0xff;
        final int c1 = (b[off + 1] ^ (localCrc >>>= 8)) & 0xff;
        final int c2 = (b[off + 2] ^ (localCrc >>>= 8)) & 0xff;
        final int c3 = (b[off + 3] ^ (localCrc >>>= 8)) & 0xff;
        localCrc = T[T8_7_START + c0] ^ T[T8_6_START + c1] ^ T[T8_5_START + c2] ^ T[T8_4_START + c3];
        final int c4 = b[off + 4] & 0xff;
        final int c5 = b[off + 5] & 0xff;
        final int c6 = b[off + 6] & 0xff;
        final int c7 = b[off + 7] & 0xff;
        localCrc ^= T[T8_3_START + c4] ^ T[T8_2_START + c5] ^ T[T8_1_START + c6] ^ T[T8_0_START + c7];
        off += 8;
        len -= 8;
    }
    // loop unroll - duff's device style
    switch(len) {
        case 7:
            localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
        // falls-through
        case 6:
            localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
        // falls-through
        case 5:
            localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
        // falls-through
        case 4:
            localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
        // falls-through
        case 3:
            localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
        // falls-through
        case 2:
            localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
        // falls-through
        case 1:
            localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];
        // falls-through
        default:
            // satisfy Findbugs
            break;
    }
    // Publish crc out to object
    crc = localCrc;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.update(byte[],int,int).b","Parameter_1","Belong to org.apache.commons.codec.digest.PureJavaCrc32C.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.update(byte[],int,int).off","Parameter_2","Belong to org.apache.commons.codec.digest.PureJavaCrc32C.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.update(byte[],int,int).len","Parameter_3","Belong to org.apache.commons.codec.digest.PureJavaCrc32C.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.update(int)","Method","No Comment","@Override
public final void update(final int b) {
    crc = crc >>> 8 ^ T[T8_0_START + ((crc ^ b) & 0xff)];
}","void","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.update(int).b","Parameter_1","Belong to org.apache.commons.codec.digest.PureJavaCrc32C.update(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.PureJavaCrc32C.<init>()","Constructor","Create a new PureJavaCrc32 object.","public PureJavaCrc32C() {
    reset();
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms","Enum","* Standard {@link HmacUtils} algorithm names from the <cite>Java Cryptography Architecture Standard Algorithm Name
 * Documentation</cite>.
 *
 * <p>
 * <strong>Note: Not all JCE implementations support all the algorithms in this enum.</strong>
 * </p>
 *
 * @see <a href=""https://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html#SunJCEProvider""> Java
 *      8 Cryptography Architecture Sun Providers Documentation</a>
 * @see <a href=
 *      ""https://docs.oracle.com/en/java/javase/11/security/oracle-providers.html#GUID-A47B1249-593C-4C38-A0D0-68FA7681E0A7"">
 *      Java 11 Cryptography Architecture Sun Providers Documentation</a>
 * @see <a href=
 *      ""https://docs.oracle.com/en/java/javase/17/security/oracle-providers.html#GUID-A47B1249-593C-4C38-A0D0-68FA7681E0A7"">
 *      Java 17 Cryptography Architecture Sun Providers Documentation</a>
 *
 * @since 1.10","Enum do not obtain Source Code","No return type","public ","enum has no extends",""
"org.apache.commons.codec.digest.HmacAlgorithms.HMAC_MD5","Enum Constant","* The HmacMD5 Message Authentication Code (MAC) algorithm specified in RFC 2104 and RFC 1321.
     * <p>
     * Every implementation of the Java platform is required to support this standard MAC algorithm.
     * </p>","HMAC_MD5(""HmacMD5"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms.HMAC_SHA_1","Enum Constant","* The HmacSHA1 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.
     * <p>
     * Every implementation of the Java platform is required to support this standard MAC algorithm.
     * </p>","HMAC_SHA_1(""HmacSHA1"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms.HMAC_SHA_224","Enum Constant","* The HmacSHA224 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.
     * <p>
     * Every implementation of the Java 8+ platform is required to support this standard MAC algorithm.
     * </p>
     * @since 1.11","HMAC_SHA_224(""HmacSHA224"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms.HMAC_SHA_256","Enum Constant","* The HmacSHA256 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.
     * <p>
     * Every implementation of the Java platform is required to support this standard MAC algorithm.
     * </p>","HMAC_SHA_256(""HmacSHA256"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms.HMAC_SHA_384","Enum Constant","* The HmacSHA384 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.
     * <p>
     * This MAC algorithm is <em>optional</em>; not all implementations support it.
     * </p>","HMAC_SHA_384(""HmacSHA384"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms.HMAC_SHA_512","Enum Constant","* The HmacSHA512 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.
     * <p>
     * This MAC algorithm is <em>optional</em>; not all implementations support it.
     * </p>","HMAC_SHA_512(""HmacSHA512"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms.getName()","Method","* Gets the algorithm name.
     *
     * @return the algorithm name.
     * @since 1.11","public String getName() {
    return name;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms.toString()","Method","* The algorithm name.
     *
     * @see <a href=""https://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunJCEProvider"">
     *      Java 6 Cryptography Architecture Sun Providers Documentation</a>
     * @see <a href=""https://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider"">
     *      Java 7 Cryptography Architecture Sun Providers Documentation</a>
     * @see <a href=""https://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html#SunJCEProvider"">
     *      Java 8 Cryptography Architecture Sun Providers Documentation</a>
     * @see <a href=
     *      ""https://docs.oracle.com/javase/9/security/oracleproviders.htm#JSSEC-GUID-A47B1249-593C-4C38-A0D0-68FA7681E0A7"">
     *      Java 9 Cryptography Architecture Sun Providers Documentation</a>
     * @return The algorithm name (""HmacSHA512"" for example)","@Override
public String toString() {
    return name;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms.<init>(String)","Constructor","No Comment","HmacAlgorithms(final String algorithm) {
    this.name = algorithm;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.HmacAlgorithms.<init>(String).algorithm","Parameter_1","Belong to org.apache.commons.codec.digest.HmacAlgorithms.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt","Class","* SHA2-based Unix crypt implementation.
 * <p>
 * Based on the C implementation released into the Public Domain by Ulrich Drepper &lt;drepper@redhat.com&gt;
 * http://www.akkadia.org/drepper/SHA-crypt.txt
 * </p>
 * <p>
 * Conversion to Kotlin and from there to Java in 2012 by Christian Hammers &lt;ch@lathspell.de&gt; and likewise put
 * into the Public Domain.
 * </p>
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @since 1.7","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.digest.Sha2Crypt.ROUNDS_DEFAULT","Field","Default number of rounds if not explicitly specified.","private static final int ROUNDS_DEFAULT = 5000;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.ROUNDS_MAX","Field","Maximum number of rounds.","private static final int ROUNDS_MAX = 999_999_999;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.ROUNDS_MIN","Field","Minimum number of rounds.","private static final int ROUNDS_MIN = 1000;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.ROUNDS_PREFIX","Field","Prefix for optional rounds specification.","private static final String ROUNDS_PREFIX = ""rounds="";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.SHA256_BLOCKSIZE","Field","The number of bytes the final hash value will have (SHA-256 variant).","private static final int SHA256_BLOCKSIZE = 32;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.SHA256_PREFIX","Field","The prefixes that can be used to identify this crypt() variant (SHA-256).","static final String SHA256_PREFIX = ""$5$"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.SHA512_BLOCKSIZE","Field","The number of bytes the final hash value will have (SHA-512 variant).","private static final int SHA512_BLOCKSIZE = 64;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.SHA512_PREFIX","Field","The prefixes that can be used to identify this crypt() variant (SHA-512).","static final String SHA512_PREFIX = ""$6$"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.SALT_PATTERN","Field","The pattern to match valid salt values.","private static final Pattern SALT_PATTERN = Pattern.compile(""^\\$([56])\\$(rounds=(\\d+)\\$)?([\\.\\/a-zA-Z0-9]{1,16}).*"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[])","Method","* Generates a libc crypt() compatible ""$5$"" hash value with random salt.
     * <p>
     * See {@link Crypt#crypt(String, String)} for details.
     * </p>
     * <p>
     * A salt is generated for you using {@link SecureRandom}.
     * </p>
     *
     * @param keyBytes
     *            plaintext to hash. Each array element is set to {@code 0} before returning.
     * @return complete hash value
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String sha256Crypt(final byte[] keyBytes) {
    return sha256Crypt(keyBytes, null);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[]).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String)","Method","* Generates a libc6 crypt() compatible ""$5$"" hash value.
     * <p>
     * See {@link Crypt#crypt(String, String)} for details.
     * </p>
     * @param keyBytes
     *            plaintext to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            real salt value without prefix or ""rounds="". The salt may be null, in which case a salt
     *            is generated for you using {@link SecureRandom}. If one does not want to use {@link SecureRandom},
     *            you can pass your own {@link Random} in {@link #sha256Crypt(byte[], String, Random)}.
     * @return complete hash value including salt
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String sha256Crypt(final byte[] keyBytes, String salt) {
    if (salt == null) {
        salt = SHA256_PREFIX + B64.getRandomSalt(8);
    }
    return sha2Crypt(keyBytes, salt, SHA256_PREFIX, SHA256_BLOCKSIZE, MessageDigestAlgorithms.SHA_256);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String,Random)","Method","* Generates a libc6 crypt() compatible ""$5$"" hash value.
     * <p>
     * See {@link Crypt#crypt(String, String)} for details.
     * </p>
     * @param keyBytes
     *            plaintext to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            real salt value without prefix or ""rounds="".
     * @param random
     *            the instance of {@link Random} to use for generating the salt.
     *            Consider using {@link SecureRandom} for more secure salts.
     * @return complete hash value including salt
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
     * @since 1.12","public static String sha256Crypt(final byte[] keyBytes, String salt, final Random random) {
    if (salt == null) {
        salt = SHA256_PREFIX + B64.getRandomSalt(8, random);
    }
    return sha2Crypt(keyBytes, salt, SHA256_PREFIX, SHA256_BLOCKSIZE, MessageDigestAlgorithms.SHA_256);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String,Random).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String,Random).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String,Random).random","Parameter_3","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[],String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String)","Method","* Generates a libc6 crypt() compatible ""$5$"" or ""$6$"" SHA2 based hash value.
     * <p>
     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm
     * description, the short C-style ones from the original C code and the ones with ""Remark"" from me.
     * </p>
     * <p>
     * See {@link Crypt#crypt(String, String)} for details.
     * </p>
     *
     * @param keyBytes
     *            plaintext to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            real salt value without prefix or ""rounds=""; may not be null
     * @param saltPrefix
     *            either $5$ or $6$
     * @param blocksize
     *            a value that differs between $5$ and $6$
     * @param algorithm
     *            {@link MessageDigest} algorithm identifier string
     * @return complete hash value including prefix and salt
     * @throws IllegalArgumentException
     *             if the given salt is {@code null} or does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link NoSuchAlgorithmException} is caught
     * @see MessageDigestAlgorithms","private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {
    final int keyLen = keyBytes.length;
    // Extracts effective salt and the number of rounds from the given salt.
    int rounds = ROUNDS_DEFAULT;
    boolean roundsCustom = false;
    if (salt == null) {
        throw new IllegalArgumentException(""Salt must not be null"");
    }
    final Matcher m = SALT_PATTERN.matcher(salt);
    if (!m.find()) {
        throw new IllegalArgumentException(""Invalid salt value: "" + salt);
    }
    if (m.group(3) != null) {
        rounds = Integer.parseInt(m.group(3));
        rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));
        roundsCustom = true;
    }
    final String saltString = m.group(4);
    final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8);
    final int saltLen = saltBytes.length;
    // 1. start digest A
    // Prepare for the real work.
    MessageDigest ctx = DigestUtils.getDigest(algorithm);
    // 2. the password string is added to digest A
    /*
         * Add the key string.
         */
    ctx.update(keyBytes);
    // 3. the salt string is added to digest A. This is just the salt string
    // itself without the enclosing '$', without the magic salt_prefix $5$ and
    // $6$ respectively and without the rounds=<N> specification.
    //
    // NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed
    // necessary since it is a constant string and does not add security
    // and /possibly/ allows a plain text attack. Since the rounds=<N>
    // specification should never be added this would also create an
    // inconsistency.
    /*
         * The last part is the salt string. This must be at most 16 characters and it ends at the first `$' character
         * (for compatibility with existing implementations).
         */
    ctx.update(saltBytes);
    // 4. start digest B
    /*
         * Compute alternate sha512 sum with input KEY, SALT, and KEY. The final result will be added to the first
         * context.
         */
    MessageDigest altCtx = DigestUtils.getDigest(algorithm);
    // 5. add the password to digest B
    /*
         * Add key.
         */
    altCtx.update(keyBytes);
    // 6. add the salt string to digest B
    /*
         * Add salt.
         */
    altCtx.update(saltBytes);
    // 7. add the password again to digest B
    /*
         * Add key again.
         */
    altCtx.update(keyBytes);
    // 8. finish digest B
    /*
         * Now get result of this (32 bytes) and add it to the other context.
         */
    byte[] altResult = altCtx.digest();
    // 9. For each block of 32 or 64 bytes in the password string (excluding
    // the terminating NUL in the C representation), add digest B to digest A
    /*
         * Add for any character in the key one byte of the alternate sum.
         */
    /*
         * (Remark: the C code comment seems wrong for key length > 32!)
         */
    int cnt = keyBytes.length;
    while (cnt > blocksize) {
        ctx.update(altResult, 0, blocksize);
        cnt -= blocksize;
    }
    // 10. For the remaining N bytes of the password string add the first
    // N bytes of digest B to digest A
    ctx.update(altResult, 0, cnt);
    // 11. For each bit of the binary representation of the length of the
    // password string up to and including the highest 1-digit, starting
    // from to the lowest bit position (numeric value 1):
    //
    // a) for a 1-digit add digest B to digest A
    //
    // b) for a 0-digit add the password string
    //
    // NB: this step differs significantly from the MD5 algorithm. It
    // adds more randomness.
    /*
         * Take the binary representation of the length of the key and for every 1 add the alternate sum, for every 0
         * the key.
         */
    cnt = keyBytes.length;
    while (cnt > 0) {
        if ((cnt & 1) != 0) {
            ctx.update(altResult, 0, blocksize);
        } else {
            ctx.update(keyBytes);
        }
        cnt >>= 1;
    }
    // 12. finish digest A
    /*
         * Create intermediate result.
         */
    altResult = ctx.digest();
    // 13. start digest DP
    /*
         * Start computation of P byte sequence.
         */
    altCtx = DigestUtils.getDigest(algorithm);
    // 14. for every byte in the password (excluding the terminating NUL byte
    // in the C representation of the string)
    //
    // add the password to digest DP
    /*
         * For every character in the password add the entire password.
         */
    for (int i = 1; i <= keyLen; i++) {
        altCtx.update(keyBytes);
    }
    // 15. finish digest DP
    /*
         * Finish the digest.
         */
    byte[] tempResult = altCtx.digest();
    // 16. produce byte sequence P of the same length as the password where
    //
    // a) for each block of 32 or 64 bytes of length of the password string
    // the entire digest DP is used
    //
    // b) for the remaining N (up to 31 or 63) bytes use the first N
    // bytes of digest DP
    /*
         * Create byte sequence P.
         */
    final byte[] pBytes = new byte[keyLen];
    int cp = 0;
    while (cp < keyLen - blocksize) {
        System.arraycopy(tempResult, 0, pBytes, cp, blocksize);
        cp += blocksize;
    }
    System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);
    // 17. start digest DS
    /*
         * Start computation of S byte sequence.
         */
    altCtx = DigestUtils.getDigest(algorithm);
    // 18. repeat the following 16+A[0] times, where A[0] represents the first
    // byte in digest A interpreted as an 8-bit unsigned value
    //
    // add the salt to digest DS
    /*
         * For every character in the password add the entire password.
         */
    for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {
        altCtx.update(saltBytes);
    }
    // 19. finish digest DS
    /*
         * Finish the digest.
         */
    tempResult = altCtx.digest();
    // 20. produce byte sequence S of the same length as the salt string where
    //
    // a) for each block of 32 or 64 bytes of length of the salt string
    // the entire digest DS is used
    //
    // b) for the remaining N (up to 31 or 63) bytes use the first N
    // bytes of digest DS
    /*
         * Create byte sequence S.
         */
    // Remark: The salt is limited to 16 chars, how does this make sense?
    final byte[] sBytes = new byte[saltLen];
    cp = 0;
    while (cp < saltLen - blocksize) {
        System.arraycopy(tempResult, 0, sBytes, cp, blocksize);
        cp += blocksize;
    }
    System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);
    // 21. repeat a loop according to the number specified in the rounds=<N>
    // specification in the salt (or the default value if none is
    // present). Each round is numbered, starting with 0 and up to N-1.
    //
    // The loop uses a digest as input. In the first round it is the
    // digest produced in step 12. In the latter steps it is the digest
    // produced in step 21.h. The following text uses the notation
    // ""digest A/C"" to describe this behavior.
    /*
         * Repeatedly run the collected hash value through sha512 to burn CPU cycles.
         */
    for (int i = 0; i <= rounds - 1; i++) {
        // a) start digest C
        /*
             * New context.
             */
        ctx = DigestUtils.getDigest(algorithm);
        // b) for odd round numbers add the byte sequence P to digest C
        // c) for even round numbers add digest A/C
        /*
             * Add key or last result.
             */
        if ((i & 1) != 0) {
            ctx.update(pBytes, 0, keyLen);
        } else {
            ctx.update(altResult, 0, blocksize);
        }
        // d) for all round numbers not divisible by 3 add the byte sequence S
        /*
             * Add salt for numbers not divisible by 3.
             */
        if (i % 3 != 0) {
            ctx.update(sBytes, 0, saltLen);
        }
        // e) for all round numbers not divisible by 7 add the byte sequence P
        /*
             * Add key for numbers not divisible by 7.
             */
        if (i % 7 != 0) {
            ctx.update(pBytes, 0, keyLen);
        }
        // f) for odd round numbers add digest A/C
        // g) for even round numbers add the byte sequence P
        /*
             * Add key or last result.
             */
        if ((i & 1) != 0) {
            ctx.update(altResult, 0, blocksize);
        } else {
            ctx.update(pBytes, 0, keyLen);
        }
        // h) finish digest C.
        /*
             * Create intermediate result.
             */
        altResult = ctx.digest();
    }
    // 22. Produce the output string. This is an ASCII string of the maximum
    // size specified above, consisting of multiple pieces:
    //
    // a) the salt salt_prefix, $5$ or $6$ respectively
    //
    // b) the rounds=<N> specification, if one was present in the input
    // salt string. A trailing '$' is added in this case to separate
    // the rounds specification from the following text.
    //
    // c) the salt string truncated to 16 characters
    //
    // d) a '$' character
    /*
         * Now we can construct the result string. It consists of three parts.
         */
    final StringBuilder buffer = new StringBuilder(saltPrefix);
    if (roundsCustom) {
        buffer.append(ROUNDS_PREFIX);
        buffer.append(rounds);
        buffer.append(""$"");
    }
    buffer.append(saltString);
    buffer.append(""$"");
    // e) the base-64 encoded final C digest. The encoding used is as
    // follows:
    // [...]
    //
    // Each group of three bytes from the digest produces four
    // characters as output:
    //
    // 1. character: the six low bits of the first byte
    // 2. character: the two high bits of the first byte and the
    // four low bytes from the second byte
    // 3. character: the four high bytes from the second byte and
    // the two low bits from the third byte
    // 4. character: the six high bits from the third byte
    //
    // The groups of three bytes are as follows (in this sequence).
    // These are the indices into the byte array containing the
    // digest, starting with index 0. For the last group there are
    // not enough bytes left in the digest and the value zero is used
    // in its place. This group also produces only three or two
    // characters as output for SHA-512 and SHA-512 respectively.
    // This was just a safeguard in the C implementation:
    // int buflen = salt_prefix.length() - 1 + ROUNDS_PREFIX.length() + 9 + 1 + salt_string.length() + 1 + 86 + 1;
    if (blocksize == 32) {
        B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);
        B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);
        B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);
        B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);
        B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);
        B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);
        B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);
        B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);
        B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);
        B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);
        B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);
    } else {
        B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);
        B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);
        B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);
        B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);
        B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);
        B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);
        B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);
        B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);
        B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);
        B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);
        B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);
        B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);
        B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);
        B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);
        B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);
        B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);
        B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);
        B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);
        B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);
        B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);
        B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);
        B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);
    }
    /*
         * Clear the buffer for the intermediate result so that people attaching to processes or reading core dumps
         * cannot get any information.
         */
    // Is there a better way to do this with the JVM?
    Arrays.fill(tempResult, (byte) 0);
    Arrays.fill(pBytes, (byte) 0);
    Arrays.fill(sBytes, (byte) 0);
    ctx.reset();
    altCtx.reset();
    Arrays.fill(keyBytes, (byte) 0);
    Arrays.fill(saltBytes, (byte) 0);
    return buffer.toString();
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String).saltPrefix","Parameter_3","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String).blocksize","Parameter_4","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String).algorithm","Parameter_5","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[],String,String,int,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[])","Method","* Generates a libc crypt() compatible ""$6$"" hash value with random salt.
     * <p>
     * See {@link Crypt#crypt(String, String)} for details.
     * </p>
     * <p>
     * A salt is generated for you using {@link SecureRandom}
     * </p>
     *
     * @param keyBytes
     *            plaintext to hash. Each array element is set to {@code 0} before returning.
     * @return complete hash value
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String sha512Crypt(final byte[] keyBytes) {
    return sha512Crypt(keyBytes, null);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[]).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String)","Method","* Generates a libc6 crypt() compatible ""$6$"" hash value.
     * <p>
     * See {@link Crypt#crypt(String, String)} for details.
     * </p>
     * @param keyBytes
     *            plaintext to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            real salt value without prefix or ""rounds="". The salt may be null, in which case a salt is generated
     *            for you using {@link SecureRandom}; if you want to use a {@link Random} object other than
     *            {@link SecureRandom} then we suggest you provide it using
     *            {@link #sha512Crypt(byte[], String, Random)}.
     * @return complete hash value including salt
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.","public static String sha512Crypt(final byte[] keyBytes, String salt) {
    if (salt == null) {
        salt = SHA512_PREFIX + B64.getRandomSalt(8);
    }
    return sha2Crypt(keyBytes, salt, SHA512_PREFIX, SHA512_BLOCKSIZE, MessageDigestAlgorithms.SHA_512);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String,Random)","Method","* Generates a libc6 crypt() compatible ""$6$"" hash value.
     * <p>
     * See {@link Crypt#crypt(String, String)} for details.
     * </p>
     * @param keyBytes
     *            plaintext to hash. Each array element is set to {@code 0} before returning.
     * @param salt
     *            real salt value without prefix or ""rounds="". The salt may be null, in which case a salt
     *            is generated for you using {@link SecureRandom}.
     * @param random
     *            the instance of {@link Random} to use for generating the salt.
     *            Consider using {@link SecureRandom} for more secure salts.
     * @return complete hash value including salt
     * @throws IllegalArgumentException
     *             if the salt does not match the allowed pattern
     * @throws IllegalArgumentException
     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
     * @since 1.12","public static String sha512Crypt(final byte[] keyBytes, String salt, final Random random) {
    if (salt == null) {
        salt = SHA512_PREFIX + B64.getRandomSalt(8, random);
    }
    return sha2Crypt(keyBytes, salt, SHA512_PREFIX, SHA512_BLOCKSIZE, MessageDigestAlgorithms.SHA_512);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String,Random).keyBytes","Parameter_1","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String,Random).salt","Parameter_2","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String,Random).random","Parameter_3","Belong to org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[],String,Random)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.Sha2Crypt.<init>()","Constructor","* Consider private.
     *
     * @deprecated Will be private in the next major version.","@Deprecated
public Sha2Crypt() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32","Class","* Implements the xxHash32 hash algorithm.
 *
 * <p>
 * Copied from Commons Compress 1.14 <a href=
 * ""https://gitbox.apache.org/repos/asf?p=commons-compress.git;a=blob;f=src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java;h=a406ffc197449be594d46f0d2712b2d4786a1e68;hb=HEAD"">https://gitbox.apache.org/repos/asf?p=commons-compress.git;a=blob;f=src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java;h=a406ffc197449be594d46f0d2712b2d4786a1e68;hb=HEAD</a>
 * </p>
 * <p>
 * NotThreadSafe
 * </p>
 *
 * @see <a href=""https://cyan4973.github.io/xxHash/"">xxHash</a>
 * @since 1.11","Class do not obtain Source Code","No return type","public ","","java.util.zip.Checksum"
"org.apache.commons.codec.digest.XXHash32.BUF_SIZE","Field","No Comment","private static final int BUF_SIZE = 16;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.ROTATE_BITS","Field","No Comment","private static final int ROTATE_BITS = 13;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.PRIME1","Field","No Comment","private static final int PRIME1 = (int) 2654435761L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.PRIME2","Field","No Comment","private static final int PRIME2 = (int) 2246822519L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.PRIME3","Field","No Comment","private static final int PRIME3 = (int) 3266489917L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.PRIME4","Field","No Comment","private static final int PRIME4 = 668265263;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.PRIME5","Field","No Comment","private static final int PRIME5 = 374761393;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.oneByte","Field","No Comment","private final byte[] oneByte = new byte[1];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.state","Field","No Comment","private final int[] state = new int[4];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.buffer","Field","See: https://gitbox.apache.org/repos/asf/commons-compress/diff/2f56fb5c","private final byte[] buffer = new byte[BUF_SIZE];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.seed","Field","No Comment","private final int seed;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.totalLen","Field","No Comment","private int totalLen;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.pos","Field","No Comment","private int pos;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.stateUpdated","Field","Sets to true when the state array has been updated since the last reset.","private boolean stateUpdated;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.getInt(byte[],int)","Method","* Gets the little-endian int from 4 bytes starting at the specified index.
     *
     * @param buffer The data
     * @param idx The index
     * @return The little-endian int","private static int getInt(final byte[] buffer, final int idx) {
    return buffer[idx] & 0xff | (buffer[idx + 1] & 0xff) << 8 | (buffer[idx + 2] & 0xff) << 16 | (buffer[idx + 3] & 0xff) << 24;
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.getInt(byte[],int).buffer","Parameter_1","Belong to org.apache.commons.codec.digest.XXHash32.getInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.getInt(byte[],int).idx","Parameter_2","Belong to org.apache.commons.codec.digest.XXHash32.getInt(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.getValue()","Method","No Comment","@Override
public long getValue() {
    int hash;
    if (stateUpdated) {
        // Hash with the state
        hash = rotateLeft(state[0], 1) + rotateLeft(state[1], 7) + rotateLeft(state[2], 12) + rotateLeft(state[3], 18);
    } else {
        // Hash using the original seed from position 2
        hash = state[2] + PRIME5;
    }
    hash += totalLen;
    int idx = 0;
    final int limit = pos - 4;
    for (; idx <= limit; idx += 4) {
        hash = rotateLeft(hash + getInt(buffer, idx) * PRIME3, 17) * PRIME4;
    }
    while (idx < pos) {
        hash = rotateLeft(hash + (buffer[idx++] & 0xff) * PRIME5, 11) * PRIME1;
    }
    hash ^= hash >>> 15;
    hash *= PRIME2;
    hash ^= hash >>> 13;
    hash *= PRIME3;
    hash ^= hash >>> 16;
    return hash & 0xffffffffL;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.initializeState()","Method","No Comment","private void initializeState() {
    state[0] = seed + PRIME1 + PRIME2;
    state[1] = seed + PRIME2;
    state[2] = seed;
    state[3] = seed - PRIME1;
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.process(byte[],int)","Method","No Comment","private void process(final byte[] b, final int offset) {
    // local shadows for performance
    int s0 = state[0];
    int s1 = state[1];
    int s2 = state[2];
    int s3 = state[3];
    s0 = rotateLeft(s0 + getInt(b, offset) * PRIME2, ROTATE_BITS) * PRIME1;
    s1 = rotateLeft(s1 + getInt(b, offset + 4) * PRIME2, ROTATE_BITS) * PRIME1;
    s2 = rotateLeft(s2 + getInt(b, offset + 8) * PRIME2, ROTATE_BITS) * PRIME1;
    s3 = rotateLeft(s3 + getInt(b, offset + 12) * PRIME2, ROTATE_BITS) * PRIME1;
    state[0] = s0;
    state[1] = s1;
    state[2] = s2;
    state[3] = s3;
    stateUpdated = true;
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.process(byte[],int).b","Parameter_1","Belong to org.apache.commons.codec.digest.XXHash32.process(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.process(byte[],int).offset","Parameter_2","Belong to org.apache.commons.codec.digest.XXHash32.process(byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.reset()","Method","No Comment","@Override
public void reset() {
    initializeState();
    totalLen = 0;
    pos = 0;
    stateUpdated = false;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.update(byte[],int,int)","Method","No Comment","@Override
public void update(final byte[] b, int off, final int len) {
    if (len <= 0) {
        return;
    }
    totalLen += len;
    final int end = off + len;
    // Check if the unprocessed bytes and new bytes can fill a block of 16.
    // Make this overflow safe in the event that len is Integer.MAX_VALUE.
    // Equivalent to: (pos + len < BUF_SIZE)
    if (pos + len - BUF_SIZE < 0) {
        System.arraycopy(b, off, buffer, pos, len);
        pos += len;
        return;
    }
    // Process left-over bytes with new bytes
    if (pos > 0) {
        final int size = BUF_SIZE - pos;
        System.arraycopy(b, off, buffer, pos, size);
        process(buffer, 0);
        off += size;
    }
    final int limit = end - BUF_SIZE;
    while (off <= limit) {
        process(b, off);
        off += BUF_SIZE;
    }
    // Handle left-over bytes
    if (off < end) {
        pos = end - off;
        System.arraycopy(b, off, buffer, 0, pos);
    } else {
        pos = 0;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.update(byte[],int,int).b","Parameter_1","Belong to org.apache.commons.codec.digest.XXHash32.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.update(byte[],int,int).off","Parameter_2","Belong to org.apache.commons.codec.digest.XXHash32.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.update(byte[],int,int).len","Parameter_3","Belong to org.apache.commons.codec.digest.XXHash32.update(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.update(int)","Method","No Comment","@Override
public void update(final int b) {
    oneByte[0] = (byte) (b & 0xff);
    update(oneByte, 0, 1);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.update(int).b","Parameter_1","Belong to org.apache.commons.codec.digest.XXHash32.update(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.<init>()","Constructor","* Creates an XXHash32 instance with a seed of 0.","public XXHash32() {
    this(0);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.<init>(int)","Constructor","* Creates an XXHash32 instance.
     * @param seed the seed to use","public XXHash32(final int seed) {
    this.seed = seed;
    initializeState();
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.digest.XXHash32.<init>(int).seed","Parameter_1","Belong to org.apache.commons.codec.digest.XXHash32.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.EncoderException","Class","* Thrown when there is a failure condition during the encoding process. This exception is thrown when an
 * {@link Encoder} encounters an encoding specific exception such as invalid data, inability to calculate a checksum,
 * characters outside of the expected range.","Class do not obtain Source Code","No return type","public ","java.lang.Exception",""
"org.apache.commons.codec.EncoderException.serialVersionUID","Field","* Declares the Serial Version Uid.
     *
     * @see <a href=""https://c2.com/cgi/wiki?AlwaysDeclareSerialVersionUid"">Always Declare Serial Version Uid</a>","private static final long serialVersionUID = 1L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.EncoderException.<init>()","Constructor","* Constructs a new exception with {@code null} as its detail message. The cause is not initialized, and may
     * subsequently be initialized by a call to {@link #initCause}.
     *
     * @since 1.4","public EncoderException() {
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.EncoderException.<init>(String)","Constructor","* Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently
     * be initialized by a call to {@link #initCause}.
     *
     * @param message
     *            a useful message relating to the encoder specific error.","public EncoderException(final String message) {
    super(message);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.EncoderException.<init>(String).message","Parameter_1","Belong to org.apache.commons.codec.EncoderException.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.EncoderException.<init>(String,Throwable)","Constructor","* Constructs a new exception with the specified detail message and cause.
     *
     * <p>
     * Note that the detail message associated with {@code cause} is not automatically incorporated into this
     * exception's detail message.
     * </p>
     *
     * @param message
     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.
     * @param cause
     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}
     *            value is permitted, and indicates that the cause is nonexistent or unknown.
     * @since 1.4","public EncoderException(final String message, final Throwable cause) {
    super(message, cause);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.EncoderException.<init>(String,Throwable).message","Parameter_1","Belong to org.apache.commons.codec.EncoderException.<init>(String,Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.EncoderException.<init>(String,Throwable).cause","Parameter_2","Belong to org.apache.commons.codec.EncoderException.<init>(String,Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.EncoderException.<init>(Throwable)","Constructor","* Constructs a new exception with the specified cause and a detail message of {@code (cause==null ?
     * null : cause.toString())} (which typically contains the class and detail message of {@code cause}).
     * This constructor is useful for exceptions that are little more than wrappers for other throwables.
     *
     * @param cause
     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}
     *            value is permitted, and indicates that the cause is nonexistent or unknown.
     * @since 1.4","public EncoderException(final Throwable cause) {
    super(cause);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.EncoderException.<init>(Throwable).cause","Parameter_1","Belong to org.apache.commons.codec.EncoderException.<init>(Throwable)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringDecoder","Interface","* Defines common decoding methods for String decoders.","Interface do not obtain Source Code","No return type","public ","org.apache.commons.codec.Decoder",""
"org.apache.commons.codec.StringDecoder.decode(String)","Abstract Method","* Decodes a String and returns a String.
     *
     * @param source
     *            the String to decode
     * @return the encoded String
     * @throws DecoderException
     *             thrown if there is an error condition during the Encoding process.","String decode(String source) throws DecoderException;","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringDecoder.decode(String).source","Parameter_1","Belong to org.apache.commons.codec.StringDecoder.decode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic","Class","* Encodes a string into a Cologne Phonetic value.
 * <p>
 * Implements the <a href=""https://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik"">K&ouml;lner Phonetik</a> (Cologne
 * Phonetic) algorithm issued by Hans Joachim Postel in 1969.
 * </p>
 * <p>
 * The <em>K&ouml;lner Phonetik</em> is a phonetic algorithm which is optimized for the German language. It is related to
 * the well-known soundex algorithm.
 * </p>
 *
 * <h2>Algorithm</h2>
 *
 * <ul>
 *
 * <li>
 * <h3>Step 1:</h3>
 * After preprocessing (conversion to upper case, transcription of <a
 * href=""https://en.wikipedia.org/wiki/Germanic_umlaut"">germanic umlauts</a>, removal of non alphabetical characters) the
 * letters of the supplied text are replaced by their phonetic code according to the following table.
 * <table border=""1"">
 * <caption style=""caption-side: bottom""><small><i>(Source: <a
 * href=""https://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik#Buchstabencodes"">Wikipedia (de): K&ouml;lner Phonetik --
 * Buchstabencodes</a>)</i></small></caption> <tbody>
 * <tr>
 * <th>Letter</th>
 * <th>Context</th>
 * <th>Code</th>
 * </tr>
 * <tr>
 * <td>A, E, I, J, O, U, Y</td>
 * <td></td>
 * <td>0</td>
 * </tr>
 * <tr>
 *
 * <td>H</td>
 * <td></td>
 * <td>-</td>
 * </tr>
 * <tr>
 * <td>B</td>
 * <td></td>
 * <td rowspan=""2"">1</td>
 * </tr>
 * <tr>
 * <td>P</td>
 * <td>not before H</td>
 *
 * </tr>
 * <tr>
 * <td>D, T</td>
 * <td>not before C, S, Z</td>
 * <td>2</td>
 * </tr>
 * <tr>
 * <td>F, V, W</td>
 * <td></td>
 * <td rowspan=""2"">3</td>
 * </tr>
 * <tr>
 *
 * <td>P</td>
 * <td>before H</td>
 * </tr>
 * <tr>
 * <td>G, K, Q</td>
 * <td></td>
 * <td rowspan=""3"">4</td>
 * </tr>
 * <tr>
 * <td rowspan=""2"">C</td>
 * <td>at onset before A, H, K, L, O, Q, R, U, X</td>
 *
 * </tr>
 * <tr>
 * <td>before A, H, K, O, Q, U, X except after S, Z</td>
 * </tr>
 * <tr>
 * <td>X</td>
 * <td>not after C, K, Q</td>
 * <td>48</td>
 * </tr>
 * <tr>
 * <td>L</td>
 * <td></td>
 *
 * <td>5</td>
 * </tr>
 * <tr>
 * <td>M, N</td>
 * <td></td>
 * <td>6</td>
 * </tr>
 * <tr>
 * <td>R</td>
 * <td></td>
 * <td>7</td>
 * </tr>
 *
 * <tr>
 * <td>S, Z</td>
 * <td></td>
 * <td rowspan=""6"">8</td>
 * </tr>
 * <tr>
 * <td rowspan=""3"">C</td>
 * <td>after S, Z</td>
 * </tr>
 * <tr>
 * <td>at onset except before A, H, K, L, O, Q, R, U, X</td>
 * </tr>
 *
 * <tr>
 * <td>not before A, H, K, O, Q, U, X</td>
 * </tr>
 * <tr>
 * <td>D, T</td>
 * <td>before C, S, Z</td>
 * </tr>
 * <tr>
 * <td>X</td>
 * <td>after C, K, Q</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * <h4>Example:</h4>
 *
 * {@code ""M}&uuml;{@code ller-L}&uuml;<code>denscheidt""
 * =&gt; ""MULLERLUDENSCHEIDT"" =&gt; ""6005507500206880022""</code>
 *
 * </li>
 *
 * <li>
 * <h3>Step 2:</h3>
 * Collapse of all multiple consecutive code digits.
 * <h4>Example:</h4>
 * {@code ""6005507500206880022"" =&gt; ""6050750206802""}</li>
 *
 * <li>
 * <h3>Step 3:</h3>
 * Removal of all codes ""0"" except at the beginning. This means that two or more identical consecutive digits can occur
 * if they occur after removing the ""0"" digits.
 *
 * <h4>Example:</h4>
 * {@code ""6050750206802"" =&gt; ""65752682""}</li>
 *
 * </ul>
 *
 * <p>
 * This class is thread-safe.
 * </p>
 *
 * @see <a href=""https://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik"">Wikipedia (de): K&ouml;lner Phonetik (in German)</a>
 * @since 1.5","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.ColognePhonetic.AEIJOUY","Field","Predefined char arrays for better performance and less GC load","private static final char[] AEIJOUY = { 'A', 'E', 'I', 'J', 'O', 'U', 'Y' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CSZ","Field","No Comment","private static final char[] CSZ = { 'C', 'S', 'Z' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.FPVW","Field","No Comment","private static final char[] FPVW = { 'F', 'P', 'V', 'W' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.GKQ","Field","No Comment","private static final char[] GKQ = { 'G', 'K', 'Q' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CKQ","Field","No Comment","private static final char[] CKQ = { 'C', 'K', 'Q' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.AHKLOQRUX","Field","No Comment","private static final char[] AHKLOQRUX = { 'A', 'H', 'K', 'L', 'O', 'Q', 'R', 'U', 'X' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.SZ","Field","No Comment","private static final char[] SZ = { 'S', 'Z' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.AHKOQUX","Field","No Comment","private static final char[] AHKOQUX = { 'A', 'H', 'K', 'O', 'Q', 'U', 'X' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.DTX","Field","No Comment","private static final char[] DTX = { 'D', 'T', 'X' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CHAR_IGNORE","Field","is this character to be ignored?","private static final char CHAR_IGNORE = '-';","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.arrayContains(char[],char)","Method","* Returns whether the array contains the key, or not.","private static boolean arrayContains(final char[] arr, final char key) {
    for (final char element : arr) {
        if (element == key) {
            return true;
        }
    }
    return false;
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.arrayContains(char[],char).arr","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.arrayContains(char[],char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.arrayContains(char[],char).key","Parameter_2","Belong to org.apache.commons.codec.language.ColognePhonetic.arrayContains(char[],char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.colognePhonetic(String)","Method","* <p>
     * Implements the <em>K&ouml;lner Phonetik</em> algorithm.
     * </p>
     * <p>
     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.
     * </p>
     *
     * @param text The source text to encode
     * @return the corresponding encoding according to the <em>K&ouml;lner Phonetik</em> algorithm","public String colognePhonetic(final String text) {
    if (text == null) {
        return null;
    }
    final CologneInputBuffer input = new CologneInputBuffer(preprocess(text));
    final CologneOutputBuffer output = new CologneOutputBuffer(input.length() * 2);
    char nextChar;
    char lastChar = CHAR_IGNORE;
    char chr;
    while (!input.isEmpty()) {
        chr = input.removeNext();
        if (!input.isEmpty()) {
            nextChar = input.getNextChar();
        } else {
            nextChar = CHAR_IGNORE;
        }
        if (chr < 'A' || chr > 'Z') {
            // ignore unwanted characters
            continue;
        }
        if (arrayContains(AEIJOUY, chr)) {
            output.put('0');
        } else if (chr == 'B' || chr == 'P' && nextChar != 'H') {
            output.put('1');
        } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) {
            output.put('2');
        } else if (arrayContains(FPVW, chr)) {
            output.put('3');
        } else if (arrayContains(GKQ, chr)) {
            output.put('4');
        } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {
            output.put('4');
            output.put('8');
        } else if (chr == 'S' || chr == 'Z') {
            output.put('8');
        } else if (chr == 'C') {
            if (output.isEmpty()) {
                if (arrayContains(AHKLOQRUX, nextChar)) {
                    output.put('4');
                } else {
                    output.put('8');
                }
            } else if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) {
                output.put('8');
            } else {
                output.put('4');
            }
        } else if (arrayContains(DTX, chr)) {
            output.put('8');
        } else {
            switch(chr) {
                case 'R':
                    output.put('7');
                    break;
                case 'L':
                    output.put('5');
                    break;
                case 'M':
                case 'N':
                    output.put('6');
                    break;
                case 'H':
                    // needed by put
                    output.put(CHAR_IGNORE);
                    break;
                default:
                    break;
            }
        }
        lastChar = chr;
    }
    return output.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.colognePhonetic(String).text","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.colognePhonetic(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.encode(Object)","Method","No Comment","@Override
public Object encode(final Object object) throws EncoderException {
    if (!(object instanceof String)) {
        throw new EncoderException(""This method's parameter was expected to be of the type "" + String.class.getName() + "". But actually it was of the type "" + object.getClass().getName() + ""."");
    }
    return encode((String) object);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.encode(Object).object","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.encode(String)","Method","No Comment","@Override
public String encode(final String text) {
    return colognePhonetic(text);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.encode(String).text","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.isEncodeEqual(String,String)","Method","* Compares the first encoded string to the second encoded string.
     *
     * @param text1 source text to encode before testing for equality.
     * @param text2 source text to encode before testing for equality.
     * @return {@code true} if the encoding the first string equals the encoding of the second string, {@code false}
     *         otherwise","public boolean isEncodeEqual(final String text1, final String text2) {
    return colognePhonetic(text1).equals(colognePhonetic(text2));
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.isEncodeEqual(String,String).text1","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.isEncodeEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.isEncodeEqual(String,String).text2","Parameter_2","Belong to org.apache.commons.codec.language.ColognePhonetic.isEncodeEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.preprocess(String)","Method","* Converts the string to upper case and replaces Germanic umlaut characters
     * The following characters are mapped:
     * <ul>
     * <li>capital A, umlaut mark</li>
     * <li>capital U, umlaut mark</li>
     * <li>capital O, umlaut mark</li>
     * <li>small sharp s, German</li>
     * </ul>","private char[] preprocess(final String text) {
    // This converts German small sharp s (Eszett) to SS
    final char[] chrs = text.toUpperCase(Locale.GERMAN).toCharArray();
    for (int index = 0; index < chrs.length; index++) {
        switch(chrs[index]) {
            case // capital A, umlaut mark
            '\u00C4':
                chrs[index] = 'A';
                break;
            case // capital U, umlaut mark
            '\u00DC':
                chrs[index] = 'U';
                break;
            case // capital O, umlaut mark
            '\u00D6':
                chrs[index] = 'O';
                break;
            default:
                break;
        }
    }
    return chrs;
}","char[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.preprocess(String).text","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.preprocess(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.<init>()","Constructor","* Constructs a new instance.","public ColognePhonetic() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer","Class","* This class is not thread-safe; the field {@link #length} is mutable.
     * However, it is not shared between threads, as it is constructed on demand
     * by the method {@link ColognePhonetic#colognePhonetic(String)}","Class do not obtain Source Code","No return type","abstract , static ","",""
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.data","Field","No Comment","protected final char[] data;","No return type","protected , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.length","Field","No Comment","protected int length;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.copyData(int,int)","Abstract Method","No Comment","protected abstract char[] copyData(int start, int length);","char[]","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.copyData(int,int).start","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.copyData(int,int).length","Parameter_2","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.isEmpty()","Method","No Comment","public boolean isEmpty() {
    return length() == 0;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.length()","Method","No Comment","public int length() {
    return length;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.toString()","Method","No Comment","@Override
public String toString() {
    return new String(copyData(0, length));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.<init>(char[])","Constructor","No Comment","CologneBuffer(final char[] data) {
    this.data = data;
    this.length = data.length;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.<init>(char[]).data","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.<init>(char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.<init>(int)","Constructor","No Comment","CologneBuffer(final int buffSize) {
    this.data = new char[buffSize];
    this.length = 0;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.<init>(int).buffSize","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneBuffer.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer","Class","No Comment","Class do not obtain Source Code","No return type","private , final ","org.apache.commons.codec.language.ColognePhonetic.CologneBuffer",""
"org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.copyData(int,int)","Method","No Comment","@Override
protected char[] copyData(final int start, final int length) {
    final char[] newData = new char[length];
    System.arraycopy(data, data.length - this.length + start, newData, 0, length);
    return newData;
}","char[]","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.copyData(int,int).start","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.copyData(int,int).length","Parameter_2","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.getNextChar()","Method","No Comment","public char getNextChar() {
    return data[getNextPos()];
}","char","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.getNextPos()","Method","No Comment","protected int getNextPos() {
    return data.length - length;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.removeNext()","Method","No Comment","public char removeNext() {
    final char ch = getNextChar();
    length--;
    return ch;
}","char","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.<init>(char[])","Constructor","No Comment","CologneInputBuffer(final char[] data) {
    super(data);
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.<init>(char[]).data","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneInputBuffer.<init>(char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer","Class","No Comment","Class do not obtain Source Code","No return type","private , final ","org.apache.commons.codec.language.ColognePhonetic.CologneBuffer",""
"org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.lastCode","Field","No Comment","private char lastCode;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.copyData(int,int)","Method","No Comment","@Override
protected char[] copyData(final int start, final int length) {
    return Arrays.copyOfRange(data, start, length);
}","char[]","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.copyData(int,int).start","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.copyData(int,int).length","Parameter_2","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.put(char)","Method","* Stores the next code in the output buffer, keeping track of the previous code.
         * '0' is only stored if it is the first entry.
         * Ignored chars are never stored.
         * If the code is the same as the last code (whether stored or not) it is not stored.
         *
         * @param code the code to store.","public void put(final char code) {
    if (code != CHAR_IGNORE && lastCode != code && (code != '0' || length == 0)) {
        data[length] = code;
        length++;
    }
    lastCode = code;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.put(char).code","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.put(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.<init>(int)","Constructor","No Comment","CologneOutputBuffer(final int buffSize) {
    super(buffSize);
    // impossible value
    lastCode = '/';
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.<init>(int).buffSize","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic$CologneOutputBuffer.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer","Abstract Class","* This class is not thread-safe; the field {@link #length} is mutable.
     * However, it is not shared between threads, as it is constructed on demand
     * by the method {@link ColognePhonetic#colognePhonetic(String)}","Abstract Class do not obtain Source Code","No return type","abstract , static ","",""
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.data","Field","No Comment","protected final char[] data;","No return type","protected , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.length","Field","No Comment","protected int length;","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.copyData(int,int)","Abstract Method","No Comment","protected abstract char[] copyData(int start, int length);","char[]","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.copyData(int,int).start","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.copyData(int,int).length","Parameter_2","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.isEmpty()","Method","No Comment","public boolean isEmpty() {
    return length() == 0;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.length()","Method","No Comment","public int length() {
    return length;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.toString()","Method","No Comment","@Override
public String toString() {
    return new String(copyData(0, length));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.<init>(char[])","Constructor","No Comment","CologneBuffer(final char[] data) {
    this.data = data;
    this.length = data.length;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.<init>(char[]).data","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.<init>(char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.<init>(int)","Constructor","No Comment","CologneBuffer(final int buffSize) {
    this.data = new char[buffSize];
    this.length = 0;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.<init>(int).buffSize","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer","Class","No Comment","Class do not obtain Source Code","No return type","private , final ","org.apache.commons.codec.language.ColognePhonetic.CologneBuffer",""
"org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.copyData(int,int)","Method","No Comment","@Override
protected char[] copyData(final int start, final int length) {
    final char[] newData = new char[length];
    System.arraycopy(data, data.length - this.length + start, newData, 0, length);
    return newData;
}","char[]","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.copyData(int,int).start","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.copyData(int,int).length","Parameter_2","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.getNextChar()","Method","No Comment","public char getNextChar() {
    return data[getNextPos()];
}","char","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.getNextPos()","Method","No Comment","protected int getNextPos() {
    return data.length - length;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.removeNext()","Method","No Comment","public char removeNext() {
    final char ch = getNextChar();
    length--;
    return ch;
}","char","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.<init>(char[])","Constructor","No Comment","CologneInputBuffer(final char[] data) {
    super(data);
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.<init>(char[]).data","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.<init>(char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer","Class","No Comment","Class do not obtain Source Code","No return type","private , final ","org.apache.commons.codec.language.ColognePhonetic.CologneBuffer",""
"org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.lastCode","Field","No Comment","private char lastCode;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.copyData(int,int)","Method","No Comment","@Override
protected char[] copyData(final int start, final int length) {
    return Arrays.copyOfRange(data, start, length);
}","char[]","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.copyData(int,int).start","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.copyData(int,int).length","Parameter_2","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.copyData(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.put(char)","Method","* Stores the next code in the output buffer, keeping track of the previous code.
         * '0' is only stored if it is the first entry.
         * Ignored chars are never stored.
         * If the code is the same as the last code (whether stored or not) it is not stored.
         *
         * @param code the code to store.","public void put(final char code) {
    if (code != CHAR_IGNORE && lastCode != code && (code != '0' || length == 0)) {
        data[length] = code;
        length++;
    }
    lastCode = code;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.put(char).code","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.put(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.<init>(int)","Constructor","No Comment","CologneOutputBuffer(final int buffSize) {
    super(buffSize);
    // impossible value
    lastCode = '/';
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.<init>(int).buffSize","Parameter_1","Belong to org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex","Class","* Encodes a string into a Refined Soundex value. A refined soundex code is
 * optimized for spell checking words. Soundex method originally developed by
 * <CITE>Margaret Odell</CITE> and <CITE>Robert Russell</CITE>.
 *
 * <p>This class is immutable and thread-safe.</p>","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.RefinedSoundex.US_ENGLISH_MAPPING_STRING","Field","ABCDEFGHIJKLMNOPQRSTUVWXYZ","public static final String US_ENGLISH_MAPPING_STRING = ""01360240043788015936020505"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.US_ENGLISH_MAPPING","Field","* RefinedSoundex is *refined* for a number of reasons one being that the
     * mappings have been altered. This implementation contains default
     * mappings for US English.","private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.US_ENGLISH","Field","* This static variable contains an instance of the RefinedSoundex using
     * the US_ENGLISH mapping.","public static final RefinedSoundex US_ENGLISH = new RefinedSoundex();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.soundexMapping","Field","* Every letter of the alphabet is ""mapped"" to a numerical value. This char
     * array holds the values to which each letter is mapped. This
     * implementation contains a default map for US_ENGLISH","private final char[] soundexMapping;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.difference(String,String)","Method","* Returns the number of characters in the two encoded Strings that are the
     * same. This return value ranges from 0 to the length of the shortest
     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for
     * example) indicates strong similarity or identical values. For refined
     * Soundex, the return value can be greater than 4.
     *
     * @param s1
     *                  A String that will be encoded and compared.
     * @param s2
     *                  A String that will be encoded and compared.
     * @return The number of characters in the two encoded Strings that are the
     *             same from 0 to the length of the shortest encoded String.
     *
     * @see SoundexUtils#difference(StringEncoder,String,String)
     * @see <a href=""https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp"">
     *          MS T-SQL DIFFERENCE</a>
     *
     * @throws EncoderException
     *                  if an error occurs encoding one of the strings
     * @since 1.3","public int difference(final String s1, final String s2) throws EncoderException {
    return SoundexUtils.difference(this, s1, s2);
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.difference(String,String).s1","Parameter_1","Belong to org.apache.commons.codec.language.RefinedSoundex.difference(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.difference(String,String).s2","Parameter_2","Belong to org.apache.commons.codec.language.RefinedSoundex.difference(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.encode(Object)","Method","* Encodes an Object using the refined soundex algorithm. This method is
     * provided in order to satisfy the requirements of the Encoder interface,
     * and will throw an EncoderException if the supplied object is not of type
     * {@link String}.
     *
     * @param obj
     *                  Object to encode
     * @return An object (or type {@link String}) containing the refined
     *             soundex code which corresponds to the String supplied.
     * @throws EncoderException
     *                  if the parameter supplied is not of type {@link String}","@Override
public Object encode(final Object obj) throws EncoderException {
    if (!(obj instanceof String)) {
        throw new EncoderException(""Parameter supplied to RefinedSoundex encode is not of type java.lang.String"");
    }
    return soundex((String) obj);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.language.RefinedSoundex.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.encode(String)","Method","* Encodes a String using the refined soundex algorithm.
     *
     * @param str
     *                  A String object to encode
     * @return A Soundex code corresponding to the String supplied","@Override
public String encode(final String str) {
    return soundex(str);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.encode(String).str","Parameter_1","Belong to org.apache.commons.codec.language.RefinedSoundex.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.getMappingCode(char)","Method","* Returns the mapping code for a given character. The mapping codes are
     * maintained in an internal char array named soundexMapping, and the
     * default values of these mappings are US English.
     *
     * @param c
     *                  char to get mapping for
     * @return A character (really a numeral) to return for the given char","char getMappingCode(final char c) {
    if (!Character.isLetter(c)) {
        return 0;
    }
    final int index = Character.toUpperCase(c) - 'A';
    if (index < 0 || index >= this.soundexMapping.length) {
        return 0;
    }
    return this.soundexMapping[index];
}","char","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.getMappingCode(char).c","Parameter_1","Belong to org.apache.commons.codec.language.RefinedSoundex.getMappingCode(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.soundex(String)","Method","* Retrieves the Refined Soundex code for a given String object.
     *
     * @param str
     *                  String to encode using the Refined Soundex algorithm
     * @return A soundex code for the String supplied","public String soundex(String str) {
    if (str == null) {
        return null;
    }
    str = SoundexUtils.clean(str);
    if (str.isEmpty()) {
        return str;
    }
    final StringBuilder sBuf = new StringBuilder();
    sBuf.append(str.charAt(0));
    char last, current;
    last = '*';
    for (int i = 0; i < str.length(); i++) {
        current = getMappingCode(str.charAt(i));
        if (current == last) {
            continue;
        }
        if (current != 0) {
            sBuf.append(current);
        }
        last = current;
    }
    return sBuf.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.soundex(String).str","Parameter_1","Belong to org.apache.commons.codec.language.RefinedSoundex.soundex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.<init>()","Constructor","* Creates an instance of the RefinedSoundex object using the default US
     * English mapping.","public RefinedSoundex() {
    this.soundexMapping = US_ENGLISH_MAPPING;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.<init>(char[])","Constructor","* Creates a refined soundex instance using a custom mapping. This
     * constructor can be used to customize the mapping, and/or possibly
     * provide an internationalized mapping for a non-Western character set.
     *
     * @param mapping
     *                  Mapping array to use when finding the corresponding code for
     *                  a given character","public RefinedSoundex(final char[] mapping) {
    this.soundexMapping = mapping.clone();
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.<init>(char[]).mapping","Parameter_1","Belong to org.apache.commons.codec.language.RefinedSoundex.<init>(char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.<init>(String)","Constructor","* Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,
     * and/or possibly provide an internationalized mapping for a non-Western character set.
     *
     * @param mapping
     *            Mapping string to use when finding the corresponding code for a given character
     * @since 1.4","public RefinedSoundex(final String mapping) {
    this.soundexMapping = mapping.toCharArray();
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.RefinedSoundex.<init>(String).mapping","Parameter_1","Belong to org.apache.commons.codec.language.RefinedSoundex.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.AbstractCaverphone","Abstract Class","* Encodes a string into a Caverphone value.
 *
 * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0
 * algorithm:
 *
 * <p>This class is immutable and thread-safe.</p>
 *
 * @see <a href=""https://en.wikipedia.org/wiki/Caverphone"">Wikipedia - Caverphone</a>
 * @since 1.5","Abstract Class do not obtain Source Code","No return type","public , abstract ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.AbstractCaverphone.encode(Object)","Method","* Encodes an Object using the Caverphone algorithm. This method is provided in order to satisfy the requirements of
     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type {@link String}.
     *
     * @param source
     *            Object to encode
     * @return An object (or type {@link String}) containing the Caverphone code which corresponds to the String
     *         supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type {@link String}.","@Override
public Object encode(final Object source) throws EncoderException {
    if (!(source instanceof String)) {
        throw new EncoderException(""Parameter supplied to Caverphone encode is not of type java.lang.String"");
    }
    return this.encode((String) source);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.AbstractCaverphone.encode(Object).source","Parameter_1","Belong to org.apache.commons.codec.language.AbstractCaverphone.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.AbstractCaverphone.isEncodeEqual(String,String)","Method","* Tests if the encodings of two strings are equal.
     *
     * This method might be promoted to a new AbstractStringEncoder superclass.
     *
     * @param str1
     *            First of two strings to compare
     * @param str2
     *            Second of two strings to compare
     * @return {@code true} if the encodings of these strings are identical, {@code false} otherwise.
     * @throws EncoderException
     *             thrown if there is an error condition during the encoding process.","public boolean isEncodeEqual(final String str1, final String str2) throws EncoderException {
    return this.encode(str1).equals(this.encode(str2));
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.AbstractCaverphone.isEncodeEqual(String,String).str1","Parameter_1","Belong to org.apache.commons.codec.language.AbstractCaverphone.isEncodeEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.AbstractCaverphone.isEncodeEqual(String,String).str2","Parameter_2","Belong to org.apache.commons.codec.language.AbstractCaverphone.isEncodeEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.AbstractCaverphone.<init>()","Constructor","* Constructs a new instance for subclasses.","public AbstractCaverphone() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone","Class","* Encodes a string into a Metaphone value.
 * <p>
 * Initial Java implementation by <CITE>William B. Brogden. December, 1997</CITE>.
 * Permission given by <CITE>wbrogden</CITE> for code to be used anywhere.
 * </p>
 * <p>
 * <CITE>Hanging on the Metaphone</CITE> by <CITE>Lawrence Philips</CITE> in <CITE>Computer Language of Dec. 1990,
 * p 39.</CITE>
 * </p>
 * <p>
 * Note, that this does not match the algorithm that ships with PHP, or the algorithm found in the Perl implementations:
 * </p>
 * <ul>
 * <li><a href=""https://search.cpan.org/~mschwern/Text-Metaphone-1.96/Metaphone.pm"">Text:Metaphone-1.96</a>
 *  (broken link 4/30/2013) </li>
 * <li><a href=""https://metacpan.org/source/MSCHWERN/Text-Metaphone-1.96//Metaphone.pm"">Text:Metaphone-1.96</a>
 *  (link checked 4/30/2013) </li>
 * </ul>
 * <p>
 * They have had undocumented changes from the originally published algorithm.
 * For more information, see <a href=""https://issues.apache.org/jira/browse/CODEC-57"">CODEC-57</a>.
 * </p>
 * <p>
 * This class is conditionally thread-safe.
 * The instance field for maximum code length is mutable {@link #setMaxCodeLen(int)}
 * but is not volatile, and accesses are not synchronized.
 * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronization
 * is used to ensure safe publication of the value between threads, and must not invoke {@link #setMaxCodeLen(int)}
 * after initial setup.
 * </p>","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.Metaphone.VOWELS","Field","* Five values in the English language","private static final String VOWELS = ""AEIOU"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.FRONTV","Field","* Variable used in Metaphone algorithm","private static final String FRONTV = ""EIY"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.VARSON","Field","* Variable used in Metaphone algorithm","private static final String VARSON = ""CSPTG"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.maxCodeLen","Field","* The max code length for metaphone is 4","private int maxCodeLen = 4;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.encode(Object)","Method","* Encodes an Object using the metaphone algorithm.  This method
     * is provided in order to satisfy the requirements of the
     * Encoder interface, and will throw an EncoderException if the
     * supplied object is not of type {@link String}.
     *
     * @param obj Object to encode
     * @return An object (or type {@link String}) containing the
     *         metaphone code which corresponds to the String supplied.
     * @throws EncoderException if the parameter supplied is not
     *                          of type {@link String}","@Override
public Object encode(final Object obj) throws EncoderException {
    if (!(obj instanceof String)) {
        throw new EncoderException(""Parameter supplied to Metaphone encode is not of type java.lang.String"");
    }
    return metaphone((String) obj);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.encode(String)","Method","* Encodes a String using the Metaphone algorithm.
     *
     * @param str String object to encode
     * @return The metaphone code corresponding to the String supplied","@Override
public String encode(final String str) {
    return metaphone(str);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.encode(String).str","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.getMaxCodeLen()","Method","* Gets the maxCodeLen.
     *
     * @return the maxCodeLen.","public int getMaxCodeLen() {
    return this.maxCodeLen;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isLastChar(int,int)","Method","No Comment","private boolean isLastChar(final int wdsz, final int n) {
    return n + 1 == wdsz;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isLastChar(int,int).wdsz","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.isLastChar(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isLastChar(int,int).n","Parameter_2","Belong to org.apache.commons.codec.language.Metaphone.isLastChar(int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isMetaphoneEqual(String,String)","Method","* Tests is the metaphones of two strings are identical.
     *
     * @param str1 First of two strings to compare
     * @param str2 Second of two strings to compare
     * @return {@code true} if the metaphones of these strings are identical,
     *        {@code false} otherwise.","public boolean isMetaphoneEqual(final String str1, final String str2) {
    return metaphone(str1).equals(metaphone(str2));
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isMetaphoneEqual(String,String).str1","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.isMetaphoneEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isMetaphoneEqual(String,String).str2","Parameter_2","Belong to org.apache.commons.codec.language.Metaphone.isMetaphoneEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isNextChar(StringBuilder,int,char)","Method","No Comment","private boolean isNextChar(final StringBuilder string, final int index, final char c) {
    boolean matches = false;
    if (index >= 0 && index < string.length() - 1) {
        matches = string.charAt(index + 1) == c;
    }
    return matches;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isNextChar(StringBuilder,int,char).string","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.isNextChar(StringBuilder,int,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isNextChar(StringBuilder,int,char).index","Parameter_2","Belong to org.apache.commons.codec.language.Metaphone.isNextChar(StringBuilder,int,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isNextChar(StringBuilder,int,char).c","Parameter_3","Belong to org.apache.commons.codec.language.Metaphone.isNextChar(StringBuilder,int,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isPreviousChar(StringBuilder,int,char)","Method","No Comment","private boolean isPreviousChar(final StringBuilder string, final int index, final char c) {
    boolean matches = false;
    if (index > 0 && index < string.length()) {
        matches = string.charAt(index - 1) == c;
    }
    return matches;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isPreviousChar(StringBuilder,int,char).string","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.isPreviousChar(StringBuilder,int,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isPreviousChar(StringBuilder,int,char).index","Parameter_2","Belong to org.apache.commons.codec.language.Metaphone.isPreviousChar(StringBuilder,int,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isPreviousChar(StringBuilder,int,char).c","Parameter_3","Belong to org.apache.commons.codec.language.Metaphone.isPreviousChar(StringBuilder,int,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isVowel(StringBuilder,int)","Method","No Comment","private boolean isVowel(final StringBuilder string, final int index) {
    return VOWELS.indexOf(string.charAt(index)) >= 0;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isVowel(StringBuilder,int).string","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.isVowel(StringBuilder,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.isVowel(StringBuilder,int).index","Parameter_2","Belong to org.apache.commons.codec.language.Metaphone.isVowel(StringBuilder,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.metaphone(String)","Method","* Find the metaphone value of a String. This is similar to the
     * soundex algorithm, but better at finding similar sounding words.
     * All input is converted to upper case.
     * Limitations: Input format is expected to be a single ASCII word
     * with only characters in the A - Z range, no punctuation or numbers.
     *
     * @param txt String to find the metaphone code for
     * @return A metaphone code corresponding to the String supplied","public String metaphone(final String txt) {
    boolean hard = false;
    final int txtLength;
    if (txt == null || (txtLength = txt.length()) == 0) {
        return """";
    }
    // single character is itself
    if (txtLength == 1) {
        return txt.toUpperCase(java.util.Locale.ENGLISH);
    }
    final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();
    // manipulate
    final StringBuilder local = new StringBuilder(40);
    // output
    final StringBuilder code = new StringBuilder(10);
    // handle initial 2 characters exceptions
    switch(inwd[0]) {
        case 'K':
        case 'G':
        case 'P':
            /* looking for KN, etc */
            if (inwd[1] == 'N') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'A':
            /* looking for AE */
            if (inwd[1] == 'E') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'W':
            /* looking for WR or WH */
            if (inwd[1] == 'R') {
                // WR -> R
                local.append(inwd, 1, inwd.length - 1);
                break;
            }
            if (inwd[1] == 'H') {
                local.append(inwd, 1, inwd.length - 1);
                // WH -> W
                local.setCharAt(0, 'W');
            } else {
                local.append(inwd);
            }
            break;
        case 'X':
            /* initial X becomes S */
            inwd[0] = 'S';
            local.append(inwd);
            break;
        default:
            local.append(inwd);
    }
    // now local has working string with initials fixed
    final int wdsz = local.length();
    int n = 0;
    while (code.length() < getMaxCodeLen() && n < wdsz) {
        // max code size of 4 works well
        final char symb = local.charAt(n);
        // remove duplicate letters except C
        if (symb != 'C' && isPreviousChar(local, n, symb)) {
            // empty
        } else {
            // not dup
            switch(symb) {
                case 'A':
                case 'E':
                case 'I':
                case 'O':
                case 'U':
                    if (n == 0) {
                        code.append(symb);
                    }
                    // only use vowel if leading char
                    break;
                case 'B':
                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {
                        // B is silent if word ends in MB
                        break;
                    }
                    code.append(symb);
                    break;
                case // lots of C special cases
                'C':
                    /* discard if SCI, SCE or SCY */
                    if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
                        break;
                    }
                    if (regionMatch(local, n, ""CIA"")) {
                        // ""CIA"" -> X
                        code.append('X');
                        break;
                    }
                    if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {
                        code.append('S');
                        // CI,CE,CY -> S
                        break;
                    }
                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {
                        // SCH->sk
                        code.append('K');
                        break;
                    }
                    if (!isNextChar(local, n, 'H') || n == 0 && wdsz >= 3 && isVowel(local, 2)) {
                        // CH consonant -> K consonant
                        code.append('K');
                    } else {
                        // CHvowel -> X
                        code.append('X');
                    }
                    break;
                case 'D':
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && FRONTV.indexOf(local.charAt(n + 2)) >= 0) {
                        // DGE DGI DGY -> J
                        code.append('J');
                        n += 2;
                    } else {
                        code.append('T');
                    }
                    break;
                case // GH silent at end or before consonant
                'G':
                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {
                        break;
                    }
                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {
                        break;
                    }
                    if (n > 0 && (regionMatch(local, n, ""GN"") || regionMatch(local, n, ""GNED""))) {
                        // silent G
                        break;
                    }
                    // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
                    hard = isPreviousChar(local, n, 'G');
                    if (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0 && !hard) {
                        code.append('J');
                    } else {
                        code.append('K');
                    }
                    break;
                case 'H':
                    if (isLastChar(wdsz, n)) {
                        // terminal H
                        break;
                    }
                    if (n > 0 && VARSON.indexOf(local.charAt(n - 1)) >= 0) {
                        break;
                    }
                    if (isVowel(local, n + 1)) {
                        // Hvowel
                        code.append('H');
                    }
                    break;
                case 'F':
                case 'J':
                case 'L':
                case 'M':
                case 'N':
                case 'R':
                    code.append(symb);
                    break;
                case 'K':
                    if (n > 0) {
                        // not initial
                        if (!isPreviousChar(local, n, 'C')) {
                            code.append(symb);
                        }
                    } else {
                        // initial K
                        code.append(symb);
                    }
                    break;
                case 'P':
                    if (isNextChar(local, n, 'H')) {
                        // PH -> F
                        code.append('F');
                    } else {
                        code.append(symb);
                    }
                    break;
                case 'Q':
                    code.append('K');
                    break;
                case 'S':
                    if (regionMatch(local, n, ""SH"") || regionMatch(local, n, ""SIO"") || regionMatch(local, n, ""SIA"")) {
                        code.append('X');
                    } else {
                        code.append('S');
                    }
                    break;
                case 'T':
                    if (regionMatch(local, n, ""TIA"") || regionMatch(local, n, ""TIO"")) {
                        code.append('X');
                        break;
                    }
                    if (regionMatch(local, n, ""TCH"")) {
                        // Silent if in ""TCH""
                        break;
                    }
                    // substitute numeral 0 for TH (resembles theta after all)
                    if (regionMatch(local, n, ""TH"")) {
                        code.append('0');
                    } else {
                        code.append('T');
                    }
                    break;
                case 'V':
                    code.append('F');
                    break;
                case 'W':
                case // silent if not followed by vowel
                'Y':
                    if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {
                        code.append(symb);
                    }
                    break;
                case 'X':
                    code.append('K');
                    code.append('S');
                    break;
                case 'Z':
                    code.append('S');
                    break;
                default:
                    // do nothing
                    break;
            }
            // end switch
        }
        // end else from symb != 'C'
        n++;
        if (code.length() > getMaxCodeLen()) {
            code.setLength(getMaxCodeLen());
        }
    }
    return code.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.metaphone(String).txt","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.metaphone(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.regionMatch(StringBuilder,int,String)","Method","No Comment","private boolean regionMatch(final StringBuilder string, final int index, final String test) {
    boolean matches = false;
    if (index >= 0 && index + test.length() - 1 < string.length()) {
        final String substring = string.substring(index, index + test.length());
        matches = substring.equals(test);
    }
    return matches;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.regionMatch(StringBuilder,int,String).string","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.regionMatch(StringBuilder,int,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.regionMatch(StringBuilder,int,String).index","Parameter_2","Belong to org.apache.commons.codec.language.Metaphone.regionMatch(StringBuilder,int,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.regionMatch(StringBuilder,int,String).test","Parameter_3","Belong to org.apache.commons.codec.language.Metaphone.regionMatch(StringBuilder,int,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.setMaxCodeLen(int)","Method","* Sets the maxCodeLen.
     *
     * @param maxCodeLen The maxCodeLen to set.","public void setMaxCodeLen(final int maxCodeLen) {
    this.maxCodeLen = maxCodeLen;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.setMaxCodeLen(int).maxCodeLen","Parameter_1","Belong to org.apache.commons.codec.language.Metaphone.setMaxCodeLen(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Metaphone.<init>()","Constructor","* Constructs a new instance.","public Metaphone() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone","Class","* Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence
 * Philips</CITE>.
 * <p>
 * This class is conditionally thread-safe. The instance field for the maximum code length is mutable
 * {@link #setMaxCodeLen(int)} but is not volatile, and accesses are not synchronized. If an instance of the class is
 * shared between threads, the caller needs to ensure that suitable synchronization is used to ensure safe publication
 * of the value between threads, and must not invoke {@link #setMaxCodeLen(int)} after initial setup.
 * </p>
 *
 * @see <a href=""https://drdobbs.com/the-double-metaphone-search-algorithm/184401251?pgno=2"">Dr. Dobbs Original Article</a>
 * @see <a href=""https://en.wikipedia.org/wiki/Metaphone"">Wikipedia Metaphone</a>","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.DoubleMetaphone.VOWELS","Field","* ""Vowels"" to test.","private static final String VOWELS = ""AEIOUY"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.SILENT_START","Field","* Prefixes when present which are not pronounced.","private static final String[] SILENT_START = { ""GN"", ""KN"", ""PN"", ""WR"", ""PS"" };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.L_R_N_M_B_H_F_V_W_SPACE","Field","No Comment","private static final String[] L_R_N_M_B_H_F_V_W_SPACE = { ""L"", ""R"", ""N"", ""M"", ""B"", ""H"", ""F"", ""V"", ""W"", "" "" };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER","Field","No Comment","private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER = { ""ES"", ""EP"", ""EB"", ""EL"", ""EY"", ""IB"", ""IL"", ""IN"", ""IE"", ""EI"", ""ER"" };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.L_T_K_S_N_M_B_Z","Field","No Comment","private static final String[] L_T_K_S_N_M_B_Z = { ""L"", ""T"", ""K"", ""S"", ""N"", ""M"", ""B"", ""Z"" };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.maxCodeLen","Field","* Maximum length of an encoding, default is 4","private int maxCodeLen = 4;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.contains(String,int,int,String[])","Method","* Tests whether {@code value} contains any of the {@code criteria} starting at index {@code start} and matching up to length {@code length}.
     *
     * @param value    The value to test.
     * @param start    Where in {@code value} to start testing.
     * @param length   How many to test.
     * @param criteria The search criteria.
     * @return Whether there was a match.","protected static boolean contains(final String value, final int start, final int length, final String... criteria) {
    boolean result = false;
    if (start >= 0 && start + length <= value.length()) {
        final String target = value.substring(start, start + length);
        for (final String element : criteria) {
            if (target.equals(element)) {
                result = true;
                break;
            }
        }
    }
    return result;
}","boolean","protected , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.contains(String,int,int,String[]).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.contains(String,int,int,String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.contains(String,int,int,String[]).start","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.contains(String,int,int,String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.contains(String,int,int,String[]).length","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.contains(String,int,int,String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.contains(String,int,int,String[]).criteria","Parameter_4","Belong to org.apache.commons.codec.language.DoubleMetaphone.contains(String,int,int,String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.charAt(String,int)","Method","* Gets the character at index {@code index} if available, or {@link Character#MIN_VALUE} if out of bounds.
     *
     * @param value The String to query.
     * @param index A string index.
     * @return The character at the index or {@link Character#MIN_VALUE} if out of bounds.","protected char charAt(final String value, final int index) {
    if (index < 0 || index >= value.length()) {
        return Character.MIN_VALUE;
    }
    return value.charAt(index);
}","char","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.charAt(String,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.charAt(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.charAt(String,int).index","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.charAt(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.cleanInput(String)","Method","* Cleans the input.","private String cleanInput(String input) {
    if (input == null) {
        return null;
    }
    input = input.trim();
    if (input.isEmpty()) {
        return null;
    }
    return input.toUpperCase(java.util.Locale.ENGLISH);
}","String","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.cleanInput(String).input","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.cleanInput(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionC0(String,int)","Method","* Complex condition 0 for 'C'.","private boolean conditionC0(final String value, final int index) {
    if (contains(value, index, 4, ""CHIA"")) {
        return true;
    }
    if (index <= 1) {
        return false;
    }
    if (isVowel(charAt(value, index - 2))) {
        return false;
    }
    if (!contains(value, index - 1, 3, ""ACH"")) {
        return false;
    }
    final char c = charAt(value, index + 2);
    return c != 'I' && c != 'E' || contains(value, index - 2, 6, ""BACHER"", ""MACHER"");
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionC0(String,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionC0(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionC0(String,int).index","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionC0(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionCH0(String,int)","Method","* Complex condition 0 for 'CH'.","private boolean conditionCH0(final String value, final int index) {
    if (index != 0) {
        return false;
    }
    if (!contains(value, index + 1, 5, ""HARAC"", ""HARIS"") && !contains(value, index + 1, 3, ""HOR"", ""HYM"", ""HIA"", ""HEM"")) {
        return false;
    }
    return !contains(value, 0, 5, ""CHORE"");
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionCH0(String,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionCH0(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionCH0(String,int).index","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionCH0(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionCH1(String,int)","Method","* Complex condition 1 for 'CH'.","private boolean conditionCH1(final String value, final int index) {
    return contains(value, 0, 4, ""VAN "", ""VON "") || contains(value, 0, 3, ""SCH"") || contains(value, index - 2, 6, ""ORCHES"", ""ARCHIT"", ""ORCHID"") || contains(value, index + 2, 1, ""T"", ""S"") || (contains(value, index - 1, 1, ""A"", ""O"", ""U"", ""E"") || index == 0) && (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1);
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionCH1(String,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionCH1(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionCH1(String,int).index","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionCH1(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionL0(String,int)","Method","* Complex condition 0 for 'L'.","private boolean conditionL0(final String value, final int index) {
    if (index == value.length() - 3 && contains(value, index - 1, 4, ""ILLO"", ""ILLA"", ""ALLE"")) {
        return true;
    }
    return (contains(value, value.length() - 2, 2, ""AS"", ""OS"") || contains(value, value.length() - 1, 1, ""A"", ""O"")) && contains(value, index - 1, 4, ""ALLE"");
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionL0(String,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionL0(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionL0(String,int).index","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionL0(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionM0(String,int)","Method","* Complex condition 0 for 'M'.","private boolean conditionM0(final String value, final int index) {
    if (charAt(value, index + 1) == 'M') {
        return true;
    }
    return contains(value, index - 1, 3, ""UMB"") && (index + 1 == value.length() - 1 || contains(value, index + 2, 2, ""ER""));
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionM0(String,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionM0(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.conditionM0(String,int).index","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.conditionM0(String,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(String)","Method","* Encode a value with Double Metaphone.
     *
     * @param value String to encode
     * @return an encoded string","public String doubleMetaphone(final String value) {
    return doubleMetaphone(value, false);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(String,boolean)","Method","* Encode a value with Double Metaphone, optionally using the alternate encoding.
     *
     * @param value String to encode
     * @param alternate use alternate encode
     * @return an encoded string","public String doubleMetaphone(String value, final boolean alternate) {
    value = cleanInput(value);
    if (value == null) {
        return null;
    }
    final boolean slavoGermanic = isSlavoGermanic(value);
    int index = isSilentStart(value) ? 1 : 0;
    final DoubleMetaphoneResult result = new DoubleMetaphoneResult(getMaxCodeLen());
    while (!result.isComplete() && index <= value.length() - 1) {
        switch(value.charAt(index)) {
            case 'A':
            case 'E':
            case 'I':
            case 'O':
            case 'U':
            case 'Y':
                index = handleAEIOUY(result, index);
                break;
            case 'B':
                result.append('P');
                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;
                break;
            case '\u00C7':
                // A C with a Cedilla
                result.append('S');
                index++;
                break;
            case 'C':
                index = handleC(value, result, index);
                break;
            case 'D':
                index = handleD(value, result, index);
                break;
            case 'F':
                result.append('F');
                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;
                break;
            case 'G':
                index = handleG(value, result, index, slavoGermanic);
                break;
            case 'H':
                index = handleH(value, result, index);
                break;
            case 'J':
                index = handleJ(value, result, index, slavoGermanic);
                break;
            case 'K':
                result.append('K');
                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;
                break;
            case 'L':
                index = handleL(value, result, index);
                break;
            case 'M':
                result.append('M');
                index = conditionM0(value, index) ? index + 2 : index + 1;
                break;
            case 'N':
                result.append('N');
                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;
                break;
            case '\u00D1':
                // N with a tilde (spanish ene)
                result.append('N');
                index++;
                break;
            case 'P':
                index = handleP(value, result, index);
                break;
            case 'Q':
                result.append('K');
                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;
                break;
            case 'R':
                index = handleR(value, result, index, slavoGermanic);
                break;
            case 'S':
                index = handleS(value, result, index, slavoGermanic);
                break;
            case 'T':
                index = handleT(value, result, index);
                break;
            case 'V':
                result.append('F');
                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;
                break;
            case 'W':
                index = handleW(value, result, index);
                break;
            case 'X':
                index = handleX(value, result, index);
                break;
            case 'Z':
                index = handleZ(value, result, index, slavoGermanic);
                break;
            default:
                index++;
                break;
        }
    }
    return alternate ? result.getAlternate() : result.getPrimary();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(String,boolean).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(String,boolean).alternate","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.encode(Object)","Method","* Encode the value using DoubleMetaphone.  It will only work if
     * {@code obj} is a {@code String} (like {@code Metaphone}).
     *
     * @param obj Object to encode (should be of type String)
     * @return An encoded Object (will be of type String)
     * @throws EncoderException encode parameter is not of type String","@Override
public Object encode(final Object obj) throws EncoderException {
    if (!(obj instanceof String)) {
        throw new EncoderException(""DoubleMetaphone encode parameter is not of type String"");
    }
    return doubleMetaphone((String) obj);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.encode(String)","Method","* Encode the value using DoubleMetaphone.
     *
     * @param value String to encode
     * @return An encoded String","@Override
public String encode(final String value) {
    return doubleMetaphone(value);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.encode(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.getMaxCodeLen()","Method","* Returns the maxCodeLen.
     * @return int","public int getMaxCodeLen() {
    return this.maxCodeLen;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleAEIOUY(DoubleMetaphoneResult,int)","Method","* Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.","private int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {
    if (index == 0) {
        result.append('A');
    }
    return index + 1;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleAEIOUY(DoubleMetaphoneResult,int).result","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleAEIOUY(DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleAEIOUY(DoubleMetaphoneResult,int).index","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleAEIOUY(DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleC(String,DoubleMetaphoneResult,int)","Method","* Handles 'C' cases.","private int handleC(final String value, final DoubleMetaphoneResult result, int index) {
    if (conditionC0(value, index)) {
        // very confusing, moved out
        result.append('K');
        index += 2;
    } else if (index == 0 && contains(value, index, 6, ""CAESAR"")) {
        result.append('S');
        index += 2;
    } else if (contains(value, index, 2, ""CH"")) {
        index = handleCH(value, result, index);
    } else if (contains(value, index, 2, ""CZ"") && !contains(value, index - 2, 4, ""WICZ"")) {
        //-- ""Czerny"" --//
        result.append('S', 'X');
        index += 2;
    } else if (contains(value, index + 1, 3, ""CIA"")) {
        //-- ""focaccia"" --//
        result.append('X');
        index += 3;
    } else if (contains(value, index, 2, ""CC"") && !(index == 1 && charAt(value, 0) == 'M')) {
        //-- double ""cc"" but not ""McClelland"" --//
        return handleCC(value, result, index);
    } else if (contains(value, index, 2, ""CK"", ""CG"", ""CQ"")) {
        result.append('K');
        index += 2;
    } else if (contains(value, index, 2, ""CI"", ""CE"", ""CY"")) {
        //-- Italian vs. English --//
        if (contains(value, index, 3, ""CIO"", ""CIE"", ""CIA"")) {
            result.append('S', 'X');
        } else {
            result.append('S');
        }
        index += 2;
    } else {
        result.append('K');
        if (contains(value, index + 1, 2, "" C"", "" Q"", "" G"")) {
            //-- Mac Caffrey, Mac Gregor --//
            index += 3;
        } else if (contains(value, index + 1, 1, ""C"", ""K"", ""Q"") && !contains(value, index + 1, 2, ""CE"", ""CI"")) {
            index += 2;
        } else {
            index++;
        }
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleC(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleC(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleC(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleC(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleC(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleC(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleCC(String,DoubleMetaphoneResult,int)","Method","* Handles 'CC' cases.","private int handleCC(final String value, final DoubleMetaphoneResult result, int index) {
    if (contains(value, index + 2, 1, ""I"", ""E"", ""H"") && !contains(value, index + 2, 2, ""HU"")) {
        //-- ""bellocchio"" but not ""bacchus"" --//
        if (index == 1 && charAt(value, index - 1) == 'A' || contains(value, index - 1, 5, ""UCCEE"", ""UCCES"")) {
            //-- ""accident"", ""accede"", ""succeed"" --//
            result.append(""KS"");
        } else {
            //-- ""bacci"", ""bertucci"", other Italian --//
            result.append('X');
        }
        index += 3;
    } else {
        // Pierce's rule
        result.append('K');
        index += 2;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleCC(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleCC(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleCC(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleCC(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleCC(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleCC(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleCH(String,DoubleMetaphoneResult,int)","Method","* Handles 'CH' cases.","private int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {
    if (index > 0 && contains(value, index, 4, ""CHAE"")) {
        // Michael
        result.append('K', 'X');
        return index + 2;
    }
    if (conditionCH0(value, index)) {
        //-- Greek roots (""chemistry"", ""chorus"", etc.) --//
        result.append('K');
        return index + 2;
    }
    if (conditionCH1(value, index)) {
        //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//
        result.append('K');
        return index + 2;
    }
    if (index > 0) {
        if (contains(value, 0, 2, ""MC"")) {
            result.append('K');
        } else {
            result.append('X', 'K');
        }
    } else {
        result.append('X');
    }
    return index + 2;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleCH(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleCH(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleCH(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleCH(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleCH(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleCH(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleD(String,DoubleMetaphoneResult,int)","Method","* Handles 'D' cases.","private int handleD(final String value, final DoubleMetaphoneResult result, int index) {
    if (contains(value, index, 2, ""DG"")) {
        //-- ""Edge"" --//
        if (contains(value, index + 2, 1, ""I"", ""E"", ""Y"")) {
            result.append('J');
            index += 3;
            //-- ""Edgar"" --//
        } else {
            result.append(""TK"");
            index += 2;
        }
    } else if (contains(value, index, 2, ""DT"", ""DD"")) {
        result.append('T');
        index += 2;
    } else {
        result.append('T');
        index++;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleD(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleD(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleD(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleD(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleD(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleD(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleG(String,DoubleMetaphoneResult,int,boolean)","Method","* Handles 'G' cases.","private int handleG(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {
    if (charAt(value, index + 1) == 'H') {
        index = handleGH(value, result, index);
    } else if (charAt(value, index + 1) == 'N') {
        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {
            result.append(""KN"", ""N"");
        } else if (!contains(value, index + 2, 2, ""EY"") && charAt(value, index + 1) != 'Y' && !slavoGermanic) {
            result.append(""N"", ""KN"");
        } else {
            result.append(""KN"");
        }
        index += 2;
    } else if (contains(value, index + 1, 2, ""LI"") && !slavoGermanic) {
        result.append(""KL"", ""L"");
        index += 2;
    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {
        //-- -ges-, -gep-, -gel-, -gie- at beginning --//
        result.append('K', 'J');
        index += 2;
    } else if ((contains(value, index + 1, 2, ""ER"") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, ""DANGER"", ""RANGER"", ""MANGER"") && !contains(value, index - 1, 1, ""E"", ""I"") && !contains(value, index - 1, 3, ""RGY"", ""OGY"")) {
        //-- -ger-, -gy- --//
        result.append('K', 'J');
        index += 2;
    } else if (contains(value, index + 1, 1, ""E"", ""I"", ""Y"") || contains(value, index - 1, 4, ""AGGI"", ""OGGI"")) {
        //-- Italian ""biaggi"" --//
        if (contains(value, 0, 4, ""VAN "", ""VON "") || contains(value, 0, 3, ""SCH"") || contains(value, index + 1, 2, ""ET"")) {
            //-- obvious germanic --//
            result.append('K');
        } else if (contains(value, index + 1, 3, ""IER"")) {
            result.append('J');
        } else {
            result.append('J', 'K');
        }
        index += 2;
    } else {
        if (charAt(value, index + 1) == 'G') {
            index += 2;
        } else {
            index++;
        }
        result.append('K');
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleG(String,DoubleMetaphoneResult,int,boolean).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleG(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleG(String,DoubleMetaphoneResult,int,boolean).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleG(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleG(String,DoubleMetaphoneResult,int,boolean).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleG(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleG(String,DoubleMetaphoneResult,int,boolean).slavoGermanic","Parameter_4","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleG(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleGH(String,DoubleMetaphoneResult,int)","Method","* Handles 'GH' cases.","private int handleGH(final String value, final DoubleMetaphoneResult result, int index) {
    if (index > 0 && !isVowel(charAt(value, index - 1))) {
        result.append('K');
        index += 2;
    } else if (index == 0) {
        if (charAt(value, index + 2) == 'I') {
            result.append('J');
        } else {
            result.append('K');
        }
        index += 2;
    } else if (index > 1 && contains(value, index - 2, 1, ""B"", ""H"", ""D"") || index > 2 && contains(value, index - 3, 1, ""B"", ""H"", ""D"") || index > 3 && contains(value, index - 4, 1, ""B"", ""H"")) {
        //-- Parker's rule (with some further refinements) - ""hugh""
        index += 2;
    } else {
        if (index > 2 && charAt(value, index - 1) == 'U' && contains(value, index - 3, 1, ""C"", ""G"", ""L"", ""R"", ""T"")) {
            //-- ""laugh"", ""McLaughlin"", ""cough"", ""gough"", ""rough"", ""tough""
            result.append('F');
        } else if (index > 0 && charAt(value, index - 1) != 'I') {
            result.append('K');
        }
        index += 2;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleGH(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleGH(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleGH(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleGH(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleGH(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleGH(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleH(String,DoubleMetaphoneResult,int)","Method","* Handles 'H' cases.","private int handleH(final String value, final DoubleMetaphoneResult result, int index) {
    //-- only keep if first & before vowel or between 2 vowels --//
    if ((index == 0 || isVowel(charAt(value, index - 1))) && isVowel(charAt(value, index + 1))) {
        result.append('H');
        index += 2;
        //-- also takes car of ""HH"" --//
    } else {
        index++;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleH(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleH(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleH(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleH(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleH(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleH(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleJ(String,DoubleMetaphoneResult,int,boolean)","Method","* Handles 'J' cases.","private int handleJ(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {
    if (contains(value, index, 4, ""JOSE"") || contains(value, 0, 4, ""SAN "")) {
        //-- obvious Spanish, ""Jose"", ""San Jacinto"" --//
        if (index == 0 && charAt(value, index + 4) == ' ' || value.length() == 4 || contains(value, 0, 4, ""SAN "")) {
            result.append('H');
        } else {
            result.append('J', 'H');
        }
        index++;
    } else {
        if (index == 0 && !contains(value, index, 4, ""JOSE"")) {
            result.append('J', 'A');
        } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {
            result.append('J', 'H');
        } else if (index == value.length() - 1) {
            result.append('J', ' ');
        } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, ""S"", ""K"", ""L"")) {
            result.append('J');
        }
        if (charAt(value, index + 1) == 'J') {
            index += 2;
        } else {
            index++;
        }
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleJ(String,DoubleMetaphoneResult,int,boolean).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleJ(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleJ(String,DoubleMetaphoneResult,int,boolean).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleJ(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleJ(String,DoubleMetaphoneResult,int,boolean).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleJ(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleJ(String,DoubleMetaphoneResult,int,boolean).slavoGermanic","Parameter_4","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleJ(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleL(String,DoubleMetaphoneResult,int)","Method","* Handles 'L' cases.","private int handleL(final String value, final DoubleMetaphoneResult result, int index) {
    if (charAt(value, index + 1) == 'L') {
        if (conditionL0(value, index)) {
            result.appendPrimary('L');
        } else {
            result.append('L');
        }
        index += 2;
    } else {
        index++;
        result.append('L');
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleL(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleL(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleL(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleL(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleL(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleL(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleP(String,DoubleMetaphoneResult,int)","Method","* Handles 'P' cases.","private int handleP(final String value, final DoubleMetaphoneResult result, int index) {
    if (charAt(value, index + 1) == 'H') {
        result.append('F');
        index += 2;
    } else {
        result.append('P');
        index = contains(value, index + 1, 1, ""P"", ""B"") ? index + 2 : index + 1;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleP(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleP(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleP(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleP(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleP(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleP(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleR(String,DoubleMetaphoneResult,int,boolean)","Method","* Handles 'R' cases.","private int handleR(final String value, final DoubleMetaphoneResult result, final int index, final boolean slavoGermanic) {
    if (index == value.length() - 1 && !slavoGermanic && contains(value, index - 2, 2, ""IE"") && !contains(value, index - 4, 2, ""ME"", ""MA"")) {
        result.appendAlternate('R');
    } else {
        result.append('R');
    }
    return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleR(String,DoubleMetaphoneResult,int,boolean).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleR(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleR(String,DoubleMetaphoneResult,int,boolean).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleR(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleR(String,DoubleMetaphoneResult,int,boolean).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleR(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleR(String,DoubleMetaphoneResult,int,boolean).slavoGermanic","Parameter_4","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleR(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleS(String,DoubleMetaphoneResult,int,boolean)","Method","* Handles 'S' cases.","private int handleS(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {
    if (contains(value, index - 1, 3, ""ISL"", ""YSL"")) {
        //-- special cases ""island"", ""isle"", ""carlisle"", ""carlysle"" --//
        index++;
    } else if (index == 0 && contains(value, index, 5, ""SUGAR"")) {
        //-- special case ""sugar-"" --//
        result.append('X', 'S');
        index++;
    } else if (contains(value, index, 2, ""SH"")) {
        if (contains(value, index + 1, 4, ""HEIM"", ""HOEK"", ""HOLM"", ""HOLZ"")) {
            //-- germanic --//
            result.append('S');
        } else {
            result.append('X');
        }
        index += 2;
    } else if (contains(value, index, 3, ""SIO"", ""SIA"") || contains(value, index, 4, ""SIAN"")) {
        //-- Italian and Armenian --//
        if (slavoGermanic) {
            result.append('S');
        } else {
            result.append('S', 'X');
        }
        index += 3;
    } else if (index == 0 && contains(value, index + 1, 1, ""M"", ""N"", ""L"", ""W"") || contains(value, index + 1, 1, ""Z"")) {
        //-- german & anglicisations, for example ""smith"" match ""schmidt"" //
        // ""snider"" match ""schneider"" --//
        //-- also, -sz- in slavic language although in hungarian it //
        //   is pronounced ""s"" --//
        result.append('S', 'X');
        index = contains(value, index + 1, 1, ""Z"") ? index + 2 : index + 1;
    } else if (contains(value, index, 2, ""SC"")) {
        index = handleSC(value, result, index);
    } else {
        if (index == value.length() - 1 && contains(value, index - 2, 2, ""AI"", ""OI"")) {
            //-- french for example ""resnais"", ""artois"" --//
            result.appendAlternate('S');
        } else {
            result.append('S');
        }
        index = contains(value, index + 1, 1, ""S"", ""Z"") ? index + 2 : index + 1;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleS(String,DoubleMetaphoneResult,int,boolean).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleS(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleS(String,DoubleMetaphoneResult,int,boolean).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleS(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleS(String,DoubleMetaphoneResult,int,boolean).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleS(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleS(String,DoubleMetaphoneResult,int,boolean).slavoGermanic","Parameter_4","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleS(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleSC(String,DoubleMetaphoneResult,int)","Method","* Handles 'SC' cases.","private int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {
    if (charAt(value, index + 2) == 'H') {
        //-- Schlesinger's rule --//
        if (contains(value, index + 3, 2, ""OO"", ""ER"", ""EN"", ""UY"", ""ED"", ""EM"")) {
            //-- Dutch origin, for example ""school"", ""schooner"" --//
            if (contains(value, index + 3, 2, ""ER"", ""EN"")) {
                //-- ""schermerhorn"", ""schenker"" --//
                result.append(""X"", ""SK"");
            } else {
                result.append(""SK"");
            }
        } else if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {
            result.append('X', 'S');
        } else {
            result.append('X');
        }
    } else if (contains(value, index + 2, 1, ""I"", ""E"", ""Y"")) {
        result.append('S');
    } else {
        result.append(""SK"");
    }
    return index + 3;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleSC(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleSC(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleSC(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleSC(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleSC(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleSC(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleT(String,DoubleMetaphoneResult,int)","Method","* Handles 'T' cases.","private int handleT(final String value, final DoubleMetaphoneResult result, int index) {
    if (contains(value, index, 4, ""TION"") || contains(value, index, 3, ""TIA"", ""TCH"")) {
        result.append('X');
        index += 3;
    } else if (contains(value, index, 2, ""TH"") || contains(value, index, 3, ""TTH"")) {
        if (contains(value, index + 2, 2, ""OM"", ""AM"") || //-- special case ""thomas"", ""thames"" or germanic --//
        contains(value, 0, 4, ""VAN "", ""VON "") || contains(value, 0, 3, ""SCH"")) {
            result.append('T');
        } else {
            result.append('0', 'T');
        }
        index += 2;
    } else {
        result.append('T');
        index = contains(value, index + 1, 1, ""T"", ""D"") ? index + 2 : index + 1;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleT(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleT(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleT(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleT(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleT(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleT(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleW(String,DoubleMetaphoneResult,int)","Method","* Handles 'W' cases.","private int handleW(final String value, final DoubleMetaphoneResult result, int index) {
    if (contains(value, index, 2, ""WR"")) {
        //-- can also be in middle of word --//
        result.append('R');
        index += 2;
    } else if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, ""WH""))) {
        if (isVowel(charAt(value, index + 1))) {
            //-- Wasserman should match Vasserman --//
            result.append('A', 'F');
        } else {
            //-- need Uomo to match Womo --//
            result.append('A');
        }
        index++;
    } else if (index == value.length() - 1 && isVowel(charAt(value, index - 1)) || contains(value, index - 1, 5, ""EWSKI"", ""EWSKY"", ""OWSKI"", ""OWSKY"") || contains(value, 0, 3, ""SCH"")) {
        //-- Arnow should match Arnoff --//
        result.appendAlternate('F');
        index++;
    } else if (contains(value, index, 4, ""WICZ"", ""WITZ"")) {
        //-- Polish for example ""filipowicz"" --//
        result.append(""TS"", ""FX"");
        index += 4;
    } else {
        index++;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleW(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleW(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleW(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleW(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleW(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleW(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleX(String,DoubleMetaphoneResult,int)","Method","* Handles 'X' cases.","private int handleX(final String value, final DoubleMetaphoneResult result, int index) {
    if (index == 0) {
        result.append('S');
        index++;
    } else {
        if (!(index == value.length() - 1 && (contains(value, index - 3, 3, ""IAU"", ""EAU"") || contains(value, index - 2, 2, ""AU"", ""OU"")))) {
            //-- French for example breaux --//
            result.append(""KS"");
        }
        index = contains(value, index + 1, 1, ""C"", ""X"") ? index + 2 : index + 1;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleX(String,DoubleMetaphoneResult,int).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleX(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleX(String,DoubleMetaphoneResult,int).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleX(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleX(String,DoubleMetaphoneResult,int).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleX(String,DoubleMetaphoneResult,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleZ(String,DoubleMetaphoneResult,int,boolean)","Method","* Handles 'Z' cases.","private int handleZ(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {
    if (charAt(value, index + 1) == 'H') {
        //-- Chinese pinyin for example ""zhao"" or Angelina ""Zhang"" --//
        result.append('J');
        index += 2;
    } else {
        if (contains(value, index + 1, 2, ""ZO"", ""ZI"", ""ZA"") || slavoGermanic && index > 0 && charAt(value, index - 1) != 'T') {
            result.append(""S"", ""TS"");
        } else {
            result.append('S');
        }
        index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;
    }
    return index;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleZ(String,DoubleMetaphoneResult,int,boolean).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleZ(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleZ(String,DoubleMetaphoneResult,int,boolean).result","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleZ(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleZ(String,DoubleMetaphoneResult,int,boolean).index","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleZ(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.handleZ(String,DoubleMetaphoneResult,int,boolean).slavoGermanic","Parameter_4","Belong to org.apache.commons.codec.language.DoubleMetaphone.handleZ(String,DoubleMetaphoneResult,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String)","Method","* Check if the Double Metaphone values of two {@code String} values
     * are equal.
     *
     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.
     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.
     * @return {@code true} if the encoded {@code String}s are equal;
     *          {@code false} otherwise.
     * @see #isDoubleMetaphoneEqual(String,String,boolean)","public boolean isDoubleMetaphoneEqual(final String value1, final String value2) {
    return isDoubleMetaphoneEqual(value1, value2, false);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String).value1","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String).value2","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String,boolean)","Method","* Check if the Double Metaphone values of two {@code String} values
     * are equal, optionally using the alternate value.
     *
     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.
     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.
     * @param alternate use the alternate value if {@code true}.
     * @return {@code true} if the encoded {@code String}s are equal;
     *          {@code false} otherwise.","public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {
    return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String,boolean).value1","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String,boolean).value2","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String,boolean).alternate","Parameter_3","Belong to org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(String,String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isSilentStart(String)","Method","* Determines whether or not the value starts with a silent letter.  It will
     * return {@code true} if the value starts with any of 'GN', 'KN',
     * 'PN', 'WR' or 'PS'.","private boolean isSilentStart(final String value) {
    boolean result = false;
    for (final String element : SILENT_START) {
        if (value.startsWith(element)) {
            result = true;
            break;
        }
    }
    return result;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isSilentStart(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.isSilentStart(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isSlavoGermanic(String)","Method","* Determines whether or not a value is of slavo-germanic origin. A value is
     * of slavo-germanic origin if it contains any of 'W', 'K', 'CZ', or 'WITZ'.","private boolean isSlavoGermanic(final String value) {
    return value.indexOf('W') > -1 || value.indexOf('K') > -1 || value.contains(""CZ"") || value.contains(""WITZ"");
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isSlavoGermanic(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.isSlavoGermanic(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)","Method","* Determines whether or not a character is a vowel or not","private boolean isVowel(final char ch) {
    return VOWELS.indexOf(ch) != -1;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.isVowel(char).ch","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.setMaxCodeLen(int)","Method","* Sets the maxCodeLen.
     * @param maxCodeLen The maxCodeLen to set","public void setMaxCodeLen(final int maxCodeLen) {
    this.maxCodeLen = maxCodeLen;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.setMaxCodeLen(int).maxCodeLen","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.setMaxCodeLen(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.<init>()","Constructor","* Constructs a new instance.","public DoubleMetaphone() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult","Class","* Stores results, since there is the optional alternate encoding.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.primary","Field","No Comment","private final StringBuilder primary = new StringBuilder(getMaxCodeLen());","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.alternate","Field","No Comment","private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.maxLength","Field","No Comment","private final int maxLength;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(char)","Method","* Appends the given value as primary and alternative.
         *
         * @param value The value to append.","public void append(final char value) {
    appendPrimary(value);
    appendAlternate(value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(char).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(char,char)","Method","* Appends the given primary and alternative values.
         *
         * @param primary   The primary value.
         * @param alternate The alternate value.","public void append(final char primary, final char alternate) {
    appendPrimary(primary);
    appendAlternate(alternate);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(char,char).primary","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(char,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(char,char).alternate","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(char,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(String)","Method","* Appends the given value as primary and alternative.
         *
         * @param value The value to append.","public void append(final String value) {
    appendPrimary(value);
    appendAlternate(value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(String,String)","Method","* Appends the given primary and alternative values.
         *
         * @param primary   The primary value.
         * @param alternate The alternate value.","public void append(final String primary, final String alternate) {
    appendPrimary(primary);
    appendAlternate(alternate);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(String,String).primary","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(String,String).alternate","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.append(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendAlternate(char)","Method","* Appends the given value as alternative.
         *
         * @param value The value to append.","public void appendAlternate(final char value) {
    if (this.alternate.length() < this.maxLength) {
        this.alternate.append(value);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendAlternate(char).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendAlternate(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendAlternate(String)","Method","* Appends the given value as alternative.
         *
         * @param value The value to append.","public void appendAlternate(final String value) {
    final int addChars = this.maxLength - this.alternate.length();
    if (value.length() <= addChars) {
        this.alternate.append(value);
    } else {
        this.alternate.append(value, 0, addChars);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendAlternate(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendAlternate(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendPrimary(char)","Method","* Appends the given value as primary.
         *
         * @param value The value to append.","public void appendPrimary(final char value) {
    if (this.primary.length() < this.maxLength) {
        this.primary.append(value);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendPrimary(char).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendPrimary(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendPrimary(String)","Method","* Appends the given value as primary.
         *
         * @param value The value to append.","public void appendPrimary(final String value) {
    final int addChars = this.maxLength - this.primary.length();
    if (value.length() <= addChars) {
        this.primary.append(value);
    } else {
        this.primary.append(value, 0, addChars);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendPrimary(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.appendPrimary(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.getAlternate()","Method","* Gets the alternate string.
         *
         * @return the alternate string.","public String getAlternate() {
    return this.alternate.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.getPrimary()","Method","* Gets the primary string.
         *
         * @return the primary string.","public String getPrimary() {
    return this.primary.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.isComplete()","Method","* Tests whether this result is complete.
         *
         * @return whether this result is complete.","public boolean isComplete() {
    return this.primary.length() >= this.maxLength && this.alternate.length() >= this.maxLength;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.<init>(int)","Constructor","* Constructs a new instance.
         *
         * @param maxLength The maximum length.","public DoubleMetaphoneResult(final int maxLength) {
    this.maxLength = maxLength;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.<init>(int).maxLength","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult","Class","* Stores results, since there is the optional alternate encoding.","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.primary","Field","No Comment","private final StringBuilder primary = new StringBuilder(getMaxCodeLen());","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.alternate","Field","No Comment","private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.maxLength","Field","No Comment","private final int maxLength;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)","Method","* Appends the given value as primary and alternative.
         *
         * @param value The value to append.","public void append(final char value) {
    appendPrimary(value);
    appendAlternate(value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char,char)","Method","* Appends the given primary and alternative values.
         *
         * @param primary   The primary value.
         * @param alternate The alternate value.","public void append(final char primary, final char alternate) {
    appendPrimary(primary);
    appendAlternate(alternate);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char,char).primary","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char,char).alternate","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(String)","Method","* Appends the given value as primary and alternative.
         *
         * @param value The value to append.","public void append(final String value) {
    appendPrimary(value);
    appendAlternate(value);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(String,String)","Method","* Appends the given primary and alternative values.
         *
         * @param primary   The primary value.
         * @param alternate The alternate value.","public void append(final String primary, final String alternate) {
    appendPrimary(primary);
    appendAlternate(alternate);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(String,String).primary","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(String,String).alternate","Parameter_2","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char)","Method","* Appends the given value as alternative.
         *
         * @param value The value to append.","public void appendAlternate(final char value) {
    if (this.alternate.length() < this.maxLength) {
        this.alternate.append(value);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(String)","Method","* Appends the given value as alternative.
         *
         * @param value The value to append.","public void appendAlternate(final String value) {
    final int addChars = this.maxLength - this.alternate.length();
    if (value.length() <= addChars) {
        this.alternate.append(value);
    } else {
        this.alternate.append(value, 0, addChars);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(char)","Method","* Appends the given value as primary.
         *
         * @param value The value to append.","public void appendPrimary(final char value) {
    if (this.primary.length() < this.maxLength) {
        this.primary.append(value);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(char).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(String)","Method","* Appends the given value as primary.
         *
         * @param value The value to append.","public void appendPrimary(final String value) {
    final int addChars = this.maxLength - this.primary.length();
    if (value.length() <= addChars) {
        this.primary.append(value);
    } else {
        this.primary.append(value, 0, addChars);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(String).value","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.getAlternate()","Method","* Gets the alternate string.
         *
         * @return the alternate string.","public String getAlternate() {
    return this.alternate.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.getPrimary()","Method","* Gets the primary string.
         *
         * @return the primary string.","public String getPrimary() {
    return this.primary.toString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.isComplete()","Method","* Tests whether this result is complete.
         *
         * @return whether this result is complete.","public boolean isComplete() {
    return this.primary.length() >= this.maxLength && this.alternate.length() >= this.maxLength;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.<init>(int)","Constructor","* Constructs a new instance.
         *
         * @param maxLength The maximum length.","public DoubleMetaphoneResult(final int maxLength) {
    this.maxLength = maxLength;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.<init>(int).maxLength","Parameter_1","Belong to org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone2","Class","* Encodes a string into a Caverphone 2.0 value.
 *
 * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0
 * algorithm:
 *
 * @see <a href=""https://en.wikipedia.org/wiki/Caverphone"">Wikipedia - Caverphone</a>
 * @see <a href=""https://caversham.otago.ac.nz/files/working/ctp150804.pdf"">Caverphone 2.0 specification</a>
 * @since 1.5
 *
 * <p>This class is immutable and thread-safe.</p>","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.language.AbstractCaverphone",""
"org.apache.commons.codec.language.Caverphone2.TEN_1","Field","No Comment","private static final String TEN_1 = ""1111111111"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone2.encode(String)","Method","* Encodes the given String into a Caverphone 2.0 value.
     *
     * @param source
     *            String the source string
     * @return A Caverphone code for the given String","@Override
public String encode(final String source) {
    String txt = source;
    if (SoundexUtils.isEmpty(txt)) {
        return TEN_1;
    }
    // 1. Convert to lowercase
    txt = txt.toLowerCase(java.util.Locale.ENGLISH);
    // 2. Remove anything not A-Z
    txt = txt.replaceAll(""[^a-z]"", """");
    // 2.5. Remove final e
    // 2.0 only
    txt = txt.replaceAll(""e$"", """");
    // 3. Handle various start options
    txt = txt.replaceAll(""^cough"", ""cou2f"");
    txt = txt.replaceAll(""^rough"", ""rou2f"");
    txt = txt.replaceAll(""^tough"", ""tou2f"");
    // 2.0 only
    txt = txt.replaceAll(""^enough"", ""enou2f"");
    // 2.0 only
    txt = txt.replaceAll(""^trough"", ""trou2f"");
    // note the spec says ^enough here again, c+p error I assume
    txt = txt.replaceAll(""^gn"", ""2n"");
    // End
    txt = txt.replaceAll(""mb$"", ""m2"");
    // 4. Handle replacements
    txt = txt.replace(""cq"", ""2q"");
    txt = txt.replace(""ci"", ""si"");
    txt = txt.replace(""ce"", ""se"");
    txt = txt.replace(""cy"", ""sy"");
    txt = txt.replace(""tch"", ""2ch"");
    txt = txt.replace(""c"", ""k"");
    txt = txt.replace(""q"", ""k"");
    txt = txt.replace(""x"", ""k"");
    txt = txt.replace(""v"", ""f"");
    txt = txt.replace(""dg"", ""2g"");
    txt = txt.replace(""tio"", ""sio"");
    txt = txt.replace(""tia"", ""sia"");
    txt = txt.replace(""d"", ""t"");
    txt = txt.replace(""ph"", ""fh"");
    txt = txt.replace(""b"", ""p"");
    txt = txt.replace(""sh"", ""s2"");
    txt = txt.replace(""z"", ""s"");
    txt = txt.replaceAll(""^[aeiou]"", ""A"");
    txt = txt.replaceAll(""[aeiou]"", ""3"");
    // 2.0 only
    txt = txt.replace(""j"", ""y"");
    // 2.0 only
    txt = txt.replaceAll(""^y3"", ""Y3"");
    // 2.0 only
    txt = txt.replaceAll(""^y"", ""A"");
    // 2.0 only
    txt = txt.replace(""y"", ""3"");
    txt = txt.replace(""3gh3"", ""3kh3"");
    txt = txt.replace(""gh"", ""22"");
    txt = txt.replace(""g"", ""k"");
    txt = txt.replaceAll(""s+"", ""S"");
    txt = txt.replaceAll(""t+"", ""T"");
    txt = txt.replaceAll(""p+"", ""P"");
    txt = txt.replaceAll(""k+"", ""K"");
    txt = txt.replaceAll(""f+"", ""F"");
    txt = txt.replaceAll(""m+"", ""M"");
    txt = txt.replaceAll(""n+"", ""N"");
    txt = txt.replace(""w3"", ""W3"");
    txt = txt.replace(""wh3"", ""Wh3"");
    // 2.0 only
    txt = txt.replaceAll(""w$"", ""3"");
    txt = txt.replace(""w"", ""2"");
    txt = txt.replaceAll(""^h"", ""A"");
    txt = txt.replace(""h"", ""2"");
    txt = txt.replace(""r3"", ""R3"");
    // 2.0 only
    txt = txt.replaceAll(""r$"", ""3"");
    txt = txt.replace(""r"", ""2"");
    txt = txt.replace(""l3"", ""L3"");
    // 2.0 only
    txt = txt.replaceAll(""l$"", ""3"");
    txt = txt.replace(""l"", ""2"");
    // 5. Handle removals
    txt = txt.replace(""2"", """");
    // 2.0 only
    txt = txt.replaceAll(""3$"", ""A"");
    txt = txt.replace(""3"", """");
    // 6. put ten 1s on the end
    txt += TEN_1;
    // 7. take the first ten characters as the code
    return txt.substring(0, TEN_1.length());
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone2.encode(String).source","Parameter_1","Belong to org.apache.commons.codec.language.Caverphone2.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone2.<init>()","Constructor","* Constructs a new instance.","public Caverphone2() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang","Class","* Language guessing utility.
 * <p>
 * This class encapsulates rules used to guess the possible languages that a word originates from. This is
 * done by reference to a whole series of rules distributed in resource files.
 * </p>
 * <p>
 * Instances of this class are typically managed through the static factory method instance().
 * Unless you are developing your own language guessing rules, you will not need to interact with this class directly.
 * </p>
 * <p>
 * This class is intended to be immutable and thread-safe.
 * </p>
 * <h2>Lang resources</h2>
 * <p>
 * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files.
 * They are systematically named following the pattern:
 * </p>
 * <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote>
 * <p>
 * The format of these resources is the following:
 * </p>
 * <ul>
 * <li><strong>Rules:</strong> whitespace separated strings.
 * There should be 3 columns to each row, and these will be interpreted as:
 * <ol>
 * <li>pattern: a regular expression.</li>
 * <li>languages: a '+'-separated list of languages.</li>
 * <li>acceptOnMatch: 'true' or 'false' indicating if a match rules in or rules out the language.</li>
 * </ol>
 * </li>
 * <li><strong>End-of-line comments:</strong> Any occurrence of '//' will cause all text following on that line to be
 * discarded as a comment.</li>
 * <li><strong>Multi-line comments:</strong> Any line starting with '/*' will start multi-line commenting mode.
 * This will skip all content until a line ending in '*' and '/' is found.</li>
 * <li><strong>Blank lines:</strong> All blank lines will be skipped.</li>
 * </ul>
 * <p>
 * Port of lang.php
 * </p>
 *
 * @since 1.6","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.bm.Lang.LANGS","Field","No Comment","private static final Map<NameType, Lang> LANGS = new EnumMap<>(NameType.class);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LANGUAGE_RULES_RN","Field","No Comment","private static final String LANGUAGE_RULES_RN = ""/org/apache/commons/codec/language/bm/%s_lang.txt"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.languages","Field","No Comment","private final Languages languages;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.rules","Field","No Comment","private final List<LangRule> rules;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.instance(NameType)","Method","* Gets a Lang instance for one of the supported NameTypes.
     *
     * @param nameType
     *            the NameType to look up
     * @return a Lang encapsulating the language guessing rules for that name type","public static Lang instance(final NameType nameType) {
    return LANGS.get(nameType);
}","Lang","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.instance(NameType).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.Lang.instance(NameType)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.loadFromResource(String,Languages)","Method","* Loads language rules from a resource.
     * <p>
     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.
     * You will only need to call this yourself if you are developing custom language mapping rules.
     * </p>
     *
     * @param languageRulesResourceName
     *            the fully-qualified resource name to load
     * @param languages
     *            the languages that these rules will support
     * @return a Lang encapsulating the loaded language-guessing rules.","public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {
    final List<LangRule> rules = new ArrayList<>();
    try (Scanner scanner = new Scanner(Resources.getInputStream(languageRulesResourceName), ResourceConstants.ENCODING)) {
        boolean inExtendedComment = false;
        while (scanner.hasNextLine()) {
            final String rawLine = scanner.nextLine();
            String line = rawLine;
            if (inExtendedComment) {
                // check for closing comment marker, otherwise discard doc comment line
                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {
                    inExtendedComment = false;
                }
            } else if (line.startsWith(ResourceConstants.EXT_CMT_START)) {
                inExtendedComment = true;
            } else {
                // discard comments
                final int cmtI = line.indexOf(ResourceConstants.CMT);
                if (cmtI >= 0) {
                    line = line.substring(0, cmtI);
                }
                // trim leading-trailing whitespace
                line = line.trim();
                if (line.isEmpty()) {
                    // empty lines can be safely skipped
                    continue;
                }
                // split it up
                final String[] parts = line.split(""\\s+"");
                if (parts.length != 3) {
                    throw new IllegalArgumentException(""Malformed line '"" + rawLine + ""' in language resource '"" + languageRulesResourceName + ""'"");
                }
                final Pattern pattern = Pattern.compile(parts[0]);
                final String[] langs = parts[1].split(""\\+"");
                final boolean accept = parts[2].equals(""true"");
                rules.add(new LangRule(pattern, new HashSet<>(Arrays.asList(langs)), accept));
            }
        }
    }
    return new Lang(rules, languages);
}","Lang","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.loadFromResource(String,Languages).languageRulesResourceName","Parameter_1","Belong to org.apache.commons.codec.language.bm.Lang.loadFromResource(String,Languages)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.loadFromResource(String,Languages).languages","Parameter_2","Belong to org.apache.commons.codec.language.bm.Lang.loadFromResource(String,Languages)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.guessLanguage(String)","Method","* Guesses the language of a word.
     *
     * @param text
     *            the word
     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match","public String guessLanguage(final String text) {
    final Languages.LanguageSet ls = guessLanguages(text);
    return ls.isSingleton() ? ls.getAny() : Languages.ANY;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.guessLanguage(String).text","Parameter_1","Belong to org.apache.commons.codec.language.bm.Lang.guessLanguage(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.guessLanguages(String)","Method","* Guesses the languages of a word.
     *
     * @param input
     *            the word
     * @return a Set of Strings of language names that are potential matches for the input word","public Languages.LanguageSet guessLanguages(final String input) {
    final String text = input.toLowerCase(Locale.ENGLISH);
    final Set<String> langs = new HashSet<>(this.languages.getLanguages());
    rules.forEach(rule -> {
        if (rule.matches(text)) {
            if (rule.acceptOnMatch) {
                langs.retainAll(rule.languages);
            } else {
                langs.removeAll(rule.languages);
            }
        }
    });
    final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);
    return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;
}","Languages.LanguageSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.guessLanguages(String).input","Parameter_1","Belong to org.apache.commons.codec.language.bm.Lang.guessLanguages(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.<init>(List,Languages)","Constructor","No Comment","private Lang(final List<LangRule> rules, final Languages languages) {
    this.rules = Collections.unmodifiableList(rules);
    this.languages = languages;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.<init>(List,Languages).rules","Parameter_1","Belong to org.apache.commons.codec.language.bm.Lang.<init>(List,Languages)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.<init>(List,Languages).languages","Parameter_2","Belong to org.apache.commons.codec.language.bm.Lang.<init>(List,Languages)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang$LangRule","Class","No Comment","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.language.bm.Lang$LangRule.acceptOnMatch","Field","No Comment","private final boolean acceptOnMatch;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang$LangRule.languages","Field","No Comment","private final Set<String> languages;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang$LangRule.pattern","Field","No Comment","private final Pattern pattern;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang$LangRule.matches(String)","Method","No Comment","public boolean matches(final String txt) {
    return this.pattern.matcher(txt).find();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang$LangRule.matches(String).txt","Parameter_1","Belong to org.apache.commons.codec.language.bm.Lang$LangRule.matches(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang$LangRule.<init>(Pattern,Set,boolean)","Constructor","No Comment","private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) {
    this.pattern = pattern;
    this.languages = languages;
    this.acceptOnMatch = acceptOnMatch;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang$LangRule.<init>(Pattern,Set,boolean).pattern","Parameter_1","Belong to org.apache.commons.codec.language.bm.Lang$LangRule.<init>(Pattern,Set,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang$LangRule.<init>(Pattern,Set,boolean).languages","Parameter_2","Belong to org.apache.commons.codec.language.bm.Lang$LangRule.<init>(Pattern,Set,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang$LangRule.<init>(Pattern,Set,boolean).acceptOnMatch","Parameter_3","Belong to org.apache.commons.codec.language.bm.Lang$LangRule.<init>(Pattern,Set,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LangRule","Class","No Comment","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.language.bm.Lang.LangRule.acceptOnMatch","Field","No Comment","private final boolean acceptOnMatch;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LangRule.languages","Field","No Comment","private final Set<String> languages;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LangRule.pattern","Field","No Comment","private final Pattern pattern;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LangRule.matches(String)","Method","No Comment","public boolean matches(final String txt) {
    return this.pattern.matcher(txt).find();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LangRule.matches(String).txt","Parameter_1","Belong to org.apache.commons.codec.language.bm.Lang.LangRule.matches(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LangRule.<init>(Pattern,Set,boolean)","Constructor","No Comment","private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) {
    this.pattern = pattern;
    this.languages = languages;
    this.acceptOnMatch = acceptOnMatch;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LangRule.<init>(Pattern,Set,boolean).pattern","Parameter_1","Belong to org.apache.commons.codec.language.bm.Lang.LangRule.<init>(Pattern,Set,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LangRule.<init>(Pattern,Set,boolean).languages","Parameter_2","Belong to org.apache.commons.codec.language.bm.Lang.LangRule.<init>(Pattern,Set,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Lang.LangRule.<init>(Pattern,Set,boolean).acceptOnMatch","Parameter_3","Belong to org.apache.commons.codec.language.bm.Lang.LangRule.<init>(Pattern,Set,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.ResourceConstants","Class","* Constants used to process resource files.
 *
 * <p>This class is immutable and thread-safe.</p>
 *
 * @since 1.6","Class do not obtain Source Code","No return type","final ","",""
"org.apache.commons.codec.language.bm.ResourceConstants.CMT","Field","No Comment","static final String CMT = ""//"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.ResourceConstants.ENCODING","Field","No Comment","static final String ENCODING = CharEncoding.UTF_8;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.ResourceConstants.EXT_CMT_END","Field","No Comment","static final String EXT_CMT_END = ""*/"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.ResourceConstants.EXT_CMT_START","Field","No Comment","static final String EXT_CMT_START = ""/*"";","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.NameType","Enum","* Supported types of names. Unless you are matching particular family names, use {@link #GENERIC}. The
 * {@code GENERIC} NameType should work reasonably well for non-name words. The other encodings are
 * specifically tuned to family names, and may not work well at all for general text.
 *
 * @since 1.6","Enum do not obtain Source Code","No return type","public ","enum has no extends",""
"org.apache.commons.codec.language.bm.NameType.ASHKENAZI","Enum Constant","* Ashkenazi family names.","ASHKENAZI(""ash"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.NameType.GENERIC","Enum Constant","* Generic names and words.","GENERIC(""gen"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.NameType.SEPHARDIC","Enum Constant","* Sephardic family names.","SEPHARDIC(""sep"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.NameType.getName()","Method","* Gets the short version of the name type.
     *
     * @return the NameType short string","public String getName() {
    return this.name;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.NameType.<init>(String)","Constructor","No Comment","NameType(final String name) {
    this.name = name;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.NameType.<init>(String).name","Parameter_1","Belong to org.apache.commons.codec.language.bm.NameType.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder","Class","* Encodes strings into their Beider-Morse phonetic encoding.
 * <p>
 * Beider-Morse phonetic encodings are optimized for family names. However, they may be useful for a wide range of
 * words.
 * </p>
 * <p>
 * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it is mutable,
 * and may not be thread-safe. If you require a guaranteed thread-safe encoding then use {@link PhoneticEngine}
 * directly.
 * </p>
 * <h2>Encoding overview</h2>
 * <p>
 * Beider-Morse phonetic encodings is a multi-step process. Firstly, a table of rules is consulted to guess what
 * language the word comes from. For example, if it ends in ""{@code ault}"" then it infers that the word is French.
 * Next, the word is translated into a phonetic representation using a language-specific phonetics table. Some runs of
 * letters can be pronounced in multiple ways, and a single run of letters may be potentially broken up into phonemes at
 * different places, so this stage results in a set of possible language-specific phonetic representations. Lastly, this
 * language-specific phonetic representation is processed by a table of rules that re-writes it phonetically taking into
 * account systematic pronunciation differences between languages, to move it towards a pan-indo-european phonetic
 * representation. Again, sometimes there are multiple ways this could be done and sometimes things that can be
 * pronounced in several ways in the source language have only one way to represent them in this average phonetic
 * language, so the result is again a set of phonetic spellings.
 * </p>
 * <p>
 * Some names are treated as having multiple parts. This can be due to two things. Firstly, they may be hyphenated. In
 * this case, each individual hyphenated word is encoded, and then these are combined end-to-end for the final encoding.
 * Secondly, some names have standard prefixes, for example, ""{@code Mac/Mc}"" in Scottish (English) names. As
 * sometimes it is ambiguous whether the prefix is intended or is an accident of the spelling, the word is encoded once
 * with the prefix and once without it. The resulting encoding contains one and then the other result.
 * </p>
 * <h2>Encoding format</h2>
 * <p>
 * Individual phonetic spellings of an input word are represented in upper- and lower-case roman characters. Where there
 * are multiple possible phonetic representations, these are joined with a pipe ({@code |}) character. If multiple
 * hyphenated words where found, or if the word may contain a name prefix, each encoded word is placed in ellipses and
 * these blocks are then joined with hyphens. For example, ""{@code d'ortley}"" has a possible prefix. The form
 * without prefix encodes to ""{@code ortlaj|ortlej}"", while the form with prefix encodes to ""
 * {@code dortlaj|dortlej}"". Thus, the full, combined encoding is ""{@code (ortlaj|ortlej)-(dortlaj|dortlej)}"".
 * </p>
 * <p>
 * The encoded forms are often quite a bit longer than the input strings. This is because a single input may have many
 * potential phonetic interpretations. For example, ""{@code Renault}"" encodes to ""
 * {@code rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult}"". The {@code APPROX} rules will tend to produce larger
 * encodings as they consider a wider range of possible, approximate phonetic interpretations of the original word.
 * Down-stream applications may wish to further process the encoding for indexing or lookup purposes, for example, by
 * splitting on pipe ({@code |}) and indexing under each of these alternatives.
 * </p>
 * <p>
 * <strong>Note</strong>: this version of the Beider-Morse encoding is equivalent with v3.4 of the reference implementation.
 * </p>
 * @see <a href=""https://stevemorse.org/phonetics/bmpm.htm"">Beider-Morse Phonetic Matching</a>
 * @see <a href=""https://stevemorse.org/phoneticinfo.htm"">Reference implementation</a>
 *
 * <p>
 * This class is Not ThreadSafe.
 * </p>
 * @since 1.6","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.engine","Field","a cached object","private PhoneticEngine engine = new PhoneticEngine(NameType.GENERIC, RuleType.APPROX, true);","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(Object)","Method","No Comment","@Override
public Object encode(final Object source) throws EncoderException {
    if (!(source instanceof String)) {
        throw new EncoderException(""BeiderMorseEncoder encode parameter is not of type String"");
    }
    return encode((String) source);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(Object).source","Parameter_1","Belong to org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(String)","Method","No Comment","@Override
public String encode(final String source) throws EncoderException {
    if (source == null) {
        return null;
    }
    return this.engine.encode(source);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(String).source","Parameter_1","Belong to org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.getNameType()","Method","* Gets the name type currently in operation.
     *
     * @return the NameType currently being used","public NameType getNameType() {
    return this.engine.getNameType();
}","NameType","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.getRuleType()","Method","* Gets the rule type currently in operation.
     *
     * @return the RuleType currently being used","public RuleType getRuleType() {
    return this.engine.getRuleType();
}","RuleType","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.isConcat()","Method","* Discovers if multiple possible encodings are concatenated.
     *
     * @return true if multiple encodings are concatenated, false if just the first one is returned","public boolean isConcat() {
    return this.engine.isConcat();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.setConcat(boolean)","Method","* Sets how multiple possible phonetic encodings are combined.
     *
     * @param concat
     *            true if multiple encodings are to be combined with a '|', false if just the first one is
     *            to be considered","public void setConcat(final boolean concat) {
    this.engine = new PhoneticEngine(this.engine.getNameType(), this.engine.getRuleType(), concat, this.engine.getMaxPhonemes());
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.setConcat(boolean).concat","Parameter_1","Belong to org.apache.commons.codec.language.bm.BeiderMorseEncoder.setConcat(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.setMaxPhonemes(int)","Method","* Sets the number of maximum of phonemes that shall be considered by the engine.
     *
     * @param maxPhonemes
     *            the maximum number of phonemes returned by the engine
     * @since 1.7","public void setMaxPhonemes(final int maxPhonemes) {
    this.engine = new PhoneticEngine(this.engine.getNameType(), this.engine.getRuleType(), this.engine.isConcat(), maxPhonemes);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.setMaxPhonemes(int).maxPhonemes","Parameter_1","Belong to org.apache.commons.codec.language.bm.BeiderMorseEncoder.setMaxPhonemes(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.setNameType(NameType)","Method","* Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings
     * optimized for Ashkenazi or Sephardic Jewish family names.
     *
     * @param nameType
     *            the NameType in use","public void setNameType(final NameType nameType) {
    this.engine = new PhoneticEngine(nameType, this.engine.getRuleType(), this.engine.isConcat(), this.engine.getMaxPhonemes());
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.setNameType(NameType).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.BeiderMorseEncoder.setNameType(NameType)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.setRuleType(RuleType)","Method","* Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.
     *
     * @param ruleType
     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches","public void setRuleType(final RuleType ruleType) {
    this.engine = new PhoneticEngine(this.engine.getNameType(), ruleType, this.engine.isConcat(), this.engine.getMaxPhonemes());
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.setRuleType(RuleType).ruleType","Parameter_1","Belong to org.apache.commons.codec.language.bm.BeiderMorseEncoder.setRuleType(RuleType)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.BeiderMorseEncoder.<init>()","Constructor","* Constructs a new instance.","public BeiderMorseEncoder() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine","Class","* Converts words into potential phonetic representations.
 * <p>
 * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes
 * into account the likely source language. Next, this phonetic representation is converted into a
 * pan-European 'average' representation, allowing comparison between different versions of essentially
 * the same word from different languages.
 * </p>
 * <p>
 * This class is intentionally immutable and thread-safe.
 * If you wish to alter the settings for a PhoneticEngine, you
 * must make a new one with the updated settings.
 * </p>
 * <p>
 * Ported from phoneticengine.php
 * </p>
 *
 * @since 1.6","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.bm.PhoneticEngine.DEFAULT_MAX_PHONEMES","Field","No Comment","private static final int DEFAULT_MAX_PHONEMES = 20;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES","Field","No Comment","private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<>(NameType.class);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.lang","Field","No Comment","private final Lang lang;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.nameType","Field","No Comment","private final NameType nameType;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.ruleType","Field","No Comment","private final RuleType ruleType;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.concat","Field","No Comment","private final boolean concat;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.maxPhonemes","Field","No Comment","private final int maxPhonemes;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.join(List,String)","Method","* Joins some strings with an internal separator.
     *
     * @param strings   Strings to join
     * @param sep       String to separate them with
     * @return a single String consisting of each element of {@code strings} interleaved by {@code sep}","private static String join(final List<String> strings, final String sep) {
    return strings.stream().collect(Collectors.joining(sep));
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.join(List,String).strings","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.join(List,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.join(List,String).sep","Parameter_2","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.join(List,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.applyFinalRules(PhonemeBuilder,Map)","Method","* Applies the final rules to convert from a language-specific phonetic representation to a
     * language-independent representation.
     *
     * @param phonemeBuilder the current phonemes
     * @param finalRules the final rules to apply
     * @return the resulting phonemes","private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> finalRules) {
    Objects.requireNonNull(finalRules, ""finalRules"");
    if (finalRules.isEmpty()) {
        return phonemeBuilder;
    }
    final Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<>(Rule.Phoneme.COMPARATOR);
    phonemeBuilder.getPhonemes().forEach(phoneme -> {
        PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
        final String phonemeText = phoneme.getPhonemeText().toString();
        for (int i = 0; i < phonemeText.length(); ) {
            final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
            final boolean found = rulesApplication.isFound();
            subBuilder = rulesApplication.getPhonemeBuilder();
            if (!found) {
                // not found, appending as-is
                subBuilder.append(phonemeText.subSequence(i, i + 1));
            }
            i = rulesApplication.getI();
        }
        // the phonemes map orders the phonemes only based on their text, but ignores the language set
        // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
        // phonemes with the same text but different language set get lost
        subBuilder.getPhonemes().forEach(newPhoneme -> {
            if (phonemes.containsKey(newPhoneme)) {
                final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                phonemes.put(mergedPhoneme, mergedPhoneme);
            } else {
                phonemes.put(newPhoneme, newPhoneme);
            }
        });
    });
    return new PhonemeBuilder(phonemes.keySet());
}","PhonemeBuilder","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.applyFinalRules(PhonemeBuilder,Map).phonemeBuilder","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.applyFinalRules(PhonemeBuilder,Map)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.applyFinalRules(PhonemeBuilder,Map).finalRules","Parameter_2","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.applyFinalRules(PhonemeBuilder,Map)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.encode(String)","Method","* Encodes a string to its phonetic representation.
     *
     * @param input
     *            the String to encode
     * @return the encoding of the input","public String encode(final String input) {
    final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
    return encode(input, languageSet);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.encode(String).input","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.encode(String,Languages.LanguageSet)","Method","* Encodes an input string into an output phonetic representation, given a set of possible origin languages.
     *
     * @param input
     *            String to phoneticise; a String with dashes or spaces separating each word
     * @param languageSet
     *            set of possible origin languages
     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the
     *         input","public String encode(String input, final Languages.LanguageSet languageSet) {
    final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
    // rules common across many (all) languages
    final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
    // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
    final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);
    // tidy the input
    // lower case is a locale-dependent operation
    input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();
    if (this.nameType == NameType.GENERIC) {
        if (input.startsWith(""d'"")) {
            // check for d'
            final String remainder = input.substring(2);
            final String combined = ""d"" + remainder;
            return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
        }
        for (final String l : NAME_PREFIXES.get(this.nameType)) {
            // handle generic prefixes
            if (input.startsWith(l + "" "")) {
                // check for any prefix in the words list
                // input without the prefix
                final String remainder = input.substring(l.length() + 1);
                // input with prefix without space
                final String combined = l + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
        }
    }
    final List<String> words = Arrays.asList(input.split(""\\s+""));
    final List<String> words2 = new ArrayList<>();
    // special-case handling of word prefixes based upon the name type
    switch(this.nameType) {
        case SEPHARDIC:
            words.forEach(aWord -> {
                final String[] parts = aWord.split(""'"", -1);
                words2.add(parts[parts.length - 1]);
            });
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
    }
    if (this.concat) {
        // concat mode enabled
        input = join(words2, "" "");
    } else if (words2.size() == 1) {
        // not a multi-word name
        input = words.iterator().next();
    } else if (!words2.isEmpty()) {
        // encode each word in a multi-word name separately (normally used for approx matches)
        final StringBuilder result = new StringBuilder();
        words2.forEach(word -> result.append(""-"").append(encode(word)));
        // return the result without the leading ""-""
        return result.substring(1);
    }
    PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);
    // loop over each char in the input - we will handle the increment manually
    for (int i = 0; i < input.length(); ) {
        final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
        i = rulesApplication.getI();
        phonemeBuilder = rulesApplication.getPhonemeBuilder();
    }
    // Apply the general rules
    phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
    // Apply the language-specific rules
    phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);
    return phonemeBuilder.makeString();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.encode(String,Languages.LanguageSet).input","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.encode(String,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.encode(String,Languages.LanguageSet).languageSet","Parameter_2","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.encode(String,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.getLang()","Method","* Gets the Lang language guessing rules being used.
     *
     * @return the Lang in use","public Lang getLang() {
    return this.lang;
}","Lang","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.getMaxPhonemes()","Method","* Gets the maximum number of phonemes the engine will calculate for a given input.
     *
     * @return the maximum number of phonemes
     * @since 1.7","public int getMaxPhonemes() {
    return this.maxPhonemes;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.getNameType()","Method","* Gets the NameType being used.
     *
     * @return the NameType in use","public NameType getNameType() {
    return this.nameType;
}","NameType","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.getRuleType()","Method","* Gets the RuleType being used.
     *
     * @return the RuleType in use","public RuleType getRuleType() {
    return this.ruleType;
}","RuleType","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.isConcat()","Method","* Gets if multiple phonetic encodings are concatenated or if just the first one is kept.
     *
     * @return true if multiple phonetic encodings are returned, false if just the first is","public boolean isConcat() {
    return this.concat;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean)","Constructor","* Generates a new, fully-configured phonetic engine.
     *
     * @param nameType
     *            the type of names it will use
     * @param ruleType
     *            the type of rules it will apply
     * @param concatenate
     *            if it will concatenate multiple encodings","public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concatenate) {
    this(nameType, ruleType, concatenate, DEFAULT_MAX_PHONEMES);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean).ruleType","Parameter_2","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean).concatenate","Parameter_3","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean,int)","Constructor","* Generates a new, fully-configured phonetic engine.
     *
     * @param nameType
     *            the type of names it will use
     * @param ruleType
     *            the type of rules it will apply
     * @param concatenate
     *            if it will concatenate multiple encodings
     * @param maxPhonemes
     *            the maximum number of phonemes that will be handled
     * @since 1.7","public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concatenate, final int maxPhonemes) {
    if (ruleType == RuleType.RULES) {
        throw new IllegalArgumentException(""ruleType must not be "" + RuleType.RULES);
    }
    this.nameType = nameType;
    this.ruleType = ruleType;
    this.concat = concatenate;
    this.lang = Lang.instance(nameType);
    this.maxPhonemes = maxPhonemes;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean,int).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean,int).ruleType","Parameter_2","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean,int).concatenate","Parameter_3","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean,int).maxPhonemes","Parameter_4","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.<init>(NameType,RuleType,boolean,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder","Class","* Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside
     * this package, and probably not outside the {@link PhoneticEngine} class.
     *
     * @since 1.6","Class do not obtain Source Code","No return type","static , final ","",""
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.phonemes","Field","No Comment","private final Set<Rule.Phoneme> phonemes;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.empty(Languages.LanguageSet)","Method","* An empty builder where all phonemes must come from some set of languages. This will contain a single
         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new
         * phoneme from scratch.
         *
         * @param languages the set of languages
         * @return  a new, empty phoneme builder","public static PhonemeBuilder empty(final Languages.LanguageSet languages) {
    return new PhonemeBuilder(new Rule.Phoneme("""", languages));
}","PhonemeBuilder","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.empty(Languages.LanguageSet).languages","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.empty(Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.append(CharSequence)","Method","* Creates a new phoneme builder containing all phonemes in this one extended by {@code str}.
         *
         * @param str   the characters to append to the phonemes","public void append(final CharSequence str) {
    phonemes.forEach(ph -> ph.append(str));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.append(CharSequence).str","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.append(CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.apply(Rule.PhonemeExpr,int)","Method","* Applies the given phoneme expression to all phonemes in this phoneme builder.
         * <p>
         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are
         * incompatible.
         * </p>
         *
         * @param phonemeExpr   the expression to apply
         * @param maxPhonemes   the maximum number of phonemes to build up","public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
    final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<>(Math.min(phonemes.size() * phonemeExpr.size(), maxPhonemes));
    EXPR: for (final Rule.Phoneme left : phonemes) {
        for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
            final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
            if (!languages.isEmpty()) {
                final Rule.Phoneme join = new Phoneme(left, right, languages);
                if (newPhonemes.size() < maxPhonemes) {
                    newPhonemes.add(join);
                    if (newPhonemes.size() >= maxPhonemes) {
                        break EXPR;
                    }
                }
            }
        }
    }
    phonemes.clear();
    phonemes.addAll(newPhonemes);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.apply(Rule.PhonemeExpr,int).phonemeExpr","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.apply(Rule.PhonemeExpr,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.apply(Rule.PhonemeExpr,int).maxPhonemes","Parameter_2","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.apply(Rule.PhonemeExpr,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.getPhonemes()","Method","* Gets underlying phoneme set. Please don't mutate.
         *
         * @return  the phoneme set","public Set<Rule.Phoneme> getPhonemes() {
    return phonemes;
}","Set","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.makeString()","Method","* Stringifies the phoneme set. This produces a single string of the strings of each phoneme,
         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially
         * expensive operation, which should be avoided when debugging.
         *
         * @return  the stringified phoneme set","public String makeString() {
    return phonemes.stream().map(Rule.Phoneme::getPhonemeText).collect(Collectors.joining(""|""));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.<init>(Rule.Phoneme)","Constructor","No Comment","private PhonemeBuilder(final Rule.Phoneme phoneme) {
    this.phonemes = new LinkedHashSet<>();
    this.phonemes.add(phoneme);
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.<init>(Rule.Phoneme).phoneme","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.<init>(Rule.Phoneme)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.<init>(Set)","Constructor","No Comment","private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {
    this.phonemes = phonemes;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.<init>(Set).phonemes","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$PhonemeBuilder.<init>(Set)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication","Class","* A function closure capturing the application of a list of rules to an input sequence at a particular offset.
     * After invocation, the values {@code i} and {@code found} are updated. {@code i} points to the
     * index of the next char in {@code input} that must be processed next (the input up to that index having been
     * processed already), and {@code found} indicates if a matching rule was found or not. In the case where a
     * matching rule was found, {@code phonemeBuilder} is replaced with a new builder containing the phonemes
     * updated by the matching rule.
     * <p>
     * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads
     * as it is constructed as needed by the calling methods.
     * </p>
     *
     * @since 1.6","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.finalRules","Field","No Comment","private final Map<String, List<Rule>> finalRules;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.input","Field","No Comment","private final CharSequence input;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.phonemeBuilder","Field","No Comment","private final PhonemeBuilder phonemeBuilder;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.i","Field","No Comment","private int i;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.maxPhonemes","Field","No Comment","private final int maxPhonemes;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.found","Field","No Comment","private boolean found;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.getI()","Method","No Comment","public int getI() {
    return i;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.getPhonemeBuilder()","Method","No Comment","public PhonemeBuilder getPhonemeBuilder() {
    return phonemeBuilder;
}","PhonemeBuilder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.invoke()","Method","* Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context
         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no
         * match, {@code i} is advanced one and the character is silently dropped from the phonetic spelling.
         *
         * @return {@code this}","public RulesApplication invoke() {
    found = false;
    int patternLength = 1;
    final List<Rule> rules = finalRules.get(input.subSequence(i, i + patternLength));
    if (rules != null) {
        for (final Rule rule : rules) {
            final String pattern = rule.getPattern();
            patternLength = pattern.length();
            if (rule.patternAndContextMatches(input, i)) {
                phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                found = true;
                break;
            }
        }
    }
    if (!found) {
        patternLength = 1;
    }
    i += patternLength;
    return this;
}","RulesApplication","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.isFound()","Method","No Comment","public boolean isFound() {
    return found;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Constructor","No Comment","RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input, final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {
    Objects.requireNonNull(finalRules, ""finalRules"");
    this.finalRules = finalRules;
    this.phonemeBuilder = phonemeBuilder;
    this.input = input;
    this.i = i;
    this.maxPhonemes = maxPhonemes;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).finalRules","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).input","Parameter_2","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).phonemeBuilder","Parameter_3","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).i","Parameter_4","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).maxPhonemes","Parameter_5","Belong to org.apache.commons.codec.language.bm.PhoneticEngine$RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder","Class","* Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside
     * this package, and probably not outside the {@link PhoneticEngine} class.
     *
     * @since 1.6","Class do not obtain Source Code","No return type","static , final ","",""
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.phonemes","Field","No Comment","private final Set<Rule.Phoneme> phonemes;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.empty(Languages.LanguageSet)","Method","* An empty builder where all phonemes must come from some set of languages. This will contain a single
         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new
         * phoneme from scratch.
         *
         * @param languages the set of languages
         * @return  a new, empty phoneme builder","public static PhonemeBuilder empty(final Languages.LanguageSet languages) {
    return new PhonemeBuilder(new Rule.Phoneme("""", languages));
}","PhonemeBuilder","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.empty(Languages.LanguageSet).languages","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.empty(Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.append(CharSequence)","Method","* Creates a new phoneme builder containing all phonemes in this one extended by {@code str}.
         *
         * @param str   the characters to append to the phonemes","public void append(final CharSequence str) {
    phonemes.forEach(ph -> ph.append(str));
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.append(CharSequence).str","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.append(CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.apply(Rule.PhonemeExpr,int)","Method","* Applies the given phoneme expression to all phonemes in this phoneme builder.
         * <p>
         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are
         * incompatible.
         * </p>
         *
         * @param phonemeExpr   the expression to apply
         * @param maxPhonemes   the maximum number of phonemes to build up","public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
    final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<>(Math.min(phonemes.size() * phonemeExpr.size(), maxPhonemes));
    EXPR: for (final Rule.Phoneme left : phonemes) {
        for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
            final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
            if (!languages.isEmpty()) {
                final Rule.Phoneme join = new Phoneme(left, right, languages);
                if (newPhonemes.size() < maxPhonemes) {
                    newPhonemes.add(join);
                    if (newPhonemes.size() >= maxPhonemes) {
                        break EXPR;
                    }
                }
            }
        }
    }
    phonemes.clear();
    phonemes.addAll(newPhonemes);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.apply(Rule.PhonemeExpr,int).phonemeExpr","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.apply(Rule.PhonemeExpr,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.apply(Rule.PhonemeExpr,int).maxPhonemes","Parameter_2","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.apply(Rule.PhonemeExpr,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.getPhonemes()","Method","* Gets underlying phoneme set. Please don't mutate.
         *
         * @return  the phoneme set","public Set<Rule.Phoneme> getPhonemes() {
    return phonemes;
}","Set","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.makeString()","Method","* Stringifies the phoneme set. This produces a single string of the strings of each phoneme,
         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially
         * expensive operation, which should be avoided when debugging.
         *
         * @return  the stringified phoneme set","public String makeString() {
    return phonemes.stream().map(Rule.Phoneme::getPhonemeText).collect(Collectors.joining(""|""));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.<init>(Rule.Phoneme)","Constructor","No Comment","private PhonemeBuilder(final Rule.Phoneme phoneme) {
    this.phonemes = new LinkedHashSet<>();
    this.phonemes.add(phoneme);
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.<init>(Rule.Phoneme).phoneme","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.<init>(Rule.Phoneme)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.<init>(Set)","Constructor","No Comment","private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {
    this.phonemes = phonemes;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.<init>(Set).phonemes","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.<init>(Set)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication","Class","* A function closure capturing the application of a list of rules to an input sequence at a particular offset.
     * After invocation, the values {@code i} and {@code found} are updated. {@code i} points to the
     * index of the next char in {@code input} that must be processed next (the input up to that index having been
     * processed already), and {@code found} indicates if a matching rule was found or not. In the case where a
     * matching rule was found, {@code phonemeBuilder} is replaced with a new builder containing the phonemes
     * updated by the matching rule.
     * <p>
     * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads
     * as it is constructed as needed by the calling methods.
     * </p>
     *
     * @since 1.6","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.finalRules","Field","No Comment","private final Map<String, List<Rule>> finalRules;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.input","Field","No Comment","private final CharSequence input;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.phonemeBuilder","Field","No Comment","private final PhonemeBuilder phonemeBuilder;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.i","Field","No Comment","private int i;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.maxPhonemes","Field","No Comment","private final int maxPhonemes;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.found","Field","No Comment","private boolean found;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.getI()","Method","No Comment","public int getI() {
    return i;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.getPhonemeBuilder()","Method","No Comment","public PhonemeBuilder getPhonemeBuilder() {
    return phonemeBuilder;
}","PhonemeBuilder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.invoke()","Method","* Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context
         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no
         * match, {@code i} is advanced one and the character is silently dropped from the phonetic spelling.
         *
         * @return {@code this}","public RulesApplication invoke() {
    found = false;
    int patternLength = 1;
    final List<Rule> rules = finalRules.get(input.subSequence(i, i + patternLength));
    if (rules != null) {
        for (final Rule rule : rules) {
            final String pattern = rule.getPattern();
            patternLength = pattern.length();
            if (rule.patternAndContextMatches(input, i)) {
                phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                found = true;
                break;
            }
        }
    }
    if (!found) {
        patternLength = 1;
    }
    i += patternLength;
    return this;
}","RulesApplication","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.isFound()","Method","No Comment","public boolean isFound() {
    return found;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Constructor","No Comment","RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input, final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {
    Objects.requireNonNull(finalRules, ""finalRules"");
    this.finalRules = finalRules;
    this.phonemeBuilder = phonemeBuilder;
    this.input = input;
    this.i = i;
    this.maxPhonemes = maxPhonemes;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).finalRules","Parameter_1","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).input","Parameter_2","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).phonemeBuilder","Parameter_3","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).i","Parameter_4","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int).maxPhonemes","Parameter_5","Belong to org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.<init>(Map,CharSequence,PhonemeBuilder,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages","Class","* Language codes.
 * <p>
 * Language codes are typically loaded from resource files. These are UTF-8
 * encoded text files. They are systematically named following the pattern:
 * </p>
 * <blockquote>org/apache/commons/codec/language/bm/${{@link NameType#getName()}
 * languages.txt</blockquote>
 * <p>
 * The format of these resources is the following:
 * </p>
 * <ul>
 * <li><strong>Language:</strong> a single string containing no whitespace</li>
 * <li><strong>End-of-line comments:</strong> Any occurrence of '//' will cause all text
 * following on that line to be discarded as a comment.</li>
 * <li><strong>Multi-line comments:</strong> Any line starting with '/*' will start
 * multi-line commenting mode. This will skip all content until a line ending in
 * '*' and '/' is found.</li>
 * <li><strong>Blank lines:</strong> All blank lines will be skipped.</li>
 * </ul>
 * <p>
 * Ported from language.php
 * </p>
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @since 1.6","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.bm.Languages.ANY","Field","* Marker for any language.","public static final String ANY = ""any"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LANGUAGES","Field","No Comment","private static final Map<NameType, Languages> LANGUAGES = new EnumMap<>(NameType.class);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.NO_LANGUAGES","Field","* No languages at all.","public static final LanguageSet NO_LANGUAGES = new LanguageSet() {

    @Override
    public boolean contains(final String language) {
        return false;
    }

    @Override
    public String getAny() {
        throw new NoSuchElementException(""Can't fetch any language from the empty language set."");
    }

    @Override
    public boolean isEmpty() {
        return true;
    }

    @Override
    public boolean isSingleton() {
        return false;
    }

    @Override
    public LanguageSet merge(final LanguageSet other) {
        return other;
    }

    @Override
    public LanguageSet restrictTo(final LanguageSet other) {
        return this;
    }

    @Override
    public String toString() {
        return ""NO_LANGUAGES"";
    }
};","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.ANY_LANGUAGE","Field","* Any/all languages.","public static final LanguageSet ANY_LANGUAGE = new LanguageSet() {

    @Override
    public boolean contains(final String language) {
        return true;
    }

    @Override
    public String getAny() {
        throw new NoSuchElementException(""Can't fetch any language from the any language set."");
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public boolean isSingleton() {
        return false;
    }

    @Override
    public LanguageSet merge(final LanguageSet other) {
        return other;
    }

    @Override
    public LanguageSet restrictTo(final LanguageSet other) {
        return other;
    }

    @Override
    public String toString() {
        return ""ANY_LANGUAGE"";
    }
};","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.languages","Field","No Comment","private final Set<String> languages;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.getInstance(NameType)","Method","* Gets an instance for the given name type.
     *
     * @param nameType The name type to lookup.
     * @return an instance for the given name type.","public static Languages getInstance(final NameType nameType) {
    return LANGUAGES.get(nameType);
}","Languages","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.getInstance(NameType).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.getInstance(NameType)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.getInstance(String)","Method","* Gets a new instance for the given resource name.
     *
     * @param languagesResourceName the resource name to lookup.
     * @return a new instance.","public static Languages getInstance(final String languagesResourceName) {
    // read languages list
    final Set<String> ls = new HashSet<>();
    try (Scanner lsScanner = new Scanner(Resources.getInputStream(languagesResourceName), ResourceConstants.ENCODING)) {
        boolean inExtendedComment = false;
        while (lsScanner.hasNextLine()) {
            final String line = lsScanner.nextLine().trim();
            if (inExtendedComment) {
                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {
                    inExtendedComment = false;
                }
            } else if (line.startsWith(ResourceConstants.EXT_CMT_START)) {
                inExtendedComment = true;
            } else if (!line.isEmpty()) {
                ls.add(line);
            }
        }
        return new Languages(Collections.unmodifiableSet(ls));
    }
}","Languages","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.getInstance(String).languagesResourceName","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.getInstance(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.langResourceName(NameType)","Method","No Comment","private static String langResourceName(final NameType nameType) {
    return String.format(""/org/apache/commons/codec/language/bm/%s_languages.txt"", nameType.getName());
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.langResourceName(NameType).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.langResourceName(NameType)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.getLanguages()","Method","* Gets the language set.
     *
     * @return the language set.","public Set<String> getLanguages() {
    return this.languages;
}","Set","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.<init>(Set)","Constructor","No Comment","private Languages(final Set<String> languages) {
    this.languages = languages;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.<init>(Set).languages","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.<init>(Set)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet","Class","* A set of languages.","Class do not obtain Source Code","No return type","public , abstract , static ","",""
"org.apache.commons.codec.language.bm.Languages$LanguageSet.from(Set)","Method","* Gets a language set for the given languages.
         *
         * @param languages a language set.
         * @return a LanguageSet.","public static LanguageSet from(final Set<String> languages) {
    return languages.isEmpty() ? NO_LANGUAGES : new SomeLanguages(languages);
}","LanguageSet","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.from(Set).languages","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages$LanguageSet.from(Set)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.contains(String)","Abstract Method","* Tests whether this instance contains the given value.
         *
         * @param language the value to test.
         * @return whether this instance contains the given value.","public abstract boolean contains(String language);","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.contains(String).language","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages$LanguageSet.contains(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.getAny()","Abstract Method","* Gets any of this instance's element.
         *
         * @return any of this instance's element.","public abstract String getAny();","String","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.isEmpty()","Abstract Method","* Tests whether this instance is empty.
         *
         * @return whether this instance is empty.","public abstract boolean isEmpty();","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.isSingleton()","Abstract Method","* Tests whether this instance contains a single element.
         *
         * @return whether this instance contains a single element.","public abstract boolean isSingleton();","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.merge(LanguageSet)","Abstract Method","No Comment","abstract LanguageSet merge(LanguageSet other);","LanguageSet","abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.merge(LanguageSet).other","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages$LanguageSet.merge(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.restrictTo(LanguageSet)","Abstract Method","* Returns an instance restricted to this instances and the given values'.
         *
         * @param other The other instance.
         * @return an instance restricted to this instances and the given values'.","public abstract LanguageSet restrictTo(LanguageSet other);","LanguageSet","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.restrictTo(LanguageSet).other","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages$LanguageSet.restrictTo(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$LanguageSet.<init>()","Constructor","* Constructs a new instance for subclasses.","public LanguageSet() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages","Class","* Some languages, explicitly enumerated.","Class do not obtain Source Code","No return type","public , static , final ","org.apache.commons.codec.language.bm.Languages.LanguageSet",""
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.languages","Field","No Comment","private final Set<String> languages;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.contains(String)","Method","No Comment","@Override
public boolean contains(final String language) {
    return this.languages.contains(language);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.contains(String).language","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages$SomeLanguages.contains(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.getAny()","Method","No Comment","@Override
public String getAny() {
    return this.languages.iterator().next();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.getLanguages()","Method","* Gets the language strings
         *
         * @return the languages strings.","public Set<String> getLanguages() {
    return this.languages;
}","Set","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.isEmpty()","Method","No Comment","@Override
public boolean isEmpty() {
    return this.languages.isEmpty();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.isSingleton()","Method","No Comment","@Override
public boolean isSingleton() {
    return this.languages.size() == 1;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.merge(LanguageSet)","Method","No Comment","@Override
public LanguageSet merge(final LanguageSet other) {
    if (other == NO_LANGUAGES) {
        return this;
    }
    if (other == ANY_LANGUAGE) {
        return other;
    }
    final SomeLanguages someLanguages = (SomeLanguages) other;
    final Set<String> set = new HashSet<>(languages);
    set.addAll(someLanguages.languages);
    return from(set);
}","LanguageSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.merge(LanguageSet).other","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages$SomeLanguages.merge(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.restrictTo(LanguageSet)","Method","No Comment","@Override
public LanguageSet restrictTo(final LanguageSet other) {
    if (other == NO_LANGUAGES) {
        return other;
    }
    if (other == ANY_LANGUAGE) {
        return this;
    }
    final SomeLanguages someLanguages = (SomeLanguages) other;
    return from(languages.stream().filter(lang -> someLanguages.languages.contains(lang)).collect(Collectors.toSet()));
}","LanguageSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.restrictTo(LanguageSet).other","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages$SomeLanguages.restrictTo(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.toString()","Method","No Comment","@Override
public String toString() {
    return ""Languages("" + languages.toString() + "")"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.<init>(Set)","Constructor","No Comment","private SomeLanguages(final Set<String> languages) {
    this.languages = Collections.unmodifiableSet(languages);
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages$SomeLanguages.<init>(Set).languages","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages$SomeLanguages.<init>(Set)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet","Abstract Class","* A set of languages.","Abstract Class do not obtain Source Code","No return type","public , abstract , static ","",""
"org.apache.commons.codec.language.bm.Languages.LanguageSet.from(Set)","Method","* Gets a language set for the given languages.
         *
         * @param languages a language set.
         * @return a LanguageSet.","public static LanguageSet from(final Set<String> languages) {
    return languages.isEmpty() ? NO_LANGUAGES : new SomeLanguages(languages);
}","LanguageSet","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.from(Set).languages","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.LanguageSet.from(Set)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.contains(String)","Abstract Method","* Tests whether this instance contains the given value.
         *
         * @param language the value to test.
         * @return whether this instance contains the given value.","public abstract boolean contains(String language);","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.contains(String).language","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.LanguageSet.contains(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.getAny()","Abstract Method","* Gets any of this instance's element.
         *
         * @return any of this instance's element.","public abstract String getAny();","String","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.isEmpty()","Abstract Method","* Tests whether this instance is empty.
         *
         * @return whether this instance is empty.","public abstract boolean isEmpty();","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.isSingleton()","Abstract Method","* Tests whether this instance contains a single element.
         *
         * @return whether this instance contains a single element.","public abstract boolean isSingleton();","boolean","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.merge(LanguageSet)","Abstract Method","No Comment","abstract LanguageSet merge(LanguageSet other);","LanguageSet","abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.merge(LanguageSet).other","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.LanguageSet.merge(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.restrictTo(LanguageSet)","Abstract Method","* Returns an instance restricted to this instances and the given values'.
         *
         * @param other The other instance.
         * @return an instance restricted to this instances and the given values'.","public abstract LanguageSet restrictTo(LanguageSet other);","LanguageSet","public , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.restrictTo(LanguageSet).other","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.LanguageSet.restrictTo(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.LanguageSet.<init>()","Constructor","* Constructs a new instance for subclasses.","public LanguageSet() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages","Class","* Some languages, explicitly enumerated.","Class do not obtain Source Code","No return type","public , static , final ","org.apache.commons.codec.language.bm.Languages.LanguageSet",""
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.languages","Field","No Comment","private final Set<String> languages;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.contains(String)","Method","No Comment","@Override
public boolean contains(final String language) {
    return this.languages.contains(language);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.contains(String).language","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.SomeLanguages.contains(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.getAny()","Method","No Comment","@Override
public String getAny() {
    return this.languages.iterator().next();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.getLanguages()","Method","* Gets the language strings
         *
         * @return the languages strings.","public Set<String> getLanguages() {
    return this.languages;
}","Set","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.isEmpty()","Method","No Comment","@Override
public boolean isEmpty() {
    return this.languages.isEmpty();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.isSingleton()","Method","No Comment","@Override
public boolean isSingleton() {
    return this.languages.size() == 1;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.merge(LanguageSet)","Method","No Comment","@Override
public LanguageSet merge(final LanguageSet other) {
    if (other == NO_LANGUAGES) {
        return this;
    }
    if (other == ANY_LANGUAGE) {
        return other;
    }
    final SomeLanguages someLanguages = (SomeLanguages) other;
    final Set<String> set = new HashSet<>(languages);
    set.addAll(someLanguages.languages);
    return from(set);
}","LanguageSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.merge(LanguageSet).other","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.SomeLanguages.merge(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.restrictTo(LanguageSet)","Method","No Comment","@Override
public LanguageSet restrictTo(final LanguageSet other) {
    if (other == NO_LANGUAGES) {
        return other;
    }
    if (other == ANY_LANGUAGE) {
        return this;
    }
    final SomeLanguages someLanguages = (SomeLanguages) other;
    return from(languages.stream().filter(lang -> someLanguages.languages.contains(lang)).collect(Collectors.toSet()));
}","LanguageSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.restrictTo(LanguageSet).other","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.SomeLanguages.restrictTo(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.toString()","Method","No Comment","@Override
public String toString() {
    return ""Languages("" + languages.toString() + "")"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.<init>(Set)","Constructor","No Comment","private SomeLanguages(final Set<String> languages) {
    this.languages = Collections.unmodifiableSet(languages);
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Languages.SomeLanguages.<init>(Set).languages","Parameter_1","Belong to org.apache.commons.codec.language.bm.Languages.SomeLanguages.<init>(Set)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule","Class","* A phoneme rule.
 * <p>
 * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply
 * and a logical flag indicating if all languages must be in play. A rule matches if:
 * </p>
 * <ul>
 * <li>the pattern matches at the current position</li>
 * <li>the string up until the beginning of the pattern matches the left context</li>
 * <li>the string from the end of the pattern matches the right context</li>
 * <li>logical is ALL and all languages are in scope; or</li>
 * <li>logical is any other value and at least one language is in scope</li>
 * </ul>
 * <p>
 * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user
 * to explicitly construct their own.
 * </p>
 * <p>
 * Rules are immutable and thread-safe.
 * </p>
 * <h2>Rules resources</h2>
 * <p>
 * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically
 * named following the pattern:
 * </p>
 * <blockquote>/org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt</blockquote>
 * <p>
 * The format of these resources is the following:
 * </p>
 * <ul>
 * <li><strong>Rules:</strong> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these
 * will be interpreted as:
 * <ol>
 * <li>pattern</li>
 * <li>left context</li>
 * <li>right context</li>
 * <li>phoneme</li>
 * </ol>
 * </li>
 * <li><strong>End-of-line comments:</strong> Any occurrence of '//' will cause all text following on that line to be discarded
 * as a comment.</li>
 * <li><strong>Multi-line comments:</strong> Any line starting with '/*' will start multi-line commenting mode. This will skip
 * all content until a line ending in '*' and '/' is found.</li>
 * <li><strong>Blank lines:</strong> All blank lines will be skipped.</li>
 * </ul>
 *
 * @since 1.6","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.bm.Rule.ALL_STRINGS_RMATCHER","Field","* Always matches.","public static final RPattern ALL_STRINGS_RMATCHER = input -> true;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.ALL","Field","* Unused.","public static final String ALL = ""ALL"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.DOUBLE_QUOTE","Field","No Comment","private static final String DOUBLE_QUOTE = ""\"""";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.HASH_INCLUDE","Field","No Comment","private static final String HASH_INCLUDE = ""#include"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.HASH_INCLUDE_LENGTH","Field","No Comment","private static final int HASH_INCLUDE_LENGTH = HASH_INCLUDE.length();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.RULES","Field","No Comment","private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES = new EnumMap<>(NameType.class);","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.lContext","Field","No Comment","private final RPattern lContext;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.pattern","Field","No Comment","private final String pattern;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.phoneme","Field","No Comment","private final PhonemeExpr phoneme;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.rContext","Field","No Comment","private final RPattern rContext;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.contains(CharSequence,char)","Method","No Comment","private static boolean contains(final CharSequence chars, final char input) {
    return chars.chars().anyMatch(c -> c == input);
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.contains(CharSequence,char).chars","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.contains(CharSequence,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.contains(CharSequence,char).input","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.contains(CharSequence,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createResourceName(NameType,RuleType,String)","Method","No Comment","private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {
    return String.format(""/org/apache/commons/codec/language/bm/%s_%s_%s.txt"", nameType.getName(), rt.getName(), lang);
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createResourceName(NameType,RuleType,String).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.createResourceName(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createResourceName(NameType,RuleType,String).rt","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.createResourceName(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createResourceName(NameType,RuleType,String).lang","Parameter_3","Belong to org.apache.commons.codec.language.bm.Rule.createResourceName(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createScanner(NameType,RuleType,String)","Method","No Comment","// Closing the Scanner closes the resource
@SuppressWarnings(""resource"")
private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {
    final String resName = createResourceName(nameType, rt, lang);
    return new Scanner(Resources.getInputStream(resName), ResourceConstants.ENCODING);
}","Scanner","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createScanner(NameType,RuleType,String).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.createScanner(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createScanner(NameType,RuleType,String).rt","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.createScanner(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createScanner(NameType,RuleType,String).lang","Parameter_3","Belong to org.apache.commons.codec.language.bm.Rule.createScanner(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createScanner(String)","Method","No Comment","// Closing the Scanner closes the resource
@SuppressWarnings(""resource"")
private static Scanner createScanner(final String lang) {
    final String resName = String.format(""/org/apache/commons/codec/language/bm/%s.txt"", lang);
    return new Scanner(Resources.getInputStream(resName), ResourceConstants.ENCODING);
}","Scanner","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.createScanner(String).lang","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.createScanner(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.endsWith(CharSequence,CharSequence)","Method","No Comment","private static boolean endsWith(final CharSequence input, final CharSequence suffix) {
    final int suffixLength = suffix.length();
    final int inputLength = input.length();
    if (suffixLength > inputLength) {
        return false;
    }
    for (int i = inputLength - 1, j = suffixLength - 1; j >= 0; i--, j--) {
        if (input.charAt(i) != suffix.charAt(j)) {
            return false;
        }
    }
    return true;
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.endsWith(CharSequence,CharSequence).input","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.endsWith(CharSequence,CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.endsWith(CharSequence,CharSequence).suffix","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.endsWith(CharSequence,CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,Languages.LanguageSet)","Method","* Gets rules for a combination of name type, rule type and languages.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param langs
     *            the set of languages to consider
     * @return a list of Rules that apply","public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) {
    final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs);
    final List<Rule> allRules = new ArrayList<>();
    ruleMap.values().forEach(rules -> allRules.addAll(rules));
    return allRules;
}","List","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,Languages.LanguageSet).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,Languages.LanguageSet).rt","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,Languages.LanguageSet).langs","Parameter_3","Belong to org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,String)","Method","* Gets rules for a combination of name type, rule type and a single language.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param lang
     *            the language to consider
     * @return a list of Rules that apply","public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {
    return getInstance(nameType, rt, LanguageSet.from(new HashSet<>(Arrays.asList(lang))));
}","List","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,String).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,String).rt","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,String).lang","Parameter_3","Belong to org.apache.commons.codec.language.bm.Rule.getInstance(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,Languages.LanguageSet)","Method","* Gets rules for a combination of name type, rule type and languages.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param langs
     *            the set of languages to consider
     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern
     * @since 1.9","public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) {
    return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) : getInstanceMap(nameType, rt, Languages.ANY);
}","Map","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,Languages.LanguageSet).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,Languages.LanguageSet).rt","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,Languages.LanguageSet).langs","Parameter_3","Belong to org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,String)","Method","* Gets rules for a combination of name type, rule type and a single language.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param lang
     *            the language to consider
     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern
     * @since 1.9","public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final String lang) {
    final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);
    if (rules == null) {
        throw new IllegalArgumentException(String.format(""No rules found for %s, %s, %s."", nameType.getName(), rt.getName(), lang));
    }
    return rules;
}","Map","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,String).nameType","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,String).rt","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,String).lang","Parameter_3","Belong to org.apache.commons.codec.language.bm.Rule.getInstanceMap(NameType,RuleType,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.parsePhoneme(String)","Method","No Comment","private static Phoneme parsePhoneme(final String ph) {
    final int open = ph.indexOf(""["");
    if (open >= 0) {
        if (!ph.endsWith(""]"")) {
            throw new IllegalArgumentException(""Phoneme expression contains a '[' but does not end in ']'"");
        }
        final String before = ph.substring(0, open);
        final String in = ph.substring(open + 1, ph.length() - 1);
        final Set<String> langs = new HashSet<>(Arrays.asList(in.split(""[+]"")));
        return new Phoneme(before, Languages.LanguageSet.from(langs));
    }
    return new Phoneme(ph, Languages.ANY_LANGUAGE);
}","Phoneme","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.parsePhoneme(String).ph","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.parsePhoneme(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.parsePhonemeExpr(String)","Method","No Comment","private static PhonemeExpr parsePhonemeExpr(final String ph) {
    if (ph.startsWith(""("")) {
        // we have a bracketed list of options
        if (!ph.endsWith("")"")) {
            throw new IllegalArgumentException(""Phoneme starts with '(' so must end with ')'"");
        }
        final List<Phoneme> phs = new ArrayList<>();
        final String body = ph.substring(1, ph.length() - 1);
        for (final String part : body.split(""[|]"")) {
            phs.add(parsePhoneme(part));
        }
        if (body.startsWith(""|"") || body.endsWith(""|"")) {
            phs.add(new Phoneme("""", Languages.ANY_LANGUAGE));
        }
        return new PhonemeList(phs);
    }
    return parsePhoneme(ph);
}","PhonemeExpr","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.parsePhonemeExpr(String).ph","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.parsePhonemeExpr(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.parseRules(Scanner,String)","Method","No Comment","private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {
    final Map<String, List<Rule>> lines = new HashMap<>();
    int currentLine = 0;
    boolean inMultilineComment = false;
    while (scanner.hasNextLine()) {
        currentLine++;
        final String rawLine = scanner.nextLine();
        String line = rawLine;
        if (inMultilineComment) {
            if (line.endsWith(ResourceConstants.EXT_CMT_END)) {
                inMultilineComment = false;
            }
        } else if (line.startsWith(ResourceConstants.EXT_CMT_START)) {
            inMultilineComment = true;
        } else {
            // discard comments
            final int cmtI = line.indexOf(ResourceConstants.CMT);
            if (cmtI >= 0) {
                line = line.substring(0, cmtI);
            }
            // trim leading-trailing whitespace
            line = line.trim();
            if (line.isEmpty()) {
                // empty lines can be safely skipped
                continue;
            }
            if (line.startsWith(HASH_INCLUDE)) {
                // include statement
                final String incl = line.substring(HASH_INCLUDE_LENGTH).trim();
                if (incl.contains("" "")) {
                    throw new IllegalArgumentException(""Malformed import statement '"" + rawLine + ""' in "" + location);
                }
                try (Scanner hashIncludeScanner = createScanner(incl)) {
                    lines.putAll(parseRules(hashIncludeScanner, location + ""->"" + incl));
                }
            } else {
                // rule
                final String[] parts = line.split(""\\s+"");
                if (parts.length != 4) {
                    throw new IllegalArgumentException(""Malformed rule statement split into "" + parts.length + "" parts: "" + rawLine + "" in "" + location);
                }
                try {
                    final String pat = stripQuotes(parts[0]);
                    final String lCon = stripQuotes(parts[1]);
                    final String rCon = stripQuotes(parts[2]);
                    final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));
                    final int cLine = currentLine;
                    final Rule r = new Rule(pat, lCon, rCon, ph) {

                        private final int myLine = cLine;

                        private final String loc = location;

                        @Override
                        public String toString() {
                            final StringBuilder sb = new StringBuilder();
                            sb.append(""Rule"");
                            sb.append(""{line="").append(myLine);
                            sb.append("", loc='"").append(loc).append('\'');
                            sb.append("", pat='"").append(pat).append('\'');
                            sb.append("", lcon='"").append(lCon).append('\'');
                            sb.append("", rcon='"").append(rCon).append('\'');
                            sb.append('}');
                            return sb.toString();
                        }
                    };
                    final String patternKey = r.pattern.substring(0, 1);
                    final List<Rule> rules = lines.computeIfAbsent(patternKey, k -> new ArrayList<>());
                    rules.add(r);
                } catch (final IllegalArgumentException e) {
                    throw new IllegalStateException(""Problem parsing line '"" + currentLine + ""' in "" + location, e);
                }
            }
        }
    }
    return lines;
}","Map","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.parseRules(Scanner,String).scanner","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.parseRules(Scanner,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.parseRules(Scanner,String).location","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.parseRules(Scanner,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.pattern(String)","Method","* Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.
     *
     * @param regex
     *            the regular expression to compile
     * @return an RPattern that will match this regex","private static RPattern pattern(final String regex) {
    final boolean startsWith = regex.startsWith(""^"");
    final boolean endsWith = regex.endsWith(""$"");
    final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());
    final boolean boxes = content.contains(""["");
    if (!boxes) {
        if (startsWith && endsWith) {
            // exact match
            if (content.isEmpty()) {
                // empty
                return input -> input.length() == 0;
            }
            return input -> input.equals(content);
        }
        if ((startsWith || endsWith) && content.isEmpty()) {
            // matches every string
            return ALL_STRINGS_RMATCHER;
        }
        if (startsWith) {
            // matches from start
            return input -> startsWith(input, content);
        }
        if (endsWith) {
            // matches from start
            return input -> endsWith(input, content);
        }
    } else {
        final boolean startsWithBox = content.startsWith(""["");
        final boolean endsWithBox = content.endsWith(""]"");
        if (startsWithBox && endsWithBox) {
            String boxContent = content.substring(1, content.length() - 1);
            if (!boxContent.contains(""["")) {
                // box containing alternatives
                final boolean negate = boxContent.startsWith(""^"");
                if (negate) {
                    boxContent = boxContent.substring(1);
                }
                final String bContent = boxContent;
                final boolean shouldMatch = !negate;
                if (startsWith && endsWith) {
                    // exact match
                    return input -> input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;
                }
                if (startsWith) {
                    // first char
                    return input -> input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;
                }
                if (endsWith) {
                    // last char
                    return input -> input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;
                }
            }
        }
    }
    return new RPattern() {

        final Pattern pattern = Pattern.compile(regex);

        @Override
        public boolean isMatch(final CharSequence input) {
            final Matcher matcher = pattern.matcher(input);
            return matcher.find();
        }
    };
}","RPattern","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.pattern(String).regex","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.pattern(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.startsWith(CharSequence,CharSequence)","Method","No Comment","private static boolean startsWith(final CharSequence input, final CharSequence prefix) {
    if (prefix.length() > input.length()) {
        return false;
    }
    for (int i = 0; i < prefix.length(); i++) {
        if (input.charAt(i) != prefix.charAt(i)) {
            return false;
        }
    }
    return true;
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.startsWith(CharSequence,CharSequence).input","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.startsWith(CharSequence,CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.startsWith(CharSequence,CharSequence).prefix","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.startsWith(CharSequence,CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.stripQuotes(String)","Method","No Comment","private static String stripQuotes(String str) {
    if (str.startsWith(DOUBLE_QUOTE)) {
        str = str.substring(1);
    }
    if (str.endsWith(DOUBLE_QUOTE)) {
        str = str.substring(0, str.length() - 1);
    }
    return str;
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.stripQuotes(String).str","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.stripQuotes(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getLContext()","Method","* Gets the left context. This is a regular expression that must match to the left of the pattern.
     *
     * @return the left context Pattern","public RPattern getLContext() {
    return this.lContext;
}","RPattern","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getPattern()","Method","* Gets the pattern. This is a string-literal that must exactly match.
     *
     * @return the pattern","public String getPattern() {
    return this.pattern;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getPhoneme()","Method","* Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.
     *
     * @return the phoneme","public PhonemeExpr getPhoneme() {
    return this.phoneme;
}","PhonemeExpr","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.getRContext()","Method","* Gets the right context. This is a regular expression that must match to the right of the pattern.
     *
     * @return the right context Pattern","public RPattern getRContext() {
    return this.rContext;
}","RPattern","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.patternAndContextMatches(CharSequence,int)","Method","* Decides if the pattern and context match the input starting at a position. It is a match if the
     * {@code lContext} matches {@code input} up to {@code i}, {@code pattern} matches at i and
     * {@code rContext} matches from the end of the match of {@code pattern} to the end of {@code input}.
     *
     * @param input
     *            the input String
     * @param i
     *            the int position within the input
     * @return true if the pattern and left/right context match, false otherwise","public boolean patternAndContextMatches(final CharSequence input, final int i) {
    if (i < 0) {
        throw new IndexOutOfBoundsException(""Can not match pattern at negative indexes"");
    }
    final int patternLength = this.pattern.length();
    final int ipl = i + patternLength;
    if (ipl > input.length()) {
        // not enough room for the pattern to match
        return false;
    }
    // evaluate the pattern, left context and right context
    // fail early if any of the evaluations is not successful
    if (!input.subSequence(i, ipl).equals(this.pattern)) {
        return false;
    }
    if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {
        return false;
    }
    return this.lContext.isMatch(input.subSequence(0, i));
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.patternAndContextMatches(CharSequence,int).input","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.patternAndContextMatches(CharSequence,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.patternAndContextMatches(CharSequence,int).i","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.patternAndContextMatches(CharSequence,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.<init>(String,String,String,PhonemeExpr)","Constructor","* Creates a new rule.
     *
     * @param pattern
     *            the pattern
     * @param lContext
     *            the left context
     * @param rContext
     *            the right context
     * @param phoneme
     *            the resulting phoneme","public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {
    this.pattern = pattern;
    this.lContext = pattern(lContext + ""$"");
    this.rContext = pattern(""^"" + rContext);
    this.phoneme = phoneme;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.<init>(String,String,String,PhonemeExpr).pattern","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.<init>(String,String,String,PhonemeExpr)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.<init>(String,String,String,PhonemeExpr).lContext","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.<init>(String,String,String,PhonemeExpr)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.<init>(String,String,String,PhonemeExpr).rContext","Parameter_3","Belong to org.apache.commons.codec.language.bm.Rule.<init>(String,String,String,PhonemeExpr)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.<init>(String,String,String,PhonemeExpr).phoneme","Parameter_4","Belong to org.apache.commons.codec.language.bm.Rule.<init>(String,String,String,PhonemeExpr)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme","Class","* A phoneme.","Class do not obtain Source Code","No return type","public , static , final ","","org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
"org.apache.commons.codec.language.bm.Rule$Phoneme.COMPARATOR","Field","* The Phoneme Comparator.","public static final Comparator<Phoneme> COMPARATOR = (o1, o2) -> {
    final int o1Length = o1.phonemeText.length();
    final int o2Length = o2.phonemeText.length();
    for (int i = 0; i < o1Length; i++) {
        if (i >= o2Length) {
            return +1;
        }
        final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);
        if (c != 0) {
            return c;
        }
    }
    if (o1Length < o2Length) {
        return -1;
    }
    return 0;
};","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.phonemeText","Field","No Comment","private final StringBuilder phonemeText;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.languages","Field","No Comment","private final Languages.LanguageSet languages;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.append(CharSequence)","Method","* Appends the sequence to the phone text.
         *
         * @param sequence The sequence to append.
         * @return this instance.","public Phoneme append(final CharSequence sequence) {
    this.phonemeText.append(sequence);
    return this;
}","Phoneme","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.append(CharSequence).sequence","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.append(CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.getLanguages()","Method","* Gets the language set.
         *
         * @return the language set.","public Languages.LanguageSet getLanguages() {
    return this.languages;
}","Languages.LanguageSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.getPhonemes()","Method","No Comment","@Override
public Iterable<Phoneme> getPhonemes() {
    return Collections.singleton(this);
}","Iterable","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.getPhonemeText()","Method","* Gets the phoneme text sequence.
         *
         * @return the phoneme text sequence.","public CharSequence getPhonemeText() {
    return this.phonemeText;
}","CharSequence","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.join(Phoneme)","Method","* Deprecated since 1.9.
         *
         * @param right the Phoneme to join
         * @return a new Phoneme
         * @deprecated since 1.9","@Deprecated
public Phoneme join(final Phoneme right) {
    return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(), this.languages.restrictTo(right.languages));
}","Phoneme","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.join(Phoneme).right","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.join(Phoneme)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.mergeWithLanguage(LanguageSet)","Method","* Returns a new Phoneme with the same text but a union of its
         * current language set and the given one.
         *
         * @param lang the language set to merge
         * @return a new Phoneme","public Phoneme mergeWithLanguage(final LanguageSet lang) {
    return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));
}","Phoneme","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.mergeWithLanguage(LanguageSet).lang","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.mergeWithLanguage(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.size()","Method","No Comment","@Override
public int size() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.toString()","Method","No Comment","@Override
public String toString() {
    return phonemeText.toString() + ""["" + languages + ""]"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(CharSequence,Languages.LanguageSet)","Constructor","* Constructs a new instance.
         *
         * @param phonemeText The phoneme text.
         * @param languages A language set.","public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {
    this.phonemeText = new StringBuilder(phonemeText);
    this.languages = languages;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(CharSequence,Languages.LanguageSet).phonemeText","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(CharSequence,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(CharSequence,Languages.LanguageSet).languages","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(CharSequence,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme)","Constructor","* Constructs a new instance.
         *
         * @param phonemeLeft The left phoneme text.
         * @param phonemeRight The right phoneme text.","public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) {
    this(phonemeLeft.phonemeText, phonemeLeft.languages);
    this.phonemeText.append(phonemeRight.phonemeText);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme).phonemeLeft","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme).phonemeRight","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet)","Constructor","* Constructs a new instance.
         *
         * @param phonemeLeft The left phoneme text.
         * @param phonemeRight The right phoneme text.
         * @param languages A language set.","public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {
    this(phonemeLeft.phonemeText, languages);
    this.phonemeText.append(phonemeRight.phonemeText);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet).phonemeLeft","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet).phonemeRight","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet).languages","Parameter_3","Belong to org.apache.commons.codec.language.bm.Rule$Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$PhonemeExpr","Interface","* A phoneme expression.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.bm.Rule$PhonemeExpr.getPhonemes()","Abstract Method","* Gets an iteration of phonemes.
         *
         * @return an iteration of phonemes.","Iterable<Phoneme> getPhonemes();","Iterable","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$PhonemeExpr.size()","Abstract Method","* Gets the expression size in phonemes.
         *
         * @return the expression size in phonemes.
         * @since 1.17.0","default int size() {
    // All implementations are int-bound.
    return (int) Math.min(getPhonemes().spliterator().getExactSizeIfKnown(), Integer.MAX_VALUE);
}","int","default ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$PhonemeList","Class","* A list of phonemes.","Class do not obtain Source Code","No return type","public , static , final ","","org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
"org.apache.commons.codec.language.bm.Rule$PhonemeList.phonemeList","Field","No Comment","private final List<Phoneme> phonemeList;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$PhonemeList.getPhonemes()","Method","No Comment","@Override
public List<Phoneme> getPhonemes() {
    return phonemeList;
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$PhonemeList.size()","Method","No Comment","@Override
public int size() {
    return phonemeList.size();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$PhonemeList.<init>(List)","Constructor","* Constructs a new instance.
         *
         * @param phonemes the phoneme list.","public PhonemeList(final List<Phoneme> phonemes) {
    this.phonemeList = phonemes;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$PhonemeList.<init>(List).phonemes","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule$PhonemeList.<init>(List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$RPattern","Interface","* A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.bm.Rule$RPattern.isMatch(CharSequence)","Abstract Method","* Tests whether the given input matches this instance.
         *
         * @param input the input to test.
         * @return whether the given input matches this instance.","boolean isMatch(CharSequence input);","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule$RPattern.isMatch(CharSequence).input","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule$RPattern.isMatch(CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme","Class","* A phoneme.","Class do not obtain Source Code","No return type","public , static , final ","","org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
"org.apache.commons.codec.language.bm.Rule.Phoneme.COMPARATOR","Field","* The Phoneme Comparator.","public static final Comparator<Phoneme> COMPARATOR = (o1, o2) -> {
    final int o1Length = o1.phonemeText.length();
    final int o2Length = o2.phonemeText.length();
    for (int i = 0; i < o1Length; i++) {
        if (i >= o2Length) {
            return +1;
        }
        final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);
        if (c != 0) {
            return c;
        }
    }
    if (o1Length < o2Length) {
        return -1;
    }
    return 0;
};","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.phonemeText","Field","No Comment","private final StringBuilder phonemeText;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.languages","Field","No Comment","private final Languages.LanguageSet languages;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.append(CharSequence)","Method","* Appends the sequence to the phone text.
         *
         * @param sequence The sequence to append.
         * @return this instance.","public Phoneme append(final CharSequence sequence) {
    this.phonemeText.append(sequence);
    return this;
}","Phoneme","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.append(CharSequence).sequence","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.append(CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.getLanguages()","Method","* Gets the language set.
         *
         * @return the language set.","public Languages.LanguageSet getLanguages() {
    return this.languages;
}","Languages.LanguageSet","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.getPhonemes()","Method","No Comment","@Override
public Iterable<Phoneme> getPhonemes() {
    return Collections.singleton(this);
}","Iterable","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.getPhonemeText()","Method","* Gets the phoneme text sequence.
         *
         * @return the phoneme text sequence.","public CharSequence getPhonemeText() {
    return this.phonemeText;
}","CharSequence","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.join(Phoneme)","Method","* Deprecated since 1.9.
         *
         * @param right the Phoneme to join
         * @return a new Phoneme
         * @deprecated since 1.9","@Deprecated
public Phoneme join(final Phoneme right) {
    return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(), this.languages.restrictTo(right.languages));
}","Phoneme","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.join(Phoneme).right","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.join(Phoneme)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.mergeWithLanguage(LanguageSet)","Method","* Returns a new Phoneme with the same text but a union of its
         * current language set and the given one.
         *
         * @param lang the language set to merge
         * @return a new Phoneme","public Phoneme mergeWithLanguage(final LanguageSet lang) {
    return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));
}","Phoneme","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.mergeWithLanguage(LanguageSet).lang","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.mergeWithLanguage(LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.size()","Method","No Comment","@Override
public int size() {
    return 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.toString()","Method","No Comment","@Override
public String toString() {
    return phonemeText.toString() + ""["" + languages + ""]"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(CharSequence,Languages.LanguageSet)","Constructor","* Constructs a new instance.
         *
         * @param phonemeText The phoneme text.
         * @param languages A language set.","public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {
    this.phonemeText = new StringBuilder(phonemeText);
    this.languages = languages;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(CharSequence,Languages.LanguageSet).phonemeText","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(CharSequence,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(CharSequence,Languages.LanguageSet).languages","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(CharSequence,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme)","Constructor","* Constructs a new instance.
         *
         * @param phonemeLeft The left phoneme text.
         * @param phonemeRight The right phoneme text.","public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) {
    this(phonemeLeft.phonemeText, phonemeLeft.languages);
    this.phonemeText.append(phonemeRight.phonemeText);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme).phonemeLeft","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme).phonemeRight","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet)","Constructor","* Constructs a new instance.
         *
         * @param phonemeLeft The left phoneme text.
         * @param phonemeRight The right phoneme text.
         * @param languages A language set.","public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {
    this(phonemeLeft.phonemeText, languages);
    this.phonemeText.append(phonemeRight.phonemeText);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet).phonemeLeft","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet).phonemeRight","Parameter_2","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet).languages","Parameter_3","Belong to org.apache.commons.codec.language.bm.Rule.Phoneme.<init>(Phoneme,Phoneme,Languages.LanguageSet)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.PhonemeExpr","Interface","* A phoneme expression.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.bm.Rule.PhonemeExpr.getPhonemes()","Abstract Method","* Gets an iteration of phonemes.
         *
         * @return an iteration of phonemes.","Iterable<Phoneme> getPhonemes();","Iterable","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.PhonemeExpr.size()","Abstract Method","* Gets the expression size in phonemes.
         *
         * @return the expression size in phonemes.
         * @since 1.17.0","default int size() {
    // All implementations are int-bound.
    return (int) Math.min(getPhonemes().spliterator().getExactSizeIfKnown(), Integer.MAX_VALUE);
}","int","default ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.PhonemeList","Class","* A list of phonemes.","Class do not obtain Source Code","No return type","public , static , final ","","org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
"org.apache.commons.codec.language.bm.Rule.PhonemeList.phonemeList","Field","No Comment","private final List<Phoneme> phonemeList;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.PhonemeList.getPhonemes()","Method","No Comment","@Override
public List<Phoneme> getPhonemes() {
    return phonemeList;
}","List","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.PhonemeList.size()","Method","No Comment","@Override
public int size() {
    return phonemeList.size();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.PhonemeList.<init>(List)","Constructor","* Constructs a new instance.
         *
         * @param phonemes the phoneme list.","public PhonemeList(final List<Phoneme> phonemes) {
    this.phonemeList = phonemes;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.PhonemeList.<init>(List).phonemes","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.PhonemeList.<init>(List)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.RPattern","Interface","* A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.language.bm.Rule.RPattern.isMatch(CharSequence)","Abstract Method","* Tests whether the given input matches this instance.
         *
         * @param input the input to test.
         * @return whether the given input matches this instance.","boolean isMatch(CharSequence input);","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.Rule.RPattern.isMatch(CharSequence).input","Parameter_1","Belong to org.apache.commons.codec.language.bm.Rule.RPattern.isMatch(CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.RuleType","Enum","* Types of rule.
 *
 * @since 1.6","Enum do not obtain Source Code","No return type","public ","enum has no extends",""
"org.apache.commons.codec.language.bm.RuleType.APPROX","Enum Constant","* Approximate rules, which will lead to the largest number of phonetic interpretations.","APPROX(""approx"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.RuleType.EXACT","Enum Constant","* Exact rules, which will lead to a minimum number of phonetic interpretations.","EXACT(""exact"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.RuleType.RULES","Enum Constant","* For internal use only. Please use {@link #APPROX} or {@link #EXACT}.","RULES(""rules"")","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.RuleType.getName()","Method","* Gets the rule name.
     *
     * @return the rule name.","public String getName() {
    return this.name;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.RuleType.<init>(String)","Constructor","No Comment","RuleType(final String name) {
    this.name = name;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.bm.RuleType.<init>(String).name","Parameter_1","Belong to org.apache.commons.codec.language.bm.RuleType.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder","Class","* Match Rating Approach Phonetic Algorithm Developed by <CITE>Western Airlines</CITE> in 1977.
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @see <a href=""https://en.wikipedia.org/wiki/Match_rating_approach"">Wikipedia - Match Rating Approach</a>
 * @since 1.8","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.SPACE","Field","No Comment","private static final String SPACE = "" "";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.EMPTY","Field","No Comment","private static final String EMPTY = """";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.PLAIN_ASCII","Field","* The plain letter equivalent of the accented letters.","private static final String PLAIN_ASCII = // grave
""AaEeIiOoUu"" + // acute
""AaEeIiOoUuYy"" + // circumflex
""AaEeIiOoUuYy"" + // tilde
""AaOoNn"" + // umlaut
""AaEeIiOoUuYy"" + // ring
""Aa"" + // cedilla
""Cc"" + // double acute
""OoUu"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.UNICODE","Field","* Unicode characters corresponding to various accented letters. For example: \u00DA is U acute etc...","private static final String UNICODE = ""\u00C0\u00E0\u00C8\u00E8\u00CC\u00EC\u00D2\u00F2\u00D9\u00F9"" + ""\u00C1\u00E1\u00C9\u00E9\u00CD\u00ED\u00D3\u00F3\u00DA\u00FA\u00DD\u00FD"" + ""\u00C2\u00E2\u00CA\u00EA\u00CE\u00EE\u00D4\u00F4\u00DB\u00FB\u0176\u0177"" + ""\u00C3\u00E3\u00D5\u00F5\u00D1\u00F1"" + ""\u00C4\u00E4\u00CB\u00EB\u00CF\u00EF\u00D6\u00F6\u00DC\u00FC\u0178\u00FF"" + ""\u00C5\u00E5"" + ""\u00C7\u00E7"" + ""\u0150\u0151\u0170\u0171"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.DOUBLE_CONSONANT","Field","No Comment","private static final String[] DOUBLE_CONSONANT = { ""BB"", ""CC"", ""DD"", ""FF"", ""GG"", ""HH"", ""JJ"", ""KK"", ""LL"", ""MM"", ""NN"", ""PP"", ""QQ"", ""RR"", ""SS"", ""TT"", ""VV"", ""WW"", ""XX"", ""YY"", ""ZZ"" };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.cleanName(String)","Method","* Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any
     * spaces.
     *
     * <h2>API Usage</h2>
     * <p>
     * Consider this method private, it is package protected for unit testing only.
     * </p>
     *
     * @param name
     *            The name to be cleaned
     * @return The cleaned name","String cleanName(final String name) {
    String upperName = name.toUpperCase(Locale.ENGLISH);
    final String[] charsToTrim = { ""\\-"", ""[&]"", ""\\'"", ""\\."", ""[\\,]"" };
    for (final String str : charsToTrim) {
        upperName = upperName.replaceAll(str, EMPTY);
    }
    upperName = removeAccents(upperName);
    return upperName.replaceAll(""\\s+"", EMPTY);
}","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.cleanName(String).name","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.cleanName(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(Object)","Method","* Encodes an Object using the Match Rating Approach algorithm. Method is here to satisfy the requirements of the
     * Encoder interface Throws an EncoderException if input object is not of type {@link String}.
     *
     * @param pObject
     *            Object to encode
     * @return An object (or type {@link String}) containing the Match Rating Approach code which corresponds to the
     *         String supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type {@link String}","@Override
public final Object encode(final Object pObject) throws EncoderException {
    if (!(pObject instanceof String)) {
        throw new EncoderException(""Parameter supplied to Match Rating Approach encoder is not of type java.lang.String"");
    }
    return encode((String) pObject);
}","Object","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(Object).pObject","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(String)","Method","* Encodes a String using the Match Rating Approach (MRA) algorithm.
     *
     * @param name
     *            String object to encode
     * @return The MRA code corresponding to the String supplied","@Override
public final String encode(String name) {
    // Bulletproof for trivial input - NINO
    if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {
        return EMPTY;
    }
    // Preprocessing
    name = cleanName(name);
    // Bulletproof if name becomes empty after cleanName(name)
    if (SPACE.equals(name) || name.isEmpty()) {
        return EMPTY;
    }
    // BEGIN: Actual encoding part of the algorithm...
    // 1. Delete all vowels unless the vowel begins the word
    name = removeVowels(name);
    // Bulletproof if name becomes empty after removeVowels(name)
    if (SPACE.equals(name) || name.isEmpty()) {
        return EMPTY;
    }
    // 2. Remove second consonant from any double consonant
    name = removeDoubleConsonants(name);
    return getFirst3Last3(name);
}","String","public , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(String).name","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.getFirst3Last3(String)","Method","* Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.
     *
     * <h2>API Usage</h2>
     * <p>
     * Consider this method private, it is package protected for unit testing only.
     * </p>
     *
     * @param name
     *            The string to get the substrings from
     * @return Annexed first and last 3 letters of input word.","String getFirst3Last3(final String name) {
    final int nameLength = name.length();
    if (nameLength > 6) {
        final String firstThree = name.substring(0, 3);
        final String lastThree = name.substring(nameLength - 3, nameLength);
        return firstThree + lastThree;
    }
    return name;
}","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.getFirst3Last3(String).name","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.getFirst3Last3(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)","Method","* Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the
     * min rating. Values strictly from documentation.
     *
     * <h2>API Usage</h2>
     * <p>
     * Consider this method private, it is package protected for unit testing only.
     * </p>
     *
     * @param sumLength
     *            The length of 2 strings sent down
     * @return The min rating value","int getMinRating(final int sumLength) {
    int minRating = 0;
    if (sumLength <= 4) {
        minRating = 5;
    } else if (sumLength <= 7) {
        // already know it is at least 5
        minRating = 4;
    } else if (sumLength <= 11) {
        // already know it is at least 8
        minRating = 3;
    } else if (sumLength == 12) {
        minRating = 2;
    } else {
        // docs said little here.
        minRating = 1;
    }
    return minRating;
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int).sumLength","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(String,String)","Method","* Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the
     * strings are cleaned in the same way as {@link #encode(String)}.
     *
     * @param name1
     *            First of the 2 strings (names) to compare
     * @param name2
     *            Second of the 2 names to compare
     * @return {@code true} if the encodings are identical {@code false} otherwise.","public boolean isEncodeEquals(String name1, String name2) {
    // Bulletproof for trivial input - NINO
    if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) {
        return false;
    }
    if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) {
        return false;
    }
    if (name1.length() == 1 || name2.length() == 1) {
        return false;
    }
    if (name1.equalsIgnoreCase(name2)) {
        return true;
    }
    // Preprocessing
    name1 = cleanName(name1);
    name2 = cleanName(name2);
    // Actual MRA Algorithm
    // 1. Remove vowels
    name1 = removeVowels(name1);
    name2 = removeVowels(name2);
    // 2. Remove double consonants
    name1 = removeDoubleConsonants(name1);
    name2 = removeDoubleConsonants(name2);
    // 3. Reduce down to 3 letters
    name1 = getFirst3Last3(name1);
    name2 = getFirst3Last3(name2);
    // 4. Check for length difference - if 3 or greater, then no similarity
    // comparison is done
    if (Math.abs(name1.length() - name2.length()) >= 3) {
        return false;
    }
    // 5. Obtain the minimum rating value by calculating the length sum of the
    // encoded Strings and sending it down.
    final int sumLength = Math.abs(name1.length() + name2.length());
    final int minRating = getMinRating(sumLength);
    // 6. Process the encoded Strings from left to right and remove any
    // identical characters found from both Strings respectively.
    final int count = leftToRightThenRightToLeftProcessing(name1, name2);
    // 7. Each PNI item that has a similarity rating equal to or greater than
    // the min is considered to be a good candidate match
    return count >= minRating;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(String,String).name1","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(String,String).name2","Parameter_2","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.isVowel(String)","Method","* Determines if a letter is a vowel.
     *
     * <h2>API Usage</h2>
     * <p>
     * Consider this method private, it is package protected for unit testing only.
     * </p>
     *
     * @param letter
     *            The letter under investigation
     * @return True if a vowel, else false","boolean isVowel(final String letter) {
    return letter.equalsIgnoreCase(""E"") || letter.equalsIgnoreCase(""A"") || letter.equalsIgnoreCase(""O"") || letter.equalsIgnoreCase(""I"") || letter.equalsIgnoreCase(""U"");
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.isVowel(String).letter","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.isVowel(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.leftToRightThenRightToLeftProcessing(String,String)","Method","* Processes the names from left to right (first) then right to left removing identical letters in same positions.
     * Then subtracts the longer string that remains from 6 and returns this.
     *
     * <h2>API Usage</h2>
     * <p>
     * Consider this method private, it is package protected for unit testing only.
     * </p>
     *
     * @param name1
     *            name2
     * @return the length as above","int leftToRightThenRightToLeftProcessing(final String name1, final String name2) {
    final char[] name1Char = name1.toCharArray();
    final char[] name2Char = name2.toCharArray();
    final int name1Size = name1.length() - 1;
    final int name2Size = name2.length() - 1;
    String name1LtRStart = EMPTY;
    String name1LtREnd = EMPTY;
    String name2RtLStart = EMPTY;
    String name2RtLEnd = EMPTY;
    for (int i = 0; i < name1Char.length; i++) {
        if (i > name2Size) {
            break;
        }
        name1LtRStart = name1.substring(i, i + 1);
        name1LtREnd = name1.substring(name1Size - i, name1Size - i + 1);
        name2RtLStart = name2.substring(i, i + 1);
        name2RtLEnd = name2.substring(name2Size - i, name2Size - i + 1);
        // Left to right...
        if (name1LtRStart.equals(name2RtLStart)) {
            name1Char[i] = ' ';
            name2Char[i] = ' ';
        }
        // Right to left...
        if (name1LtREnd.equals(name2RtLEnd)) {
            name1Char[name1Size - i] = ' ';
            name2Char[name2Size - i] = ' ';
        }
    }
    // Char arrays -> string & remove extraneous space
    final String strA = new String(name1Char).replaceAll(""\\s+"", EMPTY);
    final String strB = new String(name2Char).replaceAll(""\\s+"", EMPTY);
    // Final bit - subtract the longest string from 6 and return this int value
    if (strA.length() > strB.length()) {
        return Math.abs(6 - strA.length());
    }
    return Math.abs(6 - strB.length());
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.leftToRightThenRightToLeftProcessing(String,String).name1","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.leftToRightThenRightToLeftProcessing(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.leftToRightThenRightToLeftProcessing(String,String).name2","Parameter_2","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.leftToRightThenRightToLeftProcessing(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(String)","Method","* Removes accented letters and replaces with non-accented ASCII equivalent Case is preserved.
     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29
     *
     * @param accentedWord
     *            The word that may have accents in it.
     * @return De-accented word","String removeAccents(final String accentedWord) {
    if (accentedWord == null) {
        return null;
    }
    final StringBuilder sb = new StringBuilder();
    final int n = accentedWord.length();
    for (int i = 0; i < n; i++) {
        final char c = accentedWord.charAt(i);
        final int pos = UNICODE.indexOf(c);
        if (pos > -1) {
            sb.append(PLAIN_ASCII.charAt(pos));
        } else {
            sb.append(c);
        }
    }
    return sb.toString();
}","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(String).accentedWord","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.removeDoubleConsonants(String)","Method","* Replaces any double consonant pair with the single letter equivalent.
     *
     * <h2>API Usage</h2>
     * <p>
     * Consider this method private, it is package protected for unit testing only.
     * </p>
     *
     * @param name
     *            String to have double consonants removed
     * @return Single consonant word","String removeDoubleConsonants(final String name) {
    String replacedName = name.toUpperCase(Locale.ENGLISH);
    for (final String dc : DOUBLE_CONSONANT) {
        if (replacedName.contains(dc)) {
            final String singleLetter = dc.substring(0, 1);
            replacedName = replacedName.replace(dc, singleLetter);
        }
    }
    return replacedName;
}","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.removeDoubleConsonants(String).name","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.removeDoubleConsonants(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.removeVowels(String)","Method","* Deletes all vowels unless the vowel begins the word.
     *
     * <h2>API Usage</h2>
     * <p>
     * Consider this method private, it is package protected for unit testing only.
     * </p>
     *
     * @param name
     *            The name to have vowels removed
     * @return De-voweled word","String removeVowels(String name) {
    // Extract first letter
    final String firstLetter = name.substring(0, 1);
    name = name.replace(""A"", EMPTY);
    name = name.replace(""E"", EMPTY);
    name = name.replace(""I"", EMPTY);
    name = name.replace(""O"", EMPTY);
    name = name.replace(""U"", EMPTY);
    name = name.replaceAll(""\\s{2,}\\b"", SPACE);
    // return isVowel(firstLetter) ? (firstLetter + name) : name;
    if (isVowel(firstLetter)) {
        return firstLetter + name;
    }
    return name;
}","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.removeVowels(String).name","Parameter_1","Belong to org.apache.commons.codec.language.MatchRatingApproachEncoder.removeVowels(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.MatchRatingApproachEncoder.<init>()","Constructor","* Constructs a new instance.","public MatchRatingApproachEncoder() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex","Class","* Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names, but can also be used as a
 * general purpose scheme to find word with similar phonemes.
 *
 * <p>This class is thread-safe.
 * Although not strictly immutable, the mutable fields are not actually used.</p>","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.Soundex.SILENT_MARKER","Field","* The marker character used to indicate a silent (ignored) character.
     * These are ignored except when they appear as the first character.
     * <p>
     * Note: The {@link #US_ENGLISH_MAPPING_STRING} does not use this mechanism
     * because changing it might break existing code. Mappings that don't contain
     * a silent marker code are treated as though H and W are silent.
     * </p>
     * <p>
     * To override this, use the {@link #Soundex(String, boolean)} constructor.
     * </p>
     *
     * @since 1.11","public static final char SILENT_MARKER = '-';","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.US_ENGLISH_MAPPING_STRING","Field","* This is a default mapping of the 26 letters used in US English. A value of {@code 0} for a letter position
     * means do not encode, but treat as a separator when it occurs between consonants with the same code.
     * <p>
     * (This constant is provided as both an implementation convenience and to allow Javadoc to pick
     * up the value for the constant values page.)
     * </p>
     * <p>
     * <strong>Note that letters H and W are treated specially.</strong>
     * They are ignored (after the first letter) and don't act as separators
     * between consonants with the same code.
     * </p>","public static final String US_ENGLISH_MAPPING_STRING = ""01230120022455012623010202"";","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.US_ENGLISH_MAPPING","Field","* This is a default mapping of the 26 letters used in US English. A value of {@code 0} for a letter position
     * means do not encode.
     *
     * @see Soundex#Soundex(char[])","private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.US_ENGLISH","Field","* An instance of Soundex using the US_ENGLISH_MAPPING mapping.
     * This treats H and W as silent letters.
     * Apart from when they appear as the first letter, they are ignored.
     * They don't act as separators between duplicate codes.
     *
     * @see #US_ENGLISH_MAPPING_STRING","public static final Soundex US_ENGLISH = new Soundex();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.US_ENGLISH_SIMPLIFIED","Field","* An instance of Soundex using the Simplified Soundex mapping, as described here:
     * http://west-penwith.org.uk/misc/soundex.htm
     * <p>
     * This treats H and W the same as vowels (AEIOUY).
     * Such letters aren't encoded (after the first), but they do
     * act as separators when dropping duplicate codes.
     * The mapping is otherwise the same as for {@link #US_ENGLISH}
     * </p>
     *
     * @since 1.11","public static final Soundex US_ENGLISH_SIMPLIFIED = new Soundex(US_ENGLISH_MAPPING_STRING, false);","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.US_ENGLISH_GENEALOGY","Field","* An instance of Soundex using the mapping as per the Genealogy site:
     * http://www.genealogy.com/articles/research/00000060.html
     * <p>
     * This treats vowels (AEIOUY), H and W as silent letters.
     * Such letters are ignored (after the first) and do not
     * act as separators when dropping duplicate codes.
     * </p>
     * <p>
     * The codes for consonants are otherwise the same as for
     * {@link #US_ENGLISH_MAPPING_STRING} and {@link #US_ENGLISH_SIMPLIFIED}
     * </p>
     *
     * @since 1.11","public static final Soundex US_ENGLISH_GENEALOGY = new Soundex(""-123-12--22455-12623-1-2-2"");","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.maxLength","Field","* The maximum length of a Soundex code - Soundex codes are only four characters by definition.
     *
     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.","@Deprecated
private int maxLength = 4;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.soundexMapping","Field","* Every letter of the alphabet is ""mapped"" to a numerical value. This char array holds the values to which each
     * letter is mapped. This implementation contains a default map for US_ENGLISH","private final char[] soundexMapping;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.specialCaseHW","Field","* Should H and W be treated specially?
     * <p>
     * In versions of the code prior to 1.11,
     * the code always treated H and W as silent (ignored) letters.
     * If this field is false, H and W are no longer special-cased.
     * </p>","private final boolean specialCaseHW;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.difference(String,String)","Method","* Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This
     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or
     * identical values.
     *
     * @param s1
     *                  A String that will be encoded and compared.
     * @param s2
     *                  A String that will be encoded and compared.
     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.
     * @see SoundexUtils#difference(StringEncoder,String,String)
     * @see <a href=""https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp""> MS
     *          T-SQL DIFFERENCE</a>
     *
     * @throws EncoderException
     *                  if an error occurs encoding one of the strings
     * @since 1.3","public int difference(final String s1, final String s2) throws EncoderException {
    return SoundexUtils.difference(this, s1, s2);
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.difference(String,String).s1","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.difference(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.difference(String,String).s2","Parameter_2","Belong to org.apache.commons.codec.language.Soundex.difference(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.encode(Object)","Method","* Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of
     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type {@link String}.
     *
     * @param obj
     *                  Object to encode
     * @return An object (or type {@link String}) containing the soundex code which corresponds to the String
     *             supplied.
     * @throws EncoderException
     *                  if the parameter supplied is not of type {@link String}
     * @throws IllegalArgumentException
     *                  if a character is not mapped","@Override
public Object encode(final Object obj) throws EncoderException {
    if (!(obj instanceof String)) {
        throw new EncoderException(""Parameter supplied to Soundex encode is not of type java.lang.String"");
    }
    return soundex((String) obj);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.encode(String)","Method","* Encodes a String using the soundex algorithm.
     *
     * @param str
     *                  A String object to encode
     * @return A Soundex code corresponding to the String supplied
     * @throws IllegalArgumentException
     *                  if a character is not mapped","@Override
public String encode(final String str) {
    return soundex(str);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.encode(String).str","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.getMaxLength()","Method","* Returns the maxLength. Standard Soundex
     *
     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.
     * @return int","@Deprecated
public int getMaxLength() {
    return this.maxLength;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.hasMarker(char[])","Method","No Comment","private boolean hasMarker(final char[] mapping) {
    for (final char ch : mapping) {
        if (ch == SILENT_MARKER) {
            return true;
        }
    }
    return false;
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.hasMarker(char[]).mapping","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.hasMarker(char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.map(char)","Method","* Maps the given upper-case character to its Soundex code.
     *
     * @param ch
     *                  An upper-case character.
     * @return A Soundex code.
     * @throws IllegalArgumentException
     *                  Thrown if {@code ch} is not mapped.","private char map(final char ch) {
    final int index = ch - 'A';
    if (index < 0 || index >= this.soundexMapping.length) {
        throw new IllegalArgumentException(""The character is not mapped: "" + ch + "" (index="" + index + "")"");
    }
    return this.soundexMapping[index];
}","char","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.map(char).ch","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.map(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.setMaxLength(int)","Method","* Sets the maxLength.
     *
     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.
     * @param maxLength
     *                  The maxLength to set","@Deprecated
public void setMaxLength(final int maxLength) {
    this.maxLength = maxLength;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.setMaxLength(int).maxLength","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.setMaxLength(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.soundex(String)","Method","* Retrieves the Soundex code for a given String object.
     *
     * @param str
     *                  String to encode using the Soundex algorithm
     * @return A soundex code for the String supplied
     * @throws IllegalArgumentException
     *                  if a character is not mapped","public String soundex(String str) {
    if (str == null) {
        return null;
    }
    str = SoundexUtils.clean(str);
    if (str.isEmpty()) {
        return str;
    }
    final char[] out = { '0', '0', '0', '0' };
    int count = 0;
    final char first = str.charAt(0);
    out[count++] = first;
    // previous digit
    char lastDigit = map(first);
    for (int i = 1; i < str.length() && count < out.length; i++) {
        final char ch = str.charAt(i);
        if (this.specialCaseHW && (ch == 'H' || ch == 'W')) {
            // these are ignored completely
            continue;
        }
        final char digit = map(ch);
        if (digit == SILENT_MARKER) {
            continue;
        }
        if (digit != '0' && digit != lastDigit) {
            // don't store vowels or repeats
            out[count++] = digit;
        }
        lastDigit = digit;
    }
    return new String(out);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.soundex(String).str","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.soundex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.<init>()","Constructor","* Creates an instance using US_ENGLISH_MAPPING
     *
     * @see Soundex#Soundex(char[])
     * @see Soundex#US_ENGLISH_MAPPING_STRING","public Soundex() {
    this.soundexMapping = US_ENGLISH_MAPPING;
    this.specialCaseHW = true;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.<init>(char[])","Constructor","* Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized
     * mapping for a non-Western character set.
     * <p>
     * Every letter of the alphabet is ""mapped"" to a numerical value. This char array holds the values to which each
     * letter is mapped. This implementation contains a default map for US_ENGLISH
     * </p>
     * <p>
     * If the mapping contains an instance of {@link #SILENT_MARKER} then H and W are not given special treatment
     * </p>
     *
     * @param mapping
     *                  Mapping array to use when finding the corresponding code for a given character","public Soundex(final char[] mapping) {
    this.soundexMapping = mapping.clone();
    this.specialCaseHW = !hasMarker(this.soundexMapping);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.<init>(char[]).mapping","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.<init>(char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.<init>(String)","Constructor","* Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,
     * and/or possibly provide an internationalized mapping for a non-Western character set.
     * <p>
     * If the mapping contains an instance of {@link #SILENT_MARKER} then H and W are not given special treatment
     * </p>
     *
     * @param mapping
     *            Mapping string to use when finding the corresponding code for a given character
     * @since 1.4","public Soundex(final String mapping) {
    this.soundexMapping = mapping.toCharArray();
    this.specialCaseHW = !hasMarker(this.soundexMapping);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.<init>(String).mapping","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.<init>(String,boolean)","Constructor","* Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,
     * and/or possibly provide an internationalized mapping for a non-Western character set.
     *
     * @param mapping
     *            Mapping string to use when finding the corresponding code for a given character
     * @param specialCaseHW if true, then
     * @since 1.11","public Soundex(final String mapping, final boolean specialCaseHW) {
    this.soundexMapping = mapping.toCharArray();
    this.specialCaseHW = specialCaseHW;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.<init>(String,boolean).mapping","Parameter_1","Belong to org.apache.commons.codec.language.Soundex.<init>(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Soundex.<init>(String,boolean).specialCaseHW","Parameter_2","Belong to org.apache.commons.codec.language.Soundex.<init>(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex","Class","* Encodes a string into a Daitch-Mokotoff Soundex value.
 * <p>
 * The Daitch-Mokotoff Soundex algorithm is a refinement of the Russel and American Soundex algorithms, yielding greater
 * accuracy in matching especially Slavish and Yiddish surnames with similar pronunciation but differences in spelling.
 * </p>
 * <p>
 * The main differences compared to the other soundex variants are:
 * </p>
 * <ul>
 * <li>coded names are 6 digits long
 * <li>the initial character of the name is coded
 * <li>rules to encoded multi-character n-grams
 * <li>multiple possible encodings for the same name (branching)
 * </ul>
 * <p>
 * This implementation supports branching, depending on the used method:
 * <ul>
 * <li>{@link #encode(String)} - branching disabled, only the first code will be returned
 * <li>{@link #soundex(String)} - branching enabled, all codes will be returned, separated by '|'
 * </ul>
 * <p>
 * Note: This implementation has additional branching rules compared to the original description of the algorithm. The
 * rules can be customized by overriding the default rules contained in the resource file
 * {@code org/apache/commons/codec/language/dmrules.txt}.
 * </p>
 * <p>
 * This class is thread-safe.
 * </p>
 *
 * @see Soundex
 * @see <a href=""https://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex""> Wikipedia - Daitch-Mokotoff Soundex</a>
 * @see <a href=""http://www.avotaynu.com/soundex.htm"">Avotaynu - Soundexing and Genealogy</a>
 * @since 1.10","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.NUL","Field","* The NUL character.","private static final char NUL = '\0';","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.COMMENT","Field","No Comment","private static final String COMMENT = ""//"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.DOUBLE_QUOTE","Field","No Comment","private static final String DOUBLE_QUOTE = ""\"""";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.MULTILINE_COMMENT_END","Field","No Comment","private static final String MULTILINE_COMMENT_END = ""*/"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.MULTILINE_COMMENT_START","Field","No Comment","private static final String MULTILINE_COMMENT_START = ""/*"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.RESOURCE_FILE","Field","The resource file containing the replacement and folding rules","private static final String RESOURCE_FILE = ""/org/apache/commons/codec/language/dmrules.txt"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.MAX_LENGTH","Field","The code length of a DM soundex value.","private static final int MAX_LENGTH = 6;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.RULES","Field","Transformation rules indexed by the first character of their pattern.","private static final Map<Character, List<Rule>> RULES = new HashMap<>();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.FOLDINGS","Field","Folding rules.","private static final Map<Character, Character> FOLDINGS = new HashMap<>();","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.folding","Field","Whether to use ASCII folding prior to encoding.","private final boolean folding;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.parseRules(Scanner,String,Map,Map)","Method","No Comment","private static void parseRules(final Scanner scanner, final String location, final Map<Character, List<Rule>> ruleMapping, final Map<Character, Character> asciiFoldings) {
    int currentLine = 0;
    boolean inMultilineComment = false;
    while (scanner.hasNextLine()) {
        currentLine++;
        final String rawLine = scanner.nextLine();
        String line = rawLine;
        if (inMultilineComment) {
            if (line.endsWith(MULTILINE_COMMENT_END)) {
                inMultilineComment = false;
            }
            continue;
        }
        if (line.startsWith(MULTILINE_COMMENT_START)) {
            inMultilineComment = true;
        } else {
            // discard comments
            final int cmtI = line.indexOf(COMMENT);
            if (cmtI >= 0) {
                line = line.substring(0, cmtI);
            }
            // trim leading-trailing whitespace
            line = line.trim();
            if (line.isEmpty()) {
                // empty lines can be safely skipped
                continue;
            }
            if (line.contains(""="")) {
                // folding
                final String[] parts = line.split(""="");
                if (parts.length != 2) {
                    throw new IllegalArgumentException(""Malformed folding statement split into "" + parts.length + "" parts: "" + rawLine + "" in "" + location);
                }
                final String leftCharacter = parts[0];
                final String rightCharacter = parts[1];
                if (leftCharacter.length() != 1 || rightCharacter.length() != 1) {
                    throw new IllegalArgumentException(""Malformed folding statement - "" + ""patterns are not single characters: "" + rawLine + "" in "" + location);
                }
                asciiFoldings.put(leftCharacter.charAt(0), rightCharacter.charAt(0));
            } else {
                // rule
                final String[] parts = line.split(""\\s+"");
                if (parts.length != 4) {
                    throw new IllegalArgumentException(""Malformed rule statement split into "" + parts.length + "" parts: "" + rawLine + "" in "" + location);
                }
                try {
                    final String pattern = stripQuotes(parts[0]);
                    final String replacement1 = stripQuotes(parts[1]);
                    final String replacement2 = stripQuotes(parts[2]);
                    final String replacement3 = stripQuotes(parts[3]);
                    final Rule r = new Rule(pattern, replacement1, replacement2, replacement3);
                    final char patternKey = r.pattern.charAt(0);
                    final List<Rule> rules = ruleMapping.computeIfAbsent(patternKey, k -> new ArrayList<>());
                    rules.add(r);
                } catch (final IllegalArgumentException e) {
                    throw new IllegalStateException(""Problem parsing line '"" + currentLine + ""' in "" + location, e);
                }
            }
        }
    }
}","void","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.parseRules(Scanner,String,Map,Map).scanner","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.parseRules(Scanner,String,Map,Map)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.parseRules(Scanner,String,Map,Map).location","Parameter_2","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.parseRules(Scanner,String,Map,Map)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.parseRules(Scanner,String,Map,Map).ruleMapping","Parameter_3","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.parseRules(Scanner,String,Map,Map)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.parseRules(Scanner,String,Map,Map).asciiFoldings","Parameter_4","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.parseRules(Scanner,String,Map,Map)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.stripQuotes(String)","Method","No Comment","private static String stripQuotes(String str) {
    if (str.startsWith(DOUBLE_QUOTE)) {
        str = str.substring(1);
    }
    if (str.endsWith(DOUBLE_QUOTE)) {
        str = str.substring(0, str.length() - 1);
    }
    return str;
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.stripQuotes(String).str","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.stripQuotes(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.cleanup(String)","Method","* Performs a cleanup of the input string before the actual soundex transformation.
     * <p>
     * Removes all whitespace characters and performs ASCII folding if enabled.
     * </p>
     *
     * @param input
     *            the input string to clean up
     * @return a cleaned up string","private String cleanup(final String input) {
    final StringBuilder sb = new StringBuilder();
    for (char ch : input.toCharArray()) {
        if (Character.isWhitespace(ch)) {
            continue;
        }
        ch = Character.toLowerCase(ch);
        final Character character = FOLDINGS.get(ch);
        if (folding && character != null) {
            ch = character;
        }
        sb.append(ch);
    }
    return sb.toString();
}","String","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.cleanup(String).input","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.cleanup(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.encode(Object)","Method","* Encodes an Object using the Daitch-Mokotoff soundex algorithm without branching.
     * <p>
     * This method is provided in order to satisfy the requirements of the Encoder interface, and will throw an
     * EncoderException if the supplied object is not of type {@link String}.
     * </p>
     *
     * @see #soundex(String)
     * @param obj
     *            Object to encode
     * @return An object (of type {@link String}) containing the DM soundex code, which corresponds to the String
     *         supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type {@link String}
     * @throws IllegalArgumentException
     *             if a character is not mapped","@Override
public Object encode(final Object obj) throws EncoderException {
    if (!(obj instanceof String)) {
        throw new EncoderException(""Parameter supplied to DaitchMokotoffSoundex encode is not of type java.lang.String"");
    }
    return encode((String) obj);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.encode(String)","Method","* Encodes a String using the Daitch-Mokotoff soundex algorithm without branching.
     *
     * @see #soundex(String)
     * @param source
     *            A String object to encode
     * @return A DM Soundex code corresponding to the String supplied
     * @throws IllegalArgumentException
     *             if a character is not mapped","@Override
public String encode(final String source) {
    if (source == null) {
        return null;
    }
    return soundex(source, false)[0];
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.encode(String).source","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(String)","Method","* Encodes a String using the Daitch-Mokotoff soundex algorithm with branching.
     * <p>
     * In case a string is encoded into multiple codes (see branching rules), the result will contain all codes,
     * separated by '|'.
     * </p>
     * <p>
     * Example: the name ""AUERBACH"" is encoded as both
     * </p>
     * <ul>
     * <li>097400</li>
     * <li>097500</li>
     * </ul>
     * <p>
     * Thus the result will be ""097400|097500"".
     * </p>
     *
     * @param source
     *            A String object to encode
     * @return A string containing a set of DM Soundex codes corresponding to the String supplied
     * @throws IllegalArgumentException
     *             if a character is not mapped","public String soundex(final String source) {
    return String.join(""|"", soundex(source, true));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(String).source","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(String,boolean)","Method","* Perform the actual DM Soundex algorithm on the input string.
     *
     * @param source
     *            A String object to encode
     * @param branching
     *            If branching shall be performed
     * @return A string array containing all DM Soundex codes corresponding to the String supplied depending on the
     *         selected branching mode","private String[] soundex(final String source, final boolean branching) {
    if (source == null) {
        return null;
    }
    final String input = cleanup(source);
    final Set<Branch> currentBranches = new LinkedHashSet<>();
    currentBranches.add(new Branch());
    char lastChar = NUL;
    for (int index = 0; index < input.length(); index++) {
        final char ch = input.charAt(index);
        // ignore whitespace inside a name
        if (Character.isWhitespace(ch)) {
            continue;
        }
        final String inputContext = input.substring(index);
        final List<Rule> rules = RULES.get(ch);
        if (rules == null) {
            continue;
        }
        // use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access
        final List<Branch> nextBranches = branching ? new ArrayList<>() : Collections.emptyList();
        for (final Rule rule : rules) {
            if (rule.matches(inputContext)) {
                if (branching) {
                    nextBranches.clear();
                }
                final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0');
                final boolean branchingRequired = replacements.length > 1 && branching;
                for (final Branch branch : currentBranches) {
                    for (final String nextReplacement : replacements) {
                        // if we have multiple replacements, always create a new branch
                        final Branch nextBranch = branchingRequired ? branch.createBranch() : branch;
                        // special rule: occurrences of mn or nm are treated differently
                        final boolean force = lastChar == 'm' && ch == 'n' || lastChar == 'n' && ch == 'm';
                        nextBranch.processNextReplacement(nextReplacement, force);
                        if (!branching) {
                            break;
                        }
                        nextBranches.add(nextBranch);
                    }
                }
                if (branching) {
                    currentBranches.clear();
                    currentBranches.addAll(nextBranches);
                }
                index += rule.getPatternLength() - 1;
                break;
            }
        }
        lastChar = ch;
    }
    final String[] result = new String[currentBranches.size()];
    int index = 0;
    for (final Branch branch : currentBranches) {
        branch.finish();
        result[index++] = branch.toString();
    }
    return result;
}","String[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(String,boolean).source","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(String,boolean).branching","Parameter_2","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.<init>()","Constructor","* Creates a new instance with ASCII-folding enabled.","public DaitchMokotoffSoundex() {
    this(true);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.<init>(boolean)","Constructor","* Creates a new instance.
     * <p>
     * With ASCII-folding enabled, certain accented characters will be transformed to equivalent ASCII characters, for example
     *  -&gt; e.
     * </p>
     *
     * @param folding
     *            if ASCII-folding shall be performed before encoding","public DaitchMokotoffSoundex(final boolean folding) {
    this.folding = folding;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.<init>(boolean).folding","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.<init>(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch","Class","* Inner class representing a branch during DM soundex encoding.","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.builder","Field","No Comment","private final StringBuilder builder;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.cachedString","Field","No Comment","private String cachedString;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.lastReplacement","Field","No Comment","private String lastReplacement;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.createBranch()","Method","* Creates a new branch, identical to this branch.
         *
         * @return a new, identical branch","public Branch createBranch() {
    final Branch branch = new Branch();
    branch.builder.append(toString());
    branch.lastReplacement = this.lastReplacement;
    return branch;
}","Branch","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object other) {
    if (this == other) {
        return true;
    }
    if (!(other instanceof Branch)) {
        return false;
    }
    return toString().equals(((Branch) other).toString());
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.equals(Object).other","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.finish()","Method","* Finish this branch by appending '0's until the maximum code length has been reached.","public void finish() {
    while (builder.length() < MAX_LENGTH) {
        builder.append('0');
        cachedString = null;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return toString().hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.processNextReplacement(String,boolean)","Method","* Process the next replacement to be added to this branch.
         *
         * @param replacement
         *            the next replacement to append
         * @param forceAppend
         *            indicates if the default processing shall be overridden","public void processNextReplacement(final String replacement, final boolean forceAppend) {
    final boolean append = lastReplacement == null || !lastReplacement.endsWith(replacement) || forceAppend;
    if (append && builder.length() < MAX_LENGTH) {
        builder.append(replacement);
        // remove all characters after the maximum length
        if (builder.length() > MAX_LENGTH) {
            builder.delete(MAX_LENGTH, builder.length());
        }
        cachedString = null;
    }
    lastReplacement = replacement;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.processNextReplacement(String,boolean).replacement","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.processNextReplacement(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.processNextReplacement(String,boolean).forceAppend","Parameter_2","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.processNextReplacement(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.toString()","Method","No Comment","@Override
public String toString() {
    if (cachedString == null) {
        cachedString = builder.toString();
    }
    return cachedString;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Branch.<init>()","Constructor","No Comment","private Branch() {
    builder = new StringBuilder();
    lastReplacement = null;
    cachedString = null;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule","Class","* Inner class for storing rules.","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.pattern","Field","No Comment","private final String pattern;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.replacementAtStart","Field","No Comment","private final String[] replacementAtStart;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.replacementBeforeVowel","Field","No Comment","private final String[] replacementBeforeVowel;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.replacementDefault","Field","No Comment","private final String[] replacementDefault;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.getPatternLength()","Method","No Comment","public int getPatternLength() {
    return pattern.length();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.getReplacements(String,boolean)","Method","No Comment","public String[] getReplacements(final String context, final boolean atStart) {
    if (atStart) {
        return replacementAtStart;
    }
    final int nextIndex = getPatternLength();
    final boolean nextCharIsVowel = nextIndex < context.length() && isVowel(context.charAt(nextIndex));
    if (nextCharIsVowel) {
        return replacementBeforeVowel;
    }
    return replacementDefault;
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.getReplacements(String,boolean).context","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.getReplacements(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.getReplacements(String,boolean).atStart","Parameter_2","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.getReplacements(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.isVowel(char)","Method","No Comment","private boolean isVowel(final char ch) {
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.isVowel(char).ch","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.isVowel(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.matches(String)","Method","No Comment","public boolean matches(final String context) {
    return context.startsWith(pattern);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.matches(String).context","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.matches(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.toString()","Method","No Comment","@Override
public String toString() {
    return String.format(""%s=(%s,%s,%s)"", pattern, Arrays.asList(replacementAtStart), Arrays.asList(replacementBeforeVowel), Arrays.asList(replacementDefault));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.<init>(String,String,String,String)","Constructor","No Comment","protected Rule(final String pattern, final String replacementAtStart, final String replacementBeforeVowel, final String replacementDefault) {
    this.pattern = pattern;
    this.replacementAtStart = replacementAtStart.split(""\\|"");
    this.replacementBeforeVowel = replacementBeforeVowel.split(""\\|"");
    this.replacementDefault = replacementDefault.split(""\\|"");
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.<init>(String,String,String,String).pattern","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.<init>(String,String,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.<init>(String,String,String,String).replacementAtStart","Parameter_2","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.<init>(String,String,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.<init>(String,String,String,String).replacementBeforeVowel","Parameter_3","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.<init>(String,String,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.<init>(String,String,String,String).replacementDefault","Parameter_4","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex$Rule.<init>(String,String,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch","Class","* Inner class representing a branch during DM soundex encoding.","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.builder","Field","No Comment","private final StringBuilder builder;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.cachedString","Field","No Comment","private String cachedString;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.lastReplacement","Field","No Comment","private String lastReplacement;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.createBranch()","Method","* Creates a new branch, identical to this branch.
         *
         * @return a new, identical branch","public Branch createBranch() {
    final Branch branch = new Branch();
    branch.builder.append(toString());
    branch.lastReplacement = this.lastReplacement;
    return branch;
}","Branch","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.equals(Object)","Method","No Comment","@Override
public boolean equals(final Object other) {
    if (this == other) {
        return true;
    }
    if (!(other instanceof Branch)) {
        return false;
    }
    return toString().equals(((Branch) other).toString());
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.equals(Object).other","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.equals(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.finish()","Method","* Finish this branch by appending '0's until the maximum code length has been reached.","public void finish() {
    while (builder.length() < MAX_LENGTH) {
        builder.append('0');
        cachedString = null;
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.hashCode()","Method","No Comment","@Override
public int hashCode() {
    return toString().hashCode();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.processNextReplacement(String,boolean)","Method","* Process the next replacement to be added to this branch.
         *
         * @param replacement
         *            the next replacement to append
         * @param forceAppend
         *            indicates if the default processing shall be overridden","public void processNextReplacement(final String replacement, final boolean forceAppend) {
    final boolean append = lastReplacement == null || !lastReplacement.endsWith(replacement) || forceAppend;
    if (append && builder.length() < MAX_LENGTH) {
        builder.append(replacement);
        // remove all characters after the maximum length
        if (builder.length() > MAX_LENGTH) {
            builder.delete(MAX_LENGTH, builder.length());
        }
        cachedString = null;
    }
    lastReplacement = replacement;
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.processNextReplacement(String,boolean).replacement","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.processNextReplacement(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.processNextReplacement(String,boolean).forceAppend","Parameter_2","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.processNextReplacement(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.toString()","Method","No Comment","@Override
public String toString() {
    if (cachedString == null) {
        cachedString = builder.toString();
    }
    return cachedString;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.<init>()","Constructor","No Comment","private Branch() {
    builder = new StringBuilder();
    lastReplacement = null;
    cachedString = null;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule","Class","* Inner class for storing rules.","Class do not obtain Source Code","No return type","private , static , final ","",""
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.pattern","Field","No Comment","private final String pattern;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.replacementAtStart","Field","No Comment","private final String[] replacementAtStart;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.replacementBeforeVowel","Field","No Comment","private final String[] replacementBeforeVowel;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.replacementDefault","Field","No Comment","private final String[] replacementDefault;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.getPatternLength()","Method","No Comment","public int getPatternLength() {
    return pattern.length();
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.getReplacements(String,boolean)","Method","No Comment","public String[] getReplacements(final String context, final boolean atStart) {
    if (atStart) {
        return replacementAtStart;
    }
    final int nextIndex = getPatternLength();
    final boolean nextCharIsVowel = nextIndex < context.length() && isVowel(context.charAt(nextIndex));
    if (nextCharIsVowel) {
        return replacementBeforeVowel;
    }
    return replacementDefault;
}","String[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.getReplacements(String,boolean).context","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.getReplacements(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.getReplacements(String,boolean).atStart","Parameter_2","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.getReplacements(String,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.isVowel(char)","Method","No Comment","private boolean isVowel(final char ch) {
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';
}","boolean","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.isVowel(char).ch","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.isVowel(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.matches(String)","Method","No Comment","public boolean matches(final String context) {
    return context.startsWith(pattern);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.matches(String).context","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.matches(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.toString()","Method","No Comment","@Override
public String toString() {
    return String.format(""%s=(%s,%s,%s)"", pattern, Arrays.asList(replacementAtStart), Arrays.asList(replacementBeforeVowel), Arrays.asList(replacementDefault));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.<init>(String,String,String,String)","Constructor","No Comment","protected Rule(final String pattern, final String replacementAtStart, final String replacementBeforeVowel, final String replacementDefault) {
    this.pattern = pattern;
    this.replacementAtStart = replacementAtStart.split(""\\|"");
    this.replacementBeforeVowel = replacementBeforeVowel.split(""\\|"");
    this.replacementDefault = replacementDefault.split(""\\|"");
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.<init>(String,String,String,String).pattern","Parameter_1","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.<init>(String,String,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.<init>(String,String,String,String).replacementAtStart","Parameter_2","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.<init>(String,String,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.<init>(String,String,String,String).replacementBeforeVowel","Parameter_3","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.<init>(String,String,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.<init>(String,String,String,String).replacementDefault","Parameter_4","Belong to org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.<init>(String,String,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis","Class","* Encodes a string into a NYSIIS value. NYSIIS is an encoding used to relate similar names, but can also be used as a
 * general purpose scheme to find word with similar phonemes.
 * <p>
 * NYSIIS features an accuracy increase of 2.7% over the traditional Soundex algorithm.
 * </p>
 * <p>
 * Algorithm description:
 * </p>
 * <pre>
 * 1. Transcode first characters of name
 *   1a. MAC -&gt;   MCC
 *   1b. KN  -&gt;   NN
 *   1c. K   -&gt;   C
 *   1d. PH  -&gt;   FF
 *   1e. PF  -&gt;   FF
 *   1f. SCH -&gt;   SSS
 * 2. Transcode last characters of name
 *   2a. EE, IE          -&gt;   Y
 *   2b. DT,RT,RD,NT,ND  -&gt;   D
 * 3. First character of key = first character of name
 * 4. Transcode remaining characters by following these rules, incrementing by one character each time
 *   4a. EV  -&gt;   AF  else A,E,I,O,U -&gt; A
 *   4b. Q   -&gt;   G
 *   4c. Z   -&gt;   S
 *   4d. M   -&gt;   N
 *   4e. KN  -&gt;   N   else K -&gt; C
 *   4f. SCH -&gt;   SSS
 *   4g. PH  -&gt;   FF
 *   4h. H   -&gt;   If previous or next is non-vowel, previous
 *   4i. W   -&gt;   If previous is vowel, previous
 *   4j. Add current to key if current != last key character
 * 5. If last character is S, remove it
 * 6. If last characters are AY, replace with Y
 * 7. If last character is A, remove it
 * 8. Collapse all strings of repeated characters
 * 9. Add original first character of name as first character of key
 * </pre>
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @see <a href=""https://en.wikipedia.org/wiki/NYSIIS"">NYSIIS on Wikipedia</a>
 * @see <a href=""http://www.dropby.com/NYSIIS.html"">NYSIIS on dropby.com</a>
 * @see Soundex
 * @since 1.7","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.Nysiis.CHARS_A","Field","No Comment","private static final char[] CHARS_A = { 'A' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.CHARS_AF","Field","No Comment","private static final char[] CHARS_AF = { 'A', 'F' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.CHARS_C","Field","No Comment","private static final char[] CHARS_C = { 'C' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.CHARS_FF","Field","No Comment","private static final char[] CHARS_FF = { 'F', 'F' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.CHARS_G","Field","No Comment","private static final char[] CHARS_G = { 'G' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.CHARS_N","Field","No Comment","private static final char[] CHARS_N = { 'N' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.CHARS_NN","Field","No Comment","private static final char[] CHARS_NN = { 'N', 'N' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.CHARS_S","Field","No Comment","private static final char[] CHARS_S = { 'S' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.CHARS_SSS","Field","No Comment","private static final char[] CHARS_SSS = { 'S', 'S', 'S' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.PAT_MAC","Field","No Comment","private static final Pattern PAT_MAC = Pattern.compile(""^MAC"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.PAT_KN","Field","No Comment","private static final Pattern PAT_KN = Pattern.compile(""^KN"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.PAT_K","Field","No Comment","private static final Pattern PAT_K = Pattern.compile(""^K"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.PAT_PH_PF","Field","No Comment","private static final Pattern PAT_PH_PF = Pattern.compile(""^(PH|PF)"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.PAT_SCH","Field","No Comment","private static final Pattern PAT_SCH = Pattern.compile(""^SCH"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.PAT_EE_IE","Field","No Comment","private static final Pattern PAT_EE_IE = Pattern.compile(""(EE|IE)$"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.PAT_DT_ETC","Field","No Comment","private static final Pattern PAT_DT_ETC = Pattern.compile(""(DT|RT|RD|NT|ND)$"");","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.SPACE","Field","No Comment","private static final char SPACE = ' ';","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.TRUE_LENGTH","Field","No Comment","private static final int TRUE_LENGTH = 6;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.strict","Field","Indicates the strict mode.","private final boolean strict;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.isVowel(char)","Method","* Tests if the given character is a vowel.
     *
     * @param c
     *            the character to test
     * @return {@code true} if the character is a vowel, {@code false} otherwise","private static boolean isVowel(final char c) {
    return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
}","boolean","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.isVowel(char).c","Parameter_1","Belong to org.apache.commons.codec.language.Nysiis.isVowel(char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.transcodeRemaining(char,char,char,char)","Method","* Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at
     * a time: [i-1, i, i+1, i+2].
     *
     * @param prev
     *            the previous character
     * @param curr
     *            the current character
     * @param next
     *            the next character
     * @param aNext
     *            the after next character
     * @return a transcoded array of characters, starting from the current position","private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {
    // 1. EV -> AF
    if (curr == 'E' && next == 'V') {
        return CHARS_AF;
    }
    // A, E, I, O, U -> A
    if (isVowel(curr)) {
        return CHARS_A;
    }
    // 2. Q -> G, Z -> S, M -> N
    // 3. KN -> NN else K -> C
    switch(curr) {
        case 'Q':
            return CHARS_G;
        case 'Z':
            return CHARS_S;
        case 'M':
            return CHARS_N;
        case 'K':
            if (next == 'N') {
                return CHARS_NN;
            }
            return CHARS_C;
        default:
            break;
    }
    // 4. SCH -> SSS
    if (curr == 'S' && next == 'C' && aNext == 'H') {
        return CHARS_SSS;
    }
    // PH -> FF
    if (curr == 'P' && next == 'H') {
        return CHARS_FF;
    }
    // 5. H -> If previous or next is a non vowel, previous.
    if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) {
        return new char[] { prev };
    }
    // 6. W -> If previous is vowel, previous.
    if (curr == 'W' && isVowel(prev)) {
        return new char[] { prev };
    }
    return new char[] { curr };
}","char[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.transcodeRemaining(char,char,char,char).prev","Parameter_1","Belong to org.apache.commons.codec.language.Nysiis.transcodeRemaining(char,char,char,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.transcodeRemaining(char,char,char,char).curr","Parameter_2","Belong to org.apache.commons.codec.language.Nysiis.transcodeRemaining(char,char,char,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.transcodeRemaining(char,char,char,char).next","Parameter_3","Belong to org.apache.commons.codec.language.Nysiis.transcodeRemaining(char,char,char,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.transcodeRemaining(char,char,char,char).aNext","Parameter_4","Belong to org.apache.commons.codec.language.Nysiis.transcodeRemaining(char,char,char,char)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.encode(Object)","Method","* Encodes an Object using the NYSIIS algorithm. This method is provided in order to satisfy the requirements of the
     * Encoder interface, and will throw an {@link EncoderException} if the supplied object is not of type
     * {@link String}.
     *
     * @param obj
     *            Object to encode
     * @return An object (or a {@link String}) containing the NYSIIS code which corresponds to the given String.
     * @throws EncoderException
     *            if the parameter supplied is not of a {@link String}
     * @throws IllegalArgumentException
     *            if a character is not mapped","@Override
public Object encode(final Object obj) throws EncoderException {
    if (!(obj instanceof String)) {
        throw new EncoderException(""Parameter supplied to Nysiis encode is not of type java.lang.String"");
    }
    return nysiis((String) obj);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.language.Nysiis.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.encode(String)","Method","* Encodes a String using the NYSIIS algorithm.
     *
     * @param str
     *            A String object to encode
     * @return A Nysiis code corresponding to the String supplied
     * @throws IllegalArgumentException
     *            if a character is not mapped","@Override
public String encode(final String str) {
    return nysiis(str);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.encode(String).str","Parameter_1","Belong to org.apache.commons.codec.language.Nysiis.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.isStrict()","Method","* Indicates the strict mode for this {@link Nysiis} encoder.
     *
     * @return {@code true} if the encoder is configured for strict mode, {@code false} otherwise","public boolean isStrict() {
    return this.strict;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.nysiis(String)","Method","* Retrieves the NYSIIS code for a given String object.
     *
     * @param str
     *            String to encode using the NYSIIS algorithm
     * @return A NYSIIS code for the String supplied","public String nysiis(String str) {
    if (str == null) {
        return null;
    }
    // Use the same clean rules as Soundex
    str = SoundexUtils.clean(str);
    if (str.isEmpty()) {
        return str;
    }
    // Translate first characters of name:
    // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS
    str = PAT_MAC.matcher(str).replaceFirst(""MCC"");
    str = PAT_KN.matcher(str).replaceFirst(""NN"");
    str = PAT_K.matcher(str).replaceFirst(""C"");
    str = PAT_PH_PF.matcher(str).replaceFirst(""FF"");
    str = PAT_SCH.matcher(str).replaceFirst(""SSS"");
    // Translate last characters of name:
    // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D
    str = PAT_EE_IE.matcher(str).replaceFirst(""Y"");
    str = PAT_DT_ETC.matcher(str).replaceFirst(""D"");
    // First character of key = first character of name.
    final StringBuilder key = new StringBuilder(str.length());
    key.append(str.charAt(0));
    // Transcode remaining characters, incrementing by one character each time
    final char[] chars = str.toCharArray();
    final int len = chars.length;
    for (int i = 1; i < len; i++) {
        final char next = i < len - 1 ? chars[i + 1] : SPACE;
        final char aNext = i < len - 2 ? chars[i + 2] : SPACE;
        final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);
        System.arraycopy(transcoded, 0, chars, i, transcoded.length);
        // only append the current char to the key if it is different from the last one
        if (chars[i] != chars[i - 1]) {
            key.append(chars[i]);
        }
    }
    if (key.length() > 1) {
        char lastChar = key.charAt(key.length() - 1);
        // If last character is S, remove it.
        if (lastChar == 'S') {
            key.deleteCharAt(key.length() - 1);
            lastChar = key.charAt(key.length() - 1);
        }
        if (key.length() > 2) {
            final char last2Char = key.charAt(key.length() - 2);
            // If last characters are AY, replace with Y.
            if (last2Char == 'A' && lastChar == 'Y') {
                key.deleteCharAt(key.length() - 2);
            }
        }
        // If last character is A, remove it.
        if (lastChar == 'A') {
            key.deleteCharAt(key.length() - 1);
        }
    }
    final String string = key.toString();
    return isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.nysiis(String).str","Parameter_1","Belong to org.apache.commons.codec.language.Nysiis.nysiis(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.<init>()","Constructor","* Creates an instance of the {@link Nysiis} encoder with strict mode (original form),
     * i.e. encoded strings have a maximum length of 6.","public Nysiis() {
    this(true);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.<init>(boolean)","Constructor","* Create an instance of the {@link Nysiis} encoder with the specified strict mode:
     *
     * <ul>
     *  <li>{@code true}: encoded strings have a maximum length of 6</li>
     *  <li>{@code false}: encoded strings may have arbitrary length</li>
     * </ul>
     *
     * @param strict
     *            the strict mode","public Nysiis(final boolean strict) {
    this.strict = strict;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Nysiis.<init>(boolean).strict","Parameter_1","Belong to org.apache.commons.codec.language.Nysiis.<init>(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone","Class","* Encodes a string into a Caverphone 2.0 value. Delegate to a {@link Caverphone2} instance.
 *
 * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0
 * algorithm:
 *
 * @see <a href=""https://en.wikipedia.org/wiki/Caverphone"">Wikipedia - Caverphone</a>
 * @see <a href=""https://caversham.otago.ac.nz/files/working/ctp150804.pdf"">Caverphone 2.0 specification</a>
 * @since 1.4
 * @deprecated 1.5 Replaced by {@link Caverphone2}, will be removed in 2.0.","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.StringEncoder"
"org.apache.commons.codec.language.Caverphone.encoder","Field","* Delegate to a {@link Caverphone2} instance to avoid code duplication.","private final Caverphone2 encoder = new Caverphone2();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.caverphone(String)","Method","* Encodes the given String into a Caverphone value.
     *
     * @param source
     *            String the source string
     * @return A Caverphone code for the given String","public String caverphone(final String source) {
    return this.encoder.encode(source);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.caverphone(String).source","Parameter_1","Belong to org.apache.commons.codec.language.Caverphone.caverphone(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.encode(Object)","Method","* Encodes an Object using the Caverphone algorithm. This method is provided in order to satisfy the requirements of
     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type {@link String}.
     *
     * @param obj
     *            Object to encode
     * @return An object (or type {@link String}) containing the Caverphone code which corresponds to the String
     *         supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type {@link String}.","@Override
public Object encode(final Object obj) throws EncoderException {
    if (!(obj instanceof String)) {
        throw new EncoderException(""Parameter supplied to Caverphone encode is not of type java.lang.String"");
    }
    return caverphone((String) obj);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.language.Caverphone.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.encode(String)","Method","* Encodes a String using the Caverphone algorithm.
     *
     * @param str
     *            String object to encode
     * @return The Caverphone code corresponding to the String supplied","@Override
public String encode(final String str) {
    return caverphone(str);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.encode(String).str","Parameter_1","Belong to org.apache.commons.codec.language.Caverphone.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.isCaverphoneEqual(String,String)","Method","* Tests if the Caverphones of two strings are identical.
     *
     * @param str1
     *            First of two strings to compare
     * @param str2
     *            Second of two strings to compare
     * @return {@code true} if the Caverphones of these strings are identical, {@code false} otherwise.","public boolean isCaverphoneEqual(final String str1, final String str2) {
    return caverphone(str1).equals(caverphone(str2));
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.isCaverphoneEqual(String,String).str1","Parameter_1","Belong to org.apache.commons.codec.language.Caverphone.isCaverphoneEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.isCaverphoneEqual(String,String).str2","Parameter_2","Belong to org.apache.commons.codec.language.Caverphone.isCaverphoneEqual(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone.<init>()","Constructor","* Constructs a new instance.","public Caverphone() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone1","Class","* Encodes a string into a Caverphone 1.0 value.
 *
 * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 1.0
 * algorithm:
 *
 * @see <a href=""https://en.wikipedia.org/wiki/Caverphone"">Wikipedia - Caverphone</a>
 * @see <a href=""https://caversham.otago.ac.nz/files/working/ctp060902.pdf"">Caverphone 1.0 specification</a>
 * @since 1.5
 *
 * <p>This class is immutable and thread-safe.</p>","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.language.AbstractCaverphone",""
"org.apache.commons.codec.language.Caverphone1.SIX_1","Field","No Comment","private static final String SIX_1 = ""111111"";","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone1.encode(String)","Method","* Encodes the given String into a Caverphone value.
     *
     * @param source
     *            String the source string
     * @return A Caverphone code for the given String","@Override
public String encode(final String source) {
    String txt = source;
    if (txt == null || txt.isEmpty()) {
        return SIX_1;
    }
    // 1. Convert to lowercase
    txt = txt.toLowerCase(java.util.Locale.ENGLISH);
    // 2. Remove anything not A-Z
    txt = txt.replaceAll(""[^a-z]"", """");
    // 3. Handle various start options
    // 2 is a temporary placeholder to indicate a consonant which we are no longer interested in.
    txt = txt.replaceAll(""^cough"", ""cou2f"");
    txt = txt.replaceAll(""^rough"", ""rou2f"");
    txt = txt.replaceAll(""^tough"", ""tou2f"");
    txt = txt.replaceAll(""^enough"", ""enou2f"");
    txt = txt.replaceAll(""^gn"", ""2n"");
    // End
    txt = txt.replaceAll(""mb$"", ""m2"");
    // 4. Handle replacements
    txt = txt.replace(""cq"", ""2q"");
    txt = txt.replace(""ci"", ""si"");
    txt = txt.replace(""ce"", ""se"");
    txt = txt.replace(""cy"", ""sy"");
    txt = txt.replace(""tch"", ""2ch"");
    txt = txt.replace(""c"", ""k"");
    txt = txt.replace(""q"", ""k"");
    txt = txt.replace(""x"", ""k"");
    txt = txt.replace(""v"", ""f"");
    txt = txt.replace(""dg"", ""2g"");
    txt = txt.replace(""tio"", ""sio"");
    txt = txt.replace(""tia"", ""sia"");
    txt = txt.replace(""d"", ""t"");
    txt = txt.replace(""ph"", ""fh"");
    txt = txt.replace(""b"", ""p"");
    txt = txt.replace(""sh"", ""s2"");
    txt = txt.replace(""z"", ""s"");
    txt = txt.replaceAll(""^[aeiou]"", ""A"");
    // 3 is a temporary placeholder marking a vowel
    txt = txt.replaceAll(""[aeiou]"", ""3"");
    txt = txt.replace(""3gh3"", ""3kh3"");
    txt = txt.replace(""gh"", ""22"");
    txt = txt.replace(""g"", ""k"");
    txt = txt.replaceAll(""s+"", ""S"");
    txt = txt.replaceAll(""t+"", ""T"");
    txt = txt.replaceAll(""p+"", ""P"");
    txt = txt.replaceAll(""k+"", ""K"");
    txt = txt.replaceAll(""f+"", ""F"");
    txt = txt.replaceAll(""m+"", ""M"");
    txt = txt.replaceAll(""n+"", ""N"");
    txt = txt.replace(""w3"", ""W3"");
    // 1.0 only
    txt = txt.replace(""wy"", ""Wy"");
    txt = txt.replace(""wh3"", ""Wh3"");
    // 1.0 only
    txt = txt.replace(""why"", ""Why"");
    txt = txt.replace(""w"", ""2"");
    txt = txt.replaceAll(""^h"", ""A"");
    txt = txt.replace(""h"", ""2"");
    txt = txt.replace(""r3"", ""R3"");
    // 1.0 only
    txt = txt.replace(""ry"", ""Ry"");
    txt = txt.replace(""r"", ""2"");
    txt = txt.replace(""l3"", ""L3"");
    // 1.0 only
    txt = txt.replace(""ly"", ""Ly"");
    txt = txt.replace(""l"", ""2"");
    // 1.0 only
    txt = txt.replace(""j"", ""y"");
    // 1.0 only
    txt = txt.replace(""y3"", ""Y3"");
    // 1.0 only
    txt = txt.replace(""y"", ""2"");
    // 5. Handle removals
    txt = txt.replace(""2"", """");
    txt = txt.replace(""3"", """");
    // 6. put six 1s on the end
    txt += SIX_1;
    // 7. take the first six characters as the code
    return txt.substring(0, SIX_1.length());
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone1.encode(String).source","Parameter_1","Belong to org.apache.commons.codec.language.Caverphone1.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.Caverphone1.<init>()","Constructor","* Constructs a new instance.","public Caverphone1() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils","Class","* Utility methods for {@link Soundex} and {@link RefinedSoundex} classes.
 *
 * <p>This class is immutable and thread-safe.</p>
 *
 * @since 1.3","Class do not obtain Source Code","No return type","final ","",""
"org.apache.commons.codec.language.SoundexUtils.clean(String)","Method","* Cleans up the input string before Soundex processing by only returning
     * upper case letters.
     *
     * @param str
     *                  The String to clean.
     * @return A clean String.","static String clean(final String str) {
    if (isEmpty(str)) {
        return str;
    }
    final int len = str.length();
    final char[] chars = new char[len];
    int count = 0;
    for (int i = 0; i < len; i++) {
        if (Character.isLetter(str.charAt(i))) {
            chars[count++] = str.charAt(i);
        }
    }
    if (count == len) {
        return str.toUpperCase(java.util.Locale.ENGLISH);
    }
    return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);
}","String","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.clean(String).str","Parameter_1","Belong to org.apache.commons.codec.language.SoundexUtils.clean(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.difference(StringEncoder,String,String)","Method","* Encodes the Strings and returns the number of characters in the two
     * encoded Strings that are the same.
     * <ul>
     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates
     * little or no similarity, and 4 indicates strong similarity or identical
     * values.</li>
     * <li>For refined Soundex, the return value can be greater than 4.</li>
     * </ul>
     *
     * @param encoder
     *                  The encoder to use to encode the Strings.
     * @param s1
     *                  A String that will be encoded and compared.
     * @param s2
     *                  A String that will be encoded and compared.
     * @return The number of characters in the two Soundex encoded Strings that
     *             are the same.
     *
     * @see #differenceEncoded(String,String)
     * @see <a href=""https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp"">
     *          MS T-SQL DIFFERENCE</a>
     *
     * @throws EncoderException
     *                  if an error occurs encoding one of the strings","static int difference(final StringEncoder encoder, final String s1, final String s2) throws EncoderException {
    return differenceEncoded(encoder.encode(s1), encoder.encode(s2));
}","int","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.difference(StringEncoder,String,String).encoder","Parameter_1","Belong to org.apache.commons.codec.language.SoundexUtils.difference(StringEncoder,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.difference(StringEncoder,String,String).s1","Parameter_2","Belong to org.apache.commons.codec.language.SoundexUtils.difference(StringEncoder,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.difference(StringEncoder,String,String).s2","Parameter_3","Belong to org.apache.commons.codec.language.SoundexUtils.difference(StringEncoder,String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.differenceEncoded(String,String)","Method","* Returns the number of characters in the two Soundex encoded Strings that
     * are the same.
     * <ul>
     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates
     * little or no similarity, and 4 indicates strong similarity or identical
     * values.</li>
     * <li>For refined Soundex, the return value can be greater than 4.</li>
     * </ul>
     *
     * @param es1
     *                  An encoded String.
     * @param es2
     *                  An encoded String.
     * @return The number of characters in the two Soundex encoded Strings that
     *             are the same.
     *
     * @see <a href=""https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp"">
     *          MS T-SQL DIFFERENCE</a>","static int differenceEncoded(final String es1, final String es2) {
    if (es1 == null || es2 == null) {
        return 0;
    }
    final int lengthToMatch = Math.min(es1.length(), es2.length());
    int diff = 0;
    for (int i = 0; i < lengthToMatch; i++) {
        if (es1.charAt(i) == es2.charAt(i)) {
            diff++;
        }
    }
    return diff;
}","int","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.differenceEncoded(String,String).es1","Parameter_1","Belong to org.apache.commons.codec.language.SoundexUtils.differenceEncoded(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.differenceEncoded(String,String).es2","Parameter_2","Belong to org.apache.commons.codec.language.SoundexUtils.differenceEncoded(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.isEmpty(CharSequence)","Method","* <p>Checks if a CharSequence is empty ("""") or null.</p>
     *
     * <pre>
     * StringUtils.isEmpty(null)      = true
     * StringUtils.isEmpty("""")        = true
     * StringUtils.isEmpty("" "")       = false
     * StringUtils.isEmpty(""bob"")     = false
     * StringUtils.isEmpty(""  bob  "") = false
     * </pre>
     *
     * @param cs  the CharSequence to check, may be null
     * @return {@code true} if the CharSequence is empty or null","static boolean isEmpty(final CharSequence cs) {
    return cs == null || cs.length() == 0;
}","boolean","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.language.SoundexUtils.isEmpty(CharSequence).cs","Parameter_1","Belong to org.apache.commons.codec.language.SoundexUtils.isEmpty(CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest","Class","* A minimal command line to run digest over files, directories or a string.
 *
 * @see #main(String[])
 * @since 1.11","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.cli.Digest.algorithm","Field","No Comment","private final String algorithm;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.args","Field","No Comment","private final String[] args;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.inputs","Field","No Comment","private final String[] inputs;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.main(String[])","Method","* Runs the digest algorithm in {@code args[0]} on the file in {@code args[1]}. If there is no {@code args[1]}, use
     * standard input.
     *
     * <p>
     * The algorithm can also be {@code ALL} or {@code *} to output one line for each known algorithm.
     * </p>
     *
     * @param args
     *            {@code args[0]} is one of {@link MessageDigestAlgorithms} name,
     *            {@link MessageDigest} name, {@code ALL}, or {@code *}.
     *            {@code args[1+]} is a FILE/DIRECTORY/String.
     * @throws IOException if an error occurs","public static void main(final String[] args) throws IOException {
    new Digest(args).run();
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.main(String[]).args","Parameter_1","Belong to org.apache.commons.codec.cli.Digest.main(String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.println(String,byte[])","Method","No Comment","private void println(final String prefix, final byte[] digest) {
    println(prefix, digest, null);
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.println(String,byte[]).prefix","Parameter_1","Belong to org.apache.commons.codec.cli.Digest.println(String,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.println(String,byte[]).digest","Parameter_2","Belong to org.apache.commons.codec.cli.Digest.println(String,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.println(String,byte[],String)","Method","No Comment","private void println(final String prefix, final byte[] digest, final String fileName) {
    // The standard appears to be to print
    // hex, space, then either space or '*' followed by file name
    // where '*' is used for binary files
    // shasum(1) has a -b option which generates "" *"" separator
    // we don't distinguish binary files at present
    System.out.println(prefix + Hex.encodeHexString(digest) + (fileName != null ? ""  "" + fileName : """"));
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.println(String,byte[],String).prefix","Parameter_1","Belong to org.apache.commons.codec.cli.Digest.println(String,byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.println(String,byte[],String).digest","Parameter_2","Belong to org.apache.commons.codec.cli.Digest.println(String,byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.println(String,byte[],String).fileName","Parameter_3","Belong to org.apache.commons.codec.cli.Digest.println(String,byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run()","Method","No Comment","private void run() throws IOException {
    if (algorithm.equalsIgnoreCase(""ALL"") || algorithm.equals(""*"")) {
        run(MessageDigestAlgorithms.values());
        return;
    }
    final MessageDigest messageDigest = DigestUtils.getDigest(algorithm, null);
    if (messageDigest != null) {
        run("""", messageDigest);
    } else {
        run("""", DigestUtils.getDigest(algorithm.toUpperCase(Locale.ROOT)));
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,MessageDigest)","Method","No Comment","private void run(final String prefix, final MessageDigest messageDigest) throws IOException {
    if (inputs == null) {
        println(prefix, DigestUtils.digest(messageDigest, System.in));
        return;
    }
    for (final String source : inputs) {
        final File file = new File(source);
        if (file.isFile()) {
            println(prefix, DigestUtils.digest(messageDigest, file), source);
        } else if (file.isDirectory()) {
            final File[] listFiles = file.listFiles();
            if (listFiles != null) {
                run(prefix, messageDigest, listFiles);
            }
        } else {
            // use the default charset for the command-line parameter
            final byte[] bytes = source.getBytes(Charset.defaultCharset());
            println(prefix, DigestUtils.digest(messageDigest, bytes));
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,MessageDigest).prefix","Parameter_1","Belong to org.apache.commons.codec.cli.Digest.run(String,MessageDigest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,MessageDigest).messageDigest","Parameter_2","Belong to org.apache.commons.codec.cli.Digest.run(String,MessageDigest)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,MessageDigest,File[])","Method","No Comment","private void run(final String prefix, final MessageDigest messageDigest, final File[] files) throws IOException {
    for (final File file : files) {
        if (file.isFile()) {
            println(prefix, DigestUtils.digest(messageDigest, file), file.getName());
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,MessageDigest,File[]).prefix","Parameter_1","Belong to org.apache.commons.codec.cli.Digest.run(String,MessageDigest,File[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,MessageDigest,File[]).messageDigest","Parameter_2","Belong to org.apache.commons.codec.cli.Digest.run(String,MessageDigest,File[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,MessageDigest,File[]).files","Parameter_3","Belong to org.apache.commons.codec.cli.Digest.run(String,MessageDigest,File[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,String)","Method","No Comment","private void run(final String prefix, final String messageDigestAlgorithm) throws IOException {
    run(prefix, DigestUtils.getDigest(messageDigestAlgorithm));
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,String).prefix","Parameter_1","Belong to org.apache.commons.codec.cli.Digest.run(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String,String).messageDigestAlgorithm","Parameter_2","Belong to org.apache.commons.codec.cli.Digest.run(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String[])","Method","No Comment","private void run(final String[] digestAlgorithms) throws IOException {
    for (final String messageDigestAlgorithm : digestAlgorithms) {
        if (DigestUtils.isAvailable(messageDigestAlgorithm)) {
            run(messageDigestAlgorithm + "" "", messageDigestAlgorithm);
        }
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.run(String[]).digestAlgorithms","Parameter_1","Belong to org.apache.commons.codec.cli.Digest.run(String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.toString()","Method","No Comment","@Override
public String toString() {
    return String.format(""%s %s"", super.toString(), Arrays.toString(args));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.<init>(String[])","Constructor","No Comment","private Digest(final String[] args) {
    Objects.requireNonNull(args);
    final int argsLength = args.length;
    if (argsLength == 0) {
        throw new IllegalArgumentException(String.format(""Usage: java %s [algorithm] [FILE|DIRECTORY|string] ..."", Digest.class.getName()));
    }
    this.args = args;
    this.algorithm = args[0];
    if (argsLength <= 1) {
        this.inputs = null;
    } else {
        this.inputs = Arrays.copyOfRange(args, 1, argsLength);
    }
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.cli.Digest.<init>(String[]).args","Parameter_1","Belong to org.apache.commons.codec.cli.Digest.<init>(String[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Resources","Class","* Consider this class package private. Helps load resources.
 *
 * @since 1.12","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.Resources.getInputStream(String)","Method","* Gets a read-only stream on the contents of the resource specified by resName. The mapping between the resource name and the stream is managed by this
     * class's class loader.
     *
     * @param name The resource name.
     * @return An input stream.
     * @see ClassLoader#getResourceAsStream(String)","public static InputStream getInputStream(final String name) {
    // Use java.lang.Class.getResourceAsStream(String) to make JPMS happy
    final InputStream inputStream = Resources.class.getResourceAsStream(name);
    if (inputStream == null) {
        throw new IllegalArgumentException(""Unable to resolve required resource: "" + name);
    }
    return inputStream;
}","InputStream","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Resources.getInputStream(String).name","Parameter_1","Belong to org.apache.commons.codec.Resources.getInputStream(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Resources.<init>()","Constructor","* TODO Make private in 2.0.
     *
     * @deprecated TODO Make private in 2.0.","@Deprecated
public Resources() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.CharEncoding","Class","* Character encoding names required of every implementation of the Java platform.
 *
 * From the Java documentation for {@link Charset}:
 * <p>
 * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the
 * release documentation for your implementation to see if any other encodings are supported. Consult the release
 * documentation for your implementation to see if any other encodings are supported.</cite>
 * </p>
 *
 * <ul>
 * <li>{@code US-ASCII}<p>
 * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</p></li>
 * <li>{@code ISO-8859-1}<p>
 * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</p></li>
 * <li>{@code UTF-8}<p>
 * Eight-bit Unicode Transformation Format.</p></li>
 * <li>{@code UTF-16BE}<p>
 * Sixteen-bit Unicode Transformation Format, big-endian byte order.</p></li>
 * <li>{@code UTF-16LE}<p>
 * Sixteen-bit Unicode Transformation Format, little-endian byte order.</p></li>
 * <li>{@code UTF-16}<p>
 * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order
 * accepted on input, big-endian used on output.)</p></li>
 * </ul>
 *
 * This perhaps would best belong in the [lang] project. Even if a similar interface is defined in [lang], it is not
 * foreseen that [codec] would be made to depend on [lang].
 *
 * <p>
 * This class is immutable and thread-safe.
 * </p>
 *
 * @see Charset
 * @since 1.4","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.CharEncoding.ISO_8859_1","Field","* CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @see Charset","public static final String ISO_8859_1 = StandardCharsets.ISO_8859_1.name();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.CharEncoding.US_ASCII","Field","* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @see Charset","public static final String US_ASCII = StandardCharsets.US_ASCII.name();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.CharEncoding.UTF_16","Field","* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark
     * (either order accepted on input, big-endian used on output)
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @see Charset","public static final String UTF_16 = StandardCharsets.UTF_16.name();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.CharEncoding.UTF_16BE","Field","* Sixteen-bit Unicode Transformation Format, big-endian byte order.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @see Charset","public static final String UTF_16BE = StandardCharsets.UTF_16BE.name();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.CharEncoding.UTF_16LE","Field","* Sixteen-bit Unicode Transformation Format, little-endian byte order.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @see Charset","public static final String UTF_16LE = StandardCharsets.UTF_16LE.name();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.CharEncoding.UTF_8","Field","* Eight-bit Unicode Transformation Format.
     * <p>
     * Every implementation of the Java platform is required to support this character encoding.
     * </p>
     *
     * @see Charset","public static final String UTF_8 = StandardCharsets.UTF_8.name();","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.CharEncoding.<init>()","Constructor","* TODO Make private in 2.0.
     *
     * @deprecated TODO Make private in 2.0.","@Deprecated
public CharEncoding() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.BinaryEncoder","Interface","* Defines common encoding methods for byte array encoders.","Interface do not obtain Source Code","No return type","public ","org.apache.commons.codec.Encoder",""
"org.apache.commons.codec.BinaryEncoder.encode(byte[])","Abstract Method","* Encodes a byte array and return the encoded data as a byte array.
     *
     * @param source
     *            Data to be encoded
     * @return A byte array containing the encoded data
     * @throws EncoderException
     *             thrown if the Encoder encounters a failure condition during the encoding process.","byte[] encode(byte[] source) throws EncoderException;","byte[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.BinaryEncoder.encode(byte[]).source","Parameter_1","Belong to org.apache.commons.codec.BinaryEncoder.encode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringEncoderComparator","Class","* Compares Strings using a {@link StringEncoder}. This comparator is used to sort Strings by an encoding scheme such as
 * Soundex, Metaphone, etc. This class can come in handy if one need to sort Strings by an encoded form of a name such
 * as Soundex.
 *
 * <p>This class is immutable and thread-safe.</p>","Class do not obtain Source Code","No return type","public ","","java.util.Comparator"
"org.apache.commons.codec.StringEncoderComparator.stringEncoder","Field","* Internal encoder instance.","private final StringEncoder stringEncoder;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringEncoderComparator.compare(Object,Object)","Method","* Compares two strings based not on the strings themselves, but on an encoding of the two strings using the
     * StringEncoder this Comparator was created with.
     *
     * If an {@link EncoderException} is encountered, return {@code 0}.
     *
     * @param o1
     *            the object to compare
     * @param o2
     *            the object to compare to
     * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.
     * @see Comparable","@Override
public int compare(final Object o1, final Object o2) {
    int compareCode = 0;
    try {
        // May fail with CCE if encode returns something that is not Comparable
        @SuppressWarnings(""unchecked"")
        final Comparable<Comparable<?>> // However this was always the case.
        s1 = (Comparable<Comparable<?>>) this.stringEncoder.encode(o1);
        final Comparable<?> s2 = (Comparable<?>) this.stringEncoder.encode(o2);
        compareCode = s1.compareTo(s2);
    } catch (final EncoderException ee) {
        compareCode = 0;
    }
    return compareCode;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringEncoderComparator.compare(Object,Object).o1","Parameter_1","Belong to org.apache.commons.codec.StringEncoderComparator.compare(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringEncoderComparator.compare(Object,Object).o2","Parameter_2","Belong to org.apache.commons.codec.StringEncoderComparator.compare(Object,Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringEncoderComparator.<init>()","Constructor","* Constructs a new instance.
     *
     * @deprecated Creating an instance without a {@link StringEncoder} leads to a {@link NullPointerException}. Will be
     *             removed in 2.0.","@Deprecated
public StringEncoderComparator() {
    // Trying to use this will cause things to break
    this.stringEncoder = null;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringEncoderComparator.<init>(StringEncoder)","Constructor","* Constructs a new instance with the given algorithm.
     *
     * @param stringEncoder
     *            the StringEncoder used for comparisons.","public StringEncoderComparator(final StringEncoder stringEncoder) {
    this.stringEncoder = stringEncoder;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringEncoderComparator.<init>(StringEncoder).stringEncoder","Parameter_1","Belong to org.apache.commons.codec.StringEncoderComparator.<init>(StringEncoder)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream","Class","* Provides Base64 encoding in a streaming fashion (unlimited size). When encoding the default lineLength
 * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate
 * constructor.
 * <p>
 * The default behavior of the Base64OutputStream is to ENCODE, whereas the default behavior of the Base64InputStream
 * is to DECODE. But this behavior can be overridden by using a different constructor.
 * </p>
 * <p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 * <p>
 * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
 * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
 * </p>
 * <p>
 * <strong>Note:</strong> It is mandatory to close the stream after the last byte has been written to it, otherwise the
 * final padding will be omitted and the resulting data will be incomplete/inconsistent.
 * </p>
 * <p>
 * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a
 * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is
 * lenient decoding.
 * </p>
 * <ul>
 * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.
 * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid
 * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not
 * allowed.
 * </ul>
 * <p>
 * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches
 * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding
 * and alphabet as the encoder.
 * </p>
 * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>
 * @since 1.4","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.binary.BaseNCodecOutputStream",""
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream)","Constructor","* Constructs a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.
     *
     * @param outputStream
     *            OutputStream to wrap.","public Base64OutputStream(final OutputStream outputStream) {
    this(outputStream, true);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean)","Constructor","* Constructs a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the
     * original provided OutputStream.
     *
     * @param outputStream
     *            OutputStream to wrap.
     * @param doEncode
     *            true if we should encode all data written to us, false if we should decode.","public Base64OutputStream(final OutputStream outputStream, final boolean doEncode) {
    super(outputStream, new Base64(false), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[])","Constructor","* Constructs a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the
     * original provided OutputStream.
     *
     * @param outputStream
     *            OutputStream to wrap.
     * @param doEncode
     *            true if we should encode all data written to us, false if we should decode.
     * @param lineLength
     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If
     *            doEncode is false, lineLength is ignored.
     * @param lineSeparator
     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (for example \r\n).
     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.","public Base64OutputStream(final OutputStream outputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {
    super(outputStream, new Base64(lineLength, lineSeparator), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[]).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[]).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[]).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[]).lineSeparator","Parameter_4","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Constructor","* Constructs a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the
     * original provided OutputStream.
     *
     * @param outputStream
     *            OutputStream to wrap.
     * @param doEncode
     *            true if we should encode all data written to us, false if we should decode.
     * @param lineLength
     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If
     *            doEncode is false, lineLength is ignored.
     * @param lineSeparator
     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (for example \r\n).
     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.
     * @param decodingPolicy The decoding policy.
     * @since 1.15","public Base64OutputStream(final OutputStream outputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator, final CodecPolicy decodingPolicy) {
    super(outputStream, new Base64(lineLength, lineSeparator, false, decodingPolicy), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).lineSeparator","Parameter_4","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).decodingPolicy","Parameter_5","Belong to org.apache.commons.codec.binary.Base64OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32","Class","* Provides Base32 encoding and decoding as defined by <a href=""http://www.ietf.org/rfc/rfc4648.txt"">RFC 4648</a>.
 *
 * <p>
 * The class can be parameterized in the following manner with various constructors:
 * </p>
 * <ul>
 * <li>Whether to use the ""base32hex"" variant instead of the default ""base32""</li>
 * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
 * <li>Line separator: Default is CRLF (""\r\n"")</li>
 * </ul>
 * <p>
 * This class operates directly on byte streams, and not character streams.
 * </p>
 * <p>
 * This class is thread-safe.
 * </p>
 * <p>
 * You can configure instances with the {@link Builder}.
 * </p>
 * <pre>
 * Base32 base32 = Base32.builder()
 *   .setDecodingPolicy(DecodingPolicy.LENIENT) // default is lenient
 *   .setEncodeTable(customEncodeTable)
 *   .setLineLength(0)                          // default is none
 *   .setLineSeparator('\r', '\n')              // default is CR LF
 *   .setPadding('=')                           // default is =
 *   .get()
 * </pre>
 *
 * @see <a href=""http://www.ietf.org/rfc/rfc4648.txt"">RFC 4648</a>
 * @since 1.5","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.binary.BaseNCodec",""
"org.apache.commons.codec.binary.Base32.BITS_PER_ENCODED_BYTE","Field","* BASE32 characters are 5 bits in length. They are formed by taking a block of five octets to form a 40-bit string, which is converted into eight BASE32
     * characters.","private static final int BITS_PER_ENCODED_BYTE = 5;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.BYTES_PER_ENCODED_BLOCK","Field","No Comment","private static final int BYTES_PER_ENCODED_BLOCK = 8;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.BYTES_PER_UNENCODED_BLOCK","Field","No Comment","private static final int BYTES_PER_UNENCODED_BLOCK = 5;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.DECODE_TABLE","Field","@formatter:off","private static final byte[] DECODE_TABLE = { //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
// 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 30-3f 2-7
-1, // 30-3f 2-7
-1, // 30-3f 2-7
26, // 30-3f 2-7
27, // 30-3f 2-7
28, // 30-3f 2-7
29, // 30-3f 2-7
30, // 30-3f 2-7
31, // 30-3f 2-7
-1, // 30-3f 2-7
-1, // 30-3f 2-7
-1, // 30-3f 2-7
-1, // 30-3f 2-7
-1, // 30-3f 2-7
-1, // 30-3f 2-7
-1, // 30-3f 2-7
-1, // 40-4f A-O
-1, // 40-4f A-O
0, // 40-4f A-O
1, // 40-4f A-O
2, // 40-4f A-O
3, // 40-4f A-O
4, // 40-4f A-O
5, // 40-4f A-O
6, // 40-4f A-O
7, // 40-4f A-O
8, // 40-4f A-O
9, // 40-4f A-O
10, // 40-4f A-O
11, // 40-4f A-O
12, // 40-4f A-O
13, // 40-4f A-O
14, // 50-5a P-Z
15, // 50-5a P-Z
16, // 50-5a P-Z
17, // 50-5a P-Z
18, // 50-5a P-Z
19, // 50-5a P-Z
20, // 50-5a P-Z
21, // 50-5a P-Z
22, // 50-5a P-Z
23, // 50-5a P-Z
24, // 50-5a P-Z
25, // 5b-5f
-1, // 5b-5f
-1, // 5b-5f
-1, // 5b-5f
-1, // 5b-5f
-1, // 60-6f a-o
-1, // 60-6f a-o
0, // 60-6f a-o
1, // 60-6f a-o
2, // 60-6f a-o
3, // 60-6f a-o
4, // 60-6f a-o
5, // 60-6f a-o
6, // 60-6f a-o
7, // 60-6f a-o
8, // 60-6f a-o
9, // 60-6f a-o
10, // 60-6f a-o
11, // 60-6f a-o
12, // 60-6f a-o
13, // 60-6f a-o
14, // 70-7a p-z
15, // 70-7a p-z
16, // 70-7a p-z
17, // 70-7a p-z
18, // 70-7a p-z
19, // 70-7a p-z
20, // 70-7a p-z
21, // 70-7a p-z
22, // 70-7a p-z
23, // 70-7a p-z
24, // 70-7a p-z
25 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.ENCODE_TABLE","Field","@formatter:off","private static final byte[] ENCODE_TABLE = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '2', '3', '4', '5', '6', '7' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.HEX_DECODE_TABLE","Field","@formatter:off","private static final byte[] HEX_DECODE_TABLE = { //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
// 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 30-3f 0-9
0, // 30-3f 0-9
1, // 30-3f 0-9
2, // 30-3f 0-9
3, // 30-3f 0-9
4, // 30-3f 0-9
5, // 30-3f 0-9
6, // 30-3f 0-9
7, // 30-3f 0-9
8, // 30-3f 0-9
9, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 40-4f A-O
-1, // 40-4f A-O
10, // 40-4f A-O
11, // 40-4f A-O
12, // 40-4f A-O
13, // 40-4f A-O
14, // 40-4f A-O
15, // 40-4f A-O
16, // 40-4f A-O
17, // 40-4f A-O
18, // 40-4f A-O
19, // 40-4f A-O
20, // 40-4f A-O
21, // 40-4f A-O
22, // 40-4f A-O
23, // 40-4f A-O
24, // 50-56 P-V
25, // 50-56 P-V
26, // 50-56 P-V
27, // 50-56 P-V
28, // 50-56 P-V
29, // 50-56 P-V
30, // 50-56 P-V
31, // 57-5f
-1, // 57-5f
-1, // 57-5f
-1, // 57-5f
-1, // 57-5f
-1, // 57-5f
-1, // 57-5f
-1, // 57-5f
-1, // 57-5f
-1, // 60-6f a-o
-1, // 60-6f a-o
10, // 60-6f a-o
11, // 60-6f a-o
12, // 60-6f a-o
13, // 60-6f a-o
14, // 60-6f a-o
15, // 60-6f a-o
16, // 60-6f a-o
17, // 60-6f a-o
18, // 60-6f a-o
19, // 60-6f a-o
20, // 60-6f a-o
21, // 60-6f a-o
22, // 60-6f a-o
23, // 60-6f a-o
24, // 70-76 p-v
25, // 70-76 p-v
26, // 70-76 p-v
27, // 70-76 p-v
28, // 70-76 p-v
29, // 70-76 p-v
30, // 70-76 p-v
31 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.HEX_ENCODE_TABLE","Field","@formatter:off","private static final byte[] HEX_ENCODE_TABLE = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.MASK_5BITS","Field","Mask used to extract 5 bits, used when encoding Base32 bytes","private static final int MASK_5BITS = 0x1f;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.MASK_4BITS","Field","Mask used to extract 4 bits, used when decoding final trailing character.","private static final long MASK_4BITS = 0x0fL;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.MASK_3BITS","Field","Mask used to extract 3 bits, used when decoding final trailing character.","private static final long MASK_3BITS = 0x07L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.MASK_2BITS","Field","Mask used to extract 2 bits, used when decoding final trailing character.","private static final long MASK_2BITS = 0x03L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.MASK_1BITS","Field","Mask used to extract 1 bits, used when decoding final trailing character.","private static final long MASK_1BITS = 0x01L;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.decodeTable","Field","* Decode table to use.","private final byte[] decodeTable;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.encodeSize","Field","* Convenience variable to help us determine when our buffer is going to run out of room and needs resizing. {@code encodeSize = {@link
     * #BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;}","private final int encodeSize;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.encodeTable","Field","* Encode table to use.","private final byte[] encodeTable;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.lineSeparator","Field","* Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.","private final byte[] lineSeparator;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.builder()","Method","* Creates a new Builder.
     *
     * @return a new Builder.
     * @since 1.17.0","public static Builder builder() {
    return new Builder();
}","Builder","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.decodeTable(boolean)","Method","No Comment","private static byte[] decodeTable(final boolean useHex) {
    return useHex ? HEX_DECODE_TABLE : DECODE_TABLE;
}","byte[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.decodeTable(boolean).useHex","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.decodeTable(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.encodeTable(boolean)","Method","No Comment","private static byte[] encodeTable(final boolean useHex) {
    return useHex ? HEX_ENCODE_TABLE : ENCODE_TABLE;
}","byte[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.encodeTable(boolean).useHex","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.encodeTable(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.decode(byte[],int,int,Context)","Method","* <p>
     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once with the data to decode, and once with
     * inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1"" call is not necessary when decoding, but it doesn't hurt, either.
     * </p>
     * <p>
     * Ignores all non-Base32 characters. This is how chunked (for example 76 character) data is handled, since CR and LF are silently ignored, but has implications
     * for other bytes, too. This method subscribes to the garbage-in, garbage-out philosophy: it will not check the provided data for validity.
     * </p>
     * <p>
     * Output is written to {@link org.apache.commons.codec.binary.BaseNCodec.Context#buffer Context#buffer} as 8-bit octets, using
     * {@link org.apache.commons.codec.binary.BaseNCodec.Context#pos Context#pos} as the buffer position
     * </p>
     *
     * @param input   byte[] array of ASCII data to Base32 decode.
     * @param inPos   Position to start reading data from.
     * @param inAvail Amount of bytes available from input for decoding.
     * @param context the context to be used","@Override
void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    if (inAvail < 0) {
        context.eof = true;
    }
    final int decodeSize = this.encodeSize - 1;
    for (int i = 0; i < inAvail; i++) {
        final byte b = input[inPos++];
        if (b == pad) {
            // We're done.
            context.eof = true;
            break;
        }
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        if (b >= 0 && b < this.decodeTable.length) {
            final int result = this.decodeTable[b];
            if (result >= 0) {
                context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
                // collect decoded bytes
                context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;
                if (context.modulus == 0) {
                    // we can output the 5 bytes
                    buffer[context.pos++] = (byte) (context.lbitWorkArea >> 32 & MASK_8BITS);
                    buffer[context.pos++] = (byte) (context.lbitWorkArea >> 24 & MASK_8BITS);
                    buffer[context.pos++] = (byte) (context.lbitWorkArea >> 16 & MASK_8BITS);
                    buffer[context.pos++] = (byte) (context.lbitWorkArea >> 8 & MASK_8BITS);
                    buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                }
            }
        }
    }
    // Two forms of EOF as far as Base32 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (context.eof && context.modulus > 0) {
        // if modulus == 0, nothing to do
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        // We ignore partial bytes, i.e. only multiples of 8 count.
        // Any combination not part of a valid encoding is either partially decoded
        // or will raise an exception. Possible trailing characters are 2, 4, 5, 7.
        // It is not possible to encode with 1, 3, 6 trailing characters.
        // For backwards compatibility 3 & 6 chars are decoded anyway rather than discarded.
        // See the encode(byte[]) method EOF section.
        switch(context.modulus) {
            //              case 0 : // impossible, as excluded above
            case // 5 bits - either ignore entirely, or raise an exception
            1:
                validateTrailingCharacters();
            // falls-through
            case // 10 bits, drop 2 and output one byte
            2:
                validateCharacter(MASK_2BITS, context);
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 2 & MASK_8BITS);
                break;
            case // 15 bits, drop 7 and output 1 byte, or raise an exception
            3:
                validateTrailingCharacters();
                // Not possible from a valid encoding but decode anyway
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 7 & MASK_8BITS);
                break;
            case // 20 bits = 2*8 + 4
            4:
                validateCharacter(MASK_4BITS, context);
                // drop 4 bits
                context.lbitWorkArea = context.lbitWorkArea >> 4;
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 8 & MASK_8BITS);
                buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                break;
            case // 25 bits = 3*8 + 1
            5:
                validateCharacter(MASK_1BITS, context);
                context.lbitWorkArea = context.lbitWorkArea >> 1;
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 16 & MASK_8BITS);
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 8 & MASK_8BITS);
                buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                break;
            case // 30 bits = 3*8 + 6, or raise an exception
            6:
                validateTrailingCharacters();
                // Not possible from a valid encoding but decode anyway
                context.lbitWorkArea = context.lbitWorkArea >> 6;
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 16 & MASK_8BITS);
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 8 & MASK_8BITS);
                buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                break;
            case // 35 bits = 4*8 +3
            7:
                validateCharacter(MASK_3BITS, context);
                context.lbitWorkArea = context.lbitWorkArea >> 3;
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 24 & MASK_8BITS);
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 16 & MASK_8BITS);
                buffer[context.pos++] = (byte) (context.lbitWorkArea >> 8 & MASK_8BITS);
                buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                break;
            default:
                // modulus can be 0-7, and we excluded 0,1 already
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
    }
}","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.decode(byte[],int,int,Context).input","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.decode(byte[],int,int,Context).inPos","Parameter_2","Belong to org.apache.commons.codec.binary.Base32.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.decode(byte[],int,int,Context).inAvail","Parameter_3","Belong to org.apache.commons.codec.binary.Base32.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.decode(byte[],int,int,Context).context","Parameter_4","Belong to org.apache.commons.codec.binary.Base32.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.encode(byte[],int,int,Context)","Method","* <p>
     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with the data to encode, and once with
     * inAvail set to ""-1"" to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 5).
     * </p>
     *
     * @param input   byte[] array of binary data to Base32 encode.
     * @param inPos   Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     * @param context the context to be used","@Override
void encode(final byte[] input, int inPos, final int inAvail, final Context context) {
    // package protected for access from I/O streams
    if (context.eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        context.eof = true;
        if (0 == context.modulus && lineLength == 0) {
            // no leftovers to process and not using chunking
            return;
        }
        final byte[] buffer = ensureBufferSize(encodeSize, context);
        final int savedPos = context.pos;
        switch(// % 5
        context.modulus) {
            case 0:
                break;
            case // Only 1 octet; take top 5 bits then remainder
            1:
                // 8-1*5 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 3) & MASK_5BITS];
                // 5-3=2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 2) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 2 octets = 16 bits to use
            2:
                // 16-1*5 = 11
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 11) & MASK_5BITS];
                // 16-2*5 = 6
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 6) & MASK_5BITS];
                // 16-3*5 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 1) & MASK_5BITS];
                // 5-1 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 4) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 3 octets = 24 bits to use
            3:
                // 24-1*5 = 19
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 19) & MASK_5BITS];
                // 24-2*5 = 14
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 14) & MASK_5BITS];
                // 24-3*5 = 9
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 9) & MASK_5BITS];
                // 24-4*5 = 4
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 4) & MASK_5BITS];
                // 5-4 = 1
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 1) & MASK_5BITS];
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                buffer[context.pos++] = pad;
                break;
            case // 4 octets = 32 bits to use
            4:
                // 32-1*5 = 27
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 27) & MASK_5BITS];
                // 32-2*5 = 22
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 22) & MASK_5BITS];
                // 32-3*5 = 17
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 17) & MASK_5BITS];
                // 32-4*5 = 12
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 12) & MASK_5BITS];
                // 32-5*5 = 7
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 7) & MASK_5BITS];
                // 32-6*5 = 2
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 2) & MASK_5BITS];
                // 5-2 = 3
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea << 3) & MASK_5BITS];
                buffer[context.pos++] = pad;
                break;
            default:
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
        // keep track of current line position
        context.currentLinePos += context.pos - savedPos;
        // if currentPos == 0 we are at the start of a line, so don't add CRLF
        if (lineLength > 0 && context.currentLinePos > 0) {
            // add chunk separator if required
            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
            context.pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            final byte[] buffer = ensureBufferSize(encodeSize, context);
            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
            int b = input[inPos++];
            if (b < 0) {
                b += 256;
            }
            // BITS_PER_BYTE
            context.lbitWorkArea = (context.lbitWorkArea << 8) + b;
            if (0 == context.modulus) {
                // we have enough bytes to create our output
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 35) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 30) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 25) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 20) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 15) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 10) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea >> 5) & MASK_5BITS];
                buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea & MASK_5BITS];
                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
                if (lineLength > 0 && lineLength <= context.currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
                    context.pos += lineSeparator.length;
                    context.currentLinePos = 0;
                }
            }
        }
    }
}","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.encode(byte[],int,int,Context).input","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.encode(byte[],int,int,Context).inPos","Parameter_2","Belong to org.apache.commons.codec.binary.Base32.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.encode(byte[],int,int,Context).inAvail","Parameter_3","Belong to org.apache.commons.codec.binary.Base32.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.encode(byte[],int,int,Context).context","Parameter_4","Belong to org.apache.commons.codec.binary.Base32.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.getLineSeparator()","Method","* Gets the line separator (for testing only).
     *
     * @return the line separator.","byte[] getLineSeparator() {
    return lineSeparator;
}","byte[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.isInAlphabet(byte)","Method","* Returns whether or not the {@code octet} is in the Base32 alphabet.
     *
     * @param octet The value to test
     * @return {@code true} if the value is defined in the Base32 alphabet {@code false} otherwise.","@Override
public boolean isInAlphabet(final byte octet) {
    return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.isInAlphabet(byte).octet","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.isInAlphabet(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.validateCharacter(long,Context)","Method","* Validates whether decoding the final trailing character is possible in the context of the set of possible base 32 values.
     * <p>
     * The character is valid if the lower bits within the provided mask are zero. This is used to test the final trailing base-32 digit is zero in the bits
     * that will be discarded.
     * </p>
     *
     * @param emptyBitsMask The mask of the lower bits that should be empty
     * @param context       the context to be used
     * @throws IllegalArgumentException if the bits being checked contain any non-zero value","private void validateCharacter(final long emptyBitsMask, final Context context) {
    // Use the long bit work area
    if (isStrictDecoding() && (context.lbitWorkArea & emptyBitsMask) != 0) {
        throw new IllegalArgumentException(""Strict decoding: Last encoded character (before the paddings if any) is a valid "" + ""base 32 alphabet but not a possible encoding. Expected the discarded bits from the character to be zero."");
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.validateCharacter(long,Context).emptyBitsMask","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.validateCharacter(long,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.validateCharacter(long,Context).context","Parameter_2","Belong to org.apache.commons.codec.binary.Base32.validateCharacter(long,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.validateTrailingCharacters()","Method","* Validates whether decoding allows final trailing characters that cannot be created during encoding.
     *
     * @throws IllegalArgumentException if strict decoding is enabled","private void validateTrailingCharacters() {
    if (isStrictDecoding()) {
        throw new IllegalArgumentException(""Strict decoding: Last encoded character(s) (before the paddings if any) are valid "" + ""base 32 alphabet but not a possible encoding. Decoding requires either 2, 4, 5, or 7 trailing 5-bit characters to create bytes."");
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>()","Constructor","* Constructs a Base32 codec used for decoding and encoding.
     * <p>
     * When encoding the line length is 0 (no chunking).
     * </p>","public Base32() {
    this(false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(boolean)","Constructor","* Constructs a Base32 codec used for decoding and encoding.
     * <p>
     * When encoding the line length is 0 (no chunking).
     * </p>
     *
     * @param useHex if {@code true} then use Base32 Hex alphabet","public Base32(final boolean useHex) {
    this(0, null, useHex, PAD_DEFAULT);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(boolean).useHex","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.<init>(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(boolean,byte)","Constructor","* Constructs a Base32 codec used for decoding and encoding.
     * <p>
     * When encoding the line length is 0 (no chunking).
     * </p>
     *
     * @param useHex  if {@code true} then use Base32 Hex alphabet
     * @param padding byte used as padding byte.","public Base32(final boolean useHex, final byte padding) {
    this(0, null, useHex, padding);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(boolean,byte).useHex","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.<init>(boolean,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(boolean,byte).padding","Parameter_2","Belong to org.apache.commons.codec.binary.Base32.<init>(boolean,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(byte)","Constructor","* Constructs a Base32 codec used for decoding and encoding.
     * <p>
     * When encoding the line length is 0 (no chunking).
     * </p>
     *
     * @param pad byte used as padding byte.","public Base32(final byte pad) {
    this(false, pad);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(byte).pad","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.<init>(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int)","Constructor","* Constructs a Base32 codec used for decoding and encoding.
     * <p>
     * When encoding the line length is given in the constructor, the line separator is CRLF.
     * </p>
     *
     * @param lineLength Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0, then
     *                   the output will not be divided into lines (chunks). Ignored when decoding.","public Base32(final int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[])","Constructor","* Constructs a Base32 codec used for decoding and encoding.
     * <p>
     * When encoding the line length and line separator are given in the constructor.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * </p>
     *
     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,
     *                      then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters.","public Base32(final int lineLength, final byte[] lineSeparator) {
    this(lineLength, lineSeparator, false, PAD_DEFAULT);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[]).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[]).lineSeparator","Parameter_2","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean)","Constructor","* Constructs a Base32 / Base32 Hex codec used for decoding and encoding.
     * <p>
     * When encoding the line length and line separator are given in the constructor.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * </p>
     *
     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,
     *                      then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.
     * @param useHex        if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &gt; 0 and lineSeparator is null.","public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {
    this(lineLength, lineSeparator, useHex, PAD_DEFAULT);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean).lineSeparator","Parameter_2","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean).useHex","Parameter_3","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte)","Constructor","* Constructs a Base32 / Base32 Hex codec used for decoding and encoding.
     * <p>
     * When encoding the line length and line separator are given in the constructor.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * </p>
     *
     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,
     *                      then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.
     * @param useHex        if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
     * @param padding       padding byte.
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &gt; 0 and lineSeparator is null.","public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte padding) {
    this(lineLength, lineSeparator, useHex, padding, DECODING_POLICY_DEFAULT);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte).lineSeparator","Parameter_2","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte).useHex","Parameter_3","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte).padding","Parameter_4","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy)","Constructor","* Constructs a Base32 / Base32 Hex codec used for decoding and encoding.
     * <p>
     * When encoding the line length and line separator are given in the constructor.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * </p>
     *
     * @param lineLength     Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,
     *                       then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator  Each line of encoded data will end with this sequence of bytes.
     * @param useHex         use Base32 hexadecimal if {@code true}, otherwise use the Base32 alphabet.
     * @param padding        padding byte.
     * @param decodingPolicy The decoding policy.
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &gt; 0 and lineSeparator is null.
     * @since 1.15","public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte padding, final CodecPolicy decodingPolicy) {
    this(lineLength, lineSeparator, encodeTable(useHex), padding, decodingPolicy);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy).lineSeparator","Parameter_2","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy).useHex","Parameter_3","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy).padding","Parameter_4","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy).decodingPolicy","Parameter_5","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],boolean,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy)","Constructor","* Constructs a Base32 / Base32 Hex codec used for decoding and encoding.
     * <p>
     * When encoding the line length and line separator are given in the constructor.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * </p>
     *
     * @param lineLength     Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,
     *                       then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator  Each line of encoded data will end with this sequence of bytes.
     * @param encodeTable    A Base32 alphabet.
     * @param padding        padding byte.
     * @param decodingPolicy The decoding policy.
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &gt; 0 and lineSeparator is null.","private Base32(final int lineLength, final byte[] lineSeparator, final byte[] encodeTable, final byte padding, final CodecPolicy decodingPolicy) {
    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, toLength(lineSeparator), padding, decodingPolicy);
    Objects.requireNonNull(encodeTable, ""encodeTable"");
    this.encodeTable = encodeTable;
    this.decodeTable = encodeTable == HEX_ENCODE_TABLE ? HEX_DECODE_TABLE : DECODE_TABLE;
    if (lineLength > 0) {
        if (lineSeparator == null) {
            throw new IllegalArgumentException(""lineLength "" + lineLength + "" > 0, but lineSeparator is null"");
        }
        final byte[] lineSeparatorCopy = lineSeparator.clone();
        // Must be done after initializing the tables
        if (containsAlphabetOrPad(lineSeparatorCopy)) {
            final String sep = StringUtils.newStringUtf8(lineSeparatorCopy);
            throw new IllegalArgumentException(""lineSeparator must not contain Base32 characters: ["" + sep + ""]"");
        }
        this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparatorCopy.length;
        this.lineSeparator = lineSeparatorCopy;
    } else {
        this.encodeSize = BYTES_PER_ENCODED_BLOCK;
        this.lineSeparator = null;
    }
    if (isInAlphabet(padding) || Character.isWhitespace(padding)) {
        throw new IllegalArgumentException(""pad must not be in alphabet or whitespace"");
    }
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy).lineSeparator","Parameter_2","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy).encodeTable","Parameter_3","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy).padding","Parameter_4","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy).decodingPolicy","Parameter_5","Belong to org.apache.commons.codec.binary.Base32.<init>(int,byte[],byte[],byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32$Builder","Class","* Builds {@link Base32} instances.
     *
     * @since 1.17.0","Class do not obtain Source Code","No return type","public , static ","org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder",""
"org.apache.commons.codec.binary.Base32$Builder.get()","Method","No Comment","@Override
public Base32 get() {
    return new Base32(getLineLength(), getLineSeparator(), getEncodeTable(), getPadding(), getDecodingPolicy());
}","Base32","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32$Builder.setHexDecodeTable(boolean)","Method","* Sets the decode table to use Base32 hexadecimal if {@code true}, otherwise use the Base32 alphabet.
         * <p>
         * This overrides a value previously set with {@link #setEncodeTable(byte...)}.
         * </p>
         *
         * @param useHex use Base32 hexadecimal if {@code true}, otherwise use the Base32 alphabet.
         * @return this instance.
         * @since 1.18.0","public Builder setHexDecodeTable(final boolean useHex) {
    return setEncodeTable(decodeTable(useHex));
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32$Builder.setHexDecodeTable(boolean).useHex","Parameter_1","Belong to org.apache.commons.codec.binary.Base32$Builder.setHexDecodeTable(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32$Builder.setHexEncodeTable(boolean)","Method","* Sets the encode table to use Base32 hexadecimal if {@code true}, otherwise use the Base32 alphabet.
         * <p>
         * This overrides a value previously set with {@link #setEncodeTable(byte...)}.
         * </p>
         *
         * @param useHex use Base32 hexadecimal if {@code true}, otherwise use the Base32 alphabet.
         * @return this instance.
         * @since 1.18.0","public Builder setHexEncodeTable(final boolean useHex) {
    return setEncodeTable(encodeTable(useHex));
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32$Builder.setHexEncodeTable(boolean).useHex","Parameter_1","Belong to org.apache.commons.codec.binary.Base32$Builder.setHexEncodeTable(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32$Builder.<init>()","Constructor","* Constructs a new instance.","public Builder() {
    super(ENCODE_TABLE);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.Builder","Class","* Builds {@link Base32} instances.
     *
     * @since 1.17.0","Class do not obtain Source Code","No return type","public , static ","org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder",""
"org.apache.commons.codec.binary.Base32.Builder.get()","Method","No Comment","@Override
public Base32 get() {
    return new Base32(getLineLength(), getLineSeparator(), getEncodeTable(), getPadding(), getDecodingPolicy());
}","Base32","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.Builder.setHexDecodeTable(boolean)","Method","* Sets the decode table to use Base32 hexadecimal if {@code true}, otherwise use the Base32 alphabet.
         * <p>
         * This overrides a value previously set with {@link #setEncodeTable(byte...)}.
         * </p>
         *
         * @param useHex use Base32 hexadecimal if {@code true}, otherwise use the Base32 alphabet.
         * @return this instance.
         * @since 1.18.0","public Builder setHexDecodeTable(final boolean useHex) {
    return setEncodeTable(decodeTable(useHex));
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.Builder.setHexDecodeTable(boolean).useHex","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.Builder.setHexDecodeTable(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.Builder.setHexEncodeTable(boolean)","Method","* Sets the encode table to use Base32 hexadecimal if {@code true}, otherwise use the Base32 alphabet.
         * <p>
         * This overrides a value previously set with {@link #setEncodeTable(byte...)}.
         * </p>
         *
         * @param useHex use Base32 hexadecimal if {@code true}, otherwise use the Base32 alphabet.
         * @return this instance.
         * @since 1.18.0","public Builder setHexEncodeTable(final boolean useHex) {
    return setEncodeTable(encodeTable(useHex));
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.Builder.setHexEncodeTable(boolean).useHex","Parameter_1","Belong to org.apache.commons.codec.binary.Base32.Builder.setHexEncodeTable(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32.Builder.<init>()","Constructor","* Constructs a new instance.","public Builder() {
    super(ENCODE_TABLE);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils","Class","* Converts String to and from bytes using the encodings required by the Java specification. These encodings are
 * specified in standard {@link Charset}.
 *
 * <p>This class is immutable and thread-safe.</p>
 *
 * @see CharEncoding
 * @see Charset
 * @see StandardCharsets
 * @since 1.4","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.binary.StringUtils.equals(CharSequence,CharSequence)","Method","* <p>
     * Compares two CharSequences, returning {@code true} if they represent equal sequences of characters.
     * </p>
     *
     * <p>
     * {@code null}s are handled without exceptions. Two {@code null} references are considered to be equal.
     * The comparison is case sensitive.
     * </p>
     *
     * <pre>
     * StringUtils.equals(null, null)   = true
     * StringUtils.equals(null, ""abc"")  = false
     * StringUtils.equals(""abc"", null)  = false
     * StringUtils.equals(""abc"", ""abc"") = true
     * StringUtils.equals(""abc"", ""ABC"") = false
     * </pre>
     *
     * <p>
     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).
     * </p>
     *
     * @see Object#equals(Object)
     * @param cs1
     *            the first CharSequence, may be {@code null}
     * @param cs2
     *            the second CharSequence, may be {@code null}
     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}
     * @since 1.10","public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.equals(CharSequence,CharSequence).cs1","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.equals(CharSequence,CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.equals(CharSequence,CharSequence).cs2","Parameter_2","Belong to org.apache.commons.codec.binary.StringUtils.equals(CharSequence,CharSequence)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getByteBuffer(String,Charset)","Method","* Calls {@link String#getBytes(Charset)}
     *
     * @param string
     *            The string to encode (if null, return null).
     * @param charset
     *            The {@link Charset} to encode the {@code String}
     * @return the encoded bytes","private static ByteBuffer getByteBuffer(final String string, final Charset charset) {
    if (string == null) {
        return null;
    }
    return ByteBuffer.wrap(string.getBytes(charset));
}","ByteBuffer","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getByteBuffer(String,Charset).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getByteBuffer(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getByteBuffer(String,Charset).charset","Parameter_2","Belong to org.apache.commons.codec.binary.StringUtils.getByteBuffer(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getByteBufferUtf8(String)","Method","* Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte
     * array.
     *
     * @param string
     *            the String to encode, may be {@code null}
     * @return encoded bytes, or {@code null} if the input string was {@code null}
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#UTF_8} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @see Charset
     * @see #getBytesUnchecked(String, String)
     * @since 1.11","public static ByteBuffer getByteBufferUtf8(final String string) {
    return getByteBuffer(string, StandardCharsets.UTF_8);
}","ByteBuffer","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getByteBufferUtf8(String).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getByteBufferUtf8(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytes(String,Charset)","Method","* Calls {@link String#getBytes(Charset)}
     *
     * @param string
     *            The string to encode (if null, return null).
     * @param charset
     *            The {@link Charset} to encode the {@code String}
     * @return the encoded bytes","private static byte[] getBytes(final String string, final Charset charset) {
    return string == null ? null : string.getBytes(charset);
}","byte[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytes(String,Charset).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getBytes(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytes(String,Charset).charset","Parameter_2","Belong to org.apache.commons.codec.binary.StringUtils.getBytes(String,Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(String)","Method","* Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new
     * byte array.
     *
     * @param string
     *            the String to encode, may be {@code null}
     * @return encoded bytes, or {@code null} if the input string was {@code null}
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#ISO_8859_1} is not initialized, which should never happen
     *             since it is required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
     * @see Charset
     * @see #getBytesUnchecked(String, String)","public static byte[] getBytesIso8859_1(final String string) {
    return getBytes(string, StandardCharsets.ISO_8859_1);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(String).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(String,String)","Method","* Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte
     * array.
     * <p>
     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which
     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
     * </p>
     *
     * @param string
     *            the String to encode, may be {@code null}
     * @param charsetName
     *            The name of a required {@link java.nio.charset.Charset}
     * @return encoded bytes, or {@code null} if the input string was {@code null}
     * @throws IllegalStateException
     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
     *             required charset name.
     * @see CharEncoding
     * @see String#getBytes(String)","public static byte[] getBytesUnchecked(final String string, final String charsetName) {
    if (string == null) {
        return null;
    }
    try {
        return string.getBytes(charsetName);
    } catch (final UnsupportedEncodingException e) {
        throw StringUtils.newIllegalStateException(charsetName, e);
    }
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(String,String).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(String,String).charsetName","Parameter_2","Belong to org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(String,String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(String)","Method","* Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte
     * array.
     *
     * @param string
     *            the String to encode, may be {@code null}
     * @return encoded bytes, or {@code null} if the input string was {@code null}
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#US_ASCII} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
     * @see Charset
     * @see #getBytesUnchecked(String, String)","public static byte[] getBytesUsAscii(final String string) {
    return getBytes(string, StandardCharsets.US_ASCII);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(String).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUtf16(String)","Method","* Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte
     * array.
     *
     * @param string
     *            the String to encode, may be {@code null}
     * @return encoded bytes, or {@code null} if the input string was {@code null}
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#UTF_16} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
     * @see Charset
     * @see #getBytesUnchecked(String, String)","public static byte[] getBytesUtf16(final String string) {
    return getBytes(string, StandardCharsets.UTF_16);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUtf16(String).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getBytesUtf16(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUtf16Be(String)","Method","* Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte
     * array.
     *
     * @param string
     *            the String to encode, may be {@code null}
     * @return encoded bytes, or {@code null} if the input string was {@code null}
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#UTF_16BE} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
     * @see Charset
     * @see #getBytesUnchecked(String, String)","public static byte[] getBytesUtf16Be(final String string) {
    return getBytes(string, StandardCharsets.UTF_16BE);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUtf16Be(String).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getBytesUtf16Be(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUtf16Le(String)","Method","* Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte
     * array.
     *
     * @param string
     *            the String to encode, may be {@code null}
     * @return encoded bytes, or {@code null} if the input string was {@code null}
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#UTF_16LE} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
     * @see Charset
     * @see #getBytesUnchecked(String, String)","public static byte[] getBytesUtf16Le(final String string) {
    return getBytes(string, StandardCharsets.UTF_16LE);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUtf16Le(String).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getBytesUtf16Le(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUtf8(String)","Method","* Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte
     * array.
     *
     * @param string
     *            the String to encode, may be {@code null}
     * @return encoded bytes, or {@code null} if the input string was {@code null}
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#UTF_8} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
     * @see Charset
     * @see #getBytesUnchecked(String, String)","public static byte[] getBytesUtf8(final String string) {
    return getBytes(string, StandardCharsets.UTF_8);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.getBytesUtf8(String).string","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.getBytesUtf8(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newIllegalStateException(String,UnsupportedEncodingException)","Method","No Comment","private static IllegalStateException newIllegalStateException(final String charsetName, final UnsupportedEncodingException e) {
    return new IllegalStateException(charsetName + "": "" + e);
}","IllegalStateException","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newIllegalStateException(String,UnsupportedEncodingException).charsetName","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.newIllegalStateException(String,UnsupportedEncodingException)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newIllegalStateException(String,UnsupportedEncodingException).e","Parameter_2","Belong to org.apache.commons.codec.binary.StringUtils.newIllegalStateException(String,UnsupportedEncodingException)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newString(byte[],Charset)","Method","* Constructs a new {@code String} by decoding the specified array of bytes using the given charset.
     *
     * @param bytes
     *            The bytes to be decoded into characters
     * @param charset
     *            The {@link Charset} to encode the {@code String}; not {@code null}
     * @return A new {@code String} decoded from the specified array of bytes using the given charset,
     *         or {@code null} if the input byte array was {@code null}.
     * @throws NullPointerException
     *             Thrown if charset is {@code null}","private static String newString(final byte[] bytes, final Charset charset) {
    return bytes == null ? null : new String(bytes, charset);
}","String","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newString(byte[],Charset).bytes","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.newString(byte[],Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newString(byte[],Charset).charset","Parameter_2","Belong to org.apache.commons.codec.binary.StringUtils.newString(byte[],Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newString(byte[],String)","Method","* Constructs a new {@code String} by decoding the specified array of bytes using the given charset.
     * <p>
     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which
     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.
     * </p>
     *
     * @param bytes
     *            The bytes to be decoded into characters, may be {@code null}
     * @param charsetName
     *            The name of a required {@link java.nio.charset.Charset}
     * @return A new {@code String} decoded from the specified array of bytes using the given charset,
     *         or {@code null} if the input byte array was {@code null}.
     * @throws IllegalStateException
     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
     *             required charset name.
     * @see CharEncoding
     * @see String#String(byte[], String)","public static String newString(final byte[] bytes, final String charsetName) {
    if (bytes == null) {
        return null;
    }
    try {
        return new String(bytes, charsetName);
    } catch (final UnsupportedEncodingException e) {
        throw StringUtils.newIllegalStateException(charsetName, e);
    }
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newString(byte[],String).bytes","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.newString(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newString(byte[],String).charsetName","Parameter_2","Belong to org.apache.commons.codec.binary.StringUtils.newString(byte[],String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringIso8859_1(byte[])","Method","* Constructs a new {@code String} by decoding the specified array of bytes using the ISO-8859-1 charset.
     *
     * @param bytes
     *            The bytes to be decoded into characters, may be {@code null}
     * @return A new {@code String} decoded from the specified array of bytes using the ISO-8859-1 charset, or
     *         {@code null} if the input byte array was {@code null}.
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#ISO_8859_1} is not initialized, which should never happen
     *             since it is required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException","public static String newStringIso8859_1(final byte[] bytes) {
    return newString(bytes, StandardCharsets.ISO_8859_1);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringIso8859_1(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.newStringIso8859_1(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])","Method","* Constructs a new {@code String} by decoding the specified array of bytes using the US-ASCII charset.
     *
     * @param bytes
     *            The bytes to be decoded into characters
     * @return A new {@code String} decoded from the specified array of bytes using the US-ASCII charset,
     *         or {@code null} if the input byte array was {@code null}.
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#US_ASCII} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException","public static String newStringUsAscii(final byte[] bytes) {
    return newString(bytes, StandardCharsets.US_ASCII);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUtf16(byte[])","Method","* Constructs a new {@code String} by decoding the specified array of bytes using the UTF-16 charset.
     *
     * @param bytes
     *            The bytes to be decoded into characters
     * @return A new {@code String} decoded from the specified array of bytes using the UTF-16 charset
     *         or {@code null} if the input byte array was {@code null}.
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#UTF_16} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException","public static String newStringUtf16(final byte[] bytes) {
    return newString(bytes, StandardCharsets.UTF_16);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUtf16(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.newStringUtf16(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUtf16Be(byte[])","Method","* Constructs a new {@code String} by decoding the specified array of bytes using the UTF-16BE charset.
     *
     * @param bytes
     *            The bytes to be decoded into characters
     * @return A new {@code String} decoded from the specified array of bytes using the UTF-16BE charset,
     *         or {@code null} if the input byte array was {@code null}.
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#UTF_16BE} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException","public static String newStringUtf16Be(final byte[] bytes) {
    return newString(bytes, StandardCharsets.UTF_16BE);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUtf16Be(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.newStringUtf16Be(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUtf16Le(byte[])","Method","* Constructs a new {@code String} by decoding the specified array of bytes using the UTF-16LE charset.
     *
     * @param bytes
     *            The bytes to be decoded into characters
     * @return A new {@code String} decoded from the specified array of bytes using the UTF-16LE charset,
     *         or {@code null} if the input byte array was {@code null}.
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#UTF_16LE} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException","public static String newStringUtf16Le(final byte[] bytes) {
    return newString(bytes, StandardCharsets.UTF_16LE);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUtf16Le(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.newStringUtf16Le(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])","Method","* Constructs a new {@code String} by decoding the specified array of bytes using the UTF-8 charset.
     *
     * @param bytes
     *            The bytes to be decoded into characters
     * @return A new {@code String} decoded from the specified array of bytes using the UTF-8 charset,
     *         or {@code null} if the input byte array was {@code null}.
     * @throws NullPointerException
     *             Thrown if {@link StandardCharsets#UTF_8} is not initialized, which should never happen since it is
     *             required by the Java platform specification.
     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException","public static String newStringUtf8(final byte[] bytes) {
    return newString(bytes, StandardCharsets.UTF_8);
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[]).bytes","Parameter_1","Belong to org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.StringUtils.<init>()","Constructor","* TODO Make private in 2.0.
     *
     * @deprecated TODO Make private in 2.0.","@Deprecated
public StringUtils() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64","Class","* Provides Base64 encoding and decoding as defined by <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>.
 *
 * <p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 * <p>
 * The class can be parameterized in the following manner with various constructors:
 * </p>
 * <ul>
 * <li>URL-safe mode: Default off.</li>
 * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of
 * 4 in the encoded data.
 * <li>Line separator: Default is CRLF (""\r\n"")</li>
 * </ul>
 * <p>
 * The URL-safe parameter is only applied to encode operations. Decoding seamlessly handles both modes.
 * </p>
 * <p>
 * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only
 * encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252,
 * UTF-8, etc).
 * </p>
 * <p>
 * This class is thread-safe.
 * </p>
 * <p>
 * You can configure instances with the {@link Builder}.
 * </p>
 * <pre>
 * Base64 base64 = Base64.builder()
 *   .setDecodingPolicy(DecodingPolicy.LENIENT) // default is lenient, null resets to default
 *   .setEncodeTable(customEncodeTable)         // default is built in, null resets to default
 *   .setLineLength(0)                          // default is none
 *   .setLineSeparator('\r', '\n')              // default is CR LF, null resets to default
 *   .setPadding('=')                           // default is =
 *   .setUrlSafe(false)                         // default is false
 *   .get()
 * </pre>
 *
 * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>
 * @since 1.0","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.binary.BaseNCodec",""
"org.apache.commons.codec.binary.Base64.BITS_PER_ENCODED_BYTE","Field","* BASE64 characters are 6 bits in length.
     * They are formed by taking a block of 3 octets to form a 24-bit string,
     * which is converted into 4 BASE64 characters.","private static final int BITS_PER_ENCODED_BYTE = 6;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.BYTES_PER_UNENCODED_BLOCK","Field","No Comment","private static final int BYTES_PER_UNENCODED_BLOCK = 3;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.BYTES_PER_ENCODED_BLOCK","Field","No Comment","private static final int BYTES_PER_ENCODED_BLOCK = 4;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.ALPHABET_LENGTH","Field","No Comment","private static final int ALPHABET_LENGTH = 64;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.DECODING_TABLE_LENGTH","Field","No Comment","private static final int DECODING_TABLE_LENGTH = 256;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE","Field","* This array is a lookup table that translates 6-bit positive integer index values into their ""Base64 Alphabet""
     * equivalents as specified in Table 1 of RFC 2045.
     * <p>
     * Thanks to ""commons"" project in ws.apache.org for this code.
     * https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>","private static final byte[] STANDARD_ENCODE_TABLE = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE","Field","* This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /
     * changed to - and _ to make the encoded Base64 results more URL-SAFE.
     * This table is only used when the Base64's mode is set to URL-SAFE.","private static final byte[] URL_SAFE_ENCODE_TABLE = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.DECODE_TABLE","Field","* This array is a lookup table that translates Unicode characters drawn from the ""Base64 Alphabet"" (as specified
     * in Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64
     * alphabet but fall within the bounds of the array are translated to -1.
     * <p>
     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both
     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).
     * </p>
     * <p>
     * Thanks to ""commons"" project in ws.apache.org for this code.
     * https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>","private static final byte[] DECODE_TABLE = { //   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
// 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
-1, // 20-2f + - /
62, // 20-2f + - /
-1, // 20-2f + - /
62, // 20-2f + - /
-1, // 20-2f + - /
63, // 30-3f 0-9
52, // 30-3f 0-9
53, // 30-3f 0-9
54, // 30-3f 0-9
55, // 30-3f 0-9
56, // 30-3f 0-9
57, // 30-3f 0-9
58, // 30-3f 0-9
59, // 30-3f 0-9
60, // 30-3f 0-9
61, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 40-4f A-O
-1, // 40-4f A-O
0, // 40-4f A-O
1, // 40-4f A-O
2, // 40-4f A-O
3, // 40-4f A-O
4, // 40-4f A-O
5, // 40-4f A-O
6, // 40-4f A-O
7, // 40-4f A-O
8, // 40-4f A-O
9, // 40-4f A-O
10, // 40-4f A-O
11, // 40-4f A-O
12, // 40-4f A-O
13, // 40-4f A-O
14, // 50-5f P-Z _
15, // 50-5f P-Z _
16, // 50-5f P-Z _
17, // 50-5f P-Z _
18, // 50-5f P-Z _
19, // 50-5f P-Z _
20, // 50-5f P-Z _
21, // 50-5f P-Z _
22, // 50-5f P-Z _
23, // 50-5f P-Z _
24, // 50-5f P-Z _
25, // 50-5f P-Z _
-1, // 50-5f P-Z _
-1, // 50-5f P-Z _
-1, // 50-5f P-Z _
-1, // 50-5f P-Z _
63, // 60-6f a-o
-1, // 60-6f a-o
26, // 60-6f a-o
27, // 60-6f a-o
28, // 60-6f a-o
29, // 60-6f a-o
30, // 60-6f a-o
31, // 60-6f a-o
32, // 60-6f a-o
33, // 60-6f a-o
34, // 60-6f a-o
35, // 60-6f a-o
36, // 60-6f a-o
37, // 60-6f a-o
38, // 60-6f a-o
39, // 60-6f a-o
40, // 70-7a p-z
41, // 70-7a p-z
42, // 70-7a p-z
43, // 70-7a p-z
44, // 70-7a p-z
45, // 70-7a p-z
46, // 70-7a p-z
47, // 70-7a p-z
48, // 70-7a p-z
49, // 70-7a p-z
50, // 70-7a p-z
51 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.MASK_6BITS","Field","Mask used to extract 6 bits, used when encoding","private static final int MASK_6BITS = 0x3f;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.MASK_4BITS","Field","Mask used to extract 4 bits, used when decoding final trailing character.","private static final int MASK_4BITS = 0xf;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.MASK_2BITS","Field","Mask used to extract 2 bits, used when decoding final trailing character.","private static final int MASK_2BITS = 0x3;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeTable","Field","* Encode table to use: either STANDARD or URL_SAFE or custom.
     * Note: the DECODE_TABLE above remains static because it is able
     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch
     * between the two modes.","private final byte[] encodeTable;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decodeTable","Field","* Decode table to use.","private final byte[] decodeTable;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.lineSeparator","Field","* Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.","private final byte[] lineSeparator;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeSize","Field","* Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.
     * {@code encodeSize = 4 + lineSeparator.length;}","private final int encodeSize;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isUrlSafe","Field","No Comment","private final boolean isUrlSafe;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.builder()","Method","* Creates a new Builder.
     *
     * @return a new Builder.
     * @since 1.17.0","public static Builder builder() {
    return new Builder();
}","Builder","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decodeBase64(byte[])","Method","* Decodes Base64 data into octets.
     * <p>
     * <strong>Note:</strong> this method seamlessly handles data encoded in URL-safe or normal mode.
     * </p>
     *
     * @param base64Data
     *            Byte array containing Base64 data
     * @return Array containing decoded data.","public static byte[] decodeBase64(final byte[] base64Data) {
    return new Base64().decode(base64Data);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decodeBase64(byte[]).base64Data","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.decodeBase64(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decodeBase64(String)","Method","* Decodes a Base64 String into octets.
     * <p>
     * <strong>Note:</strong> this method seamlessly handles data encoded in URL-safe or normal mode.
     * </p>
     *
     * @param base64String
     *            String containing Base64 data
     * @return Array containing decoded data.
     * @since 1.4","public static byte[] decodeBase64(final String base64String) {
    return new Base64().decode(base64String);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decodeBase64(String).base64String","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.decodeBase64(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decodeInteger(byte[])","Method","* Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.
     *
     * @param pArray
     *            a byte array containing base64 character data
     * @return A BigInteger
     * @since 1.4","public static BigInteger decodeInteger(final byte[] pArray) {
    return new BigInteger(1, decodeBase64(pArray));
}","BigInteger","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decodeInteger(byte[]).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.decodeInteger(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[])","Method","* Encodes binary data using the base64 algorithm but does not chunk the output.
     *
     * @param binaryData
     *            binary data to encode
     * @return byte[] containing Base64 characters in their UTF-8 representation.","public static byte[] encodeBase64(final byte[] binaryData) {
    return encodeBase64(binaryData, false);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[]).binaryData","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean)","Method","* Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}","public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {
    return encodeBase64(binaryData, isChunked, false);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean).binaryData","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean).isChunked","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean)","Method","* Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks
     * @param urlSafe
     *            if {@code true} this encoder will emit - and _ instead of the usual + and / characters.
     *            <strong>Note: No padding is added when encoding using the URL-safe alphabet.</strong>
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
     * @since 1.4","public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {
    return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean).binaryData","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean).isChunked","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean).urlSafe","Parameter_3","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean,int)","Method","* Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks
     * @param urlSafe
     *            if {@code true} this encoder will emit - and _ instead of the usual + and / characters.
     *            <strong>Note: No padding is added when encoding using the URL-safe alphabet.</strong>
     * @param maxResultSize
     *            The maximum result size to accept.
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than maxResultSize
     * @since 1.4","public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe, final int maxResultSize) {
    if (BinaryCodec.isEmpty(binaryData)) {
        return binaryData;
    }
    // Create this so can use the super-class method
    // Also ensures that the same roundings are performed by the ctor and the code
    final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
    final long len = b64.getEncodedLength(binaryData);
    if (len > maxResultSize) {
        throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" + len + "") than the specified maximum size of "" + maxResultSize);
    }
    return b64.encode(binaryData);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean,int).binaryData","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean,int).isChunked","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean,int).urlSafe","Parameter_3","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean,int).maxResultSize","Parameter_4","Belong to org.apache.commons.codec.binary.Base64.encodeBase64(byte[],boolean,boolean,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64Chunked(byte[])","Method","* Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters chunked in 76 character blocks","public static byte[] encodeBase64Chunked(final byte[] binaryData) {
    return encodeBase64(binaryData, true);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64Chunked(byte[]).binaryData","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encodeBase64Chunked(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64String(byte[])","Method","* Encodes binary data using the base64 algorithm but does not chunk the output.
     *
     * NOTE:  We changed the behavior of this method from multi-line chunking (commons-codec-1.4) to
     * single-line non-chunking (commons-codec-1.5).
     *
     * @param binaryData
     *            binary data to encode
     * @return String containing Base64 characters.
     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).","public static String encodeBase64String(final byte[] binaryData) {
    return StringUtils.newStringUsAscii(encodeBase64(binaryData, false));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64String(byte[]).binaryData","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encodeBase64String(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64URLSafe(byte[])","Method","* Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
     * url-safe variation emits - and _ instead of + and / characters.
     * <strong>Note: No padding is added.</strong>
     * @param binaryData
     *            binary data to encode
     * @return byte[] containing Base64 characters in their UTF-8 representation.
     * @since 1.4","public static byte[] encodeBase64URLSafe(final byte[] binaryData) {
    return encodeBase64(binaryData, false, true);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64URLSafe(byte[]).binaryData","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encodeBase64URLSafe(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(byte[])","Method","* Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
     * url-safe variation emits - and _ instead of + and / characters.
     * <strong>Note: No padding is added.</strong>
     * @param binaryData
     *            binary data to encode
     * @return String containing Base64 characters
     * @since 1.4","public static String encodeBase64URLSafeString(final byte[] binaryData) {
    return StringUtils.newStringUsAscii(encodeBase64(binaryData, false, true));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(byte[]).binaryData","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeInteger(BigInteger)","Method","* Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.
     *
     * @param bigInteger
     *            a BigInteger
     * @return A byte array containing base64 character data
     * @throws NullPointerException
     *             if null is passed in
     * @since 1.4","public static byte[] encodeInteger(final BigInteger bigInteger) {
    Objects.requireNonNull(bigInteger, ""bigInteger"");
    return encodeBase64(toIntegerBytes(bigInteger), false);
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encodeInteger(BigInteger).bigInteger","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encodeInteger(BigInteger)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isArrayByteBase64(byte[])","Method","* Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
     * method treats whitespace as valid.
     *
     * @param arrayOctet
     *            byte array to test
     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
     *         {@code false}, otherwise
     * @deprecated 1.5 Use {@link #isBase64(byte[])}, will be removed in 2.0.","@Deprecated
public static boolean isArrayByteBase64(final byte[] arrayOctet) {
    return isBase64(arrayOctet);
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isArrayByteBase64(byte[]).arrayOctet","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.isArrayByteBase64(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isBase64(byte)","Method","* Returns whether or not the {@code octet} is in the base 64 alphabet.
     *
     * @param octet
     *            The value to test
     * @return {@code true} if the value is defined in the base 64 alphabet, {@code false} otherwise.
     * @since 1.4","public static boolean isBase64(final byte octet) {
    return octet == PAD_DEFAULT || octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1;
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isBase64(byte).octet","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.isBase64(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isBase64(byte[])","Method","* Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
     * method treats whitespace as valid.
     *
     * @param arrayOctet
     *            byte array to test
     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
     *         {@code false}, otherwise
     * @since 1.5","public static boolean isBase64(final byte[] arrayOctet) {
    for (final byte element : arrayOctet) {
        if (!isBase64(element) && !Character.isWhitespace(element)) {
            return false;
        }
    }
    return true;
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isBase64(byte[]).arrayOctet","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.isBase64(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isBase64(String)","Method","* Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the
     * method treats whitespace as valid.
     *
     * @param base64
     *            String to test
     * @return {@code true} if all characters in the String are valid characters in the Base64 alphabet or if
     *         the String is empty; {@code false}, otherwise
     *  @since 1.5","public static boolean isBase64(final String base64) {
    return isBase64(StringUtils.getBytesUtf8(base64));
}","boolean","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isBase64(String).base64","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.isBase64(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.toIntegerBytes(BigInteger)","Method","* Returns a byte-array representation of a {@code BigInteger} without sign bit.
     *
     * @param bigInt
     *            {@code BigInteger} to be converted
     * @return a byte array representation of the BigInteger parameter","static byte[] toIntegerBytes(final BigInteger bigInt) {
    int bitlen = bigInt.bitLength();
    // round bitlen
    bitlen = bitlen + 7 >> 3 << 3;
    final byte[] bigBytes = bigInt.toByteArray();
    if (bigInt.bitLength() % 8 != 0 && bigInt.bitLength() / 8 + 1 == bitlen / 8) {
        return bigBytes;
    }
    // set up params for copying everything but sign bit
    int startSrc = 0;
    int len = bigBytes.length;
    // if bigInt is exactly byte-aligned, just skip signbit in copy
    if (bigInt.bitLength() % 8 == 0) {
        startSrc = 1;
        len--;
    }
    // to pad w/ nulls as per spec
    final int startDst = bitlen / 8 - len;
    final byte[] resizedBytes = new byte[bitlen / 8];
    System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
    return resizedBytes;
}","byte[]","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.toIntegerBytes(BigInteger).bigInt","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.toIntegerBytes(BigInteger)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.toUrlSafeEncodeTable(boolean)","Method","No Comment","private static byte[] toUrlSafeEncodeTable(final boolean urlSafe) {
    return urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
}","byte[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.toUrlSafeEncodeTable(boolean).urlSafe","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.toUrlSafeEncodeTable(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.calculateDecodeTable(byte[])","Method","* Calculates a decode table for a given encode table.
     *
     * @param encodeTable that is used to determine decode lookup table
     * @return decodeTable","private byte[] calculateDecodeTable(final byte[] encodeTable) {
    final byte[] decodeTable = new byte[DECODING_TABLE_LENGTH];
    Arrays.fill(decodeTable, (byte) -1);
    for (int i = 0; i < encodeTable.length; i++) {
        decodeTable[encodeTable[i]] = (byte) i;
    }
    return decodeTable;
}","byte[]","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.calculateDecodeTable(byte[]).encodeTable","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.calculateDecodeTable(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decode(byte[],int,int,Context)","Method","* <p>
     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
     * with the data to decode, and once with inAvail set to ""-1"" to alert decoder that EOF has been reached. The ""-1""
     * call is not necessary when decoding, but it doesn't hurt, either.
     * </p>
     * <p>
     * Ignores all non-base64 characters. This is how chunked (for example 76 character) data is handled, since CR and LF are
     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
     * garbage-out philosophy: it will not check the provided data for validity.
     * </p>
     * <p>
     * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
     * https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>
     *
     * @param input
     *            byte[] array of ASCII data to base64 decode.
     * @param inPos
     *            Position to start reading data from.
     * @param inAvail
     *            Amount of bytes available from input for decoding.
     * @param context
     *            the context to be used","@Override
void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
    if (context.eof) {
        return;
    }
    if (inAvail < 0) {
        context.eof = true;
    }
    final int decodeSize = this.encodeSize - 1;
    for (int i = 0; i < inAvail; i++) {
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        final byte b = input[inPos++];
        if (b == pad) {
            // We're done.
            context.eof = true;
            break;
        }
        if (b >= 0 && b < decodeTable.length) {
            final int result = decodeTable[b];
            if (result >= 0) {
                context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;
                context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;
                if (context.modulus == 0) {
                    buffer[context.pos++] = (byte) (context.ibitWorkArea >> 16 & MASK_8BITS);
                    buffer[context.pos++] = (byte) (context.ibitWorkArea >> 8 & MASK_8BITS);
                    buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);
                }
            }
        }
    }
    // Two forms of EOF as far as base64 decoder is concerned: actual
    // EOF (-1) and first time '=' character is encountered in stream.
    // This approach makes the '=' padding characters completely optional.
    if (context.eof && context.modulus != 0) {
        final byte[] buffer = ensureBufferSize(decodeSize, context);
        // We have some spare bits remaining
        // Output all whole multiples of 8 bits and ignore the rest
        switch(context.modulus) {
            //              case 0 : // impossible, as excluded above
            case // 6 bits - either ignore entirely, or raise an exception
            1:
                validateTrailingCharacter();
                break;
            case // 12 bits = 8 + 4
            2:
                validateCharacter(MASK_4BITS, context);
                // dump the extra 4 bits
                context.ibitWorkArea = context.ibitWorkArea >> 4;
                buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);
                break;
            case // 18 bits = 8 + 8 + 2
            3:
                validateCharacter(MASK_2BITS, context);
                // dump 2 bits
                context.ibitWorkArea = context.ibitWorkArea >> 2;
                buffer[context.pos++] = (byte) (context.ibitWorkArea >> 8 & MASK_8BITS);
                buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);
                break;
            default:
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
    }
}","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decode(byte[],int,int,Context).input","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decode(byte[],int,int,Context).inPos","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decode(byte[],int,int,Context).inAvail","Parameter_3","Belong to org.apache.commons.codec.binary.Base64.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.decode(byte[],int,int,Context).context","Parameter_4","Belong to org.apache.commons.codec.binary.Base64.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encode(byte[],int,int,Context)","Method","* <p>
     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
     * the data to encode, and once with inAvail set to ""-1"" to alert encoder that EOF has been reached, to flush last
     * remaining bytes (if not multiple of 3).
     * </p>
     * <p><strong>Note: No padding is added when encoding using the URL-safe alphabet.</strong></p>
     * <p>
     * Thanks to ""commons"" project in ws.apache.org for the bitwise operations, and general approach.
     * https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>
     *
     * @param in
     *            byte[] array of binary data to base64 encode.
     * @param inPos
     *            Position to start reading data from.
     * @param inAvail
     *            Amount of bytes available from input for encoding.
     * @param context
     *            the context to be used","@Override
void encode(final byte[] in, int inPos, final int inAvail, final Context context) {
    if (context.eof) {
        return;
    }
    // inAvail < 0 is how we're informed of EOF in the underlying data we're
    // encoding.
    if (inAvail < 0) {
        context.eof = true;
        if (0 == context.modulus && lineLength == 0) {
            // no leftovers to process and not using chunking
            return;
        }
        final byte[] buffer = ensureBufferSize(encodeSize, context);
        final int savedPos = context.pos;
        switch(// 0-2
        context.modulus) {
            case // nothing to do here
            0:
                break;
            case // 8 bits = 6 + 2
            1:
                // top 6 bits:
                buffer[context.pos++] = encodeTable[context.ibitWorkArea >> 2 & MASK_6BITS];
                // remaining 2:
                buffer[context.pos++] = encodeTable[context.ibitWorkArea << 4 & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[context.pos++] = pad;
                    buffer[context.pos++] = pad;
                }
                break;
            case // 16 bits = 6 + 6 + 4
            2:
                buffer[context.pos++] = encodeTable[context.ibitWorkArea >> 10 & MASK_6BITS];
                buffer[context.pos++] = encodeTable[context.ibitWorkArea >> 4 & MASK_6BITS];
                buffer[context.pos++] = encodeTable[context.ibitWorkArea << 2 & MASK_6BITS];
                // URL-SAFE skips the padding to further reduce size.
                if (encodeTable == STANDARD_ENCODE_TABLE) {
                    buffer[context.pos++] = pad;
                }
                break;
            default:
                throw new IllegalStateException(""Impossible modulus "" + context.modulus);
        }
        // keep track of current line position
        context.currentLinePos += context.pos - savedPos;
        // if currentPos == 0 we are at the start of a line, so don't add CRLF
        if (lineLength > 0 && context.currentLinePos > 0) {
            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
            context.pos += lineSeparator.length;
        }
    } else {
        for (int i = 0; i < inAvail; i++) {
            final byte[] buffer = ensureBufferSize(encodeSize, context);
            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;
            int b = in[inPos++];
            if (b < 0) {
                b += 256;
            }
            // BITS_PER_BYTE
            context.ibitWorkArea = (context.ibitWorkArea << 8) + b;
            if (0 == context.modulus) {
                // 3 bytes = 24 bits = 4 * 6 bits to extract
                buffer[context.pos++] = encodeTable[context.ibitWorkArea >> 18 & MASK_6BITS];
                buffer[context.pos++] = encodeTable[context.ibitWorkArea >> 12 & MASK_6BITS];
                buffer[context.pos++] = encodeTable[context.ibitWorkArea >> 6 & MASK_6BITS];
                buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
                if (lineLength > 0 && lineLength <= context.currentLinePos) {
                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);
                    context.pos += lineSeparator.length;
                    context.currentLinePos = 0;
                }
            }
        }
    }
}","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encode(byte[],int,int,Context).in","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encode(byte[],int,int,Context).inPos","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encode(byte[],int,int,Context).inAvail","Parameter_3","Belong to org.apache.commons.codec.binary.Base64.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.encode(byte[],int,int,Context).context","Parameter_4","Belong to org.apache.commons.codec.binary.Base64.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.getLineSeparator()","Method","* Gets the line separator (for testing only).
     *
     * @return the line separator.","byte[] getLineSeparator() {
    return lineSeparator;
}","byte[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isInAlphabet(byte)","Method","* Returns whether or not the {@code octet} is in the Base64 alphabet.
     *
     * @param octet
     *            The value to test
     * @return {@code true} if the value is defined in the Base64 alphabet {@code false} otherwise.","@Override
protected boolean isInAlphabet(final byte octet) {
    return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isInAlphabet(byte).octet","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.isInAlphabet(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.isUrlSafe()","Method","* Returns our current encode mode. True if we're URL-safe, false otherwise.
     *
     * @return true if we're in URL-safe mode, false otherwise.
     * @since 1.4","public boolean isUrlSafe() {
    return isUrlSafe;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.validateCharacter(int,Context)","Method","* Validates whether decoding the final trailing character is possible in the context
     * of the set of possible base 64 values.
     * <p>
     * The character is valid if the lower bits within the provided mask are zero. This
     * is used to test the final trailing base-64 digit is zero in the bits that will be discarded.
     * </p>
     *
     * @param emptyBitsMask The mask of the lower bits that should be empty
     * @param context the context to be used
     * @throws IllegalArgumentException if the bits being checked contain any non-zero value","private void validateCharacter(final int emptyBitsMask, final Context context) {
    if (isStrictDecoding() && (context.ibitWorkArea & emptyBitsMask) != 0) {
        throw new IllegalArgumentException(""Strict decoding: Last encoded character (before the paddings if any) is a valid "" + ""base 64 alphabet but not a possible encoding. "" + ""Expected the discarded bits from the character to be zero."");
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.validateCharacter(int,Context).emptyBitsMask","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.validateCharacter(int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.validateCharacter(int,Context).context","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.validateCharacter(int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.validateTrailingCharacter()","Method","* Validates whether decoding allows an entire final trailing character that cannot be
     * used for a complete byte.
     *
     * @throws IllegalArgumentException if strict decoding is enabled","private void validateTrailingCharacter() {
    if (isStrictDecoding()) {
        throw new IllegalArgumentException(""Strict decoding: Last encoded character (before the paddings if any) is a valid "" + ""base 64 alphabet but not a possible encoding. "" + ""Decoding requires at least two trailing 6-bit characters to create bytes."");
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>()","Constructor","* Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * <p>
     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.
     * </p>
     * <p>
     * When decoding all variants are supported.
     * </p>","public Base64() {
    this(0);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(boolean)","Constructor","* Constructs a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.
     * <p>
     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.
     * </p>
     * <p>
     * When decoding all variants are supported.
     * </p>
     *
     * @param urlSafe
     *            if {@code true}, URL-safe encoding is used. In most cases this should be set to
     *            {@code false}.
     * @since 1.4","public Base64(final boolean urlSafe) {
    this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(boolean).urlSafe","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.<init>(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int)","Constructor","* Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * <p>
     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
     * STANDARD_ENCODE_TABLE.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
     * </p>
     * <p>
     * When decoding all variants are supported.
     * </p>
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of
     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     * @since 1.4","public Base64(final int lineLength) {
    this(lineLength, CHUNK_SEPARATOR);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.<init>(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[])","Constructor","* Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * <p>
     * When encoding the line length and line separator are given in the constructor, and the encoding table is
     * STANDARD_ENCODE_TABLE.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
     * </p>
     * <p>
     * When decoding all variants are supported.
     * </p>
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of
     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     * @param lineSeparator
     *            Each line of encoded data will end with this sequence of bytes.
     * @throws IllegalArgumentException
     *             Thrown when the provided lineSeparator included some base64 characters.
     * @since 1.4","public Base64(final int lineLength, final byte[] lineSeparator) {
    this(lineLength, lineSeparator, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[]).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[]).lineSeparator","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean)","Constructor","* Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * <p>
     * When encoding the line length and line separator are given in the constructor, and the encoding table is
     * STANDARD_ENCODE_TABLE.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
     * </p>
     * <p>
     * When decoding all variants are supported.
     * </p>
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of
     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     * @param lineSeparator
     *            Each line of encoded data will end with this sequence of bytes.
     * @param urlSafe
     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode
     *            operations. Decoding seamlessly handles both modes.
     *            <strong>Note: No padding is added when using the URL-safe alphabet.</strong>
     * @throws IllegalArgumentException
     *             Thrown when the {@code lineSeparator} contains Base64 characters.
     * @since 1.4","public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {
    this(lineLength, lineSeparator, PAD_DEFAULT, toUrlSafeEncodeTable(urlSafe), DECODING_POLICY_DEFAULT);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean).lineSeparator","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean).urlSafe","Parameter_3","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean,CodecPolicy)","Constructor","* Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * <p>
     * When encoding the line length and line separator are given in the constructor, and the encoding table is
     * STANDARD_ENCODE_TABLE.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
     * </p>
     * <p>
     * When decoding all variants are supported.
     * </p>
     *
     * @param lineLength
     *            Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of
     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when
     *            decoding.
     * @param lineSeparator
     *            Each line of encoded data will end with this sequence of bytes.
     * @param urlSafe
     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode
     *            operations. Decoding seamlessly handles both modes.
     *            <strong>Note: No padding is added when using the URL-safe alphabet.</strong>
     * @param decodingPolicy The decoding policy.
     * @throws IllegalArgumentException
     *             Thrown when the {@code lineSeparator} contains Base64 characters.
     * @since 1.15","public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe, final CodecPolicy decodingPolicy) {
    this(lineLength, lineSeparator, PAD_DEFAULT, toUrlSafeEncodeTable(urlSafe), decodingPolicy);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean,CodecPolicy).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean,CodecPolicy).lineSeparator","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean,CodecPolicy).urlSafe","Parameter_3","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean,CodecPolicy).decodingPolicy","Parameter_4","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy)","Constructor","* Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
     * <p>
     * When encoding the line length and line separator are given in the constructor, and the encoding table is STANDARD_ENCODE_TABLE.
     * </p>
     * <p>
     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
     * </p>
     * <p>
     * When decoding all variants are supported.
     * </p>
     *
     * @param lineLength     Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 4). If lineLength &lt;= 0,
     *                       then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator  Each line of encoded data will end with this sequence of bytes; the constructor makes a defensive copy. May be null.
     * @param padding        padding byte.
     * @param encodeTable    The manual encodeTable - a byte array of 64 chars.
     * @param decodingPolicy The decoding policy.
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base64 characters.","private Base64(final int lineLength, final byte[] lineSeparator, final byte padding, final byte[] encodeTable, final CodecPolicy decodingPolicy) {
    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, toLength(lineSeparator), padding, decodingPolicy);
    Objects.requireNonNull(encodeTable, ""encodeTable"");
    if (encodeTable.length != ALPHABET_LENGTH) {
        throw new IllegalArgumentException(""encodeTable must have exactly 64 entries."");
    }
    this.isUrlSafe = encodeTable == URL_SAFE_ENCODE_TABLE;
    if (encodeTable == STANDARD_ENCODE_TABLE || this.isUrlSafe) {
        decodeTable = DECODE_TABLE;
        // No need of a defensive copy of an internal table.
        this.encodeTable = encodeTable;
    } else {
        this.encodeTable = encodeTable.clone();
        this.decodeTable = calculateDecodeTable(this.encodeTable);
    }
    // TODO could be simplified if there is no requirement to reject invalid line sep when length <=0
    // @see test case Base64Test.testConstructors()
    if (lineSeparator != null) {
        final byte[] lineSeparatorCopy = lineSeparator.clone();
        if (containsAlphabetOrPad(lineSeparatorCopy)) {
            final String sep = StringUtils.newStringUtf8(lineSeparatorCopy);
            throw new IllegalArgumentException(""lineSeparator must not contain base64 characters: ["" + sep + ""]"");
        }
        if (lineLength > 0) {
            // null line-sep forces no chunking rather than throwing IAE
            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparatorCopy.length;
            this.lineSeparator = lineSeparatorCopy;
        } else {
            this.encodeSize = BYTES_PER_ENCODED_BLOCK;
            this.lineSeparator = null;
        }
    } else {
        this.encodeSize = BYTES_PER_ENCODED_BLOCK;
        this.lineSeparator = null;
    }
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy).lineSeparator","Parameter_2","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy).padding","Parameter_3","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy).encodeTable","Parameter_4","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy).decodingPolicy","Parameter_5","Belong to org.apache.commons.codec.binary.Base64.<init>(int,byte[],byte,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64$Builder","Class","* Builds {@link Base64} instances.
     *
     * @since 1.17.0","Class do not obtain Source Code","No return type","public , static ","org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder",""
"org.apache.commons.codec.binary.Base64$Builder.get()","Method","No Comment","@Override
public Base64 get() {
    return new Base64(getLineLength(), getLineSeparator(), getPadding(), getEncodeTable(), getDecodingPolicy());
}","Base64","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64$Builder.setUrlSafe(boolean)","Method","* Sets the URL-safe encoding policy.
         *
         * @param urlSafe URL-safe encoding policy, null resets to the default.
         * @return {@code this} instance.","public Builder setUrlSafe(final boolean urlSafe) {
    return setEncodeTable(toUrlSafeEncodeTable(urlSafe));
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64$Builder.setUrlSafe(boolean).urlSafe","Parameter_1","Belong to org.apache.commons.codec.binary.Base64$Builder.setUrlSafe(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64$Builder.<init>()","Constructor","* Constructs a new instance.","public Builder() {
    super(STANDARD_ENCODE_TABLE);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.Builder","Class","* Builds {@link Base64} instances.
     *
     * @since 1.17.0","Class do not obtain Source Code","No return type","public , static ","org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder",""
"org.apache.commons.codec.binary.Base64.Builder.get()","Method","No Comment","@Override
public Base64 get() {
    return new Base64(getLineLength(), getLineSeparator(), getPadding(), getEncodeTable(), getDecodingPolicy());
}","Base64","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.Builder.setUrlSafe(boolean)","Method","* Sets the URL-safe encoding policy.
         *
         * @param urlSafe URL-safe encoding policy, null resets to the default.
         * @return {@code this} instance.","public Builder setUrlSafe(final boolean urlSafe) {
    return setEncodeTable(toUrlSafeEncodeTable(urlSafe));
}","Builder","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.Builder.setUrlSafe(boolean).urlSafe","Parameter_1","Belong to org.apache.commons.codec.binary.Base64.Builder.setUrlSafe(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64.Builder.<init>()","Constructor","* Constructs a new instance.","public Builder() {
    super(STANDARD_ENCODE_TABLE);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec","Abstract Class","* Abstract superclass for Base-N encoders and decoders.
 *
 * <p>
 * This class is thread-safe.
 * </p>
 * <p>
 * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a
 * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is
 * lenient decoding.
 * </p>
 * <ul>
 * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.
 * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid
 * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not
 * allowed.
 * </ul>
 * <p>
 * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches
 * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding
 * and alphabet as the encoder.
 * </p>","Abstract Class do not obtain Source Code","No return type","public , abstract ","","org.apache.commons.codec.BinaryEncoder;org.apache.commons.codec.BinaryDecoder"
"org.apache.commons.codec.binary.BaseNCodec.EOF","Field","* EOF
     *
     * @since 1.7","static final int EOF = -1;","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.MIME_CHUNK_SIZE","Field","*  MIME chunk size per RFC 2045 section 6.8.
     *
     * <p>
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * </p>
     *
     * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045 section 6.8</a>","public static final int MIME_CHUNK_SIZE = 76;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.PEM_CHUNK_SIZE","Field","* PEM chunk size per RFC 1421 section 4.3.2.4.
     *
     * <p>
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * </p>
     *
     * @see <a href=""https://tools.ietf.org/html/rfc1421"">RFC 1421 section 4.3.2.4</a>","public static final int PEM_CHUNK_SIZE = 64;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.DEFAULT_BUFFER_RESIZE_FACTOR","Field","No Comment","private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.DEFAULT_BUFFER_SIZE","Field","* Defines the default buffer size - currently {@value}
     * - must be large enough for at least one encoded block+separator","private static final int DEFAULT_BUFFER_SIZE = 8192;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.MAX_BUFFER_SIZE","Field","* The maximum size buffer to allocate.
     *
     * <p>This is set to the same size used in the JDK {@link java.util.ArrayList}:</p>
     * <blockquote>
     * Some VMs reserve some header words in an array.
     * Attempts to allocate larger arrays may result in
     * OutOfMemoryError: Requested array size exceeds VM limit.
     * </blockquote>","private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.MASK_8BITS","Field","Mask used to extract 8 bits, used in decoding bytes","protected static final int MASK_8BITS = 0xff;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.PAD_DEFAULT","Field","Allow static access to default","protected static final byte PAD_DEFAULT = '=';","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.DECODING_POLICY_DEFAULT","Field","* The default decoding policy.
     * @since 1.15","protected static final CodecPolicy DECODING_POLICY_DEFAULT = CodecPolicy.LENIENT;","No return type","protected , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.CHUNK_SEPARATOR","Field","* Chunk separator per RFC 2045 section 2.1.
     *
     * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045 section 2.1</a>","static final byte[] CHUNK_SEPARATOR = { '\r', '\n' };","No return type","static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.PAD","Field","* @deprecated Use {@link #pad}. Will be removed in 2.0.","@Deprecated
protected final byte // instance variable just in case it needs to vary later
PAD = PAD_DEFAULT;","No return type","protected , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.pad","Field","Pad byte. Instance variable just in case it needs to vary later.","protected final byte pad;","No return type","protected , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.unencodedBlockSize","Field","Number of bytes in each full block of unencoded data, for example 4 for Base64 and 5 for Base32","private final int unencodedBlockSize;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encodedBlockSize","Field","Number of bytes in each full block of encoded data, for example 3 for Base64 and 8 for Base32","private final int encodedBlockSize;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.lineLength","Field","* Chunksize for encoding. Not used when decoding.
     * A value of zero or less implies no chunking of the encoded data.
     * Rounded down to the nearest multiple of encodedBlockSize.","protected final int lineLength;","No return type","protected , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.chunkSeparatorLength","Field","* Size of chunk separator. Not used unless {@link #lineLength} &gt; 0.","private final int chunkSeparatorLength;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decodingPolicy","Field","* Defines the decoding behavior when the input bytes contain leftover trailing bits that
     * cannot be created by a valid encoding. These can be bits that are unused from the final
     * character or entire characters. The default mode is lenient decoding. Set this to
     * {@code true} to enable strict decoding.
     * <ul>
     * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible.
     *     The remainder are discarded.
     * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits
     *     are not part of a valid encoding. Any unused bits from the final character must
     *     be zero. Impossible counts of entire final characters are not allowed.
     * </ul>
     * <p>
     * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded
     * to a byte array that matches the original, i.e. no changes occur on the final
     * character. This requires that the input bytes use the same padding and alphabet
     * as the encoder.
     * </p>","private final CodecPolicy decodingPolicy;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.createPositiveCapacity(int)","Method","* Create a positive capacity at least as large the minimum required capacity.
     * If the minimum capacity is negative then this throws an OutOfMemoryError as no array
     * can be allocated.
     *
     * @param minCapacity the minimum capacity
     * @return the capacity
     * @throws OutOfMemoryError if the {@code minCapacity} is negative","private static int createPositiveCapacity(final int minCapacity) {
    if (minCapacity < 0) {
        // overflow
        throw new OutOfMemoryError(""Unable to allocate array size: "" + (minCapacity & 0xffffffffL));
    }
    // This is called when we require buffer expansion to a very big array.
    // Use the conservative maximum buffer size if possible, otherwise the biggest required.
    //
    // Note: In this situation JDK 1.8 java.util.ArrayList returns Integer.MAX_VALUE.
    // This excludes some VMs that can exceed MAX_BUFFER_SIZE but not allocate a full
    // Integer.MAX_VALUE length array.
    // The result is that we may have to allocate an array of this size more than once if
    // the capacity must be expanded again.
    return Math.max(minCapacity, MAX_BUFFER_SIZE);
}","int","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.createPositiveCapacity(int).minCapacity","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.createPositiveCapacity(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.getChunkSeparator()","Method","* Gets a copy of the chunk separator per RFC 2045 section 2.1.
     *
     * @return the chunk separator
     * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045 section 2.1</a>
     * @since 1.15","public static byte[] getChunkSeparator() {
    return CHUNK_SEPARATOR.clone();
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isWhiteSpace(byte)","Method","* Checks if a byte value is whitespace or not.
     * @param byteToCheck
     *            the byte to check
     * @return true if byte is whitespace, false otherwise
     * @see Character#isWhitespace(int)
     * @deprecated Use {@link Character#isWhitespace(int)}.","@Deprecated
protected static boolean isWhiteSpace(final byte byteToCheck) {
    return Character.isWhitespace(byteToCheck);
}","boolean","protected , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isWhiteSpace(byte).byteToCheck","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.isWhiteSpace(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.resizeBuffer(Context,int)","Method","* Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.
     * @param context the context to be used
     * @param minCapacity the minimum required capacity
     * @return the resized byte[] buffer
     * @throws OutOfMemoryError if the {@code minCapacity} is negative","private static byte[] resizeBuffer(final Context context, final int minCapacity) {
    // Overflow-conscious code treats the min and new capacity as unsigned.
    final int oldCapacity = context.buffer.length;
    int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR;
    if (Integer.compareUnsigned(newCapacity, minCapacity) < 0) {
        newCapacity = minCapacity;
    }
    if (Integer.compareUnsigned(newCapacity, MAX_BUFFER_SIZE) > 0) {
        newCapacity = createPositiveCapacity(minCapacity);
    }
    final byte[] b = Arrays.copyOf(context.buffer, newCapacity);
    context.buffer = b;
    return b;
}","byte[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.resizeBuffer(Context,int).context","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.resizeBuffer(Context,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.resizeBuffer(Context,int).minCapacity","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.resizeBuffer(Context,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.toLength(byte[])","Method","* Gets the array length or 0 if null.
     *
     * @param array the array or null.
     * @return the array length or 0 if null.","static int toLength(final byte[] array) {
    return array == null ? 0 : array.length;
}","int","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.toLength(byte[]).array","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.toLength(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.available(Context)","Method","* Returns the amount of buffered data available for reading.
     *
     * @param context the context to be used
     * @return The amount of buffered data available for reading.","int available(final Context context) {
    // package protected for access from I/O streams
    return hasData(context) ? context.pos - context.readPos : 0;
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.available(Context).context","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.available(Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.containsAlphabetOrPad(byte[])","Method","* Tests a given byte array to see if it contains any characters within the alphabet or PAD.
     *
     * Intended for use in checking line-ending arrays
     *
     * @param arrayOctet
     *            byte array to test
     * @return {@code true} if any byte is a valid character in the alphabet or PAD; {@code false} otherwise","protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {
    if (arrayOctet != null) {
        for (final byte element : arrayOctet) {
            if (pad == element || isInAlphabet(element)) {
                return true;
            }
        }
    }
    return false;
}","boolean","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.containsAlphabetOrPad(byte[]).arrayOctet","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.containsAlphabetOrPad(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(byte[])","Method","* Decodes a byte[] containing characters in the Base-N alphabet.
     *
     * @param pArray
     *            A byte array containing Base-N character data
     * @return a byte array containing binary data","@Override
public byte[] decode(final byte[] pArray) {
    if (BinaryCodec.isEmpty(pArray)) {
        return pArray;
    }
    final Context context = new Context();
    decode(pArray, 0, pArray.length, context);
    // Notify decoder of EOF.
    decode(pArray, 0, EOF, context);
    final byte[] result = new byte[context.pos];
    readResults(result, 0, result.length, context);
    return result;
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(byte[]).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.decode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(byte[],int,int,Context)","Abstract Method","package protected for access from I/O streams","abstract void decode(byte[] pArray, int i, int length, Context context);","void","abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(byte[],int,int,Context).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(byte[],int,int,Context).i","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(byte[],int,int,Context).length","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodec.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(byte[],int,int,Context).context","Parameter_4","Belong to org.apache.commons.codec.binary.BaseNCodec.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(Object)","Method","* Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of
     * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.
     *
     * @param obj
     *            Object to decode
     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String
     *         supplied.
     * @throws DecoderException
     *             if the parameter supplied is not of type byte[]","@Override
public Object decode(final Object obj) throws DecoderException {
    if (obj instanceof byte[]) {
        return decode((byte[]) obj);
    }
    if (obj instanceof String) {
        return decode((String) obj);
    }
    throw new DecoderException(""Parameter supplied to Base-N decode is not a byte[] or a String"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.decode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(String)","Method","* Decodes a String containing characters in the Base-N alphabet.
     *
     * @param pArray
     *            A String containing Base-N character data
     * @return a byte array containing binary data","public byte[] decode(final String pArray) {
    return decode(StringUtils.getBytesUtf8(pArray));
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.decode(String).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.decode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[])","Method","* Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A byte array containing only the base N alphabetic character data","@Override
public byte[] encode(final byte[] pArray) {
    if (BinaryCodec.isEmpty(pArray)) {
        return pArray;
    }
    return encode(pArray, 0, pArray.length);
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[]).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.encode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int)","Method","* Encodes a byte[] containing binary data, into a byte[] containing
     * characters in the alphabet.
     *
     * @param pArray
     *            a byte array containing binary data
     * @param offset
     *            initial offset of the subarray.
     * @param length
     *            length of the subarray.
     * @return A byte array containing only the base N alphabetic character data
     * @since 1.11","public byte[] encode(final byte[] pArray, final int offset, final int length) {
    if (BinaryCodec.isEmpty(pArray)) {
        return pArray;
    }
    final Context context = new Context();
    encode(pArray, offset, length, context);
    // Notify encoder of EOF.
    encode(pArray, offset, EOF, context);
    final byte[] buf = new byte[context.pos - context.readPos];
    readResults(buf, 0, buf.length, context);
    return buf;
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int).length","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int,Context)","Abstract Method","package protected for access from I/O streams","abstract void encode(byte[] pArray, int i, int length, Context context);","void","abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int,Context).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int,Context).i","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int,Context).length","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int,Context).context","Parameter_4","Belong to org.apache.commons.codec.binary.BaseNCodec.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(Object)","Method","* Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of
     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
     *
     * @param obj
     *            Object to encode
     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type byte[]","@Override
public Object encode(final Object obj) throws EncoderException {
    if (!(obj instanceof byte[])) {
        throw new EncoderException(""Parameter supplied to Base-N encode is not a byte[]"");
    }
    return encode((byte[]) obj);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encode(Object).obj","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encodeAsString(byte[])","Method","* Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.
     * Uses UTF8 encoding.
     * <p>
     * This is a duplicate of {@link #encodeToString(byte[])}; it was merged during refactoring.
     * </p>
     *
     * @param pArray a byte array containing binary data
     * @return String containing only character data in the appropriate alphabet.
     * @since 1.5","public String encodeAsString(final byte[] pArray) {
    return StringUtils.newStringUtf8(encode(pArray));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encodeAsString(byte[]).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.encodeAsString(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[])","Method","* Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.
     * Uses UTF8 encoding.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A String containing only Base-N character data","public String encodeToString(final byte[] pArray) {
    return StringUtils.newStringUtf8(encode(pArray));
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[]).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int,Context)","Method","* Ensure that the buffer has room for {@code size} bytes
     *
     * @param size minimum spare space required
     * @param context the context to be used
     * @return the buffer","protected byte[] ensureBufferSize(final int size, final Context context) {
    if (context.buffer == null) {
        context.buffer = new byte[Math.max(size, getDefaultBufferSize())];
        context.pos = 0;
        context.readPos = 0;
        // Overflow-conscious:
        // x + y > z == x + y - z > 0
    } else if (context.pos + size - context.buffer.length > 0) {
        return resizeBuffer(context, context.pos + size);
    }
    return context.buffer;
}","byte[]","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int,Context).size","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int,Context).context","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.getCodecPolicy()","Method","* Returns the decoding behavior policy.
     *
     * <p>
     * The default is lenient. If the decoding policy is strict, then decoding will raise an
     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding. Decoding will compose
     * trailing bits into 8-bit bytes and discard the remainder.
     * </p>
     *
     * @return true if using strict decoding
     * @since 1.15","public CodecPolicy getCodecPolicy() {
    return decodingPolicy;
}","CodecPolicy","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.getDefaultBufferSize()","Method","* Gets the default buffer size. Can be overridden.
     *
     * @return the default buffer size.","protected int getDefaultBufferSize() {
    return DEFAULT_BUFFER_SIZE;
}","int","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.getEncodedLength(byte[])","Method","* Calculates the amount of space needed to encode the supplied array.
     *
     * @param pArray byte[] array which will later be encoded
     * @return amount of space needed to encode the supplied array.
     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE","public long getEncodedLength(final byte[] pArray) {
    // Calculate non-chunked size - rounded up to allow for padding
    // cast to long is needed to avoid possibility of overflow
    long len = (pArray.length + unencodedBlockSize - 1) / unencodedBlockSize * (long) encodedBlockSize;
    if (lineLength > 0) {
        // We're using chunking
        // Round up to nearest multiple
        len += (len + lineLength - 1) / lineLength * chunkSeparatorLength;
    }
    return len;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.getEncodedLength(byte[]).pArray","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.getEncodedLength(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.hasData(Context)","Method","* Returns true if this object has buffered data for reading.
     *
     * @param context the context to be used
     * @return true if there is data still available for reading.","boolean hasData(final Context context) {
    // package protected for access from I/O streams
    return context.pos > context.readPos;
}","boolean","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.hasData(Context).context","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.hasData(Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte)","Abstract Method","* Returns whether or not the {@code octet} is in the current alphabet.
     * Does not allow whitespace or pad.
     *
     * @param value The value to test
     * @return {@code true} if the value is defined in the current alphabet, {@code false} otherwise.","protected abstract boolean isInAlphabet(byte value);","boolean","protected , abstract ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte).value","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte[],boolean)","Method","* Tests a given byte array to see if it contains only valid characters within the alphabet.
     * The method optionally treats whitespace and pad as valid.
     *
     * @param arrayOctet byte array to test
     * @param allowWSPad if {@code true}, then whitespace and PAD are also allowed
     * @return {@code true} if all bytes are valid characters in the alphabet or if the byte array is empty;
     *         {@code false}, otherwise","public boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {
    for (final byte octet : arrayOctet) {
        if (!isInAlphabet(octet) && (!allowWSPad || octet != pad && !Character.isWhitespace(octet))) {
            return false;
        }
    }
    return true;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte[],boolean).arrayOctet","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte[],boolean).allowWSPad","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(String)","Method","* Tests a given String to see if it contains only valid characters within the alphabet.
     * The method treats whitespace and PAD as valid.
     *
     * @param basen String to test
     * @return {@code true} if all characters in the String are valid characters in the alphabet or if
     *         the String is empty; {@code false}, otherwise
     * @see #isInAlphabet(byte[], boolean)","public boolean isInAlphabet(final String basen) {
    return isInAlphabet(StringUtils.getBytesUtf8(basen), true);
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(String).basen","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()","Method","* Returns true if decoding behavior is strict. Decoding will raise an {@link IllegalArgumentException} if trailing
     * bits are not part of a valid encoding.
     *
     * <p>
     * The default is false for lenient decoding. Decoding will compose trailing bits into 8-bit bytes and discard the
     * remainder.
     * </p>
     *
     * @return true if using strict decoding
     * @since 1.15","public boolean isStrictDecoding() {
    return decodingPolicy == CodecPolicy.STRICT;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.readResults(byte[],int,int,Context)","Method","* Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail
     * bytes. Returns how many bytes were actually extracted.
     * <p>
     * Package private for access from I/O streams.
     * </p>
     *
     * @param b
     *            byte[] array to extract the buffered data into.
     * @param bPos
     *            position in byte[] array to start extraction at.
     * @param bAvail
     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).
     * @param context
     *            the context to be used
     * @return The number of bytes successfully extracted into the provided byte[] array.","int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {
    if (hasData(context)) {
        final int len = Math.min(available(context), bAvail);
        System.arraycopy(context.buffer, context.readPos, b, bPos, len);
        context.readPos += len;
        if (!hasData(context)) {
            // All data read.
            // Reset position markers but do not set buffer to null to allow its reuse.
            // hasData(context) will still return false, and this method will return 0 until
            // more data is available, or -1 if EOF.
            context.pos = context.readPos = 0;
        }
        return len;
    }
    return context.eof ? EOF : 0;
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.readResults(byte[],int,int,Context).b","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.readResults(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.readResults(byte[],int,int,Context).bPos","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.readResults(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.readResults(byte[],int,int,Context).bAvail","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodec.readResults(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.readResults(byte[],int,int,Context).context","Parameter_4","Belong to org.apache.commons.codec.binary.BaseNCodec.readResults(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int)","Constructor","* Constructs a new instance.
     * <p>
     * Note {@code lineLength} is rounded down to the nearest multiple of the encoded block size.
     * If {@code chunkSeparatorLength} is zero, then chunking is disabled.
     * </p>
     *
     * @param unencodedBlockSize the size of an unencoded block (for example Base64 = 3)
     * @param encodedBlockSize the size of an encoded block (for example Base64 = 4)
     * @param lineLength if &gt; 0, use chunking with a length {@code lineLength}
     * @param chunkSeparatorLength the chunk separator length, if relevant","protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength) {
    this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, PAD_DEFAULT);
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int).unencodedBlockSize","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int).encodedBlockSize","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int).chunkSeparatorLength","Parameter_4","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte)","Constructor","* Constructs a new instance.
     * <p>
     * Note {@code lineLength} is rounded down to the nearest multiple of the encoded block size.
     * If {@code chunkSeparatorLength} is zero, then chunking is disabled.
     * </p>
     *
     * @param unencodedBlockSize the size of an unencoded block (for example Base64 = 3)
     * @param encodedBlockSize the size of an encoded block (for example Base64 = 4)
     * @param lineLength if &gt; 0, use chunking with a length {@code lineLength}
     * @param chunkSeparatorLength the chunk separator length, if relevant
     * @param pad byte used as padding byte.","protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength, final byte pad) {
    this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, pad, DECODING_POLICY_DEFAULT);
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte).unencodedBlockSize","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte).encodedBlockSize","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte).chunkSeparatorLength","Parameter_4","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte).pad","Parameter_5","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy)","Constructor","* Constructs a new instance.
     * <p>
     * Note {@code lineLength} is rounded down to the nearest multiple of the encoded block size.
     * If {@code chunkSeparatorLength} is zero, then chunking is disabled.
     * </p>
     *
     * @param unencodedBlockSize the size of an unencoded block (for example Base64 = 3)
     * @param encodedBlockSize the size of an encoded block (for example Base64 = 4)
     * @param lineLength if &gt; 0, use chunking with a length {@code lineLength}
     * @param chunkSeparatorLength the chunk separator length, if relevant
     * @param pad byte used as padding byte.
     * @param decodingPolicy Decoding policy.
     * @since 1.15","protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength, final byte pad, final CodecPolicy decodingPolicy) {
    this.unencodedBlockSize = unencodedBlockSize;
    this.encodedBlockSize = encodedBlockSize;
    final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;
    this.lineLength = useChunking ? lineLength / encodedBlockSize * encodedBlockSize : 0;
    this.chunkSeparatorLength = chunkSeparatorLength;
    this.pad = pad;
    this.decodingPolicy = Objects.requireNonNull(decodingPolicy, ""codecPolicy"");
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy).unencodedBlockSize","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy).encodedBlockSize","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy).chunkSeparatorLength","Parameter_4","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy).pad","Parameter_5","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy).decodingPolicy","Parameter_6","Belong to org.apache.commons.codec.binary.BaseNCodec.<init>(int,int,int,int,byte,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder","Class","* Builds {@link Base64} instances.
     *
     * @param <T> the codec type to build.
     * @param <B> the codec builder subtype.
     * @since 1.17.0","Class do not obtain Source Code","No return type","public , abstract , static ","","java.util.function.Supplier"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.decodingPolicy","Field","No Comment","private CodecPolicy decodingPolicy = DECODING_POLICY_DEFAULT;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.lineLength","Field","No Comment","private int lineLength;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.lineSeparator","Field","No Comment","private byte[] lineSeparator = CHUNK_SEPARATOR;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.defaultEncodeTable","Field","No Comment","private final byte[] defaultEncodeTable;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.encodeTable","Field","No Comment","private byte[] encodeTable;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.padding","Field","Padding byte.","private byte padding = PAD_DEFAULT;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.asThis()","Method","* Returns this instance typed as the subclass type {@code B}.
         * <p>
         * This is the same as the expression:
         * </p>
         * <pre>
         * (B) this
         * </pre>
         *
         * @return this instance typed as the subclass type {@code B}.","@SuppressWarnings(""unchecked"")
B asThis() {
    return (B) this;
}","AbstractBuilder<T, B>","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.getDecodingPolicy()","Method","No Comment","CodecPolicy getDecodingPolicy() {
    return decodingPolicy;
}","CodecPolicy","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.getEncodeTable()","Method","No Comment","byte[] getEncodeTable() {
    return encodeTable;
}","byte[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.getLineLength()","Method","No Comment","int getLineLength() {
    return lineLength;
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.getLineSeparator()","Method","No Comment","byte[] getLineSeparator() {
    return lineSeparator;
}","byte[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.getPadding()","Method","No Comment","byte getPadding() {
    return padding;
}","byte","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setDecodingPolicy(CodecPolicy)","Method","* Sets the decoding policy.
         *
         * @param decodingPolicy the decoding policy, null resets to the default.
         * @return {@code this} instance.","public B setDecodingPolicy(final CodecPolicy decodingPolicy) {
    this.decodingPolicy = decodingPolicy != null ? decodingPolicy : DECODING_POLICY_DEFAULT;
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setDecodingPolicy(CodecPolicy).decodingPolicy","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setDecodingPolicy(CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setEncodeTable(byte[])","Method","* Sets the encode table.
         *
         * @param encodeTable the encode table, null resets to the default.
         * @return {@code this} instance.","public B setEncodeTable(final byte... encodeTable) {
    this.encodeTable = encodeTable != null ? encodeTable : defaultEncodeTable;
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setEncodeTable(byte[]).encodeTable","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setEncodeTable(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setLineLength(int)","Method","* Sets the line length.
         *
         * @param lineLength the line length, less than 0 resets to the default.
         * @return {@code this} instance.","public B setLineLength(final int lineLength) {
    this.lineLength = Math.max(0, lineLength);
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setLineLength(int).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setLineLength(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setLineSeparator(byte[])","Method","* Sets the line separator.
         *
         * @param lineSeparator the line separator, null resets to the default.
         * @return {@code this} instance.","public B setLineSeparator(final byte... lineSeparator) {
    this.lineSeparator = lineSeparator != null ? lineSeparator : CHUNK_SEPARATOR;
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setLineSeparator(byte[]).lineSeparator","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setLineSeparator(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setPadding(byte)","Method","* Sets the padding byte.
         *
         * @param padding the padding byte.
         * @return {@code this} instance.","public B setPadding(final byte padding) {
    this.padding = padding;
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setPadding(byte).padding","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.setPadding(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.<init>(byte[])","Constructor","No Comment","AbstractBuilder(final byte[] defaultEncodeTable) {
    this.defaultEncodeTable = defaultEncodeTable;
    this.encodeTable = defaultEncodeTable;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.<init>(byte[]).defaultEncodeTable","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec$AbstractBuilder.<init>(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$Context","Class","* Holds thread context so classes can be thread-safe.
     *
     * This class is not itself thread-safe; each thread must allocate its own copy.","Class do not obtain Source Code","No return type","static ","",""
"org.apache.commons.codec.binary.BaseNCodec$Context.ibitWorkArea","Field","* Placeholder for the bytes we're dealing with for our based logic.
         * Bitwise operations store and extract the encoding or decoding from this variable.","int ibitWorkArea;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$Context.lbitWorkArea","Field","* Placeholder for the bytes we're dealing with for our based logic.
         * Bitwise operations store and extract the encoding or decoding from this variable.","long lbitWorkArea;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$Context.buffer","Field","* Buffer for streaming.","byte[] buffer;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$Context.pos","Field","* Position where next character should be written in the buffer.","int pos;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$Context.readPos","Field","* Position where next character should be read from the buffer.","int readPos;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$Context.eof","Field","* Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,
         * and must be thrown away.","boolean eof;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$Context.currentLinePos","Field","* Variable tracks how many characters have been written to the current line. Only used when encoding. We use
         * it to make sure each encoded line never goes beyond lineLength (if lineLength &gt; 0).","int currentLinePos;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$Context.modulus","Field","* Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding. This
         * variable helps track that.","int modulus;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec$Context.toString()","Method","* Returns a String useful for debugging (especially within a debugger.)
         *
         * @return a String useful for debugging.","@Override
public String toString() {
    return String.format(""%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, "" + ""modulus=%s, pos=%s, readPos=%s]"", this.getClass().getSimpleName(), Arrays.toString(buffer), currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder","Abstract Class","* Builds {@link Base64} instances.
     *
     * @param <T> the codec type to build.
     * @param <B> the codec builder subtype.
     * @since 1.17.0","Abstract Class do not obtain Source Code","No return type","public , abstract , static ","","java.util.function.Supplier"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.decodingPolicy","Field","No Comment","private CodecPolicy decodingPolicy = DECODING_POLICY_DEFAULT;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.lineLength","Field","No Comment","private int lineLength;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.lineSeparator","Field","No Comment","private byte[] lineSeparator = CHUNK_SEPARATOR;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.defaultEncodeTable","Field","No Comment","private final byte[] defaultEncodeTable;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.encodeTable","Field","No Comment","private byte[] encodeTable;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.padding","Field","Padding byte.","private byte padding = PAD_DEFAULT;","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.asThis()","Method","* Returns this instance typed as the subclass type {@code B}.
         * <p>
         * This is the same as the expression:
         * </p>
         * <pre>
         * (B) this
         * </pre>
         *
         * @return this instance typed as the subclass type {@code B}.","@SuppressWarnings(""unchecked"")
B asThis() {
    return (B) this;
}","AbstractBuilder<T, B>","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getDecodingPolicy()","Method","No Comment","CodecPolicy getDecodingPolicy() {
    return decodingPolicy;
}","CodecPolicy","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getEncodeTable()","Method","No Comment","byte[] getEncodeTable() {
    return encodeTable;
}","byte[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getLineLength()","Method","No Comment","int getLineLength() {
    return lineLength;
}","int","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getLineSeparator()","Method","No Comment","byte[] getLineSeparator() {
    return lineSeparator;
}","byte[]","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getPadding()","Method","No Comment","byte getPadding() {
    return padding;
}","byte","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setDecodingPolicy(CodecPolicy)","Method","* Sets the decoding policy.
         *
         * @param decodingPolicy the decoding policy, null resets to the default.
         * @return {@code this} instance.","public B setDecodingPolicy(final CodecPolicy decodingPolicy) {
    this.decodingPolicy = decodingPolicy != null ? decodingPolicy : DECODING_POLICY_DEFAULT;
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setDecodingPolicy(CodecPolicy).decodingPolicy","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setDecodingPolicy(CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setEncodeTable(byte[])","Method","* Sets the encode table.
         *
         * @param encodeTable the encode table, null resets to the default.
         * @return {@code this} instance.","public B setEncodeTable(final byte... encodeTable) {
    this.encodeTable = encodeTable != null ? encodeTable : defaultEncodeTable;
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setEncodeTable(byte[]).encodeTable","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setEncodeTable(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineLength(int)","Method","* Sets the line length.
         *
         * @param lineLength the line length, less than 0 resets to the default.
         * @return {@code this} instance.","public B setLineLength(final int lineLength) {
    this.lineLength = Math.max(0, lineLength);
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineLength(int).lineLength","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineLength(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineSeparator(byte[])","Method","* Sets the line separator.
         *
         * @param lineSeparator the line separator, null resets to the default.
         * @return {@code this} instance.","public B setLineSeparator(final byte... lineSeparator) {
    this.lineSeparator = lineSeparator != null ? lineSeparator : CHUNK_SEPARATOR;
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineSeparator(byte[]).lineSeparator","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineSeparator(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setPadding(byte)","Method","* Sets the padding byte.
         *
         * @param padding the padding byte.
         * @return {@code this} instance.","public B setPadding(final byte padding) {
    this.padding = padding;
    return asThis();
}","AbstractBuilder<T, B>","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setPadding(byte).padding","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setPadding(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.<init>(byte[])","Constructor","No Comment","AbstractBuilder(final byte[] defaultEncodeTable) {
    this.defaultEncodeTable = defaultEncodeTable;
    this.encodeTable = defaultEncodeTable;
}","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.<init>(byte[]).defaultEncodeTable","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.<init>(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.Context","Class","* Holds thread context so classes can be thread-safe.
     *
     * This class is not itself thread-safe; each thread must allocate its own copy.","Class do not obtain Source Code","No return type","static ","",""
"org.apache.commons.codec.binary.BaseNCodec.Context.ibitWorkArea","Field","* Placeholder for the bytes we're dealing with for our based logic.
         * Bitwise operations store and extract the encoding or decoding from this variable.","int ibitWorkArea;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.Context.lbitWorkArea","Field","* Placeholder for the bytes we're dealing with for our based logic.
         * Bitwise operations store and extract the encoding or decoding from this variable.","long lbitWorkArea;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.Context.buffer","Field","* Buffer for streaming.","byte[] buffer;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.Context.pos","Field","* Position where next character should be written in the buffer.","int pos;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.Context.readPos","Field","* Position where next character should be read from the buffer.","int readPos;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.Context.eof","Field","* Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,
         * and must be thrown away.","boolean eof;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.Context.currentLinePos","Field","* Variable tracks how many characters have been written to the current line. Only used when encoding. We use
         * it to make sure each encoded line never goes beyond lineLength (if lineLength &gt; 0).","int currentLinePos;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.Context.modulus","Field","* Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding. This
         * variable helps track that.","int modulus;","No return type","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodec.Context.toString()","Method","* Returns a String useful for debugging (especially within a debugger.)
         *
         * @return a String useful for debugging.","@Override
public String toString() {
    return String.format(""%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, "" + ""modulus=%s, pos=%s, readPos=%s]"", this.getClass().getSimpleName(), Arrays.toString(buffer), currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream","Class","* Provides Base16 decoding in a streaming fashion (unlimited size).
 * <p>
 * The default behavior of the Base16InputStream is to DECODE, whereas the default behavior of the
 * {@link Base16OutputStream} is to ENCODE, but this behavior can be overridden by using a different constructor.
 * </p>
 *
 * @since 1.15","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.binary.BaseNCodecInputStream",""
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream)","Constructor","* Constructs a Base16InputStream such that all data read is Base16-decoded from the original provided InputStream.
     *
     * @param inputStream InputStream to wrap.","public Base16InputStream(final InputStream inputStream) {
    this(inputStream, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean)","Constructor","* Constructs a Base16InputStream such that all data read is either Base16-encoded or Base16-decoded from the original
     * provided InputStream.
     *
     * @param inputStream InputStream to wrap.
     * @param doEncode true if we should encode all data read from us, false if we should decode.","public Base16InputStream(final InputStream inputStream, final boolean doEncode) {
    this(inputStream, doEncode, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean)","Constructor","* Constructs a Base16InputStream such that all data read is either Base16-encoded or Base16-decoded from the original
     * provided InputStream.
     *
     * @param inputStream InputStream to wrap.
     * @param doEncode true if we should encode all data read from us, false if we should decode.
     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.","public Base16InputStream(final InputStream inputStream, final boolean doEncode, final boolean lowerCase) {
    this(inputStream, doEncode, lowerCase, CodecPolicy.LENIENT);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean).lowerCase","Parameter_3","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean,CodecPolicy)","Constructor","* Constructs a Base16InputStream such that all data read is either Base16-encoded or Base16-decoded from the original
     * provided InputStream.
     *
     * @param inputStream InputStream to wrap.
     * @param doEncode true if we should encode all data read from us, false if we should decode.
     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
     * @param decodingPolicy Decoding policy.","public Base16InputStream(final InputStream inputStream, final boolean doEncode, final boolean lowerCase, final CodecPolicy decodingPolicy) {
    super(inputStream, new Base16(lowerCase, decodingPolicy), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean,CodecPolicy).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean,CodecPolicy).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean,CodecPolicy).lowerCase","Parameter_3","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean,CodecPolicy).decodingPolicy","Parameter_4","Belong to org.apache.commons.codec.binary.Base16InputStream.<init>(InputStream,boolean,boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream","Class","* Provides Base32 decoding in a streaming fashion (unlimited size). When encoding the default lineLength
 * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate
 * constructor.
 * <p>
 * The default behavior of the Base32InputStream is to DECODE, whereas the default behavior of the Base32OutputStream
 * is to ENCODE, but this behavior can be overridden by using a different constructor.
 * </p>
 * <p>
 * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
 * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
 * </p>
 * <p>
 * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a
 * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is
 * lenient decoding.
 * </p>
 * <ul>
 * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.
 * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid
 * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not
 * allowed.
 * </ul>
 * <p>
 * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches
 * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding
 * and alphabet as the encoder.
 * </p>
 * @see <a href=""http://www.ietf.org/rfc/rfc4648.txt"">RFC 4648</a>
 * @since 1.5","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.binary.BaseNCodecInputStream",""
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream)","Constructor","* Constructs a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.
     *
     * @param inputStream
     *            InputStream to wrap.","public Base32InputStream(final InputStream inputStream) {
    this(inputStream, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean)","Constructor","* Constructs a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original
     * provided InputStream.
     *
     * @param inputStream
     *            InputStream to wrap.
     * @param doEncode
     *            true if we should encode all data read from us, false if we should decode.","public Base32InputStream(final InputStream inputStream, final boolean doEncode) {
    super(inputStream, new Base32(false), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[])","Constructor","* Constructs a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original
     * provided InputStream.
     *
     * @param inputStream
     *            InputStream to wrap.
     * @param doEncode
     *            true if we should encode all data read from us, false if we should decode.
     * @param lineLength
     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If
     *            doEncode is false, lineLength is ignored.
     * @param lineSeparator
     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (for example \r\n).
     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.","public Base32InputStream(final InputStream inputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {
    super(inputStream, new Base32(lineLength, lineSeparator), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[]).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[]).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[]).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[]).lineSeparator","Parameter_4","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Constructor","* Constructs a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original
     * provided InputStream.
     *
     * @param inputStream
     *            InputStream to wrap.
     * @param doEncode
     *            true if we should encode all data read from us, false if we should decode.
     * @param lineLength
     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If
     *            doEncode is false, lineLength is ignored.
     * @param lineSeparator
     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (for example \r\n).
     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.
     * @param decodingPolicy
     *            The decoding policy.
     * @since 1.15","public Base32InputStream(final InputStream inputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator, final CodecPolicy decodingPolicy) {
    super(inputStream, new Base32(lineLength, lineSeparator, false, BaseNCodec.PAD_DEFAULT, decodingPolicy), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).lineSeparator","Parameter_4","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).decodingPolicy","Parameter_5","Belong to org.apache.commons.codec.binary.Base32InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex","Class","* Converts hexadecimal Strings. The Charset used for certain operation can be set, the default is set in
 * {@link #DEFAULT_CHARSET_NAME}
 *
 * This class is thread-safe.
 *
 * @since 1.1","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.BinaryEncoder;org.apache.commons.codec.BinaryDecoder"
"org.apache.commons.codec.binary.Hex.DEFAULT_CHARSET","Field","* Default charset is {@link StandardCharsets#UTF_8}.
     *
     * @since 1.7","public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.DEFAULT_CHARSET_NAME","Field","* Default charset name is {@link CharEncoding#UTF_8}.
     *
     * @since 1.4","public static final String DEFAULT_CHARSET_NAME = CharEncoding.UTF_8;","No return type","public , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.DIGITS_LOWER","Field","* Used to build output as hex.","private static final char[] DIGITS_LOWER = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.DIGITS_UPPER","Field","* Used to build output as hex.","private static final char[] DIGITS_UPPER = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.charset","Field","No Comment","private final Charset charset;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decodeHex(char[])","Method","* Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The
     * returned array will be half the length of the passed array, as it takes two characters to represent any given
     * byte. An exception is thrown if the passed char array has an odd number of elements.
     *
     * @param data An array of characters containing hexadecimal digits
     * @return A byte array containing binary data decoded from the supplied char array.
     * @throws DecoderException Thrown if an odd number of characters or illegal characters are supplied","public static byte[] decodeHex(final char[] data) throws DecoderException {
    final byte[] out = new byte[data.length >> 1];
    decodeHex(data, out, 0);
    return out;
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decodeHex(char[]).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.decodeHex(char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decodeHex(char[],byte[],int)","Method","* Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The
     * returned array will be half the length of the passed array, as it takes two characters to represent any given
     * byte. An exception is thrown if the passed char array has an odd number of elements.
     *
     * @param data An array of characters containing hexadecimal digits
     * @param out A byte array to contain the binary data decoded from the supplied char array.
     * @param outOffset The position within {@code out} to start writing the decoded bytes.
     * @return the number of bytes written to {@code out}.
     * @throws DecoderException Thrown if an odd number of characters or illegal characters are supplied
     * @since 1.15","public static int decodeHex(final char[] data, final byte[] out, final int outOffset) throws DecoderException {
    final int len = data.length;
    if ((len & 0x01) != 0) {
        throw new DecoderException(""Odd number of characters."");
    }
    final int outLen = len >> 1;
    if (out.length - outOffset < outLen) {
        throw new DecoderException(""Output array is not large enough to accommodate decoded data."");
    }
    // two characters form the hex value.
    for (int i = outOffset, j = 0; j < len; i++) {
        int f = toDigit(data[j], j) << 4;
        j++;
        f |= toDigit(data[j], j);
        j++;
        out[i] = (byte) (f & 0xFF);
    }
    return outLen;
}","int","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decodeHex(char[],byte[],int).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.decodeHex(char[],byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decodeHex(char[],byte[],int).out","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.decodeHex(char[],byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decodeHex(char[],byte[],int).outOffset","Parameter_3","Belong to org.apache.commons.codec.binary.Hex.decodeHex(char[],byte[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decodeHex(String)","Method","* Converts a String representing hexadecimal values into an array of bytes of those same values. The returned array
     * will be half the length of the passed String, as it takes two characters to represent any given byte. An
     * exception is thrown if the passed String has an odd number of elements.
     *
     * @param data A String containing hexadecimal digits
     * @return A byte array containing binary data decoded from the supplied char array.
     * @throws DecoderException Thrown if an odd number of characters or illegal characters are supplied
     * @since 1.11","public static byte[] decodeHex(final String data) throws DecoderException {
    return decodeHex(data.toCharArray());
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decodeHex(String).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.decodeHex(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[])","Method","* Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
     * The returned array will be double the length of the passed array, as it takes two characters to represent any
     * given byte.
     *
     * @param data a byte[] to convert to hexadecimal characters
     * @return A char[] containing lower-case hexadecimal characters","public static char[] encodeHex(final byte[] data) {
    return encodeHex(data, true);
}","char[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],boolean)","Method","* Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
     * The returned array will be double the length of the passed array, as it takes two characters to represent any
     * given byte.
     *
     * @param data        a byte[] to convert to Hex characters
     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase
     * @return A char[] containing hexadecimal characters in the selected case
     * @since 1.4","public static char[] encodeHex(final byte[] data, final boolean toLowerCase) {
    return encodeHex(data, toAlphabet(toLowerCase));
}","char[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],boolean).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],boolean).toLowerCase","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],char[])","Method","* Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
     * The returned array will be double the length of the passed array, as it takes two characters to represent any
     * given byte.
     *
     * @param data     a byte[] to convert to hexadecimal characters
     * @param toDigits the output alphabet (must contain at least 16 chars)
     * @return A char[] containing the appropriate characters from the alphabet For best results, this should be either
     *         upper- or lower-case hex.
     * @since 1.4","protected static char[] encodeHex(final byte[] data, final char[] toDigits) {
    final int dataLength = data.length;
    return encodeHex(data, 0, dataLength, toDigits, new char[dataLength << 1], 0);
}","char[]","protected , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],char[]).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],char[]).toDigits","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean)","Method","* Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
     *
     * @param data a byte[] to convert to hexadecimal characters
     * @param dataOffset the position in {@code data} to start encoding from
     * @param dataLen the number of bytes from {@code dataOffset} to encode
     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase
     * @return A char[] containing the appropriate characters from the alphabet For best results, this should be either
     *         upper- or lower-case hex.
     * @since 1.15","public static char[] encodeHex(final byte[] data, final int dataOffset, final int dataLen, final boolean toLowerCase) {
    return encodeHex(data, dataOffset, dataLen, toAlphabet(toLowerCase), new char[dataLen << 1], 0);
}","char[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean).dataOffset","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean).dataLen","Parameter_3","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean).toLowerCase","Parameter_4","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int)","Method","* Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
     *
     * @param data a byte[] to convert to hexadecimal characters
     * @param dataOffset the position in {@code data} to start encoding from
     * @param dataLen the number of bytes from {@code dataOffset} to encode
     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase
     * @param out a char[] which will hold the resultant appropriate characters from the alphabet.
     * @param outOffset the position within {@code out} at which to start writing the encoded characters.
     * @since 1.15","public static void encodeHex(final byte[] data, final int dataOffset, final int dataLen, final boolean toLowerCase, final char[] out, final int outOffset) {
    encodeHex(data, dataOffset, dataLen, toAlphabet(toLowerCase), out, outOffset);
}","void","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int).dataOffset","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int).dataLen","Parameter_3","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int).toLowerCase","Parameter_4","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int).out","Parameter_5","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int).outOffset","Parameter_6","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,boolean,char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int)","Method","* Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
     *
     * @param data a byte[] to convert to hexadecimal characters
     * @param dataOffset the position in {@code data} to start encoding from
     * @param dataLen the number of bytes from {@code dataOffset} to encode
     * @param toDigits the output alphabet (must contain at least 16 chars)
     * @param out a char[] which will hold the resultant appropriate characters from the alphabet.
     * @param outOffset the position within {@code out} at which to start writing the encoded characters.
     * @return the given {@code out}.","private static char[] encodeHex(final byte[] data, final int dataOffset, final int dataLen, final char[] toDigits, final char[] out, final int outOffset) {
    // two characters form the hex value.
    for (int i = dataOffset, j = outOffset; i < dataOffset + dataLen; i++) {
        out[j++] = toDigits[(0xF0 & data[i]) >>> 4];
        out[j++] = toDigits[0x0F & data[i]];
    }
    return out;
}","char[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int).dataOffset","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int).dataLen","Parameter_3","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int).toDigits","Parameter_4","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int).out","Parameter_5","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int).outOffset","Parameter_6","Belong to org.apache.commons.codec.binary.Hex.encodeHex(byte[],int,int,char[],char[],int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer)","Method","* Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order. The
     * returned array will be double the length of the passed array, as it takes two characters to represent any given
     * byte.
     *
     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method
     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>
     *
     * @param data a byte buffer to convert to hexadecimal characters
     * @return A char[] containing lower-case hexadecimal characters
     * @since 1.11","public static char[] encodeHex(final ByteBuffer data) {
    return encodeHex(data, true);
}","char[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,boolean)","Method","* Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order. The
     * returned array will be double the length of the passed array, as it takes two characters to represent any given
     * byte.
     *
     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method
     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>
     *
     * @param data        a byte buffer to convert to hexadecimal characters
     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase
     * @return A char[] containing hexadecimal characters in the selected case
     * @since 1.11","public static char[] encodeHex(final ByteBuffer data, final boolean toLowerCase) {
    return encodeHex(data, toAlphabet(toLowerCase));
}","char[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,boolean).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,boolean).toLowerCase","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,char[])","Method","* Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order. The
     * returned array will be double the length of the passed array, as it takes two characters to represent any given
     * byte.
     *
     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method
     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>
     *
     * @param byteBuffer a byte buffer to convert to hexadecimal characters
     * @param toDigits   the output alphabet (must be at least 16 characters)
     * @return A char[] containing the appropriate characters from the alphabet For best results, this should be either
     *         upper- or lower-case hex.
     * @since 1.11","protected static char[] encodeHex(final ByteBuffer byteBuffer, final char[] toDigits) {
    return encodeHex(toByteArray(byteBuffer), toDigits);
}","char[]","protected , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,char[]).byteBuffer","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,char[]).toDigits","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.encodeHex(ByteBuffer,char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(byte[])","Method","* Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned
     * String will be double the length of the passed array, as it takes two characters to represent any given byte.
     *
     * @param data a byte[] to convert to hexadecimal characters
     * @return A String containing lower-case hexadecimal characters
     * @since 1.4","public static String encodeHexString(final byte[] data) {
    return new String(encodeHex(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(byte[]).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHexString(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(byte[],boolean)","Method","* Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned
     * String will be double the length of the passed array, as it takes two characters to represent any given byte.
     *
     * @param data        a byte[] to convert to hexadecimal characters
     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase
     * @return A String containing lower-case hexadecimal characters
     * @since 1.11","public static String encodeHexString(final byte[] data, final boolean toLowerCase) {
    return new String(encodeHex(data, toLowerCase));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(byte[],boolean).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHexString(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(byte[],boolean).toLowerCase","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.encodeHexString(byte[],boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(ByteBuffer)","Method","* Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned
     * String will be double the length of the passed array, as it takes two characters to represent any given byte.
     *
     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method
     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>
     *
     * @param data a byte buffer to convert to hexadecimal characters
     * @return A String containing lower-case hexadecimal characters
     * @since 1.11","public static String encodeHexString(final ByteBuffer data) {
    return new String(encodeHex(data));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(ByteBuffer).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHexString(ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(ByteBuffer,boolean)","Method","* Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned
     * String will be double the length of the passed array, as it takes two characters to represent any given byte.
     *
     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method
     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>
     *
     * @param data        a byte buffer to convert to hexadecimal characters
     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase
     * @return A String containing lower-case hexadecimal characters
     * @since 1.11","public static String encodeHexString(final ByteBuffer data, final boolean toLowerCase) {
    return new String(encodeHex(data, toLowerCase));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(ByteBuffer,boolean).data","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encodeHexString(ByteBuffer,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encodeHexString(ByteBuffer,boolean).toLowerCase","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.encodeHexString(ByteBuffer,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.toAlphabet(boolean)","Method","* Converts a boolean to an alphabet.
     *
     * @param toLowerCase true for lowercase, false for uppercase.
     * @return an alphabet.","private static char[] toAlphabet(final boolean toLowerCase) {
    return toLowerCase ? DIGITS_LOWER : DIGITS_UPPER;
}","char[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.toAlphabet(boolean).toLowerCase","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.toAlphabet(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.toByteArray(ByteBuffer)","Method","* Convert the byte buffer to a byte array. All bytes identified by
     * {@link ByteBuffer#remaining()} will be used.
     *
     * @param byteBuffer the byte buffer
     * @return the byte[]","private static byte[] toByteArray(final ByteBuffer byteBuffer) {
    final int remaining = byteBuffer.remaining();
    // Use the underlying buffer if possible
    if (byteBuffer.hasArray()) {
        final byte[] byteArray = byteBuffer.array();
        if (remaining == byteArray.length) {
            byteBuffer.position(remaining);
            return byteArray;
        }
    }
    // Copy the bytes
    final byte[] byteArray = new byte[remaining];
    byteBuffer.get(byteArray);
    return byteArray;
}","byte[]","private , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.toByteArray(ByteBuffer).byteBuffer","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.toByteArray(ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.toDigit(char,int)","Method","* Converts a hexadecimal character to an integer.
     *
     * @param ch    A character to convert to an integer digit
     * @param index The index of the character in the source
     * @return An integer
     * @throws DecoderException Thrown if ch is an illegal hexadecimal character","protected static int toDigit(final char ch, final int index) throws DecoderException {
    final int digit = Character.digit(ch, 16);
    if (digit == -1) {
        throw new DecoderException(""Illegal hexadecimal character "" + ch + "" at index "" + index);
    }
    return digit;
}","int","protected , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.toDigit(char,int).ch","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.toDigit(char,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.toDigit(char,int).index","Parameter_2","Belong to org.apache.commons.codec.binary.Hex.toDigit(char,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decode(byte[])","Method","* Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.
     * The returned array will be half the length of the passed array, as it takes two characters to represent any given
     * byte. An exception is thrown if the passed char array has an odd number of elements.
     *
     * @param array An array of character bytes containing hexadecimal digits
     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).
     * @throws DecoderException Thrown if an odd number of characters is supplied to this function
     * @see #decodeHex(char[])","@Override
public byte[] decode(final byte[] array) throws DecoderException {
    return decodeHex(new String(array, getCharset()).toCharArray());
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decode(byte[]).array","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.decode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decode(ByteBuffer)","Method","* Converts a buffer of character bytes representing hexadecimal values into an array of bytes of those same values.
     * The returned array will be half the length of the passed array, as it takes two characters to represent any given
     * byte. An exception is thrown if the passed char array has an odd number of elements.
     *
     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method
     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>
     *
     * @param buffer An array of character bytes containing hexadecimal digits
     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).
     * @throws DecoderException Thrown if an odd number of characters is supplied to this function
     * @see #decodeHex(char[])
     * @since 1.11","public byte[] decode(final ByteBuffer buffer) throws DecoderException {
    return decodeHex(new String(toByteArray(buffer), getCharset()).toCharArray());
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decode(ByteBuffer).buffer","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.decode(ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decode(Object)","Method","* Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those
     * same values. The returned array will be half the length of the passed String or array, as it takes two characters
     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.
     *
     * @param object A String, ByteBuffer, byte[], or an array of character bytes containing hexadecimal digits
     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).
     * @throws DecoderException Thrown if an odd number of characters is supplied to this function or the object is not
     *                          a String or char[]
     * @see #decodeHex(char[])","@Override
public Object decode(final Object object) throws DecoderException {
    if (object instanceof String) {
        return decode(((String) object).toCharArray());
    }
    if (object instanceof byte[]) {
        return decode((byte[]) object);
    }
    if (object instanceof ByteBuffer) {
        return decode((ByteBuffer) object);
    }
    try {
        return decodeHex((char[]) object);
    } catch (final ClassCastException e) {
        throw new DecoderException(e.getMessage(), e);
    }
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.decode(Object).object","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.decode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encode(byte[])","Method","* Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each
     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to
     * represent any given byte.
     * <p>
     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by
     * {@link #getCharset()}.
     * </p>
     *
     * @param array a byte[] to convert to hexadecimal characters
     * @return A byte[] containing the bytes of the lower-case hexadecimal characters
     * @since 1.7 No longer throws IllegalStateException if the charsetName is invalid.
     * @see #encodeHex(byte[])","@Override
public byte[] encode(final byte[] array) {
    return encodeHexString(array).getBytes(getCharset());
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encode(byte[]).array","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encode(ByteBuffer)","Method","* Converts byte buffer into an array of bytes for the characters representing the hexadecimal values of each byte
     * in order. The returned array will be double the length of the passed array, as it takes two characters to
     * represent any given byte.
     *
     * <p>The conversion from hexadecimal characters to the returned bytes is performed with the charset named by
     * {@link #getCharset()}.</p>
     *
     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method
     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>
     *
     * @param array a byte buffer to convert to hexadecimal characters
     * @return A byte[] containing the bytes of the lower-case hexadecimal characters
     * @see #encodeHex(byte[])
     * @since 1.11","public byte[] encode(final ByteBuffer array) {
    return encodeHexString(array).getBytes(getCharset());
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encode(ByteBuffer).array","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encode(ByteBuffer)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encode(Object)","Method","* Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each
     * byte in order. The returned array will be double the length of the passed String or array, as it takes two
     * characters to represent any given byte.
     * <p>
     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by
     * {@link #getCharset()}.
     * </p>
     *
     * @param object a String, ByteBuffer, or byte[] to convert to hexadecimal characters
     * @return A char[] containing lower-case hexadecimal characters
     * @throws EncoderException Thrown if the given object is not a String or byte[]
     * @see #encodeHex(byte[])","@Override
public Object encode(final Object object) throws EncoderException {
    final byte[] byteArray;
    if (object instanceof String) {
        byteArray = ((String) object).getBytes(getCharset());
    } else if (object instanceof ByteBuffer) {
        byteArray = toByteArray((ByteBuffer) object);
    } else {
        try {
            byteArray = (byte[]) object;
        } catch (final ClassCastException e) {
            throw new EncoderException(e.getMessage(), e);
        }
    }
    return encodeHex(byteArray);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.encode(Object).object","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.getCharset()","Method","* Gets the charset.
     *
     * @return the charset.
     * @since 1.7","public Charset getCharset() {
    return this.charset;
}","Charset","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.getCharsetName()","Method","* Gets the charset name.
     *
     * @return the charset name.
     * @since 1.4","public String getCharsetName() {
    return this.charset.name();
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.toString()","Method","* Returns a string representation of the object, which includes the charset name.
     *
     * @return a string representation of the object.","@Override
public String toString() {
    return super.toString() + ""[charsetName="" + this.charset + ""]"";
}","String","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.<init>()","Constructor","* Creates a new codec with the default charset name {@link #DEFAULT_CHARSET}","public Hex() {
    // use default encoding
    this.charset = DEFAULT_CHARSET;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.<init>(Charset)","Constructor","* Creates a new codec with the given Charset.
     *
     * @param charset the charset.
     * @since 1.7","public Hex(final Charset charset) {
    this.charset = charset;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.<init>(Charset).charset","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.<init>(Charset)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.<init>(String)","Constructor","* Creates a new codec with the given charset name.
     *
     * @param charsetName the charset name.
     * @throws java.nio.charset.UnsupportedCharsetException If the named charset is unavailable
     * @since 1.4
     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable","public Hex(final String charsetName) {
    this(Charset.forName(charsetName));
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Hex.<init>(String).charsetName","Parameter_1","Belong to org.apache.commons.codec.binary.Hex.<init>(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream","Class","* Abstract superclass for Base-N output streams.
 * <p>
 * To write the EOF marker without closing the stream, call {@link #eof()} or use an <a
 * href=""https://commons.apache.org/proper/commons-io/"">Apache Commons IO</a> <a href=
 * ""https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/output/CloseShieldOutputStream.html""
 * >CloseShieldOutputStream</a>.
 * </p>
 *
 * @since 1.5","Class do not obtain Source Code","No return type","public ","java.io.FilterOutputStream",""
"org.apache.commons.codec.binary.BaseNCodecOutputStream.doEncode","Field","No Comment","private final boolean doEncode;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.baseNCodec","Field","No Comment","private final BaseNCodec baseNCodec;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.singleByte","Field","No Comment","private final byte[] singleByte = new byte[1];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.context","Field","No Comment","private final Context context = new Context();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.close()","Method","* Closes this output stream and releases any system resources associated with the stream.
     * <p>
     * To write the EOF marker without closing the stream, call {@link #eof()} or use an
     * <a href=""https://commons.apache.org/proper/commons-io/"">Apache Commons IO</a> <a href=
     * ""https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/output/CloseShieldOutputStream.html""
     * >CloseShieldOutputStream</a>.
     * </p>
     *
     * @throws IOException
     *             if an I/O error occurs.","@Override
public void close() throws IOException {
    eof();
    flush();
    out.close();
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.eof()","Method","* Writes EOF.
     *
     * @since 1.11","public void eof() {
    // Notify encoder of EOF (-1).
    if (doEncode) {
        baseNCodec.encode(singleByte, 0, EOF, context);
    } else {
        baseNCodec.decode(singleByte, 0, EOF, context);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.flush()","Method","* Flushes this output stream and forces any buffered output bytes to be written out to the stream.
     *
     * @throws IOException
     *             if an I/O error occurs.","@Override
public void flush() throws IOException {
    flush(true);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.flush(boolean)","Method","* Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propagate is
     * true, the wrapped stream will also be flushed.
     *
     * @param propagate
     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.
     * @throws IOException
     *             if an I/O error occurs.","private void flush(final boolean propagate) throws IOException {
    final int avail = baseNCodec.available(context);
    if (avail > 0) {
        final byte[] buf = new byte[avail];
        final int c = baseNCodec.readResults(buf, 0, avail, context);
        if (c > 0) {
            out.write(buf, 0, c);
        }
    }
    if (propagate) {
        out.flush();
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.flush(boolean).propagate","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodecOutputStream.flush(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.isStrictDecoding()","Method","* Returns true if decoding behavior is strict. Decoding will raise an
     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding.
     *
     * <p>
     * The default is false for lenient encoding. Decoding will compose trailing bits
     * into 8-bit bytes and discard the remainder.
     * </p>
     *
     * @return true if using strict decoding
     * @since 1.15","public boolean isStrictDecoding() {
    return baseNCodec.isStrictDecoding();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[],int,int)","Method","* Writes {@code len} bytes from the specified {@code b} array starting at {@code offset} to this
     * output stream.
     *
     * @param array
     *            source byte array
     * @param offset
     *            where to start reading the bytes
     * @param len
     *            maximum number of bytes to write
     *
     * @throws IOException
     *             if an I/O error occurs.
     * @throws NullPointerException
     *             if the byte array parameter is null
     * @throws IndexOutOfBoundsException
     *             if offset, len or buffer size are invalid","@Override
public void write(final byte[] array, final int offset, final int len) throws IOException {
    Objects.requireNonNull(array, ""array"");
    if (offset < 0 || len < 0 || offset > array.length || offset + len > array.length) {
        throw new IndexOutOfBoundsException();
    }
    if (len > 0) {
        if (doEncode) {
            baseNCodec.encode(array, offset, len, context);
        } else {
            baseNCodec.decode(array, offset, len, context);
        }
        flush(false);
    }
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[],int,int).array","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[],int,int).len","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.write(int)","Method","* Writes the specified {@code byte} to this output stream.
     *
     * @param i
     *            source byte
     * @throws IOException
     *             if an I/O error occurs.","@Override
public void write(final int i) throws IOException {
    singleByte[0] = (byte) i;
    write(singleByte, 0, 1);
}","void","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.write(int).i","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodecOutputStream.write(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.<init>(OutputStream,BaseNCodec,boolean)","Constructor","* Constructs a new instance.
     *
     * TODO should this be protected?
     *
     * @param outputStream the underlying output or null.
     * @param basedCodec a BaseNCodec.
     * @param doEncode true to encode, false to decode, TODO should be an enum?","public BaseNCodecOutputStream(final OutputStream outputStream, final BaseNCodec basedCodec, final boolean doEncode) {
    super(outputStream);
    this.baseNCodec = basedCodec;
    this.doEncode = doEncode;
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.<init>(OutputStream,BaseNCodec,boolean).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodecOutputStream.<init>(OutputStream,BaseNCodec,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.<init>(OutputStream,BaseNCodec,boolean).basedCodec","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodecOutputStream.<init>(OutputStream,BaseNCodec,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecOutputStream.<init>(OutputStream,BaseNCodec,boolean).doEncode","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodecOutputStream.<init>(OutputStream,BaseNCodec,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream","Class","* Provides Base64 decoding in a streaming fashion (unlimited size). When encoding the default lineLength
 * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate
 * constructor.
 * <p>
 * The default behavior of the Base64InputStream is to DECODE, whereas the default behavior of the Base64OutputStream
 * is to ENCODE, but this behavior can be overridden by using a different constructor.
 * </p>
 * <p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 * <p>
 * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
 * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
 * </p>
 * <p>
 * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a
 * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is
 * lenient decoding.
 * </p>
 * <ul>
 * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.
 * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid
 * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not
 * allowed.
 * </ul>
 * <p>
 * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches
 * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding
 * and alphabet as the encoder.
 * </p>
 * @see <a href=""http://www.ietf.org/rfc/rfc2045.txt"">RFC 2045</a>
 * @since 1.4","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.binary.BaseNCodecInputStream",""
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream)","Constructor","* Constructs a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.
     *
     * @param inputStream
     *            InputStream to wrap.","public Base64InputStream(final InputStream inputStream) {
    this(inputStream, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean)","Constructor","* Constructs a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original
     * provided InputStream.
     *
     * @param inputStream
     *            InputStream to wrap.
     * @param doEncode
     *            true if we should encode all data read from us, false if we should decode.","public Base64InputStream(final InputStream inputStream, final boolean doEncode) {
    super(inputStream, new Base64(false), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[])","Constructor","* Constructs a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original
     * provided InputStream.
     *
     * @param inputStream
     *            InputStream to wrap.
     * @param doEncode
     *            true if we should encode all data read from us, false if we should decode.
     * @param lineLength
     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If
     *            doEncode is false, lineLength is ignored.
     * @param lineSeparator
     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (for example \r\n).
     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.","public Base64InputStream(final InputStream inputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {
    super(inputStream, new Base64(lineLength, lineSeparator), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[]).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[]).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[]).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[]).lineSeparator","Parameter_4","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Constructor","* Constructs a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original
     * provided InputStream.
     *
     * @param inputStream
     *            InputStream to wrap.
     * @param doEncode
     *            true if we should encode all data read from us, false if we should decode.
     * @param lineLength
     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If
     *            doEncode is false, lineLength is ignored.
     * @param lineSeparator
     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (for example \r\n).
     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.
     * @param decodingPolicy The decoding policy.
     * @since 1.15","public Base64InputStream(final InputStream inputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator, final CodecPolicy decodingPolicy) {
    super(inputStream, new Base64(lineLength, lineSeparator, false, decodingPolicy), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).lineSeparator","Parameter_4","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy).decodingPolicy","Parameter_5","Belong to org.apache.commons.codec.binary.Base64InputStream.<init>(InputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec","Class","* Converts between byte arrays and strings of ""0""s and ""1""s.
 *
 * <p>This class is immutable and thread-safe.</p>
 *
 * TODO: may want to add more bit vector functions like and/or/xor/nand
 * TODO: also might be good to generate boolean[] from byte[] et cetera.
 *
 * @since 1.3","Class do not obtain Source Code","No return type","public ","","org.apache.commons.codec.BinaryDecoder;org.apache.commons.codec.BinaryEncoder"
"org.apache.commons.codec.binary.BinaryCodec.EMPTY_CHAR_ARRAY","Field","Empty char array.","private static final char[] EMPTY_CHAR_ARRAY = {};","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.EMPTY_BYTE_ARRAY","Field","Empty byte array.","private static final byte[] EMPTY_BYTE_ARRAY = {};","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.BIT_0","Field","Mask for bit 0 of a byte.","private static final int BIT_0 = 1;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.BIT_1","Field","Mask for bit 1 of a byte.","private static final int BIT_1 = 0x02;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.BIT_2","Field","Mask for bit 2 of a byte.","private static final int BIT_2 = 0x04;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.BIT_3","Field","Mask for bit 3 of a byte.","private static final int BIT_3 = 0x08;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.BIT_4","Field","Mask for bit 4 of a byte.","private static final int BIT_4 = 0x10;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.BIT_5","Field","Mask for bit 5 of a byte.","private static final int BIT_5 = 0x20;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.BIT_6","Field","Mask for bit 6 of a byte.","private static final int BIT_6 = 0x40;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.BIT_7","Field","Mask for bit 7 of a byte.","private static final int BIT_7 = 0x80;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.BITS","Field","No Comment","private static final int[] BITS = { BIT_0, BIT_1, BIT_2, BIT_3, BIT_4, BIT_5, BIT_6, BIT_7 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.fromAscii(byte[])","Method","* Decodes a byte array where each byte represents an ASCII '0' or '1'.
     *
     * @param ascii
     *                  each byte represents an ASCII '0' or '1'
     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument","public static byte[] fromAscii(final byte[] ascii) {
    if (isEmpty(ascii)) {
        return EMPTY_BYTE_ARRAY;
    }
    final int asciiLength = ascii.length;
    // get length/8 times bytes with 3 bit shifts to the right of the length
    final byte[] raw = new byte[asciiLength >> 3];
    /*
         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the
         * loop.
         */
    for (int ii = 0, jj = asciiLength - 1; ii < raw.length; ii++, jj -= 8) {
        for (int bits = 0; bits < BITS.length; ++bits) {
            if (ascii[jj - bits] == '1') {
                raw[ii] |= BITS[bits];
            }
        }
    }
    return raw;
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.fromAscii(byte[]).ascii","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.fromAscii(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.fromAscii(char[])","Method","* Decodes a char array where each char represents an ASCII '0' or '1'.
     *
     * @param ascii
     *                  each char represents an ASCII '0' or '1'
     * @return the raw encoded binary where each bit corresponds to a char in the char array argument","public static byte[] fromAscii(final char[] ascii) {
    if (ascii == null || ascii.length == 0) {
        return EMPTY_BYTE_ARRAY;
    }
    final int asciiLength = ascii.length;
    // get length/8 times bytes with 3 bit shifts to the right of the length
    final byte[] raw = new byte[asciiLength >> 3];
    /*
         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the
         * loop.
         */
    for (int ii = 0, jj = asciiLength - 1; ii < raw.length; ii++, jj -= 8) {
        for (int bits = 0; bits < BITS.length; ++bits) {
            if (ascii[jj - bits] == '1') {
                raw[ii] |= BITS[bits];
            }
        }
    }
    return raw;
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.fromAscii(char[]).ascii","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.fromAscii(char[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])","Method","* Returns {@code true} if the given array is {@code null} or empty (size 0.)
     *
     * @param array
     *            the source array
     * @return {@code true} if the given array is {@code null} or empty (size 0.)","static boolean isEmpty(final byte[] array) {
    return array == null || array.length == 0;
}","boolean","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[]).array","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.toAsciiBytes(byte[])","Method","* Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated
     * char.
     *
     * @param raw
     *                  the raw binary data to convert
     * @return an array of 0 and 1 character bytes for each bit of the argument
     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])","public static byte[] toAsciiBytes(final byte[] raw) {
    if (isEmpty(raw)) {
        return EMPTY_BYTE_ARRAY;
    }
    final int rawLength = raw.length;
    // get 8 times the bytes with 3 bit shifts to the left of the length
    final byte[] l_ascii = new byte[rawLength << 3];
    /*
         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the
         * loop.
         */
    for (int ii = 0, jj = l_ascii.length - 1; ii < rawLength; ii++, jj -= 8) {
        for (int bits = 0; bits < BITS.length; ++bits) {
            if ((raw[ii] & BITS[bits]) == 0) {
                l_ascii[jj - bits] = '0';
            } else {
                l_ascii[jj - bits] = '1';
            }
        }
    }
    return l_ascii;
}","byte[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.toAsciiBytes(byte[]).raw","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.toAsciiBytes(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.toAsciiChars(byte[])","Method","* Converts an array of raw binary data into an array of ASCII 0 and 1 characters.
     *
     * @param raw
     *                  the raw binary data to convert
     * @return an array of 0 and 1 characters for each bit of the argument
     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])","public static char[] toAsciiChars(final byte[] raw) {
    if (isEmpty(raw)) {
        return EMPTY_CHAR_ARRAY;
    }
    final int rawLength = raw.length;
    // get 8 times the bytes with 3 bit shifts to the left of the length
    final char[] l_ascii = new char[rawLength << 3];
    /*
         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the
         * loop.
         */
    for (int ii = 0, jj = l_ascii.length - 1; ii < rawLength; ii++, jj -= 8) {
        for (int bits = 0; bits < BITS.length; ++bits) {
            if ((raw[ii] & BITS[bits]) == 0) {
                l_ascii[jj - bits] = '0';
            } else {
                l_ascii[jj - bits] = '1';
            }
        }
    }
    return l_ascii;
}","char[]","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.toAsciiChars(byte[]).raw","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.toAsciiChars(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.toAsciiString(byte[])","Method","* Converts an array of raw binary data into a String of ASCII 0 and 1 characters.
     *
     * @param raw
     *                  the raw binary data to convert
     * @return a String of 0 and 1 characters representing the binary data
     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])","public static String toAsciiString(final byte[] raw) {
    return new String(toAsciiChars(raw));
}","String","public , static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.toAsciiString(byte[]).raw","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.toAsciiString(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.decode(byte[])","Method","* Decodes a byte array where each byte represents an ASCII '0' or '1'.
     *
     * @param ascii
     *                  each byte represents an ASCII '0' or '1'
     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument
     * @see org.apache.commons.codec.Decoder#decode(Object)","@Override
public byte[] decode(final byte[] ascii) {
    return fromAscii(ascii);
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.decode(byte[]).ascii","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.decode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.decode(Object)","Method","* Decodes a byte array where each byte represents an ASCII '0' or '1'.
     *
     * @param ascii
     *                  each byte represents an ASCII '0' or '1'
     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument
     * @throws DecoderException
     *                  if argument is not a byte[], char[] or String
     * @see org.apache.commons.codec.Decoder#decode(Object)","@Override
public Object decode(final Object ascii) throws DecoderException {
    if (ascii == null) {
        return EMPTY_BYTE_ARRAY;
    }
    if (ascii instanceof byte[]) {
        return fromAscii((byte[]) ascii);
    }
    if (ascii instanceof char[]) {
        return fromAscii((char[]) ascii);
    }
    if (ascii instanceof String) {
        return fromAscii(((String) ascii).toCharArray());
    }
    throw new DecoderException(""argument not a byte array"");
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.decode(Object).ascii","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.decode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.encode(byte[])","Method","* Converts an array of raw binary data into an array of ASCII 0 and 1 characters.
     *
     * @param raw
     *                  the raw binary data to convert
     * @return 0 and 1 ASCII character bytes one for each bit of the argument
     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])","@Override
public byte[] encode(final byte[] raw) {
    return toAsciiBytes(raw);
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.encode(byte[]).raw","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.encode(byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.encode(Object)","Method","* Converts an array of raw binary data into an array of ASCII 0 and 1 chars.
     *
     * @param raw
     *                  the raw binary data to convert
     * @return 0 and 1 ASCII character chars one for each bit of the argument
     * @throws EncoderException
     *                  if the argument is not a byte[]
     * @see org.apache.commons.codec.Encoder#encode(Object)","@Override
public Object encode(final Object raw) throws EncoderException {
    if (!(raw instanceof byte[])) {
        throw new EncoderException(""argument not a byte array"");
    }
    return toAsciiChars((byte[]) raw);
}","Object","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.encode(Object).raw","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.toByteArray(String)","Method","* Decodes a String where each char of the String represents an ASCII '0' or '1'.
     *
     * @param ascii
     *                  String of '0' and '1' characters
     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument
     * @see org.apache.commons.codec.Decoder#decode(Object)","public byte[] toByteArray(final String ascii) {
    if (ascii == null) {
        return EMPTY_BYTE_ARRAY;
    }
    return fromAscii(ascii.toCharArray());
}","byte[]","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.toByteArray(String).ascii","Parameter_1","Belong to org.apache.commons.codec.binary.BinaryCodec.toByteArray(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BinaryCodec.<init>()","Constructor","* Constructs a new instance.","public BinaryCodec() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16","Class","* Provides Base32 encoding and decoding as defined by <a href=""https://tools.ietf.org/html/rfc4648#section-8"">RFC 4648 - 8. Base 16 Encoding</a>.
 *
 * <p>
 * This class is thread-safe.
 * </p>
 * <p>
 * This implementation strictly follows RFC 4648, and as such unlike the {@link Base32} and {@link Base64} implementations, it does not ignore invalid alphabet
 * characters or whitespace, neither does it offer chunking or padding characters.
 * </p>
 * <p>
 * The only additional feature above those specified in RFC 4648 is support for working with a lower-case alphabet in addition to the default upper-case
 * alphabet.
 * </p>
 *
 * @see <a href=""https://tools.ietf.org/html/rfc4648#section-8"">RFC 4648 - 8. Base 16 Encoding</a>
 * @since 1.15","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.binary.BaseNCodec",""
"org.apache.commons.codec.binary.Base16.BITS_PER_ENCODED_BYTE","Field","* BASE16 characters are 4 bits in length. They are formed by taking an 8-bit group, which is converted into two BASE16 characters.","private static final int BITS_PER_ENCODED_BYTE = 4;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.BYTES_PER_ENCODED_BLOCK","Field","No Comment","private static final int BYTES_PER_ENCODED_BLOCK = 2;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.BYTES_PER_UNENCODED_BLOCK","Field","No Comment","private static final int BYTES_PER_UNENCODED_BLOCK = 1;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.UPPER_CASE_DECODE_TABLE","Field","@formatter:off","private static final byte[] UPPER_CASE_DECODE_TABLE = { //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
// 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 30-3f 0-9
0, // 30-3f 0-9
1, // 30-3f 0-9
2, // 30-3f 0-9
3, // 30-3f 0-9
4, // 30-3f 0-9
5, // 30-3f 0-9
6, // 30-3f 0-9
7, // 30-3f 0-9
8, // 30-3f 0-9
9, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 40-46 A-F
-1, // 40-46 A-F
10, // 40-46 A-F
11, // 40-46 A-F
12, // 40-46 A-F
13, // 40-46 A-F
14, // 40-46 A-F
15 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.UPPER_CASE_ENCODE_TABLE","Field","* This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet"" equivalents as specified in Table 5 of RFC
     * 4648.","private static final byte[] UPPER_CASE_ENCODE_TABLE = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.LOWER_CASE_DECODE_TABLE","Field","@formatter:off","private static final byte[] LOWER_CASE_DECODE_TABLE = { //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
// 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 00-0f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 10-1f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 20-2f
-1, // 30-3f 0-9
0, // 30-3f 0-9
1, // 30-3f 0-9
2, // 30-3f 0-9
3, // 30-3f 0-9
4, // 30-3f 0-9
5, // 30-3f 0-9
6, // 30-3f 0-9
7, // 30-3f 0-9
8, // 30-3f 0-9
9, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 30-3f 0-9
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 40-4f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 50-5f
-1, // 60-66 a-f
-1, // 60-66 a-f
10, // 60-66 a-f
11, // 60-66 a-f
12, // 60-66 a-f
13, // 60-66 a-f
14, // 60-66 a-f
15 };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.LOWER_CASE_ENCODE_TABLE","Field","* This array is a lookup table that translates 4-bit positive integer index values into their ""Base16 Alphabet"" lower-case equivalents.","private static final byte[] LOWER_CASE_ENCODE_TABLE = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.MASK_4BITS","Field","Mask used to extract 4 bits, used when decoding character.","private static final int MASK_4BITS = 0x0f;","No return type","private , static , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.decodeTable","Field","* Decode table to use.","private final byte[] decodeTable;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.encodeTable","Field","* Encode table to use.","private final byte[] encodeTable;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.decode(byte[],int,int,Context)","Method","No Comment","@Override
void decode(final byte[] data, int offset, final int length, final Context context) {
    if (context.eof || length < 0) {
        context.eof = true;
        if (context.ibitWorkArea != 0) {
            validateTrailingCharacter();
        }
        return;
    }
    final int dataLen = Math.min(data.length - offset, length);
    final int availableChars = (context.ibitWorkArea != 0 ? 1 : 0) + dataLen;
    // small optimization to short-cut the rest of this method when it is fed byte-by-byte
    if (availableChars == 1 && availableChars == dataLen) {
        // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0
        context.ibitWorkArea = decodeOctet(data[offset]) + 1;
        return;
    }
    // we must have an even number of chars to decode
    final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1;
    final int end = offset + dataLen;
    final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context);
    int result;
    if (dataLen < availableChars) {
        // we have 1/2 byte from previous invocation to decode
        result = context.ibitWorkArea - 1 << BITS_PER_ENCODED_BYTE;
        result |= decodeOctet(data[offset++]);
        buffer[context.pos++] = (byte) result;
        // reset to empty-value for next invocation!
        context.ibitWorkArea = 0;
    }
    final int loopEnd = end - 1;
    while (offset < loopEnd) {
        result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE;
        result |= decodeOctet(data[offset++]);
        buffer[context.pos++] = (byte) result;
    }
    // we have one char of a hex-pair left over
    if (offset < end) {
        // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0
        context.ibitWorkArea = decodeOctet(data[offset]) + 1;
    }
}","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.decode(byte[],int,int,Context).data","Parameter_1","Belong to org.apache.commons.codec.binary.Base16.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.decode(byte[],int,int,Context).offset","Parameter_2","Belong to org.apache.commons.codec.binary.Base16.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.decode(byte[],int,int,Context).length","Parameter_3","Belong to org.apache.commons.codec.binary.Base16.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.decode(byte[],int,int,Context).context","Parameter_4","Belong to org.apache.commons.codec.binary.Base16.decode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.decodeOctet(byte)","Method","No Comment","private int decodeOctet(final byte octet) {
    int decoded = -1;
    if ((octet & 0xff) < decodeTable.length) {
        decoded = decodeTable[octet];
    }
    if (decoded == -1) {
        throw new IllegalArgumentException(""Invalid octet in encoded value: "" + (int) octet);
    }
    return decoded;
}","int","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.decodeOctet(byte).octet","Parameter_1","Belong to org.apache.commons.codec.binary.Base16.decodeOctet(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.encode(byte[],int,int,Context)","Method","No Comment","@Override
void encode(final byte[] data, final int offset, final int length, final Context context) {
    if (context.eof) {
        return;
    }
    if (length < 0) {
        context.eof = true;
        return;
    }
    final int size = length * BYTES_PER_ENCODED_BLOCK;
    if (size < 0) {
        throw new IllegalArgumentException(""Input length exceeds maximum size for encoded data: "" + length);
    }
    final byte[] buffer = ensureBufferSize(size, context);
    final int end = offset + length;
    for (int i = offset; i < end; i++) {
        final int value = data[i];
        final int high = value >> BITS_PER_ENCODED_BYTE & MASK_4BITS;
        final int low = value & MASK_4BITS;
        buffer[context.pos++] = encodeTable[high];
        buffer[context.pos++] = encodeTable[low];
    }
}","void","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.encode(byte[],int,int,Context).data","Parameter_1","Belong to org.apache.commons.codec.binary.Base16.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.encode(byte[],int,int,Context).offset","Parameter_2","Belong to org.apache.commons.codec.binary.Base16.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.encode(byte[],int,int,Context).length","Parameter_3","Belong to org.apache.commons.codec.binary.Base16.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.encode(byte[],int,int,Context).context","Parameter_4","Belong to org.apache.commons.codec.binary.Base16.encode(byte[],int,int,Context)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.isInAlphabet(byte)","Method","* Returns whether or not the {@code octet} is in the Base16 alphabet.
     *
     * @param octet The value to test.
     * @return {@code true} if the value is defined in the Base16 alphabet {@code false} otherwise.","@Override
public boolean isInAlphabet(final byte octet) {
    return (octet & 0xff) < decodeTable.length && decodeTable[octet] != -1;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.isInAlphabet(byte).octet","Parameter_1","Belong to org.apache.commons.codec.binary.Base16.isInAlphabet(byte)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.validateTrailingCharacter()","Method","* Validates whether decoding allows an entire final trailing character that cannot be used for a complete byte.
     *
     * @throws IllegalArgumentException if strict decoding is enabled","private void validateTrailingCharacter() {
    if (isStrictDecoding()) {
        throw new IllegalArgumentException(""Strict decoding: Last encoded character is a valid base 16 alphabet character but not a possible encoding. "" + ""Decoding requires at least two characters to create one byte."");
    }
}","void","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>()","Constructor","* Constructs a Base16 codec used for decoding and encoding.","public Base16() {
    this(false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>(boolean)","Constructor","* Constructs a Base16 codec used for decoding and encoding.
     *
     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.","public Base16(final boolean lowerCase) {
    this(lowerCase, DECODING_POLICY_DEFAULT);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>(boolean).lowerCase","Parameter_1","Belong to org.apache.commons.codec.binary.Base16.<init>(boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>(boolean,byte[],CodecPolicy)","Constructor","* Constructs a Base16 codec used for decoding and encoding.
     *
     * @param lowerCase      if {@code true} then use a lower-case Base16 alphabet.
     * @param encodeTable    the encode table.
     * @param decodingPolicy Decoding policy.","private Base16(final boolean lowerCase, final byte[] encodeTable, final CodecPolicy decodingPolicy) {
    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, 0, 0, PAD_DEFAULT, decodingPolicy);
    Objects.requireNonNull(encodeTable, ""encodeTable"");
    this.encodeTable = encodeTable;
    this.decodeTable = encodeTable == LOWER_CASE_ENCODE_TABLE ? LOWER_CASE_DECODE_TABLE : UPPER_CASE_DECODE_TABLE;
}","No return type","private ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>(boolean,byte[],CodecPolicy).lowerCase","Parameter_1","Belong to org.apache.commons.codec.binary.Base16.<init>(boolean,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>(boolean,byte[],CodecPolicy).encodeTable","Parameter_2","Belong to org.apache.commons.codec.binary.Base16.<init>(boolean,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>(boolean,byte[],CodecPolicy).decodingPolicy","Parameter_3","Belong to org.apache.commons.codec.binary.Base16.<init>(boolean,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>(boolean,CodecPolicy)","Constructor","* Constructs a Base16 codec used for decoding and encoding.
     *
     * @param lowerCase      if {@code true} then use a lower-case Base16 alphabet.
     * @param decodingPolicy Decoding policy.","public Base16(final boolean lowerCase, final CodecPolicy decodingPolicy) {
    this(lowerCase, lowerCase ? LOWER_CASE_ENCODE_TABLE : UPPER_CASE_ENCODE_TABLE, decodingPolicy);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>(boolean,CodecPolicy).lowerCase","Parameter_1","Belong to org.apache.commons.codec.binary.Base16.<init>(boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16.<init>(boolean,CodecPolicy).decodingPolicy","Parameter_2","Belong to org.apache.commons.codec.binary.Base16.<init>(boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.CharSequenceUtils","Class","* <p>
 * Operations on {@link CharSequence} that are {@code null} safe.
 * </p>
 * <p>
 * Copied from Apache Commons Lang r1586295 on April 10, 2014 (day of 3.3.2 release).
 * </p>
 *
 * @see CharSequence
 * @since 1.10","Class do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int)","Method","* Green implementation of regionMatches.
     *
     * <p>
     * Note: This function differs from the current implementation in Apache Commons Lang
     * where the input indices are not valid. It is only used within this package.
     * </p>
     *
     * @param cs
     *            the {@code CharSequence} to be processed
     * @param ignoreCase
     *            whether or not to be case-insensitive
     * @param thisStart
     *            the index to start on the {@code cs} CharSequence
     * @param substring
     *            the {@code CharSequence} to be looked for
     * @param start
     *            the index to start on the {@code substring} CharSequence
     * @param length
     *            character length of the region
     * @return whether the region matched","static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) {
    if (cs instanceof String && substring instanceof String) {
        return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);
    }
    int index1 = thisStart;
    int index2 = start;
    int tmpLen = length;
    while (tmpLen-- > 0) {
        final char c1 = cs.charAt(index1++);
        final char c2 = substring.charAt(index2++);
        if (c1 == c2) {
            continue;
        }
        if (!ignoreCase) {
            return false;
        }
        // The same check as in String.regionMatches():
        if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {
            return false;
        }
    }
    return true;
}","boolean","static ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int).cs","Parameter_1","Belong to org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int).ignoreCase","Parameter_2","Belong to org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int).thisStart","Parameter_3","Belong to org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int).substring","Parameter_4","Belong to org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int).start","Parameter_5","Belong to org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int).length","Parameter_6","Belong to org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequence,boolean,int,CharSequence,int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.CharSequenceUtils.<init>()","Constructor","* Consider private.
     *
     * @deprecated Will be private in the next major version.","@Deprecated
public CharSequenceUtils() {
    // empty
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream","Class","* Abstract superclass for Base-N input streams.
 *
 * @since 1.5","Class do not obtain Source Code","No return type","public ","java.io.FilterInputStream",""
"org.apache.commons.codec.binary.BaseNCodecInputStream.baseNCodec","Field","No Comment","private final BaseNCodec baseNCodec;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.doEncode","Field","No Comment","private final boolean doEncode;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.singleByte","Field","No Comment","private final byte[] singleByte = new byte[1];","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.buf","Field","No Comment","private final byte[] buf;","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.context","Field","No Comment","private final Context context = new Context();","No return type","private , final ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.available()","Method","* {@inheritDoc}
     *
     * @return {@code 0} if the {@link InputStream} has reached {@code EOF},
     * {@code 1} otherwise
     * @since 1.7","@Override
public int available() throws IOException {
    // Note: The logic is similar to the InflaterInputStream:
    //       as long as we have not reached EOF, indicate that there is more
    //       data available. As we do not know for sure how much data is left,
    //       just return 1 as a safe guess.
    return context.eof ? 0 : 1;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.isStrictDecoding()","Method","* Returns true if decoding behavior is strict. Decoding will raise an
     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding.
     *
     * <p>
     * The default is false for lenient encoding. Decoding will compose trailing bits
     * into 8-bit bytes and discard the remainder.
     * </p>
     *
     * @return true if using strict decoding
     * @since 1.15","public boolean isStrictDecoding() {
    return baseNCodec.isStrictDecoding();
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.mark(int)","Method","* Marks the current position in this input stream.
     * <p>
     * The {@link #mark} method of {@link BaseNCodecInputStream} does nothing.
     * </p>
     *
     * @param readLimit the maximum limit of bytes that can be read before the mark position becomes invalid.
     * @see #markSupported()
     * @since 1.7","@Override
public synchronized void mark(final int readLimit) {
    // noop
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.mark(int).readLimit","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodecInputStream.mark(int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.markSupported()","Method","* {@inheritDoc}
     *
     * @return Always returns {@code false}","@Override
public boolean markSupported() {
    // not an easy job to support marks
    return false;
}","boolean","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.read()","Method","* Reads one {@code byte} from this input stream.
     *
     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.
     * @throws IOException
     *             if an I/O error occurs.","@Override
public int read() throws IOException {
    int r = read(singleByte, 0, 1);
    while (r == 0) {
        r = read(singleByte, 0, 1);
    }
    if (r > 0) {
        final byte b = singleByte[0];
        return b < 0 ? 256 + b : b;
    }
    return EOF;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[],int,int)","Method","* Attempts to read {@code len} bytes into the specified {@code b} array starting at {@code offset}
     * from this InputStream.
     *
     * @param array
     *            destination byte array
     * @param offset
     *            where to start writing the bytes
     * @param len
     *            maximum number of bytes to read
     *
     * @return number of bytes read
     * @throws IOException
     *             if an I/O error occurs.
     * @throws NullPointerException
     *             if the byte array parameter is null
     * @throws IndexOutOfBoundsException
     *             if offset, len or buffer size are invalid","@Override
public int read(final byte[] array, final int offset, final int len) throws IOException {
    Objects.requireNonNull(array, ""array"");
    if (offset < 0 || len < 0 || offset > array.length || offset + len > array.length) {
        throw new IndexOutOfBoundsException();
    }
    if (len == 0) {
        return 0;
    }
    int readLen = 0;
    /*
         Rationale for while-loop on (readLen == 0):
         -----
         Base32.readResults() usually returns > 0 or EOF (-1).  In the
         rare case where it returns 0, we just keep trying.

         This is essentially an undocumented contract for InputStream
         implementors that want their code to work properly with
         java.io.InputStreamReader, since the latter hates it when
         InputStream.read(byte[]) returns a zero.  Unfortunately our
         readResults() call must return 0 if a large amount of the data
         being decoded was non-base32, so this while-loop enables proper
         interop with InputStreamReader for that scenario.
         -----
         This is a fix for CODEC-101
        */
    // Attempt to read the request length
    while (readLen < len) {
        if (!baseNCodec.hasData(context)) {
            // Obtain more data.
            // buf is reused across calls to read to avoid repeated allocations
            final int c = in.read(buf);
            if (doEncode) {
                baseNCodec.encode(buf, 0, c, context);
            } else {
                baseNCodec.decode(buf, 0, c, context);
            }
        }
        final int read = baseNCodec.readResults(array, offset + readLen, len - readLen, context);
        if (read < 0) {
            // Return the amount read or EOF
            return readLen != 0 ? readLen : -1;
        }
        readLen += read;
    }
    return readLen;
}","int","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[],int,int).array","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[],int,int).offset","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[],int,int).len","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[],int,int)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.reset()","Method","* Repositions this stream to the position at the time the mark method was last called on this input stream.
     * <p>
     * The {@link #reset} method of {@link BaseNCodecInputStream} does nothing except throw an {@link IOException}.
     * </p>
     *
     * @throws IOException if this method is invoked
     * @since 1.7","@Override
public synchronized void reset() throws IOException {
    throw new IOException(""mark/reset not supported"");
}","void","public , synchronized ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)","Method","* {@inheritDoc}
     *
     * @throws IllegalArgumentException if the provided skip length is negative
     * @since 1.7","@Override
public long skip(final long n) throws IOException {
    if (n < 0) {
        throw new IllegalArgumentException(""Negative skip length: "" + n);
    }
    // skip in chunks of 512 bytes
    final byte[] b = new byte[512];
    long todo = n;
    while (todo > 0) {
        int len = (int) Math.min(b.length, todo);
        len = this.read(b, 0, len);
        if (len == EOF) {
            break;
        }
        todo -= len;
    }
    return n - todo;
}","long","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long).n","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.<init>(InputStream,BaseNCodec,boolean)","Constructor","* Constructs a new instance.
     *
     * @param inputStream the input stream
     * @param baseNCodec the codec
     * @param doEncode set to true to perform encoding, else decoding","protected BaseNCodecInputStream(final InputStream inputStream, final BaseNCodec baseNCodec, final boolean doEncode) {
    super(inputStream);
    this.doEncode = doEncode;
    this.baseNCodec = baseNCodec;
    this.buf = new byte[doEncode ? 4096 : 8192];
}","No return type","protected ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.<init>(InputStream,BaseNCodec,boolean).inputStream","Parameter_1","Belong to org.apache.commons.codec.binary.BaseNCodecInputStream.<init>(InputStream,BaseNCodec,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.<init>(InputStream,BaseNCodec,boolean).baseNCodec","Parameter_2","Belong to org.apache.commons.codec.binary.BaseNCodecInputStream.<init>(InputStream,BaseNCodec,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.BaseNCodecInputStream.<init>(InputStream,BaseNCodec,boolean).doEncode","Parameter_3","Belong to org.apache.commons.codec.binary.BaseNCodecInputStream.<init>(InputStream,BaseNCodec,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream","Class","* Provides Base32 encoding in a streaming fashion (unlimited size). When encoding the default lineLength
 * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate
 * constructor.
 * <p>
 * The default behavior of the Base32OutputStream is to ENCODE, whereas the default behavior of the Base32InputStream
 * is to DECODE. But this behavior can be overridden by using a different constructor.
 * </p>
 * <p>
 * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
 * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
 * </p>
 * <p>
 * <strong>Note:</strong> It is mandatory to close the stream after the last byte has been written to it, otherwise the
 * final padding will be omitted and the resulting data will be incomplete/inconsistent.
 * </p>
 * <p>
 * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a
 * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is
 * lenient decoding.
 * </p>
 * <ul>
 * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.
 * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid
 * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not
 * allowed.
 * </ul>
 * <p>
 * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches
 * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding
 * and alphabet as the encoder.
 * </p>
 * @see <a href=""http://www.ietf.org/rfc/rfc4648.txt"">RFC 4648</a>
 * @since 1.5","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.binary.BaseNCodecOutputStream",""
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream)","Constructor","* Constructs a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.
     *
     * @param outputStream
     *            OutputStream to wrap.","public Base32OutputStream(final OutputStream outputStream) {
    this(outputStream, true);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean)","Constructor","* Constructs a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the
     * original provided OutputStream.
     *
     * @param outputStream
     *            OutputStream to wrap.
     * @param doEncode
     *            true if we should encode all data written to us, false if we should decode.","public Base32OutputStream(final OutputStream outputStream, final boolean doEncode) {
    super(outputStream, new Base32(false), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[])","Constructor","* Constructs a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the
     * original provided OutputStream.
     *
     * @param outputStream
     *            OutputStream to wrap.
     * @param doEncode
     *            true if we should encode all data written to us, false if we should decode.
     * @param lineLength
     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If
     *            doEncode is false, lineLength is ignored.
     * @param lineSeparator
     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (for example \r\n).
     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.","public Base32OutputStream(final OutputStream outputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {
    super(outputStream, new Base32(lineLength, lineSeparator), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[]).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[]).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[]).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[]).lineSeparator","Parameter_4","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[])","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Constructor","* Constructs a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the
     * original provided OutputStream.
     *
     * @param outputStream
     *            OutputStream to wrap.
     * @param doEncode
     *            true if we should encode all data written to us, false if we should decode.
     * @param lineLength
     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If
     *            doEncode is false, lineLength is ignored.
     * @param lineSeparator
     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (for example \r\n).
     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.
     * @param decodingPolicy The decoding policy.
     * @since 1.15","public Base32OutputStream(final OutputStream outputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator, final CodecPolicy decodingPolicy) {
    super(outputStream, new Base32(lineLength, lineSeparator, false, BaseNCodec.PAD_DEFAULT, decodingPolicy), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).lineLength","Parameter_3","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).lineSeparator","Parameter_4","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy).decodingPolicy","Parameter_5","Belong to org.apache.commons.codec.binary.Base32OutputStream.<init>(OutputStream,boolean,int,byte[],CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream","Class","* Provides Hex encoding in a streaming fashion (unlimited size).
 * <p>
 * The default behavior of the HexOutputStream is to ENCODE, whereas the default behavior of the
 * {@link Base16InputStream} is to DECODE. But this behavior can be overridden by using a different constructor.
 * </p>
 *
 * @since 1.15","Class do not obtain Source Code","No return type","public ","org.apache.commons.codec.binary.BaseNCodecOutputStream",""
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream)","Constructor","* Constructs a Base16OutputStream such that all data written is Hex-encoded to the original provided OutputStream.
     *
     * @param outputStream OutputStream to wrap.","public Base16OutputStream(final OutputStream outputStream) {
    this(outputStream, true);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean)","Constructor","* Constructs a Base16OutputStream such that all data written is either Hex-encoded or Hex-decoded to the
     * original provided OutputStream.
     *
     * @param outputStream OutputStream to wrap.
     * @param doEncode true if we should encode all data written to us, false if we should decode.","public Base16OutputStream(final OutputStream outputStream, final boolean doEncode) {
    this(outputStream, doEncode, false);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean)","Constructor","* Constructs a Base16OutputStream such that all data written is either Hex-encoded or Hex-decoded to the
     * original provided OutputStream.
     *
     * @param outputStream OutputStream to wrap.
     * @param doEncode true if we should encode all data written to us, false if we should decode.
     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.","public Base16OutputStream(final OutputStream outputStream, final boolean doEncode, final boolean lowerCase) {
    this(outputStream, doEncode, lowerCase, CodecPolicy.LENIENT);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean).lowerCase","Parameter_3","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean,CodecPolicy)","Constructor","* Constructs a Base16OutputStream such that all data written is either Hex-encoded or Hex-decoded to the
     * original provided OutputStream.
     *
     * @param outputStream OutputStream to wrap.
     * @param doEncode true if we should encode all data written to us, false if we should decode.
     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.
     * @param decodingPolicy Decoding policy.","public Base16OutputStream(final OutputStream outputStream, final boolean doEncode, final boolean lowerCase, final CodecPolicy decodingPolicy) {
    super(outputStream, new Base16(lowerCase, decodingPolicy), doEncode);
}","No return type","public ","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean,CodecPolicy).outputStream","Parameter_1","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean,CodecPolicy).doEncode","Parameter_2","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean,CodecPolicy).lowerCase","Parameter_3","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean,CodecPolicy).decodingPolicy","Parameter_4","Belong to org.apache.commons.codec.binary.Base16OutputStream.<init>(OutputStream,boolean,boolean,CodecPolicy)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Encoder","Interface","* Provides the highest level of abstraction for Encoders.
 * <p>
 * This is the sister interface of {@link Decoder}.  Every implementation of Encoder provides this
 * common generic interface which allows a user to pass a generic Object to any Encoder implementation
 * in the codec package.
 * </p>","Interface do not obtain Source Code","No return type","public ","",""
"org.apache.commons.codec.Encoder.encode(Object)","Abstract Method","* Encodes an ""Object"" and returns the encoded content as an Object. The Objects here may just be
     * {@code byte[]} or {@code String}s depending on the implementation used.
     *
     * @param source
     *            An object to encode
     * @return An ""encoded"" Object
     * @throws EncoderException
     *             An encoder exception is thrown if the encoder experiences a failure condition during the encoding
     *             process.","Object encode(Object source) throws EncoderException;","Object","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.Encoder.encode(Object).source","Parameter_1","Belong to org.apache.commons.codec.Encoder.encode(Object)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringEncoder","Interface","* Defines common encoding methods for String encoders.","Interface do not obtain Source Code","No return type","public ","org.apache.commons.codec.Encoder",""
"org.apache.commons.codec.StringEncoder.encode(String)","Abstract Method","* Encodes a String and returns a String.
     *
     * @param source
     *            the String to encode
     * @return the encoded String
     * @throws EncoderException
     *             thrown if there is an error condition during the encoding process.","String encode(String source) throws EncoderException;","String","default","method/parameter/variable has no extends","method/parameter/variable has no implements"
"org.apache.commons.codec.StringEncoder.encode(String).source","Parameter_1","Belong to org.apache.commons.codec.StringEncoder.encode(String)","Parameter has not source code","No return type","No modifier","method/parameter/variable has no extends","method/parameter/variable has no implements"
